---
title: Computer Organization and Architecture
date: 2025-11-29 21:49:43
tags: [Computer Science]
category: Review
category_bar: true
index_img: https://github.com/Richard110206/Blog-image/blob/main/cover/Computer%20Organization.jpg?raw=true
description: Based on textbooks and Bilibili lectures, a systematic review of core knowledge in Computer Organization and Architecture.
math: true
---

## 运算方法

#### IEEE754

浮点数表示标准： 

- 1 位符号位（S）：0 表示正数，1 表示负数
- 8 位阶码（E）：存储指数的 “偏移值”（偏移量为 127）
- 23 位尾数（M）：存储小数部分（隐含一个最高位的 “1”，节省空间）

{%note info%}

以`11.375`为例，步骤如下：

1. 将十进制转二进制

$11.375_{10} = 1011.011_2$（整数部分 11→1011，小数部分 0.375=0.25+0.125→011）

2. 规格化二进制（转为 $1.xxxxx \times 2^e$ 形式）

$1011.011_2 = 1.011011 \times 2^3$

→ 指数 $e=3$，尾数部分为`011011`（隐含前面的 “1”）

3. 计算阶码（E）

阶码是 “指数 + 偏移量 127”：$E = 3 + 127 = 130_{10} = 10000010_2$

4. 拼接结构

- 符号位 S：正数→`0`
- 阶码 E：`10000010`
- 尾数 M：`011011`后面补 0 到 23 位→`01101100000000000000000`

```
0 10000010 01101100000000000000000
```

{%endnote%}

#### 浮点运算方法和浮点运算器

1. 零操作数检查
2. 比较阶码大小并完成对阶（小阶向大阶看齐）：对齐小数点，以便进行尾数的加减运算

- 尾数左移会导致最高有效位的缺失，造成的误差较大

- 尾数右移最低有效位缺失，造成的误差较小，每右移一位，阶码加一，右移位数等于阶差

1. 尾数求和：与定点数加减法方法相同
2. 规格化处理：尾数右移实现规格化
3. 舍入处理：规格化后最低有效位丢失，会造成一定误差，要进行舍入处理 
   - 就近舍入
   - 朝0舍入
   - 朝+无穷舍入
   - 朝-无穷舍入
4. 判断溢出（考试的时候记得进行判断）
   - 阶码上溢
   - 阶码下溢
   - 尾数上溢
   - 尾数下溢

#### 浮点运算流水线

使各子任务能在流水线的各个阶段并发执行（实现计算机时间并行性），子任务内部具有优先关系的叫做线性流水线。

对于一个具有k级过程段的流水线处理n个任务需要的：
- 采用流水线：$T_k=k+(n-1)$
- 不采用流水线：$T_L=n·k$

流水线加速比为二者的比值$C_k=\frac{T_L}{T_k}$，取limit极限，加速比为k



### 存储系统

#### 存储器三剑客：

- 主存（内存）：用来存放计算机**运行期间所需要的程序和数据**，CPU可以直接随机的进行读/写访问，存取速度快。

- 外存：用来存放**暂时不参与运行**的程序和数据，以及一些需要**永久性保存**的信息，容量极大，但存取速度低，CPU不能直接访问，信息必须调入主存后CPU才能使用。

- CPU和主存之间还有高速缓冲存储器cache**存放正在执行的程序段和数据**，通常被放在CPU芯片中，存储容量小，价格高

#### 按存取方式分类

- 随机存储器RAM
  - 优点：对RAM任意单元的**读写时间相同**，与物理地址无关（类似数组） 
  - 缺点：一旦断电，RAM失去存储信息
    - 静态SRAM：双稳态触发器，制造cache
    - 动态DRAM：mos管和电容，主存

- 只读存储器ROM
  -  优点：断电之后不会丢失存储信息，适合**存储固定程序和数据**
  -  缺点：一经写入，之后只能读取，不能再次写入，里面的内容固定不变 
- **顺序**存取存储器：磁带
  - 缺点：必须数着存储单元的物理地址顺序，顺次访问（串行访问）（类似链表）必须从前往后遍历才能找到需要访问的单元，存取时间与存取的物理地址相关
- 直接存取存储器dam：光盘（随机+顺序存取相结合）
  - 特点：先通过随机访问，确定一个较小的存储区域，在在这小区域内顺序查找
- 相联存储器：按照内容寻址，将所存的内容的某一部分作为检索项（关键字）去检索

#### 按断电后信息的可保存性分类
- **易失性**存储器
- **非易失性**存储器

####  按读出方式分类
- 破坏性读出：读出后若不加恢复则存储器存储的信息会丢失（DRAM）
- 非破坏性读出：不会丢失信息（SRAM，ROM）



### 寻址
- 字节编址最小形式单位是一个字节，可以按字节。半字，字寻址
- 字编址最小心是单位是一个字，仅支持，按字寻址

1. 字节（Byte）：固定标准，**1字节 = 8位（bit）**，全球统一。 
2. 不同机器字长的换算示例：   
   - 32位机器：1字 = 4字节（32位），1半字 = 2字节（16位）；   
   - 16位机器：1字 = 2字节（16位），1半字 = 1字节（8位）；   
   - 64位机器（通用）：1字 = 8字节（64位），1半字 = 4字节（32位）。

{%note info%}

机器字长是 CPU 的硬件属性，指 CPU 一次能处理的二进制数据位数（32 位 / 64 位）就比如我们知道的windows32位/64位系统：具体差异体现在：

- 寻址能力：32 位系统最大支持约 4GB 内存（受限于 32 位地址线寻址上限），64 位系统可支持远超 4GB（理论上达 16EB），多开软件、运行大型程序（如设计软件、游戏）时更不易卡顿。
- 软件兼容性：32 位系统无法运行 64 位软件，64 位系统可兼容运行大部分 32 位软件
- 运算性能：64 位 CPU 一次能处理更多数据，对复杂计算（如视频渲染、编程编译）的效率比 32 位更高，日常简单操作（聊天、浏览网页）差异不明显。

{%endnote%}

{%note info%}

1GB = 1024MB，1MB = 1024KB，1KB = 1024B

{%endnote%}

{%note danger%}

- 核心原则：**“字” 的长度永远等于机器字长**，“半字” 是 “字”长度的一半，均以字节为最小单位换算。

{%endnote%}

### 存储速度

{%note info%} 

- 1 s（秒）= 10³ ms（毫秒）= 1000 ms
- 1 ms（毫秒）= 10³ μs（微秒）= 1000 μs
- 1 μs（微秒）= 10³ ns（纳秒）= 1000 ns

{%endnote%}

- 访问时间：
  - 读出时间$T_A$
  - 写入时间$T_W$
- 存储周期：进行一次**读写操作**所需要的全部时间，就是存储器进行连续读写操作所允许的最短时间间隔
- 存储带宽：表示存储器被连续访问时可以提供的数据传送速率，字节/秒

{%note info%}
- 存取时间：存储器从读出或者写入一次信息所需要的平均时间
- 存取周期：**连续两次访问存储器**之间所必需的最短时间间隔
{%endnote%}

#### 存储介质

- 磁存储器：存取速度慢，但成本低
- 光存储器：用激光束照射盘面，靠盘面的不同反射率来读出数据，便于携带
- 半导体存储器

#### RAM工作原理

存放一个二进制的物理器件叫做存储元，地址码相同的多个存储元构成一个存储单元，若干存储单元的集合构成存储体

- DRAM：用于主存，由mos管和电容组成，当电容存储的电荷数超过阈值（电量），电容所在的存储元表示1 
  - 写入：给高电压，mos管导通，充电
  - 读出：mos管导通，若电容有电，电流流出，通过外接信号放大器检测电容的电压信息，放电后需要再次充电进行恢复（破坏性读出）；漏电需要刷新 ，重新将电荷充满
- SRAM双稳态触发器（6个mos管）：存取速度按快，用于cache

| 特征       | SRAM         | DRAM       |
| ---------- | ------------ | ---------- |
| 构成       | 双稳态触发器 | 电容       |
| 破坏性读出 | 否           | 是         |
| 再生       | 不需要       | 需要       |
| 易失性     | 是           | 是         |
| 送行列地址 | 同时送       | 行列分开送 |
| 引脚数量   | 较多         | 较少       |
| 速度       | 快           | 慢         |
| 刷新       | 不需要       | 需要       |
| 集成度     | 低           | 高         |
| 功耗       | 高           | 低         |
| 价格       | 高           | 低         |



#### 线选法

$n$个地址引脚定义$2_n$的地址空间，

- 缺点：译码后输出端的线数量过多

#### 重合法

双译码法 ：核心原理类似笛卡尔坐标系，通过“行地址+列地址”的地址对唯一确定存储单元，适用于大容量存储场景。若地址引脚总数为$n$，可将其分为行、列两组地址线（每组$n/2$根），此时译码后的输出引脚数量仅需$2×(n/2) + 1$，相较于线选法大幅减少，尤其适配大容量动态存储器件。

1. 地址传输技术差异
- DRAM：采用行列地址复用技术。基于重合法原理，分两次先后将行地址、列地址传入译码驱动电路，可使地址线数量减半，有效降低硬件成本。
- SRAM：采用行列地址独立传输技术，无需地址复用。

### DRAM的刷新机制
DRAM依靠电容存储电荷来保存数据，存在电荷泄漏问题，需定期刷新：
- 刷新单位：以行为单位进行整体刷新；
- 刷新周期：电荷保持周期为10~64ms，若未在周期内刷新，电容电荷会流失，导致存储数据丢失。

关键问题：刷新操作期间，DRAM无法响应CPU的读写访问，因此CPU访问内存与内存控制器的刷新操作之间会存在内存争用现象。

#### 集中刷新

前面周期都用来进行读写或者保持工作，后面**集中进行刷新**

- 优点：读写操作期间不受刷新操作的影响，速度较快
- 缺点：存在**较长的死区时间**，集中在刷新的读写周期内，CPU较长时间不能访问存储器，行数越多，死区时间越长

#### 分散刷新

将存储周期变为$t_c '$变为$t_c+t_r$（变相增长存储周期）对于每个存储周期前半段用来进行读写或者保持操作，后半段用来刷新
- 优点：不存在长时间的“死区”
- 缺点：**刷新过于频繁**，严重影响系统的速度

#### 异步刷新

**将集中刷新和分散刷新的方式相结合**，将128次刷新分散在2ms的时间内，每过一段时间，暂停读写，执行 1 次刷新（刷 1 行）
- 优点：死时间的分布更加分散，避免CPU连续等待过久的时间

{%note info%}
- 分散刷新是 “读写必带刷新”—— 只要用存储器，就必须同时承担刷新开销，每个周期都慢；
- 异步刷新是 “读写和刷新分离”—— 大部分时间读写都全速，刷新只在间隙插入，仅插空时影响。
{%endnote%}

动态存储器的刷新**按行进行**，为了减少刷新周期，可以减少存储矩阵的行数，增加列数

### 只读存储器ROM

- 掩模式只读存储器MROM：在芯片生产过程中直接写入，写入后任何人都无法改变
  - 优点：**可靠性高**
  - 缺点：**灵活性差** 
- 一次可编程只读存储器**PROM**：允许用户一次性编程写入程序
- 可擦除可编程只读存储器**EPROM**：用户可以写入还能进行多次修改，不能取代RAM，因为编程次数有限，而且写入时间过长
- **flash**存储器：闪存，支持快速擦出和重写，写入前必须先擦除
- 固态硬盘**SSD**：基于闪存，价格较高

### 主存容量扩展

- 存储介质：具有两种**明显区别且稳定的物理状态**（分别表示0和1） 通常使用半导体材料或者磁化材料，

$存储容量=存储字数(单元数)\times存储字长$

{%note info%}

$16k(地址线数目)\times8位（数据线数目)$

- 地址线数目 $2^4 \times 2^{10} = 2^{14}$，地址线位数 $n = \log_2(2^{14}) = 14$
- 数据线数目$=8$

{%endnote%}

#### 位扩展

通过译码器控制扩展后的芯片选通

#### 字扩展

- 线选法：用除片内寻址外的高位地址线连接存储芯片的片选端
  - 优点：不需要地址译码器，线路简单
  - 缺点：地址空间不连续，不能充分利用系统的存储器的空间

{%note info%}

将$16K \times 8bit$扩展为$64K \times 8bit$:

第一片：最低地址：**1110** 00 0000 0000 0000 最高地址：**1110** 11 1111 1111 1111

第二片：最低地址：**1101** 00 0000 0000 0000 最高地址：**1101** 11 1111 1111 1111

第三片：最低地址：**1011** 00 0000 0000 0000 最高地址：**1011** 11 1111 1111 1111

第四片：最低地址：**0111** 00 0000 0000 0000 最高地址：**0111** 11 1111 1111 1111

{%endnote%}

- 译码片选法：用除片内寻址外的高位地址线通过地址译码器产生片选信号

 {%note info%}

将16Kx8bit扩展为64Kx8bit:

第一片：最低地址：**00**00 0000 0000 0000 最高地址：**00**11 1111 1111 1111

第二片：最低地址：**01**00 0000 0000 0000 最高地址：**01**11 1111 1111 1111

第三片：最低地址：**10**00 0000 0000 0000 最高地址：**10**11 1111 1111 1111

第四片：最低地址：**11**00 0000 0000 0000 最高地址：**11**11 1111 1111 1111

{%endnote%}

- 高位多体交叉访问存储器（**串行**）：高位地址产生片选信号，选择不同的存储模块；低位地址选择存储模块中不同的存储单元`模块地址`+`块内地址`，读出一个数据的平均时间为$T$

| 模块号 |   地址编址序列    | 对应二进制地址的最低两位 |
| :----: | :---------------: | :----------------------: |
|   M₀   |   0,1,2,3,...7    |            00            |
|   M₁   |  8,9,10,11,...15  |            01            |
|   M₃   | 24,25,26,27,...31 |            11            |

- 低位多体交叉访问存储器（**并行**）：相邻的地址处在不同的存储体中，同一存储体中地址不相邻`块内地址`+`模块地址`，使得多个模块可以同时工作，读出一个数据的平均时间为$\frac{T+(n-1)r}{n}$，极限值为$r$，读取数据的时间大幅缩短。（要求$T>mr$，以实现流水线的功能）

| 模块号 |        地址编址序列         | 对应二进制地址的最低两位 |
| :----: | :-------------------------: | :----------------------: |
|   M₀   |  0, 4, 8, 12, ..., 4i,...   |            00            |
|   M₁   | 1, 5, 9, 13, ..., 4i+1,...  |            01            |
|   M₂   | 2, 6, 10, 14, ..., 4i+2,... |            10            |

 ### 主存

#### 磁盘

由磁盘驱动器、磁盘控制器、磁头、盘片线组成 （从外往里数为0，1，2号磁道），磁道被分为很多**扇区**

由多个盘片构成，每个盘片分成上下两个盘面，每个盘面有多个圆环构成，圆盘上均匀分布磁介质（用来存储0和1）尽管磁道长度不同，但是**每个磁道存储的数据量相同**，因此**从外到内磁道的位密度逐渐变小**，顺时针分扇区，扇区间有扇区间隙，多个**磁道号相同的磁道**，共同构成一个**柱面**，柱面号即为磁道号，多个盘片绑在一个电机上，旋转时，盘面会同时旋转。

- 道密度：沿**磁道半径方向单位长度上的磁道数**
- 位密度：磁道**单位长度上能记录的二进制代码位数**

- 磁道的容量：
  - 非格式化（此记录表面可利用的磁化单元数）：$柱面数 \times 盘面数 \times 每条磁道的磁化单元数$
  - 格式化（按照某种特定格式存储，如**含有校验信息**）：格式化的容量比非格式化的小，$记录面数 \times 柱面数 \times 每道扇区数 \times 每个扇区的容量$      

$存取时间=寻道时间（磁头到目的磁道）（取平均时间最外到最内到一半）+旋转延迟时间（磁头定位到读写扇区时间）（平均取旋转半周）+传输时间（传输数据所花费的时间）$

CPU:arrow_right:磁盘控制器:arrow_right:磁盘驱动器:arrow_right:磁盘

磁盘寻址：
1. 确定访问哪个磁盘组（由多个磁盘构成）
2. 确定应该访问哪个**柱面**
3. 确定应该访问到**盘面**
4. 确定**扇区**

- 磁盘阵列（RAID）:用独立磁盘构成具有冗余能力的阵列（0～5分别代表不同的架构与功能）
  - RAID0：无数据校验，不提供冗余策略，没有容错能力
  - RAID1：无差别写入两份磁盘，分为工作磁盘和镜像磁盘，利用率只有50%，两块当一块使用

#### 固态硬盘(SSD)

与U盘无本质差别，只是容量更大，存取性能更好
- 优点：启动快、抗摔性好
- 缺点：一个块的写入次数不能过多，一般不超过10w次，否则会因为默算而无法再次写入;引入磨损均衡：避免数据重复在某个空间写入，以保证各个存储区域磨损程度基本一致
  - 动态：写入数据时，**自动选择**较新的内存块
  - 静态：SSD检测并自动进行数据分配，平常的读写操作在较新的闪存块中进行

### 高速缓冲存储器

- 时间局部性：同一变量/指令短时间内被多次访问/执行
- 空间局部性：指令顺序执行/数组等**连续结构**存储体在相邻的位置以短时间内被顺次访问

通过在cache设置有效位，来判断CPU的cache中是否有主存有效信息

#### CPU在cache中的访问过程

先检查cache中有没有要访问的信息

- 若有，直接从cache读取，即**cache命中**
- 若无，则从主存中把当前访问信息所在的一个主存块复制到cache中

$命中率=\frac{命中次数}{访问总次数}$

- 命中时，CPU直接在cache中存取信息：$T=T_c$
- 缺失时，需要从主存读取一个主存块送到cache：$T=T_m+T_c$

平均访问时间：$T=pT_c+(1-p)(T_m+T_c)$，由于局部性的特点，cache的命中率可以很高

#### cache行和主存的映射方式

先将主存高位地址的标记与cache进行比较，若相等且有效值为1则命中直接取出信息；若不相等则CPU从主存中读出信息送到cache任意空闲行中，有效位置1，并设置标记

- 全相联映射：主存可以复制到cache任意行中只要有空闲的cache块`主存标记+块内地址`
  - 优点：冲突概率低，空间利用率高，命中率高
  - 缺点：标记比较速度较慢，实现成本较高，要按内容寻址的相联存储器
- 直接映射：映射到特定行`主存标记+cache行号+块内地址`  
  - $cache行号=主存块号 \mod cache行数$
- 组相联映射：将cache分成多个组，组内有多行，主存可以放在特定组的任意行（组间采用直接映射，组内采用全相联映射）`主存标记+组地址+块内地址`

#### 替换策略

- 随机算法（rand）：为依据程序访问的局部性原理，导致命中率较低
- 先进先出（FIFO）：选择**最高调用**的cache行进行替换
- 近期最少使用（LRU）
  - 命中时，所命中的行计数器清零，比其低的计数器加一，其余不变
  - 未命中且还有空闲行时，新装入的行的计数器置0，其余全加1
  - 未命中且无空闲行时，计数值最大的信息被替换，新装入的行的计数器置0，其余加1

  抖动：集中访问的存储区超过cache的大小时，命中率变得很低

- 最不经常使用（LFU）：将一段时间被访问次数最少的cache行换出

#### 不一致性

写给cache时，会导致主存和cache不一致的问题

- 全写法：写操作时，若写命中，则同时写cache和主存：需要额外引入写缓冲，CPU在将数据写入cache时也写入写缓冲，然后由写缓冲将需要写入的数据写回主存
  - 缺点：增加访存次数
- 写回法：写命中时，信息写入cache而不写入主存，直到cache被替换出去时，才将数据写回主存，需要给cache增加`脏位`（`修改位`）
- 写分配法：写回主存后，把写入过的主存调入cache中
- 非写分配法：写回主存后，不调入cache

|        | 命中时 |  未命中时  |   需要   |
| :----: | :----: | :--------: | :------: |
| 方式一 | 全写法 | 非写分配法 |  写缓冲  |
| 方式二 | 写回法 |  写分配法  | 附设脏位 |

#### cache分离

- 统一cache：刚出现时**指令和数据都放在里面**
  - 优点：设计和实现相对简单
  - 缺点：存取数据又要读指令时会发生冲突
- 独立cache：**分开为指令cache和数据cache**
  - 指令cache（顺序执行）比数据cache（跳转访问）有更好的空间局部性

#### cache分离

将cache集成在CPU中称为第一级cache：减少对片外总线的访问，加快存取速度；但由于容量较小，CPU和主存之间设置的cache为第二级cache。
- L1和L2全写法
- L2和主存写回法。

## 指令

指令字长：一条指令所包含的二进制代码的位数，与机器字长美与固定关系，会影响指令时间开销，`操作码+地址码`

- 单字长指令：访存一次即可完整取出
- 双字长指令：需要**访存两次**，耗费两个存取周期
- 半字长指令

#### 指令按地址码分类

- 零地址指令：`OP`
  - 不需要操作数：空操作、停机、关中断指令
  - 两个操作数在堆栈计算机中（隐含寻址）
- 一地址指令：`OP+A1`
  - 进行`OP`操作后放回原地址：加1、减1、求反、求补、移位
  - 将结果存入默认地址如累加器中
- 二地址指令`OP+A1+A2`
  - `A1`是目的操作数`A2`是源操作数，将运算结果存入`A1`
- 三地址指令：`OP+A1+A2+A3(结果)`
- 四地址指令：`OP+A1+A2+A3(结果)+A4(下址)`

#### 指令长度

操作码随着地址码的减少而增加

- **定长**指令字结构：所有指令长度相等
- **变长**指令字结构：长度应功能而异，地址指令增加用扩展操作码，各个操作码是前缀编码，任何操作码都不是其他编码的前缀（即通过扫描前几个操作码即可判断是什么指令，不会出现重复）

#### ISA
指令集体系结构定义了计算机系统中的指令的集合以及这些指令的**规范**，不关心是什么操作系统以及一些较为细节底层的内容，主要包括：

- 指令格式，寻址方式，操作类型
- 操作数类型，操作数的寻址方式
- 寄存器编号、个数、位数
- 指令执行过程的控制方式

### 寻址

#### 指令寻址

- 顺序寻址：程序计数器（PC）+1，根据PC的内容取指并执行，自动形成下一跳指令的地址

-  跳跃寻址：程序转移类指令
  - 直接寻址
  - 相对寻址
  - 间接寻址

#### 数据寻址

` 操作码+寻址特征+形式地址`，`寻址方式+形式地址=有效地址`

- 立即寻址：`OP+#+A`，只要取出指令也就取出了可以立即使用的操作数

  - 优点：操作码和操作数同时去除，不必再次访问主存
  - 缺点：操作数是指令的一部分，不能被修改

- 直接寻址：形式地址直接给出就是有效地址

  - 优点：不需要任何寻址运算，简单便于硬件实现
  - 缺点：寻址范围受限

- 寄存器寻址：给出的是通用寄存器的编号（有效地址就是寄存器的编号），寄存器中存放着操作数

  - 优点：从寄存器中存取数据比从主存中快，寄存器数量少，地址码字段比主存单元地址字段短，可以缩短指令长度，提高指令执行速度
  - 缺点：造价昂贵，无法提供大量存储空间

- 隐含寻址：不直接给出操作数的地址，而是在指令中隐含着操作数地址（隐含在寄存器中）。

  - 指令更短
  - 缺点：需要添加额外额硬件来实现

- 间接寻址： 在地址为A的主存单元存储了操作数的有效地址，相当于进行跳转（一级、多级寻址通过间址标志位0、1判断是否已经找到有效地址还是需要继续间接选址）

  - 优点：扩大了操作数的寻址范围
  - 缺点：增加了访问主存的次数

- 寄存器间接寻址：指令中的地址吗给出的是通用寄存器的编号，在指定的寄存器中存放操作数的有效地址

  - 只需要一次访存

- 基址寻址：将基址寄存器内容加上形式地址形成有效地址，面向系统，内容由操作熊确定，其值无法改变

  - 隐式：专用基址寄存器
  - 显示：通用寄存器

- 变址寻址：将变址寄存器内容加上形式地址形成有效地址，变址面向用户，相当于一个可由用户改变的偏移量，而原有效地址是一个首地址

  - 优点：扩大寻址范围，循环中修改偏移量便利数组空间

- 相对寻址：由程序计数器（PC）提供脊椎地址，形式地址作为偏移量

  - 优点：操作数的地址与指令地址相差一个固定偏移量，便于程序浮动

- 堆栈寻址：

- 扩展变址寻址：

- 基址变址寻址：

| 寻址方式           | 有效地址                 | 访存次数 | 备注                           |
| :------------------: |:------------------------:| :--------: | :------------------------------: |
| 立即寻址           | A即是操作数              | 0        | 无需寻址即可获得操作数         |
| 直接寻址           | EA=A                     | 1        | 无需寻址即可获得操作数         |
| 一次间接寻址       | EA=(A)                   | 2        | 间接寻址次数越多，访存次数越多 |
| 寄存器寻址         | EA=R₁                    | 0        | 速度较快且可有效缩短指令字长   |
| 寄存器间接一次寻址 | EA=(R₁)                  | 1        | 比一次间接寻址快些             |
| 相对寻址           | EA=(PC)+A                | 1        | 常用于转移指令                 |
| 基址寻址           | EA=(BR)+A                | 1        | 常用于多道程序                 |
| 变址寻址           | EA=(IX)+A                | 1        | 常用于循环程序和数组问题       |
| 前变址方式         | EA=((IX)+A)              | 2        |                                |
| 后变址方式         | EA=(IX)+(A)              | 2        |                                |
| 基址变址寻址       | EA=(BR)+(IX)+A           | 1        | 最灵活的一种寻址方式           |
| 软堆栈             | 需要专门的寄存器保存栈顶 | 1        | 成本低、容量大、速度慢         |
| 硬堆栈             | 无需栈顶指针             | 0        | 成本高、容量小、速度快         |
| 隐含寻址           |                          |          | 简化地址结构                   |



### x86

#### 寄存器

- EAX（32）=E（16）+AX（16）

AX=AH（8）+AL（8）

- EAX是扩展累加寄存器（accumulator），通常用于存储操作结果。
- EBX是扩展基地址寄存器（base），可以在内存寻址时存放基地址。（基址寄存器）
-  ECX是扩展计数寄存器（count），是某些指令的计数器。
-  EDX是扩展数据寄存器（data），与EAX经常配合使用。
-  ESI/EDI是扩展源/目标指针寄存器（source index/destination），其中，ESI通常用于存储当前正在处理的源数据（source data）的索引或地址。例如数组访问中使用，以指向数据的来源位置。（变址寄存器）
- EBP是扩展基址指针寄存器（base pointer），一般用于指示 ESP是扩展堆栈指针寄存器（stack pointer），一般用于指示栈顶。

#### 指令格式

汇编指令：`助记符+目的操作数+源操作数`

- R[r]表示寄存器r的值
- M[addr]表示内存地址为addr的值

| 操作数类型 | 寻址方式       | 举例          | 值                   |
| :----------: | :--------------: | :-------------: | :--------------------: |
| 立即数     | 立即数寻址     | 0xff          | 255                  |
| 寄存器     | 寄存器寻址     | eax           | R[eax]               |
| 内存       | 直接寻址       | [var]         | M[var]               |
| 内存       | 寄存器间接寻址 | [eax]         | M[R[eax]]            |
| 内存       | 基址寻址       | [ebx+4]       | M[R[ebx]+4]          |
| 内存       | 变址寻址       | [ebx+esi+4]   | M[R[ebx]+R[esi]+4]   |
| 内存       | 比例变址寻址   | [ebx+eax*4+3] | M[R[ebx]+R[eax]*4+3] |

### 常用指令

#### MOV指令 

`mov 目的操作数, 源操作数`；将源操作数复制到目的操作数，源操作数内容不变 （`;`为注释标识符，用于解释代码，不会对指令执行产生影响）  

1. `mov <reg>, <reg>`；将一个寄存器的内容移动到另一个寄存器。   
   - `mov EAX, EBX`；将EBX寄存器的内容复制到EAX寄存器  
2. `mov <mem>, <reg>`；将寄存器的内容移动到内存地址。   
   - `mov DWORD PTR [ECX], EAX`；将EAX寄存器的内容复制到ECX指向的内存地址  
3. `mov <reg>, <mem>`；将内存内容移动到寄存器。   
   - `mov EBX, DWORD PTR [EAX]`；将EAX指向的内存地址的内容复制到EBX寄存器   （`PTR`操作符放在内存操作数之前指明其位数）     
   - `BYTE PTR`：表示操作数为单字节     
   -  `WORD PTR`：表示操作数为字(双字节)     
   - `DWORD PTR`：表示操作数为双字(四字节)  
4. `mov <mem>, <con>`；将一个常量移动到内存。   
   - `mov DWORD PTR [EBP+4], 12345`；将常量12345存储在EBP加上偏移4的内存地址  
5. `mov <reg>, <con>`；将一个常量移动到寄存器。   
   - `mov EDX, 0FFh`；将立即数0FFh（即255的十六进制表示）赋值给EDX寄存器

`mov`指令的两个操作数不能同时是内存

#### add/sub指令

将目的操作数与源操作数相加减并将结果报存在目的操作数种，源操作数保持不变

`add/sub+源操作数+目的操作数`

1. `add/sub <reg>,<reg>`两个寄存器
2. `add/sub <reg>,<mem>`寄存器和内存
3. `add/sub<reg>,<con>`寄存器和内存
4. `add/sub <reg>,<con>`寄存器和常量
5. `add/sub <mem>,<con>`内存和常量

#### inc/dec指令

`inc/dec <reg>`自增自减

#### imui指令

1. 两个操作数：两数相乘结果报存在第一个操作数中
2. 三个操作数，二、三相乘结果保存在第一次操作数中

#### and/or/xor指令

`add/or/xor 目的操作数 源操作数`

#### not指令

`not 操作数`

#### neg指令

`neg 操作数` 取相反数

#### shl/shr指令

- `shl/shr 操作数1 操作数2`逻辑左移和右移
  - `shl eax 1`；将`eax`左移1位置
  - `shr ebb,cl`；将`ebx`右移`n`位

#### cmp/test指令

只设置条件码而不改变操作数

- `cmp`比较两数大小
  - `cmp eax,ebx`不改变值，只影响状态标志
- `test`进行逻辑与

#### 无条件转移指令 

`jmp <label>`代码跳转到`<label>`执行

```x86asm
mov EAX, 1    ; EAX = 1
jmp skip      ; 直接跳到 skip 标签
mov EAX, 2    ; 这条指令被跳过！
skip:
mov EBX, EAX  ; 这里 EBX = 1
```

```x86asm
mov ECX, 3     ; 设置循环3次
mov EAX, 0     ; 用来计数

my_loop:
add EAX, 1     ; 每次加1
jmp my_loop    ; 无条件跳回开头，形成死循环
```

#### 调用子程序

```x86asmcall
call <function> ;调用其他程序（函数调用）
ret ;指令返回
```

```x86asm
section .text
global _start

_start:
    call print_hello    ; 调用打印函数
    
    ; 退出程序
    mov eax, 1          ; 系统调用号 1 = exit
    mov ebx, 0          ; 返回码 0
    int 0x80            ; 调用内核

print_hello:
    mov edx, len        ; 字符串长度
    mov ecx, msg        ; 字符串地址 (原代码写成了meg)
    mov ebx, 1          ; 文件描述符 1 = stdout
    mov eax, 4          ; 系统调用号 4 = write
    int 0x80            ; 调用内核
    ret                 ; 返回到 call 的下一条指令

section .data
msg db 'Hello World', 0xA  ; 加上换行符
len equ $ - msg            ; 计算字符串长度
```

#### Jcondition指令

结合`cmp`使用的条件转移指令

|    指令     | 跳转条件 |  跳转描述   |
| :---------: | :------: | :---------: |
|  `je`/`jz`  |    ZF    |   相等/零   |
| `jne`/`jnz` |    ZF    | 不相等/非零 |
|    `js`     |    SF    |    负数     |
|    `jns`    |    SF    |   非负数    |

- `ZF`（Zero Flag）零标志
- `SF`（Sign Flag）符号位标志

```x86asm
mov eax, 5
mov ebx, 5
cmp eax, ebx    ; 比较 eax 和 ebx
je equal_label  ; 如果相等，跳转到 equal_label

; 如果不相等，继续执行这里...
```

#### 转换

- `if-else`语句

```c++
if(a>b){
  c=a;
}
else {
  c=b;
}
```

```x86asm
mov eax, 7    ; a = 7
mov ebx, 6    ; b = 6
cmp eax, ebx  ; 比较 a 和 b
jg greater    ; 如果 a > b，跳转到 greater
mov ecx, ebx  ; 否则：c = b
jmp end
greater:
mov ecx, eax  ; c = a
end:
```

- `for`循环

```c++
int result=0;
for(int i=1;i<=100;i++){
  result+=i;
}
```

```x86asm
mov eax, 0        ; result = 0
mov edx, 1        ; i = 1

l1:
add eax, edx      ; result += i
inc edx           ; i++
cmp edx, 100      ; 比较 i 和 100
jle l1            ; 如果 i <= 100，继续循环

l2:
```

#### AT&T格式

和Intel同用于编写x86汇编程序，只是两种不同的语法风格

|     AT&T格式      |    Intel格式    |
| :---------------: | :-------------: |
|  `mov $100,%eax`  |  `mov eax,100`  |
|  `mov %eax,&ebx`  |  `mov ebx,eax`  |
| `mov %eax,(%ebx)` | `mov [ebx],eax` |

- AT&T只能用小写字母，Intel对大小写不敏感

-  AT&T第一个为源操作数，第二个为目的操作数

- AT&T寄存器需要加前缀`%`，立即数需要加前缀`$`

- 内存寻址时，AT&T用`()`，Intel用`[]`

- 复杂寻址时，`disp(base, index,scale)`分别表示偏移量、基址寄存器、变址寄存器、比例因子，如`8(%edx,%eax,2)`，表示`M[R[edx]+R[eax]*2+8]` 

#### CISC && RISC

- CISC（复杂complex指令集计算机）

  - 指令复杂、长度不固定
  - 使用频度、执行时间相差大
  - x86

- RISC（精简reduced指令集计算机）
  - ARM、MIPS、RISC-V
  - 指令简单、长度固定

## CPU

指令周期：一条指令从取出到执行完成所需要的时间。指令周期通常用若干个CPU周期来表示，CPU周期又称为机器周期。一个CPU周期有包含若干个时钟周期（T周期、处理操作的基本单位）

| CPU工作周期 | 目的                                           |
| ----------- | ---------------------------------------------- |
| 取指周期    | 取指令                                         |
| 间址周期    | 取操作数有效地址（当指令中地址需要间接寻址时） |
| 执行周期    | 取操作数，存操作数（`jmp x`可跳过）            |
| 中断周期    | 保存断电（IO有中断请求时）                     |

```RTL
(PC)→MAR, Read 
M(MAR)→MDR, (PC)+1→PC      
(MDR)→IR   
```

#### 数据通路

寄存器之间传送信息的通路

#### 寄存器传递语言RTL

- 用`(r)`代表寄存器r的内容
- 用`M(add)`代表主存单元addr的内容
- 用`(A)->B`或`B<-(A)`表示数据传送，其中A为源操作数，B为目的操作数
- 程序计数器`(PC)`表示其内容

#### 单周期处理器

- 一条指令从头到尾，在**1 个时钟周期内**完成（CPI=1）。
- 时钟周期的时长，得按 “最复杂指令的执行时间” 来定（要等最慢的步骤做完）。
- 一个时钟周期内，控制器的控制信号不能变。

#### 多周期处理器

- 一条指令拆成**多个步骤**，每个步骤用 1 个时钟周期（CPI>1）。
- 不同指令可以按 “自身复杂程度” 安排时钟周期数（简单指令用的周期少，复杂的用的多）。
- 时钟周期时长按 “单个步骤（比如一次存储器读写）” 的时间来定，不用迁就最复杂指令。

### CPU控制器模型

#### 1. 硬布线控制器

整个过程是**纯硬件电路的即时响应**， 没有中间的软件 / 微程序层，硬件电路同时接收三类信号：

- 指令译码信号：由指令寄存器中的操作码`OP`，经指令译码器翻译得到；
- 时序信号：由时序发生器产生的机器周期（如取指 / 执行周期）、节拍信号（周期内的时间片）；
- 反馈信号：来自执行单元的标志位（如运算结果是否为零相当于`if`语句的条件）、I/O 的状态等。

上述信号输入到硬布线控制器组合逻辑单元，通过**预先设计的门电路**，直接进行硬件层面的运算。

#### 2. 微程序控制器

1. **把机器指令拆成微程序**：每条机器指令对应一段 “微程序”（由多个 “微指令” 组成），每个微指令包含若干 “微命令”（对应具体硬件动作）。
2. **从控制存储器读微程序**：控制存储器（专门存微程序的硬件）根据当前机器指令的操作码，读出对应的微程序。
3. **按微指令发控制信号**：时序发生器定节奏，按顺序执行微程序里的微指令，每个微指令输出对应的微命令，指挥硬件完成微操作。

取指等公共阶段被封装，实际上只需要实现执行阶段。

#### 流水线

假设有五个功能：

- 吞吐率：单位时间内能完成的指令数，$T_p=\frac{n}{T_{max}\times(n+4)}$

- CPI：每条指令的时钟周期数，$CPI  =\frac{n}{n+4}$

- 流水线加速比：$S_p=\frac{n\times m\times \Delta t}{m\times \Delta t+(n-1)\Delta t}=\frac{n\times m}{m+n-1}$

##  总线

多个部件之间采用总线连接的方式，可大大降低部件间互联的复杂性，大幅度减少连接的数量

#### 性质

- 分时：在任何时刻只可以有一个部件向总线上发送消息
- 共享：可以有一个或多个部件接收消息

#### 类型分类

- 内部总线：CPU内部连接各寄存器、ALU 运算部件之间的总线

- 系统总线：CPU同其他计算机系统的其他高速功能相互连接的总线
  - 数据总线：传输数据、指令、终端类型
  - 地址总线：源数据、目的数据所在的主存单元或I/O端口的地址，单向传输总线，反映寻址空间
  - 控制总线：传输命令、反馈信号，总线请求/允许、中断请求/回答、存储器读写（命令相对指令更简单）

- I/O总线

#### 传输方式分类

- 串行总线：一条双向或两条单向，适合长距离通信
- 并行总线：实现多比特位的同时传输
  - 缺点：信息位有延迟，数据线之间相互干扰造成传输错误，适合近距离通信

#### 系统总线

- 单总线结构：将CPU、主存、I/O设备挂在一组总线上
  - 优点：结构简单、成本低、易于接入新设备
  - 缺点：带宽低、负载重、不支持并发传送

- 双总线结构：
  - 主存总线：用于在CPU、主存、通道之间传送数据
  - I/O总线：在多个外部设备和通道之间传送数据（I/O接口连接，通过I/O通道与主存总线连接交换数据）
    - 优点：将低速I/O设备从单总线上分离出来
    - 缺点：增加通道硬件设备

- 三总线结构：在双总线的基础上增加了DMA总线形成的
  - DMA总线：用于在内存和高速外设之间传送数据
    - 优点：提高I/O设备性能，更快响应命令、提高系统吞吐量
    - 缺点：任意时刻只能使用一种总线

#### 数据传送方式

- 非突发传送：每个周期内都是先传地址在传数据（每次只传一个数据）（$2n$个周期）
- 突发（猝发）性传送方式：传送首地址，然后可以传输多个连续单元的数据（$1+n$个周期）



## I/O系统

#### I/O核心寄存器

三者数据都通过**数据线**传输

- 数据缓冲寄存器（数据端口）：暂存 CPU / 内存与外设间的数据，CPU 可读写。
- 状态寄存器（状态端口）：记录接口 / 设备状态，CPU 仅能读（获取外设状态）。
- 控制寄存器（控制端口）：保存 CPU 对外设的控制命令，CPU 仅能写（向外设发指令）。

#### I/O端口及其编址

- 统一编址：外部设备地址与内存地址统一编址，通过不同的地址区域来进行划分。不需要设置专门的I/O指令。采用`Load/Store`访存指令就可以访问外部设备
  - 优点：更加灵活方便，共享访存指令的寻址方式和保护机制
  - 缺点：占用了主存空间的地址，减少了主存可用容量；译码过程更加复杂，降低寻址速度

```MIPS
lw $t0 0x00000004 # 从ROM读取一个字
sb $t0 0xff000004 # 写一个字节到内存
sb $t0 0xffff0004 # 写一个字节到I/O设备
```

- 独立编址：I/O映射方式，对主存空间和I/O端口地址分别进行编址，地址范围可以重叠，需要专门的I/O指令来表明访问的是I/O地址空间
  - 优点：I/O端口只需要少量地址线，译码更加简单，寻址速度更快；指令更加清晰，便于理解和检查
  - 缺点：专门的I/O指令只包含简单的传输操作，降低了程序设计的灵活性，而且CPu需要分别提供专门的读写命令，总线控制逻辑更加复杂；需要专门的硬件保护措施

```MIPS
MOV [BX], AL # 将 AL 内容送 BX 对应的内存单元

OUT DX, AL # 将 AL 字节写入 DX 对应的 I/O 端口
IN AL, DX # 从 DX 对应的 I/O 端口读取 1 字节到 AL
```

#### 程序查询

```x86
MOV DX, 0x0000   ; 将键盘“设备状态寄存器(DSR)”的端口地址0x0000存入DX寄存器
                 ; （端口地址由硬件映射表决定，这里DSR对应0x0000）
keypoll:         ; 轮询标签（循环入口）
IN AL, DX        ; 从DX指向的端口（即键盘DSR）读取8位数据，存入AL寄存器
TEST AL, 1       ; 对AL的最低位（Ready位）做测试：
                 ; TEST指令会计算 AL & 1，结果影响标志位（若Ready=1，结果非0；Ready=0则结果为0）
JZ keypoll       ; 若TEST结果为0（即Ready=0，键盘未准备好），则跳回keypoll继续循环查询
MOV DX, 0x0004   ; 当Ready=1时，将键盘“数据缓冲寄存器(DBR)”的端口地址0x0004存入DX
IN AL, DX        ; 从DX指向的端口（即键盘DBR）读取8位数据（键盘输入的字符ASCII码），存入AL
```

- 优点：设计简单、硬件少

- 缺点：CPU要花费很多时间来查询和等待

### I/O控制方式

#### 程序查询方式

- 独占查询：设备启动后，CPU 全程循环查询外设状态，直到设备就绪。
  - CPU 100% 时间用于 I/O 轮询，和外设完全串行工作；
  - 实现简单，但**CPU 资源浪费严重**
- 定时查询：CPU 启动设备后，通过**定时中断**周期性查询状态，期间可运行其他程序。
  - CPU 可以并行运行其他任务，**资源利用率比独占查询高**

#### 中断方式

不能使用I/O中断的情况：外设数据传输速率远大于CPU速率。即外设刚把缓冲寄存器填满，CPU 还没来得及处理，外设又要传新数据了，旧数据会被新数据覆盖，直接丢失。

#### DMA方式

Direct Memory Access ：让外设和内存直接传数据，不用经过 CPU

1. 预处理：CPU 初始化 DMA 控制器，随后继续执行原程序。
2. 发请求：I/O 设备就绪后，向 DMA 控制器发 DMA 请求。
3. 争总线：DMA 控制器向 CPU 请求总线控制权。
4. 传数据：CPU 让出总线，DMA 控制器直接控制 I/O 与内存传输数据。
5. 后处理：传输完成，DMA 控制器发中断请求；CPU 收请求后，执行中断服务程序做数据校验等收尾工作。

- 整个数据块传送过程都不需要CPU的参与，CPU只在最初的DMA控制器初始化和最后的DMA结束处理时才介入，用于I/O的开销非常小

#### DMA和CPU冲突

- 停止访存：当 I/O 设备有 DMA 请求时，DMA 接口让 CPU 暂停访存、交出总线控制权，直到 DMA 传完数据再归还。
  - 优点：控制简单，适合高速 I/O 设备成组传数据
  - 缺点：DMA 工作时 CPU 基本闲置。
- 周期挪用：因 I/O 访存优先级更高，I/O 会 “挪用” 1 个存取周期传 1 个数据后立刻释放总线（单字传送）。
  - CPU 不访存则无冲突；
  - CPU 正在访存则等其周期结束再让总线；
  - 二者同时访存则 CPU 暂时让权。
    - 优点：兼顾 I/O 传送与 CPU、主存效率
    - 缺点：每次挪用都要申请、建立和归还总线控制权
    - 适合 I/O 请求 “不规律、速度中等” 的设备（比如打印机），按需借用不浪费资源。
- DMA和CPU交替访存：把 CPU 工作周期分成两个时间片，分别给 CPU 和 DMA 轮流访存（适用于 CPU 周期长于主存存取周期的情况，轮流时间固定）。
  - 优点：无需申请 / 归还总线，通过分时控制总线使用权
  - 缺点：硬件逻辑复杂

|      对比维度       |                   中断方式                   |                         DMA 方式                         |
| :-----------------: | :------------------------------------------: | :------------------------------------------------------: |
| 程序影响 & 资源占用 | 是程序切换，需保护 / 恢复现场，占用 CPU 资源 | 不中断现行程序，无需保护现场，仅预处理 / 后处理占用 CPU  |
|    请求响应时机     |        仅在**每条指令执行结束时**响应        | 可在**任意机器周期结束时**（取指、间址、执行周期后）响应 |
|    CPU 干预情况     |            传输过程需要 CPU 干预             |   传输过程无需 CPU 干预，速率高，适合高速外设成组传输    |
|     请求优先级      |             优先级低于 DMA 请求              |                    优先级高于中断请求                    |
|      功能范围       |                可处理异常事件                |                   仅局限于大批数据传送                   |
|    数据传送方式     |                 依靠程序传送                 |                       依靠硬件传送                       |

#### 中断优先级

- 响应优先级：当多个中断源同时请求时，CPU 按**固定的硬件线路规则**，先响应优先级高的中断、后响应优先级低的中断，是 CPU 响应设备中断请求的先后次序。（使用优先编码器实现）
  - 大类优先级：不可屏蔽中断 > 内部异常 > 可屏蔽中断
  - 内部异常细分：硬件终止（最高）> 指令异常 / 自陷等程序故障
  - 传输类中断：DMA 中断请求 > I/O 设备传送的中断请求
  - I/O 传送类细分：高速设备 > 低速设备；输入设备 > 输出设备；实时控制设备 > 普通设备

- 处理优先级：CPU 执行某中断服务程序时，可响应更高优先级的中断请求，即中断嵌套
  - 通过配置个设备中的中断屏蔽值，可以动态改变处理优先级的次序（不能改变中断响应优先级）

## Verilog语言

事实上我们已经有了硬件描述语言ahdl的基础，verilog上手并不困难，因此在这里罗列一些基本的例子，简单阅读后即可了解个大概，然后再对特别的语法部分进行针对性讲解！

- 四位二进制加法计数器

```verilog
module CNT4(CLK,Q);
  input CLK;
  output [3:0] Q;
  
  reg [3:0]Q1;
  
  always @(posedge CLK)
    begin
      Q1<=Q1+1;
    end
  assign Q=Q1;
endmodule
```

#### `always`语句

只有满足激活条件才能被执行，其中赋值目标必须是reg型，如果有多条赋值语句则必须使用`begin`和`end`包裹（相当于`if`语句中的`{}`）

- 边沿敏感：
  - `(posedge 信号名)`信号上升沿到来
  - `(negedge 信号名)`信号下降沿到来
- 电平敏感：`(信号名列表)`信号列表中的任一个信号有变化



#### 阻塞赋值 vs. 非阻塞赋值

激活前：`M1=0`，`M2=0`，`Q=0`，设`A`、`B`同时由0变为1。

```verilog
always @ (A,B)
  begin 
    M1=A;
    M2=B&M1;
    Q=M1|M2;
  end
```

阻塞赋值的特点是**赋值语句执行完，变量的值立刻更新**，后面的语句要等前面的 “阻塞” 结束才能执行，像 “排队办事，一个办完下一个来”。

步骤拆解（A、B 变 1 后）：

- 第一步：`M1 = A` → A 现在是 1，所以`M1立刻变成1`；
- 第二步：`M2 = B & M1` → B 是 1，M1 已经是 1，所以`M2立刻变成1&1=1`；
- 第三步：`Q = M1 | M2` → M1=1、M2=1，所以`Q立刻变成1|1=1`；

最终结果：`M1=1、M2=1、Q=1`。

```verilog
always @ (A,B)
  begin 
    M1<=A;
    M2<=B&M1;
    Q<=M1|M2;
  end
```

非阻塞赋值的特点是**赋值语句先 “暂存操作”，等整个`begin-end`块里的语句都执行完，再统一更新所有变量的值**，像 “先把所有订单记下来，最后一起发货”。

步骤拆解（A、B 变 1 后）：

- 第一步：`M1 <= A` → 暂存 “M1 要变成 1”，但**现在 M1 还是原来的 0**；
- 第二步：`M2 <= B & M1` → B 是 1，但 M1 还是 0，所以暂存 “M2 要变成 1&0=0”；
- 第三步：`Q <= M1 | M2` → M1=0、M2=0，所以暂存 “Q 要变成 0|0=0”；
- 等整个块执行完，统一更新：先把 M1 改成 1，再把 M2 改成 0，最后把 Q 改成 0；

最终结果：`M1=1、M2=0、Q=0`。

***

- 设计组合电路时常用阻塞赋值
- 设计时序电路时常用非阻塞赋值

#### 模块例化

- 底层模块

```verilog
module DFF (CLK,D,Q)
  output reg Q;
  input CLK,D;
  always @ (posedge CLK)
    Q<=D;
endmodule
```

- 顶层模块：对底层模块进行实例化，相当于C++的类进行实例化调用（这里叫端口映射）

```verilog
module examp(clk,d,a,q)
  output q;
  input clk,d,a;
  
  wire d1;
  wire q1;
  
  DFF dff1(.CLK(clk),.D(d1),.Q(q1));
  DFF dff2(q1,d,q);
  
  or (d1,a,q);
  
endmodule
```

事实上，这里的端口映射使用了两种方法，其实按照函数传参的方法看即可也比较方便，符合阅读习惯

1. 命名法：`(.底层端口名1(外界信号名1),.底层端口名2(外界信号名2))`

2. 顺序法：`(外界信号名1,外界信号名2)`



#### 底层模块门原语

这是Verilog语言提供的已经设计好的门，可以直接调用，其中实例名可以忽略，且只能采用顺序法，输出在前，输入在后：`and(out,in1,in2)`。

