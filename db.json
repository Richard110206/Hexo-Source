{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1},{"_id":"source/banner_img/懒洋洋.png","path":"banner_img/懒洋洋.png","modified":1,"renderable":0},{"_id":"source/banner_img/background.jpg","path":"banner_img/background.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_data/styles.css","hash":"8baceed7a5946cac3fa937579b61f95c974d08d3","modified":1752403778899},{"_id":"source/about/index.md","hash":"267d78e36cd5973932fa07260414083f9b089887","modified":1753842114447},{"_id":"source/contact/index.md","hash":"3f773be20b1dc6b64fe44e9a9b36eb0419354af9","modified":1748529769102},{"_id":"source/_posts/Algorithm/Double-Pointer.md","hash":"a81cb468809c6627970aebea0995d21872c250d0","modified":1757751962207},{"_id":"source/_posts/CPP/Classes-and-Objects-in-C++.md","hash":"2a7e56e6f4c6311fccb0be3a72ea0f5f651391c8","modified":1757658041061},{"_id":"source/_posts/CPP/CPP-Syntax-Bits-and-Bobs.md","hash":"17394e5caaf6512deff37dd43c14a7f1d2a9c549","modified":1756887443199},{"_id":"source/_posts/Algorithm/Essential-Sorting-Algorithms-Explained.md","hash":"cf21472a5076871f5ac5b5811a0bab69990295ab","modified":1756867836975},{"_id":"source/_posts/Data structure/CUMT-Datastructure-Assignment-1.md","hash":"fea952cb756cbd867cefd784492eaf8354fdc987","modified":1756460147127},{"_id":"source/_posts/Data structure/CUMT-Datastructure-Practice-2.md","hash":"cd6c3b69f6a53e689453c3eebb2f9dd51c163bde","modified":1756265503546},{"_id":"source/_posts/CPP/Lambda-Expression-in-CPP.md","hash":"b67a7b8e26c8134305ef8c7d1fb2c9bcc65d685d","modified":1757658041062},{"_id":"source/_posts/Data structure/CUMT-Datastructure-Practice-3.md","hash":"28d20d96e3e782e2f690e6c4c7d54190163e4a46","modified":1756265558441},{"_id":"source/_posts/Data structure/CUMT-Datastructure-Assignment-2.md","hash":"9d18aec04390690849c252886bd1053cc5e8653b","modified":1756889172959},{"_id":"source/_posts/Data structure/CUMT-Datastructure-Practice-4.md","hash":"a527fc28e11d185742f2e2df1602530f0bee2c45","modified":1756265597124},{"_id":"source/_posts/Data structure/Hashtable.md","hash":"8cfd3eeb5eb9d2489a2a69ea602076277e363114","modified":1756226036821},{"_id":"source/_posts/Data structure/Stack-and-Queue.md","hash":"d8dfdd99bbe9ae0ad3309c74533a90e4f50eb347","modified":1756193142348},{"_id":"source/_posts/CPP/The-Four-Pillars-of-OOP-in-C++.md","hash":"5be8ddb357d4389b784c99b3fd0b44e4c282b03d","modified":1756180415169},{"_id":"source/_posts/CPP/Operator-Overloading-in-C++.md","hash":"a3f3439ab3a6ebe5048320da431cf3fc44cd8362","modified":1752938785197},{"_id":"source/_posts/Data structure/Linkedlist.md","hash":"c8dc04e5ace7abc78f149c281fb87a56b433a613","modified":1756193107363},{"_id":"source/_posts/Full-Stack/Html.md","hash":"ab6eb6d4c23d11322b8a450bc425f010ad09e832","modified":1755934325791},{"_id":"source/_posts/Full-Stack/CSS.md","hash":"9fe9d9aae15acc8ee5fad54c0f3ebb4e0654d8f7","modified":1755770472595},{"_id":"source/_posts/Full-Stack/JavaScript.md","hash":"0215bc44e0640176c7e06a2735f0a47475e3b02e","modified":1756824416565},{"_id":"source/_posts/Python/Basic-Python-Tutorial.md","hash":"6d748dc526dc3cc1f67ec7aa56a8df95809191b3","modified":1757739742861},{"_id":"source/_posts/Python/The-CS61A-Lab-Notebook1.md","hash":"7e884cae422909879ca4f48adcde64d5c27800c5","modified":1755769772257},{"_id":"source/_posts/Python/Pandas-Data-Analysis.md","hash":"fa6ea856bc3a02fef460a233cb1021ed22d344a1","modified":1757822374235},{"_id":"source/_posts/Review/Digital-Circuits-and-Logic-Design.md","hash":"558837ab9d4d50b3c5083625c9842a69b262ed5f","modified":1757596633402},{"_id":"source/_posts/Review/Probability-Theory.md","hash":"d84bb2a1764921f1d2ea1175e7419499f40cb153","modified":1757658041064},{"_id":"source/_posts/Review/College-Physics-2.md","hash":"e8052b4e005aca766f471296253f96ee2a34b859","modified":1757661065885},{"_id":"source/_posts/other/Casual-Chronicles.md","hash":"e89fccc08646cdee237ec1bf42f635a963b18184","modified":1756780560443},{"_id":"source/_posts/other/About Me and My Blog.md","hash":"27880986c63c8a319c8bf3b08a4473a325e34eb5","modified":1756880570613},{"_id":"source/_posts/Leetcode-Collection/Leetcode-Mistake-Collection-1.md","hash":"8329a7c71c1c4785708dd6ce8e742f18eb884778","modified":1756630554261},{"_id":"source/_posts/other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice.md","hash":"dc116fa8fea972de60f3c3fe5f7d28aa13a33a57","modified":1756881080169},{"_id":"source/_posts/other/hello-world.md","hash":"f2575cd1e4ea4cb01636df614ef1dffbdf2e15a5","modified":1755781346691},{"_id":"source/_posts/Leetcode-Collection/Leetcode-Mistake-Collection-2.md","hash":"503e9c63b2b68f70ae9ac7937ab11754ab95c005","modified":1757752631465},{"_id":"source/_posts/other/life-musings.md","hash":"976ae87845c3024e53e22bc05830c2e074cc3487","modified":1757744930501},{"_id":"source/_posts/Tutorial/GitHub-Connection-Deep-Dive.md","hash":"eca1ed01d3bbe0ee971c3877aceefbbf7a0f50d7","modified":1756283687598},{"_id":"source/_posts/Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic.md","hash":"7dce816b0fb2622bbc145ea0343eb29b4b7e9e52","modified":1755769706720},{"_id":"source/_posts/Python/Matplotlib-Python-Visualization.md","hash":"978b57f6e214303bbd2cbc4f22239893aa6a7c44","modified":1757731592166},{"_id":"source/_posts/Tutorial/Markdown，Practical Guide to Writing Blogs！.md","hash":"4d53f570242f2a0b98eaf72e05222a8e3be047dc","modified":1755769591922},{"_id":"source/_posts/Tutorial/Powerful-Editor-Vim.md","hash":"67ad5aaf8780fed953a1b6c06f04a60466b1c3d7","modified":1755769548651},{"_id":"source/_posts/Tutorial/Shell-Magic.md","hash":"f02b53aacce2517e08f34658cce291fa9c9f27ee","modified":1756786070712},{"_id":"source/_posts/Tutorial/Offload-Your-Hexo-Images.md","hash":"4fe001884ebb101987931627280d38101fd5fca5","modified":1756869073781},{"_id":"source/_posts/Mathematical Modeling Tutorial/Huashu Cup Conclusion.md","hash":"fb4f6b00225130c09595595a7ff2b1d18c8074bc","modified":1755882426118},{"_id":"source/_posts/Tutorial/Simple-Git-Project-Management-Guide.md","hash":"9cb7f1bec382da32021db2a438091e6a258755ea","modified":1757663416196},{"_id":"source/banner_img/懒洋洋.png","hash":"a5de43175a2388a4978e8186965e03a7e0a2574c","modified":1728223220237},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1757653859378},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1757653859244},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"e62d2e25cae57e8469e3f48c9d17be1fd284a969","modified":1757653859390},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1757653858470},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1757653858239},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1757653858708},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1757653859240},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1757653858932},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1757653858938},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1757653858771},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1757653858633},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1757653859015},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1757653859055},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1757653859051},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1757653859004},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1757653859392},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1757653858413},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1757653858945},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1757653859395},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1757653859400},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1757653859405},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1757653859407},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1757653859402},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1757653859397},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1757653859409},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1757653858759},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1757653858604},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1757653858835},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1757653858808},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1757653858742},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1757653858910},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1757653858887},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1757653858919},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1757653859404},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1757653858958},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1757653859025},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1757653859134},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1757653859192},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1757653859171},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1757653859010},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1757653859166},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1757653859129},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1757653859031},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1757653859186},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1757653859137},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1757653859215},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1757653859176},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1757653859206},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1757653859221},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1757653859162},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1757653859142},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1757653859209},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1757653859229},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1757653859104},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1757653859231},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1757653859238},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1757653859146},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1757653859150},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1757653859198},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1757653859178},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1757653859114},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1757653859200},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1757653859204},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1757653859226},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1757653859124},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1757653859218},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1757653859336},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1757653859100},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1757653858343},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1757653859352},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1757653859246},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1757653859274},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1757653859089},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1757653859340},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1757653859277},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1757653859107},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1757653859160},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1757653859095},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1757653859189},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1757653859183},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1757653859141},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1757653859235},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1757653859224},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1757653859386},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1757653858844},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1757653858785},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1757653859213},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1757653858951},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1757653858862},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1757653858853},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1757653859063},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1757653859073},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1757653858901},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1757653859020},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1757653859076},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1757653859046},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1757653859081},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1757653858660},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1757653858994},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1757653858527},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1757653858692},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1757653858871},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1757653858894},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1757653858926},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1757653858565},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1757653858879},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1757653858797},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1757653858989},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1757653859068},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1757653858967},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1757653858727},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1757653858972},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1757653858984},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1757653859035},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1757653858978},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1757653858825},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1757653859059},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1757653859000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1757653859040},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1757653859154},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1757653859181},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1757653859173},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1757653859148},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1757653859156},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1757653859195},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1757653859297},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1757653859300},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1757653859308},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1757653859365},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1757653859318},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1757653859316},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1757653859281},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1757653859352},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1757653859305},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1757653859324},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1757653859320},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1757653859291},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1757653859120},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1757653859347},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1757653859371},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1757653859327},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1757653859352},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1757653859338},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1757653859370},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1757653859344},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1757653859380},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1757653859368},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1757653859287},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1757653859345},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1757653859293},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1757653859321},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1757653859331},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1757653859328},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1757653859311},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1757653859333},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1757653859359},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1757653859360},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1757653859362},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1757653859366},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1757653859372},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1757653859375},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1757653859381},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1757653859335},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1757653859374},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1757653859272},{"_id":"source/banner_img/background.jpg","hash":"d1a7a935aaa72ca6af2348ea0676406f6c6ac459","modified":1755049374942},{"_id":"public/local-search.xml","hash":"b656e6ad7a6c8780d6d60449d286b651be51a821","modified":1757822581522},{"_id":"public/about/index.html","hash":"420cf2450c98e1f4f95ca3879faaf559ecf0254e","modified":1757822581522},{"_id":"public/2025/09/13/Python/Pandas-Data-Analysis/index.html","hash":"0391df8da8de7613732d27cc1c7c31b2c04bc869","modified":1757822581522},{"_id":"public/contact/index.html","hash":"0448f85dc50d7bf1c08a6039c1e51c1da6659c6f","modified":1757822581522},{"_id":"public/2025/09/13/Python/Basic-Python-Tutorial/index.html","hash":"08444ded33b5157fd36f9fddca0ebbe7ff86e466","modified":1757822581522},{"_id":"public/2025/09/13/Python/Matplotlib-Python-Visualization/index.html","hash":"ff4be2fcb24ae446ef82734bb04b9b2644dbe063","modified":1757822581522},{"_id":"public/2025/09/04/Review/Probability-Theory/index.html","hash":"afde8dd8ac9e35aeb19517c36079e03d094e847d","modified":1757822581522},{"_id":"public/2025/09/10/Leetcode-Collection/Leetcode-Mistake-Collection-2/index.html","hash":"4caf84ca622320da1091ed2fe43c9caca409fe66","modified":1757822581522},{"_id":"public/2025/09/04/Review/Digital-Circuits-and-Logic-Design/index.html","hash":"2d7f484bbd84d175e2f87e765eaab99d213f63fb","modified":1757822581522},{"_id":"public/2025/09/01/Full-Stack/JavaScript/index.html","hash":"58f6dc421cf5aa0b50bfb0d25b978524f962623f","modified":1757822581522},{"_id":"public/2025/08/29/Algorithm/Double-Pointer/index.html","hash":"38a9323f92576ec329ae7ab57c5eec7c3a35517a","modified":1757822581522},{"_id":"public/2025/09/02/Review/College-Physics-2/index.html","hash":"82243109c859878960b585a4aceb7da6c97c2be3","modified":1757822581522},{"_id":"public/2025/08/27/Tutorial/GitHub-Connection-Deep-Dive/index.html","hash":"0b429348aea08d2d49f9e0c32883d68d19942148","modified":1757822581522},{"_id":"public/2025/08/25/CPP/Lambda-Expression-in-CPP/index.html","hash":"b227d701a396993aeb4a77026c9c75d6ccaeaf6f","modified":1757822581522},{"_id":"public/2025/08/26/Data structure/Hashtable/index.html","hash":"433ab667792396bf43b5195df388faa1411403ed","modified":1757822581522},{"_id":"public/2025/08/26/Leetcode-Collection/Leetcode-Mistake-Collection-1/index.html","hash":"734a5b4cb6942eb075fc85cb1642610215c4dda3","modified":1757822581522},{"_id":"public/2025/08/25/CPP/CPP-Syntax-Bits-and-Bobs/index.html","hash":"0a0ea773a4aec638a62e5d73af589444a47b0b4f","modified":1757822581522},{"_id":"public/2025/08/22/Mathematical Modeling Tutorial/Huashu Cup Conclusion/index.html","hash":"e9c8b3a19733c207257b7acf6a3468b75e59c430","modified":1757822581522},{"_id":"public/2025/08/23/Data structure/Stack-and-Queue/index.html","hash":"29b0918a6be73c05e4cfef44d4f7c1b8b2556c23","modified":1757822581522},{"_id":"public/2025/08/22/Data structure/Linkedlist/index.html","hash":"74c6c5cffbfbc457f751ae571208f8d7bb429ab0","modified":1757822581522},{"_id":"public/2025/08/13/other/Casual-Chronicles/index.html","hash":"4aa72703938960651e0d4029a5b9aa0539e31bb0","modified":1757822581522},{"_id":"public/2025/08/21/Tutorial/Offload-Your-Hexo-Images/index.html","hash":"b3a8011f0449009acb1b4e8d5e76796b7290dd87","modified":1757822581522},{"_id":"public/2025/08/18/Full-Stack/CSS/index.html","hash":"0b327985dfaea37b95ca9feed7b65ba473047f8f","modified":1757822581522},{"_id":"public/2025/08/12/Full-Stack/Html/index.html","hash":"5d26ef13b87a899f2c4a8b9224edcfe0ce6f6a00","modified":1757822581522},{"_id":"public/2025/07/28/Tutorial/Powerful-Editor-Vim/index.html","hash":"84efae3432f81b56d9510a7f14e7a0bb4d54db61","modified":1757822581522},{"_id":"public/2025/07/27/Tutorial/Shell-Magic/index.html","hash":"c59f44ea72691fa9fba052f444fc021e564fd7c4","modified":1757822581522},{"_id":"public/2025/07/22/CPP/Classes-and-Objects-in-C++/index.html","hash":"d6ae88217232dbe8e5eb34147b958f4cb7bd1ac9","modified":1757822581522},{"_id":"public/2025/07/25/Python/The-CS61A-Lab-Notebook1/index.html","hash":"d8c87ffb1c69029a2d4465d517ed622d695ee75d","modified":1757822581522},{"_id":"public/2025/07/24/Algorithm/Essential-Sorting-Algorithms-Explained/index.html","hash":"f46e2725090504f2343171edf4c8bea72d56e3d8","modified":1757822581522},{"_id":"public/2025/07/19/CPP/Operator-Overloading-in-C++/index.html","hash":"14dcbaf5f15fe77d7243dd5b5ec4271c9b91b2b7","modified":1757822581522},{"_id":"public/2025/07/13/Tutorial/Simple-Git-Project-Management-Guide/index.html","hash":"2aefcaeb9851e630820135b17a48723be60511bf","modified":1757822581522},{"_id":"public/2025/07/17/CPP/The-Four-Pillars-of-OOP-in-C++/index.html","hash":"5218e35e49ef07fa441a9c2079b84cd61e615b49","modified":1757822581522},{"_id":"public/2025/07/14/other/life-musings/index.html","hash":"ddf4345d393de0c08fc0786efb46104114c0ea9f","modified":1757822581522},{"_id":"public/2025/06/27/Data structure/CUMT-Datastructure-Practice-4/index.html","hash":"7e6c8ca8e555d5c62d2dbddd323f202f59952769","modified":1757822581522},{"_id":"public/2025/07/12/Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic/index.html","hash":"ae5c819f8d3fa0f009f9e7331c6afd533a7893af","modified":1757822581522},{"_id":"public/2025/07/09/other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/index.html","hash":"a68ee7dfbf89efad4318c1efe3136159c15315ba","modified":1757822581522},{"_id":"public/2025/06/24/Data structure/CUMT-Datastructure-Practice-3/index.html","hash":"5be994d0a169bd32accd1bb37fb8cfb362a82a58","modified":1757822581522},{"_id":"public/2025/06/18/Data structure/CUMT-Datastructure-Assignment-2/index.html","hash":"12db728a04bd3d6a4771018aae9a3da368f91b16","modified":1757822581522},{"_id":"public/2025/06/18/Data structure/CUMT-Datastructure-Practice-2/index.html","hash":"867e8a57aa56df40095c4501064cb7ba4390a638","modified":1757822581522},{"_id":"public/2025/05/29/Tutorial/Markdown，Practical Guide to Writing Blogs！/index.html","hash":"9deedf4b55cf60381964ae7b90322d3562ab7cfd","modified":1757822581522},{"_id":"public/2025/06/08/Data structure/CUMT-Datastructure-Assignment-1/index.html","hash":"3e80ebd89d7a2c755c8072a889cac99b90820273","modified":1757822581522},{"_id":"public/2025/06/04/other/About Me and My Blog/index.html","hash":"161bed8a5ccbbb9158ecadf0060363c1ddc5fa8c","modified":1757822581522},{"_id":"public/2025/05/01/other/hello-world/index.html","hash":"b18d2c58d0f0fd7ee65314c7f677aa5d8cf48b4c","modified":1757822581522},{"_id":"public/archives/index.html","hash":"3f6e5b72bcf4d1e1c9c94666d90fabef18a9a2c8","modified":1757822581522},{"_id":"public/archives/page/4/index.html","hash":"526e74c76a4a114016dc8d600689bcfaf4d9b885","modified":1757822581522},{"_id":"public/archives/page/2/index.html","hash":"12152ad13e54d052df936ec6b825a7272b3e6a68","modified":1757822581522},{"_id":"public/archives/page/3/index.html","hash":"97cf1b220dbc958b87b4fa91fe1e5849a19662de","modified":1757822581522},{"_id":"public/archives/2025/index.html","hash":"338c231c88d5c1814781745f5e8633389efe40cd","modified":1757822581522},{"_id":"public/archives/2025/page/2/index.html","hash":"b358bc71323004995b35a2112cb2740adc29ca11","modified":1757822581522},{"_id":"public/archives/2025/page/3/index.html","hash":"cd3b6842881a2cf8b12ce57f8e5f21ac7847e09a","modified":1757822581522},{"_id":"public/archives/2025/page/4/index.html","hash":"71ee606f4b5b9b54b09d0fc41a45a5d3656587ee","modified":1757822581522},{"_id":"public/archives/2025/05/index.html","hash":"5ccc389881f5583cd0c43a4e8fac59b63cabad62","modified":1757822581522},{"_id":"public/archives/2025/06/index.html","hash":"1bbb7e7a940ccfab25a52088ca0ab78d909461d3","modified":1757822581522},{"_id":"public/archives/2025/07/index.html","hash":"f28015bc8311d8bcc0cbb25e706a3a84115ac0ba","modified":1757822581522},{"_id":"public/archives/2025/07/page/2/index.html","hash":"b3243e8c9f0542b00acca59fab5cdf1651a66294","modified":1757822581522},{"_id":"public/archives/2025/08/index.html","hash":"ea5c6ebdc02011d61bce364c6e6e8d4c9bffeacf","modified":1757822581522},{"_id":"public/archives/2025/08/page/2/index.html","hash":"4fefc12b329f18de0743c7b31cfc520c0c60a758","modified":1757822581522},{"_id":"public/archives/2025/09/index.html","hash":"dd0746a4c514f7583e7ecfb822fb6abcbdd427c8","modified":1757822581522},{"_id":"public/categories/Algorithm/index.html","hash":"d99fe71dac77ff723811b9e58967a608a99fc277","modified":1757822581522},{"_id":"public/categories/CPP/index.html","hash":"063f226b2f13eae1dd6144ff483c916b7a98f0f6","modified":1757822581522},{"_id":"public/categories/CPP/OOP/index.html","hash":"9ca2a33a9782cbe3973a2795e3c84511cbff6049","modified":1757822581522},{"_id":"public/categories/Data-Structure/index.html","hash":"2d85e8e3c081f53459809ebc9d75aae6be3a134b","modified":1757822581522},{"_id":"public/categories/Full-Stack/index.html","hash":"3c213a105df0c169c2ae376371a469f6ba382f30","modified":1757822581522},{"_id":"public/categories/Python/index.html","hash":"d89c3a1826b1b76091cb40b1e81c71d6b8f45edb","modified":1757822581522},{"_id":"public/categories/Review/index.html","hash":"a84165a5f2d5ad26abf6561a04ee678f69d227af","modified":1757822581522},{"_id":"public/categories/Leetcode-Mistake-Collection/index.html","hash":"a9f2202c37bbb744228ce77ee266730f236a1a4f","modified":1757822581522},{"_id":"public/index.html","hash":"7b71625a9110c4132bd05f85c2a5ef1259cd5328","modified":1757822581522},{"_id":"public/categories/Tutorial/index.html","hash":"a9a424cedea26ed19be4ba63fdca7ab5da43a1cb","modified":1757822581522},{"_id":"public/categories/Mathematical-Modeling-Tutorial/index.html","hash":"e7cc0ac95ae8400e44fa62580acc04794f3a1a42","modified":1757822581522},{"_id":"public/page/2/index.html","hash":"5eac41b035508d189bbe5eb42cffcf64219ccfc5","modified":1757822581522},{"_id":"public/page/3/index.html","hash":"8ab33951c56e2fbfff5bd6c1e6ec9cacf3925ae9","modified":1757822581522},{"_id":"public/tags/Algorithm/index.html","hash":"6bbc78c9f593cd253f6f6398d6cb476e9535a6aa","modified":1757822581522},{"_id":"public/tags/Double-Pointer/index.html","hash":"13a8860e53aabc9d236ca917db3615c1e8ebc1a3","modified":1757822581522},{"_id":"public/tags/C/index.html","hash":"cbb0cd70a9fbbfa7d28edd17d0ca10f703895a4e","modified":1757822581522},{"_id":"public/tags/OOP/index.html","hash":"880d99857b1dfa4a78497642f4f0674726ae6ada","modified":1757822581522},{"_id":"public/tags/sort/index.html","hash":"ac915e3465c1e66f0115ab72fd396849f60a82b0","modified":1757822581522},{"_id":"public/tags/algorithm/index.html","hash":"1abe86f28865ef81bd39b778b6ff126c53654b42","modified":1757822581522},{"_id":"public/tags/CPP/index.html","hash":"61292ec9ffd8252ed57a017d8996d743e87b2d0f","modified":1757822581522},{"_id":"public/tags/syntax/index.html","hash":"2e6f19949294e1774e22a1a80e672396b88b75a7","modified":1757822581522},{"_id":"public/tags/updating/index.html","hash":"1f192ef5a10075fa66b2bc90d8f710e2d72593cc","modified":1757822581522},{"_id":"public/tags/Linear-List，stack/index.html","hash":"42c4742ac453805255f63f2844894b18901fbc71","modified":1757822581522},{"_id":"public/tags/stack/index.html","hash":"bd90b828c7111533971ba165b4d528df683bdb84","modified":1757822581522},{"_id":"public/tags/binary-tree/index.html","hash":"0c4e17a0f7f054a95e2334655b6e187da9732abf","modified":1757822581522},{"_id":"public/tags/DFS/index.html","hash":"68cb7c091ab91d334c98951c2444380ee6f44a12","modified":1757822581522},{"_id":"public/tags/search，graph，sort/index.html","hash":"982baa02388b5a7cac1b3d26beb4eb26f6184825","modified":1757822581522},{"_id":"public/tags/huffman-tree/index.html","hash":"3ec49f0f143cf1ee80ec0b057469933f188c09f8","modified":1757822581522},{"_id":"public/tags/queue/index.html","hash":"cfb546bfb1ea3aca8b8004fe1192d26a31088b29","modified":1757822581522},{"_id":"public/tags/Dijkstra/index.html","hash":"f300b21a9ae141ff4859c710f850a1401516837b","modified":1757822581522},{"_id":"public/tags/Kruskal/index.html","hash":"ea376c0a9e59a0b97593f9d7d0ebef6e20cb85c7","modified":1757822581522},{"_id":"public/tags/datastructure/index.html","hash":"d281b3a8fabefad0956b2b88059b1a4a77bc18a8","modified":1757822581522},{"_id":"public/tags/linkedlist/index.html","hash":"ade8c720606ef622c39f9a111c1b24fbcf1bdd22","modified":1757822581522},{"_id":"public/tags/hashtable/index.html","hash":"c534cb33c5e3f1faa97a4674006608b6e7795cea","modified":1757822581522},{"_id":"public/tags/CSS/index.html","hash":"135bfa7e3aa90c6f8c4babf1b16f1043ab6ad16f","modified":1757822581522},{"_id":"public/tags/html/index.html","hash":"1d1b006c44377b0e6a5bef394226efffb16cf0a4","modified":1757822581522},{"_id":"public/tags/JavaScript/index.html","hash":"86f03015721989c615a2809db838ec30bfe5fe87","modified":1757822581522},{"_id":"public/tags/Python/index.html","hash":"5309a56d00abb642910727c1224150a1206709fb","modified":1757822581522},{"_id":"public/tags/function/index.html","hash":"2e63e105448484392a72270d4590fab6f92c716f","modified":1757822581522},{"_id":"public/tags/College-Physics/index.html","hash":"e0bdd764b9cfe464e04c13228c626a2d67123de9","modified":1757822581522},{"_id":"public/tags/Motivation/index.html","hash":"2c24d4d1925d4d25a92926b8fe57eff60c904879","modified":1757822581522},{"_id":"public/tags/Leetcode/index.html","hash":"01ec471db11b2b93a23082ba356c2d911478c4b5","modified":1757822581522},{"_id":"public/tags/opencv/index.html","hash":"1e67d26dd5b6e9e636c4bbf47bc83fa98e17b1cf","modified":1757822581522},{"_id":"public/tags/yolov5/index.html","hash":"18fec1065b25b666c8b7c6a2cab9ba2b90055b64","modified":1757822581522},{"_id":"public/tags/object-detection/index.html","hash":"ac25702a7f32028c832c8ac94359f174a33e0bdf","modified":1757822581522},{"_id":"public/tags/Github/index.html","hash":"3c2f7523c5216de8ae34618f234adebfd7155f3f","modified":1757822581522},{"_id":"public/tags/Hexo/index.html","hash":"7505a85e299c3b19b8b9a84fda21fbb5ffacdaef","modified":1757822581522},{"_id":"public/tags/Blogging/index.html","hash":"8c4a072af1170fd3f772e22b641b1d925785348a","modified":1757822581522},{"_id":"public/tags/markdown/index.html","hash":"90a5d8ef591b5ddfc5ae33c4099f0780443b38d0","modified":1757822581522},{"_id":"public/tags/blogger/index.html","hash":"d5665bc8c0b1b9938e9c750b747393677857d473","modified":1757822581522},{"_id":"public/tags/tutorial/index.html","hash":"2dff59b3215cbdfc643dd111084eb19fcf037e96","modified":1757822581522},{"_id":"public/tags/hexo/index.html","hash":"5147c837f6d86f9e2ef894d94997269141276b25","modified":1757822581522},{"_id":"public/tags/image-hosting/index.html","hash":"b5bc6c2692c7d4f8cdb98a60856ce0c6cad8adde","modified":1757822581522},{"_id":"public/tags/vim/index.html","hash":"62e06fd8c708259bd95781f2c8c9c57a721d6355","modified":1757822581522},{"_id":"public/tags/shell/index.html","hash":"4ccc48a6d8336a59ab2c12509a5d94a45b8efeed","modified":1757822581522},{"_id":"public/404.html","hash":"5e808da488d4c79769f6fea59c8d83a08a6c15b9","modified":1757822581522},{"_id":"public/tags/Git/index.html","hash":"2930dabdb042d00367e115c57f7dc06688c341f8","modified":1757822581522},{"_id":"public/tags/review/index.html","hash":"56aa595e7b81ec4b2704038eb93a6b9919692792","modified":1757822581522},{"_id":"public/tags/index.html","hash":"a8bcd7ff56e293e0cb6b94c45b6bfd8e125301da","modified":1757822581522},{"_id":"public/links/index.html","hash":"ba34078432846964d682633fcb23fe3e3ba30e6b","modified":1757822581522},{"_id":"public/categories/index.html","hash":"6cc497ff9643160943b9c94213fd0b4b31f7e893","modified":1757822581522},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1757822581522},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1757822581522},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1757822581522},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1757822581522},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1757822581522},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1757822581522},{"_id":"public/css/main.css","hash":"90a4ec8d04be7c5abf0cdceb6f9aff4a7991946d","modified":1757822581522},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1757822581522},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1757822581522},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1757822581522},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1757822581522},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1757822581522},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1757822581522},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1757822581522},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1757822581522},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1757822581522},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1757822581522},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1757822581522},{"_id":"public/banner_img/懒洋洋.png","hash":"a5de43175a2388a4978e8186965e03a7e0a2574c","modified":1757822581522},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1757822581522},{"_id":"public/banner_img/background.jpg","hash":"d1a7a935aaa72ca6af2348ea0676406f6c6ac459","modified":1757822581522}],"Category":[{"name":"Algorithm","_id":"cmfj66hch000440w37mukaqfq"},{"name":"CPP","_id":"cmfj66hcj000940w36ddsafbj"},{"name":"OOP","parent":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hco000u40w33w26e5yd"},{"name":"Data Structure","_id":"cmfj66hcp001640w3bi7j6y6r"},{"name":"Full Stack","_id":"cmfj66hcu002l40w382s00hpy"},{"name":"Full-Stack","_id":"cmfj66hcw003340w3g3959swh"},{"name":"Python","_id":"cmfj66hcw003740w3hhl82hh7"},{"name":"Review","_id":"cmfj66hcw003a40w3el9s48xg"},{"name":"Leetcode Mistake Collection","_id":"cmfj66hcw003g40w3gamxdekm"},{"name":"Tutorial","_id":"cmfj66hcx003l40w3614lag19"},{"name":"Mathematical Modeling Tutorial","_id":"cmfj66hd4006540w32w62ggna"}],"Data":[{"_id":"styles","data":"/* 覆盖 Fluid 主题的 .note 样式 */\n.note {\n  &.note-primary {\n    font-size: 18px !important;\n\n    p, strong, em, span {\n      font-size: inherit !important;\n    }\n  }\n}"}],"Page":[{"title":"about","date":"2025-05-29T14:42:37.000Z","layout":"about","_content":"\n\n**Greetings!** I am **Li Qinxuan(李沁轩)**, currently pursuing an undergraduate degree in Computer Science and Technology at **China University of Mining and Technology**! Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. I hope your visit here is both enjoyable and enriching!\n\n ### My Email\n\n + lqx3222482537@qq.com\n + richardli.11.02.06@gmail.com\n + 08241120@cumt.edu.cn\n\n### My Blog in CSDN\n[不在了情绪的CSDN博客账号](https://blog.csdn.net/2401_86849688?type=blog)\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-05-29 22:42:37\nlayout: about\n---\n\n\n**Greetings!** I am **Li Qinxuan(李沁轩)**, currently pursuing an undergraduate degree in Computer Science and Technology at **China University of Mining and Technology**! Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. I hope your visit here is both enjoyable and enriching!\n\n ### My Email\n\n + lqx3222482537@qq.com\n + richardli.11.02.06@gmail.com\n + 08241120@cumt.edu.cn\n\n### My Blog in CSDN\n[不在了情绪的CSDN博客账号](https://blog.csdn.net/2401_86849688?type=blog)\n","updated":"2025-07-30T02:21:54.447Z","path":"about/index.html","comments":1,"_id":"cmfj66hce000040w36whu2r3h","content":"<p><strong>Greetings!</strong> I am <strong>Li Qinxuan(李沁轩)</strong>, currently pursuing an undergraduate degree in Computer Science and Technology at <strong>China University of Mining and Technology</strong>! Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. I hope your visit here is both enjoyable and enriching!</p>\n<h3 id=\"My-Email\">My Email</h3>\n<ul>\n<li><a href=\"mailto:lqx3222482537@qq.com\">lqx3222482537@qq.com</a></li>\n<li><a href=\"mailto:richardli.11.02.06@gmail.com\">richardli.11.02.06@gmail.com</a></li>\n<li><a href=\"mailto:08241120@cumt.edu.cn\">08241120@cumt.edu.cn</a></li>\n</ul>\n<h3 id=\"My-Blog-in-CSDN\">My Blog in CSDN</h3>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪的CSDN博客账号</a></p>\n","excerpt":"","more":"<p><strong>Greetings!</strong> I am <strong>Li Qinxuan(李沁轩)</strong>, currently pursuing an undergraduate degree in Computer Science and Technology at <strong>China University of Mining and Technology</strong>! Through my personal website, I aim to share a collection of my blogs and learning notes with you. Some of these entries will be presented as a series, updated at irregular intervals. I hope your visit here is both enjoyable and enriching!</p>\n<h3 id=\"My-Email\">My Email</h3>\n<ul>\n<li><a href=\"mailto:lqx3222482537@qq.com\">lqx3222482537@qq.com</a></li>\n<li><a href=\"mailto:richardli.11.02.06@gmail.com\">richardli.11.02.06@gmail.com</a></li>\n<li><a href=\"mailto:08241120@cumt.edu.cn\">08241120@cumt.edu.cn</a></li>\n</ul>\n<h3 id=\"My-Blog-in-CSDN\">My Blog in CSDN</h3>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪的CSDN博客账号</a></p>\n"},{"title":"contact","date":"2025-05-29T14:42:49.000Z","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2025-05-29 22:42:49\n---\n","updated":"2025-05-29T14:42:49.102Z","path":"contact/index.html","comments":1,"layout":"page","_id":"cmfj66hch000240w3h6hk0xvu","content":"","excerpt":"","more":""}],"Post":[{"title":"Double Pointer","date":"2025-08-28T17:10:42.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/DoublePointer.png?raw=true","category_bar":true,"description":"Focusing on the three kinds of double-pointer techniques，fast and slow, left and right, and sliding windows.","_content":"\n## Double Pointer\n**双指针**是算法设计中一种**高效且灵活**的技巧，通过两个指针在数据结构中**协同移动**，能够将原本需要**嵌套循环** $ O(n^2) $ 的问题优化为线性时间复杂度 $O(n) $，同时减少空间消耗。\n\n### 左右指针\n\n- **核心思想**：两个指针分别从**序列的两端**出发，**向中间移动**，通过判断条件调整指针位置，**直至相遇或满足特定条件**。\n- **适用场景**：\n  \n  - 有序数组问题（如两数之和、三数之和）\n  - 对称结构判断（如回文串、回文链表）\n  - 二分查找变种（如寻找旋转数组的最小值）\n  - 需要从两端向中间收缩的场景（如盛最多水的容器）\n\n- **方法**：\n  - 双指针分别**指向数组两端**：左指针`left = 0`（**起点**），右指针`right = n-1`（**终点**）\n  - 循环条件：`left < right`（指针**未相遇**）\n  - 根据要求**动态移动指针**\n\n[Leetcode 167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left=0,right=numbers.size()-1;\n        while(right>left){\n            if(numbers[right]+numbers[left]>target){\n                right--;\n            }\n            else if(numbers[right]+numbers[left]<target){\n                left++;\n            }\n            else break;\n        }\n        return {left+1,right+1};\n    }\n};\n```\n\n***\n\n[Leetcode 11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water)\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0,right=height.size()-1;\n        int max_vol=INT_MIN;\n        int vol;\n        while(right!=left){\n            vol=(right-left)*min(height[left],height[right]);\n            max_vol=max(max_vol,vol);\n            if(height[left]>height[right]){\n                right--;\n            }\n            else left++;\n        }\n        return max_vol;\n    }\n};\n```\n\n***\n\n[Leetcode 27. 移除元素](https://leetcode.cn/problems/remove-element)\n#### 方法一：类快慢指针\n让我们**模拟**一下程序运行的过程：\n- 当前几个均`!=val`时：`left`和`right`都**指向同一个索引**，**同时向后移动**\n- 当同时指向`val`时，`right`向后继续移动寻找`!=val`，`left`保持不变，标记`val`的位置\n- 当`right`再次指向`!=val`时，这时`left`的**标记起作用**了，与`nums[right]`进行交换并向后移动\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int right,left=0;\n        int n=nums.size();\n        for(right=0;right<n;right++){\n            if(nums[right]!=val){\n                nums[left]=nums[right];\n                left++;\n            }\n        }\n        return left;\n    }\n};\n```\n#### 方法二：对撞指针\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int n=nums.size();\n        int right=n-1,left=0;\n        while(left<=right){\n            if(nums[left]==val){\n                swap(nums[right],nums[left]);\n                right--;\n            }else {\n                left++;\n            }\n        }\n        return left;\n    }\n};\n```\n\n***\n\n### 快慢指针\n\n- **核心思想**：两个指针从**同一起点出发**，以**不同速度同向移动**，利用**速度差**解决问题。\n- **适用场景**：\n  \n  - 链表问题（如检测环、寻找环入口、链表中点）\n  - 数组去重（如删除有序数组中的重复项）\n  - 追及问题（如找到链表中倒数第 k 个节点）\n\n- **方法**：\n  - 快指针`fast`和慢指针`slow`均**指向起点**（如链表头节点、数组下标 0）\n  - **快指针每次移动 2 步**（`fast = fast->next->next`）\n  - **慢指针每次移动 1 步**（`slow = slow->next`）\n  - 直至**快指针到达终点**（`fast == nullptr`或`fast->next == nullptr`）或**两指针相遇**\n\n{%fold into @ 有环必相遇%}\n若链表存在环，那么环是**闭合的循环结构**。一旦指针进入环，就会在环内**永不停歇地循环移动**（因为环的末尾节点指向环内某个节点，而非`nullptr`）。\n{%endfold%}\n\n***\n\n[Leetcode 141.环形链表](https://leetcode.cn/problems/linked-list-cycle)\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head==nullptr || head->next==nullptr){\n            return false;//空链表或单节点无环\n        }\n        ListNode* fast=head->next;\n        //初始化，防止误判（直接跳过循环）\n        ListNode* slow=head;\n        while(slow!=fast){\n            if(fast == nullptr || fast->next == nullptr){\n                return false;\n            }\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        return true;\n    }\n};\n```\n\n***\n \n[Leetcode 26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)\n\n- 使用`fast`遍历数组，`slow`前段是**已处理序列**，指向的是下一个替换元素的位置（`tag`）\n  - 若`fast`标记重复元素，`slow`不动\n  - 若`fast`标记非重复元素，`slow`交换位置\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int fast=1,slow=1;\n        int n=nums.size();\n        while(fast<n){\n            if(nums[fast]!=nums[fast-1]){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n```\n\n***\n\n### 滑动窗口\n\n- **核心思想**：维护一个由**左右指针界定的「窗口」**（**连续区间**），通过移动左右指针**动态调整窗口范围**，以寻找满足条件的最优子序列。\n- **适用场景**：\n\n  - 子串 / 子数组问题（如最小覆盖子串、最长无重复子串）\n  - 区间求和问题（如长度最小的子数组）\n  - 固定长度区间问题（如滑动窗口最大值）\n\n- **方法**：\n  - 使用两个指针`left=0,right=0`定义一个窗口，**初始时窗口为空**。\n  - 移动右指针`right++`**扩展窗口**，移动左指针`left++`**缩小窗口**，直到满足条件。\n  - 在收缩过程中**更新满足条件的最优解**\n\n基本模版：\n```cpp\n//外层循环扩展右边界，内层循环扩展左边界\nfor (int l = 0, r = 0 ; r < n ; r++) {\n\t//当前考虑的元素\n\twhile (l <= r && check()) {//区间[left,right]不符合题意\n        //扩展左边界\n    }\n    //区间[left,right]符合题意，统计相关信息\n}\n```\n\n***\n\n[Leetcode 76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)\n\n```cpp\nclass Solution {\npublic:\n    unordered_map <char, int> ori, cnt;\n\n    bool check() {\n        for (const auto &p: ori) {\n            if (cnt[p.first] < p.second) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        for (const auto &c: t) {\n            ++ori[c];\n        }\n\n        int l = 0, r = -1;\n        int len = INT_MAX, ansL = -1, ansR = -1;\n\n        while (r < int(s.size())) {\n            if (ori.find(s[++r]) != ori.end()) {\n                ++cnt[s[r]];\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                }\n                if (ori.find(s[l]) != ori.end()) {\n                    --cnt[s[l]];\n                }\n                ++l;\n            }\n        }\n\n        return ansL == -1 ? string() : s.substr(ansL, len);\n    }\n};\n```\n\n[Leetcode 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)\n\n#### 滑动窗口+哈希表\n维持两个指针`right``left`，两指针之间代表**不重复子序列**，当`left++`时，会发现终止点`right`的**索引是递增的**，通过滚动数组记录最大值与当前值进行比较，用哈希表记录已在子序列中的字符。\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> map;\n        int n=s.length();\n        int right=-1;\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(i!=0){\n            map.erase(s[i-1]);\n            }\n            while(right<n-1 && !map.count(s[right+1])){\n                map.insert(s[right+1]);\n                right++;\n            }\n            ans=max(ans,right-i+1);\n        }\n        return ans;\n    }\n};\n```\n","source":"_posts/Algorithm/Double-Pointer.md","raw":"---\ntitle: Double Pointer\ndate: 2025-08-29 01:10:42\ntags: [Algorithm, Double Pointer]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/DoublePointer.png?raw=true\ncategory: Algorithm\ncategory_bar: true\ndescription: Focusing on the three kinds of double-pointer techniques，fast and slow, left and right, and sliding windows.\n---\n\n## Double Pointer\n**双指针**是算法设计中一种**高效且灵活**的技巧，通过两个指针在数据结构中**协同移动**，能够将原本需要**嵌套循环** $ O(n^2) $ 的问题优化为线性时间复杂度 $O(n) $，同时减少空间消耗。\n\n### 左右指针\n\n- **核心思想**：两个指针分别从**序列的两端**出发，**向中间移动**，通过判断条件调整指针位置，**直至相遇或满足特定条件**。\n- **适用场景**：\n  \n  - 有序数组问题（如两数之和、三数之和）\n  - 对称结构判断（如回文串、回文链表）\n  - 二分查找变种（如寻找旋转数组的最小值）\n  - 需要从两端向中间收缩的场景（如盛最多水的容器）\n\n- **方法**：\n  - 双指针分别**指向数组两端**：左指针`left = 0`（**起点**），右指针`right = n-1`（**终点**）\n  - 循环条件：`left < right`（指针**未相遇**）\n  - 根据要求**动态移动指针**\n\n[Leetcode 167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left=0,right=numbers.size()-1;\n        while(right>left){\n            if(numbers[right]+numbers[left]>target){\n                right--;\n            }\n            else if(numbers[right]+numbers[left]<target){\n                left++;\n            }\n            else break;\n        }\n        return {left+1,right+1};\n    }\n};\n```\n\n***\n\n[Leetcode 11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water)\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left=0,right=height.size()-1;\n        int max_vol=INT_MIN;\n        int vol;\n        while(right!=left){\n            vol=(right-left)*min(height[left],height[right]);\n            max_vol=max(max_vol,vol);\n            if(height[left]>height[right]){\n                right--;\n            }\n            else left++;\n        }\n        return max_vol;\n    }\n};\n```\n\n***\n\n[Leetcode 27. 移除元素](https://leetcode.cn/problems/remove-element)\n#### 方法一：类快慢指针\n让我们**模拟**一下程序运行的过程：\n- 当前几个均`!=val`时：`left`和`right`都**指向同一个索引**，**同时向后移动**\n- 当同时指向`val`时，`right`向后继续移动寻找`!=val`，`left`保持不变，标记`val`的位置\n- 当`right`再次指向`!=val`时，这时`left`的**标记起作用**了，与`nums[right]`进行交换并向后移动\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int right,left=0;\n        int n=nums.size();\n        for(right=0;right<n;right++){\n            if(nums[right]!=val){\n                nums[left]=nums[right];\n                left++;\n            }\n        }\n        return left;\n    }\n};\n```\n#### 方法二：对撞指针\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int n=nums.size();\n        int right=n-1,left=0;\n        while(left<=right){\n            if(nums[left]==val){\n                swap(nums[right],nums[left]);\n                right--;\n            }else {\n                left++;\n            }\n        }\n        return left;\n    }\n};\n```\n\n***\n\n### 快慢指针\n\n- **核心思想**：两个指针从**同一起点出发**，以**不同速度同向移动**，利用**速度差**解决问题。\n- **适用场景**：\n  \n  - 链表问题（如检测环、寻找环入口、链表中点）\n  - 数组去重（如删除有序数组中的重复项）\n  - 追及问题（如找到链表中倒数第 k 个节点）\n\n- **方法**：\n  - 快指针`fast`和慢指针`slow`均**指向起点**（如链表头节点、数组下标 0）\n  - **快指针每次移动 2 步**（`fast = fast->next->next`）\n  - **慢指针每次移动 1 步**（`slow = slow->next`）\n  - 直至**快指针到达终点**（`fast == nullptr`或`fast->next == nullptr`）或**两指针相遇**\n\n{%fold into @ 有环必相遇%}\n若链表存在环，那么环是**闭合的循环结构**。一旦指针进入环，就会在环内**永不停歇地循环移动**（因为环的末尾节点指向环内某个节点，而非`nullptr`）。\n{%endfold%}\n\n***\n\n[Leetcode 141.环形链表](https://leetcode.cn/problems/linked-list-cycle)\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(head==nullptr || head->next==nullptr){\n            return false;//空链表或单节点无环\n        }\n        ListNode* fast=head->next;\n        //初始化，防止误判（直接跳过循环）\n        ListNode* slow=head;\n        while(slow!=fast){\n            if(fast == nullptr || fast->next == nullptr){\n                return false;\n            }\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        return true;\n    }\n};\n```\n\n***\n \n[Leetcode 26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array)\n\n- 使用`fast`遍历数组，`slow`前段是**已处理序列**，指向的是下一个替换元素的位置（`tag`）\n  - 若`fast`标记重复元素，`slow`不动\n  - 若`fast`标记非重复元素，`slow`交换位置\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int fast=1,slow=1;\n        int n=nums.size();\n        while(fast<n){\n            if(nums[fast]!=nums[fast-1]){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n            fast++;\n        }\n        return slow;\n    }\n};\n```\n\n***\n\n### 滑动窗口\n\n- **核心思想**：维护一个由**左右指针界定的「窗口」**（**连续区间**），通过移动左右指针**动态调整窗口范围**，以寻找满足条件的最优子序列。\n- **适用场景**：\n\n  - 子串 / 子数组问题（如最小覆盖子串、最长无重复子串）\n  - 区间求和问题（如长度最小的子数组）\n  - 固定长度区间问题（如滑动窗口最大值）\n\n- **方法**：\n  - 使用两个指针`left=0,right=0`定义一个窗口，**初始时窗口为空**。\n  - 移动右指针`right++`**扩展窗口**，移动左指针`left++`**缩小窗口**，直到满足条件。\n  - 在收缩过程中**更新满足条件的最优解**\n\n基本模版：\n```cpp\n//外层循环扩展右边界，内层循环扩展左边界\nfor (int l = 0, r = 0 ; r < n ; r++) {\n\t//当前考虑的元素\n\twhile (l <= r && check()) {//区间[left,right]不符合题意\n        //扩展左边界\n    }\n    //区间[left,right]符合题意，统计相关信息\n}\n```\n\n***\n\n[Leetcode 76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)\n\n```cpp\nclass Solution {\npublic:\n    unordered_map <char, int> ori, cnt;\n\n    bool check() {\n        for (const auto &p: ori) {\n            if (cnt[p.first] < p.second) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        for (const auto &c: t) {\n            ++ori[c];\n        }\n\n        int l = 0, r = -1;\n        int len = INT_MAX, ansL = -1, ansR = -1;\n\n        while (r < int(s.size())) {\n            if (ori.find(s[++r]) != ori.end()) {\n                ++cnt[s[r]];\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                }\n                if (ori.find(s[l]) != ori.end()) {\n                    --cnt[s[l]];\n                }\n                ++l;\n            }\n        }\n\n        return ansL == -1 ? string() : s.substr(ansL, len);\n    }\n};\n```\n\n[Leetcode 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters)\n\n#### 滑动窗口+哈希表\n维持两个指针`right``left`，两指针之间代表**不重复子序列**，当`left++`时，会发现终止点`right`的**索引是递增的**，通过滚动数组记录最大值与当前值进行比较，用哈希表记录已在子序列中的字符。\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> map;\n        int n=s.length();\n        int right=-1;\n        int ans=0;\n        for(int i=0;i<n;i++){\n            if(i!=0){\n            map.erase(s[i-1]);\n            }\n            while(right<n-1 && !map.count(s[right+1])){\n                map.insert(s[right+1]);\n                right++;\n            }\n            ans=max(ans,right-i+1);\n        }\n        return ans;\n    }\n};\n```\n","slug":"Algorithm/Double-Pointer","published":1,"updated":"2025-09-13T08:26:02.207Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcf000140w366ip256j","content":"<h2 id=\"Double-Pointer\">Double Pointer</h2>\n<p><strong>双指针</strong>是算法设计中一种<strong>高效且灵活</strong>的技巧，通过两个指针在数据结构中<strong>协同移动</strong>，能够将原本需要<strong>嵌套循环</strong> $ O(n^2) $ 的问题优化为线性时间复杂度 $O(n) $，同时减少空间消耗。</p>\n<h3 id=\"左右指针\">左右指针</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：两个指针分别从<strong>序列的两端</strong>出发，<strong>向中间移动</strong>，通过判断条件调整指针位置，<strong>直至相遇或满足特定条件</strong>。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>有序数组问题（如两数之和、三数之和）</li>\n<li>对称结构判断（如回文串、回文链表）</li>\n<li>二分查找变种（如寻找旋转数组的最小值）</li>\n<li>需要从两端向中间收缩的场景（如盛最多水的容器）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>双指针分别<strong>指向数组两端</strong>：左指针<code>left = 0</code>（<strong>起点</strong>），右指针<code>right = n-1</code>（<strong>终点</strong>）</li>\n<li>循环条件：<code>left &lt; right</code>（指针<strong>未相遇</strong>）</li>\n<li>根据要求<strong>动态移动指针</strong></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted\">Leetcode 167. 两数之和 II - 输入有序数组</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; numbers, <span class=\"hljs-type\">int</span> target)</span> </span>{<br>        <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=numbers.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(right&gt;left){<br>            <span class=\"hljs-keyword\">if</span>(numbers[right]+numbers[left]&gt;target){<br>                right--;<br>            }<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(numbers[right]+numbers[left]&lt;target){<br>                left++;<br>            }<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>;<br>        }<br>        <span class=\"hljs-keyword\">return</span> {left<span class=\"hljs-number\">+1</span>,right<span class=\"hljs-number\">+1</span>};<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/container-with-most-water\">Leetcode 11. 盛最多水的容器</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxArea</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; height)</span> </span>{<br>        <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=height.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> max_vol=INT_MIN;<br>        <span class=\"hljs-type\">int</span> vol;<br>        <span class=\"hljs-keyword\">while</span>(right!=left){<br>            vol=(right-left)*<span class=\"hljs-built_in\">min</span>(height[left],height[right]);<br>            max_vol=<span class=\"hljs-built_in\">max</span>(max_vol,vol);<br>            <span class=\"hljs-keyword\">if</span>(height[left]&gt;height[right]){<br>                right--;<br>            }<br>            <span class=\"hljs-keyword\">else</span> left++;<br>        }<br>        <span class=\"hljs-keyword\">return</span> max_vol;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/remove-element\">Leetcode 27. 移除元素</a></p>\n<h4 id=\"方法一：类快慢指针\">方法一：类快慢指针</h4>\n<p>让我们<strong>模拟</strong>一下程序运行的过程：</p>\n<ul>\n<li>当前几个均<code>!=val</code>时：<code>left</code>和<code>right</code>都<strong>指向同一个索引</strong>，<strong>同时向后移动</strong></li>\n<li>当同时指向<code>val</code>时，<code>right</code>向后继续移动寻找<code>!=val</code>，<code>left</code>保持不变，标记<code>val</code>的位置</li>\n<li>当<code>right</code>再次指向<code>!=val</code>时，这时<code>left</code>的<strong>标记起作用</strong>了，与<code>nums[right]</code>进行交换并向后移动</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> val)</span> </span>{<br>        <span class=\"hljs-type\">int</span> right,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(right=<span class=\"hljs-number\">0</span>;right&lt;n;right++){<br>            <span class=\"hljs-keyword\">if</span>(nums[right]!=val){<br>                nums[left]=nums[right];<br>                left++;<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> left;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"方法二：对撞指针\">方法二：对撞指针</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> val)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> right=n<span class=\"hljs-number\">-1</span>,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(left&lt;=right){<br>            <span class=\"hljs-keyword\">if</span>(nums[left]==val){<br>                <span class=\"hljs-built_in\">swap</span>(nums[right],nums[left]);<br>                right--;<br>            }<span class=\"hljs-keyword\">else</span> {<br>                left++;<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> left;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h3 id=\"快慢指针\">快慢指针</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：两个指针从<strong>同一起点出发</strong>，以<strong>不同速度同向移动</strong>，利用<strong>速度差</strong>解决问题。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>链表问题（如检测环、寻找环入口、链表中点）</li>\n<li>数组去重（如删除有序数组中的重复项）</li>\n<li>追及问题（如找到链表中倒数第 k 个节点）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>快指针<code>fast</code>和慢指针<code>slow</code>均<strong>指向起点</strong>（如链表头节点、数组下标 0）</li>\n<li><strong>快指针每次移动 2 步</strong>（<code>fast = fast-&gt;next-&gt;next</code>）</li>\n<li><strong>慢指针每次移动 1 步</strong>（<code>slow = slow-&gt;next</code>）</li>\n<li>直至<strong>快指针到达终点</strong>（<code>fast == nullptr</code>或<code>fast-&gt;next == nullptr</code>）或<strong>两指针相遇</strong></li>\n</ul>\n</li>\n</ul>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-2cbc2e5f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-2cbc2e5f\">\n        <div class=\"fold-arrow\">▶</div> 有环必相遇\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-2cbc2e5f\">\n        <div class=\"fold-content\">\n          <p>若链表存在环，那么环是<strong>闭合的循环结构</strong>。一旦指针进入环，就会在环内<strong>永不停歇地循环移动</strong>（因为环的末尾节点指向环内某个节点，而非<code>nullptr</code>）。</p>\n        </div>\n      </div>\n    </div>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/linked-list-cycle\">Leetcode 141.环形链表</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition for singly-linked list.</span><br><span class=\"hljs-comment\"> * struct ListNode {</span><br><span class=\"hljs-comment\"> *     int val;</span><br><span class=\"hljs-comment\"> *     ListNode *next;</span><br><span class=\"hljs-comment\"> *     ListNode(int x) : val(x), next(NULL) {}</span><br><span class=\"hljs-comment\"> * };</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hasCycle</span><span class=\"hljs-params\">(ListNode *head)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span>(head==<span class=\"hljs-literal\">nullptr</span> || head-&gt;next==<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//空链表或单节点无环</span><br>        }<br>        ListNode* fast=head-&gt;next;<br>        <span class=\"hljs-comment\">//初始化，防止误判（直接跳过循环）</span><br>        ListNode* slow=head;<br>        <span class=\"hljs-keyword\">while</span>(slow!=fast){<br>            <span class=\"hljs-keyword\">if</span>(fast == <span class=\"hljs-literal\">nullptr</span> || fast-&gt;next == <span class=\"hljs-literal\">nullptr</span>){<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            }<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array\">Leetcode 26. 删除有序数组中的重复项</a></p>\n<ul>\n<li>使用<code>fast</code>遍历数组，<code>slow</code>前段是<strong>已处理序列</strong>，指向的是下一个替换元素的位置（<code>tag</code>）\n<ul>\n<li>若<code>fast</code>标记重复元素，<code>slow</code>不动</li>\n<li>若<code>fast</code>标记非重复元素，<code>slow</code>交换位置</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> fast=<span class=\"hljs-number\">1</span>,slow=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(fast&lt;n){<br>            <span class=\"hljs-keyword\">if</span>(nums[fast]!=nums[fast<span class=\"hljs-number\">-1</span>]){<br>                nums[slow]=nums[fast];<br>                slow++;<br>            }<br>            fast++;<br>        }<br>        <span class=\"hljs-keyword\">return</span> slow;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h3 id=\"滑动窗口\">滑动窗口</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：维护一个由<strong>左右指针界定的「窗口」</strong>（<strong>连续区间</strong>），通过移动左右指针<strong>动态调整窗口范围</strong>，以寻找满足条件的最优子序列。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>子串 / 子数组问题（如最小覆盖子串、最长无重复子串）</li>\n<li>区间求和问题（如长度最小的子数组）</li>\n<li>固定长度区间问题（如滑动窗口最大值）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>使用两个指针<code>left=0,right=0</code>定义一个窗口，<strong>初始时窗口为空</strong>。</li>\n<li>移动右指针<code>right++</code><strong>扩展窗口</strong>，移动左指针<code>left++</code><strong>缩小窗口</strong>，直到满足条件。</li>\n<li>在收缩过程中<strong>更新满足条件的最优解</strong></li>\n</ul>\n</li>\n</ul>\n<p>基本模版：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//外层循环扩展右边界，内层循环扩展左边界</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, r = <span class=\"hljs-number\">0</span> ; r &lt; n ; r++) {<br>\t<span class=\"hljs-comment\">//当前考虑的元素</span><br>\t<span class=\"hljs-keyword\">while</span> (l &lt;= r &amp;&amp; <span class=\"hljs-built_in\">check</span>()) {<span class=\"hljs-comment\">//区间[left,right]不符合题意</span><br>        <span class=\"hljs-comment\">//扩展左边界</span><br>    }<br>    <span class=\"hljs-comment\">//区间[left,right]符合题意，统计相关信息</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/minimum-window-substring\">Leetcode 76. 最小覆盖子串</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    unordered_map &lt;<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">int</span>&gt; ori, cnt;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;p: ori) {<br>            <span class=\"hljs-keyword\">if</span> (cnt[p.first] &lt; p.second) {<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    }<br><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">minWindow</span><span class=\"hljs-params\">(string s, string t)</span> </span>{<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;c: t) {<br>            ++ori[c];<br>        }<br><br>        <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, r = <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> len = INT_MAX, ansL = <span class=\"hljs-number\">-1</span>, ansR = <span class=\"hljs-number\">-1</span>;<br><br>        <span class=\"hljs-keyword\">while</span> (r &lt; <span class=\"hljs-built_in\">int</span>(s.<span class=\"hljs-built_in\">size</span>())) {<br>            <span class=\"hljs-keyword\">if</span> (ori.<span class=\"hljs-built_in\">find</span>(s[++r]) != ori.<span class=\"hljs-built_in\">end</span>()) {<br>                ++cnt[s[r]];<br>            }<br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">check</span>() &amp;&amp; l &lt;= r) {<br>                <span class=\"hljs-keyword\">if</span> (r - l + <span class=\"hljs-number\">1</span> &lt; len) {<br>                    len = r - l + <span class=\"hljs-number\">1</span>;<br>                    ansL = l;<br>                }<br>                <span class=\"hljs-keyword\">if</span> (ori.<span class=\"hljs-built_in\">find</span>(s[l]) != ori.<span class=\"hljs-built_in\">end</span>()) {<br>                    --cnt[s[l]];<br>                }<br>                ++l;<br>            }<br>        }<br><br>        <span class=\"hljs-keyword\">return</span> ansL == <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-built_in\">string</span>() : s.<span class=\"hljs-built_in\">substr</span>(ansL, len);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<p><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters\">Leetcode 3. 无重复字符的最长子串</a></p>\n<h4 id=\"滑动窗口-哈希表\">滑动窗口+哈希表</h4>\n<p>维持两个指针<code>right``left</code>，两指针之间代表<strong>不重复子序列</strong>，当<code>left++</code>时，会发现终止点<code>right</code>的<strong>索引是递增的</strong>，通过滚动数组记录最大值与当前值进行比较，用哈希表记录已在子序列中的字符。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lengthOfLongestSubstring</span><span class=\"hljs-params\">(string s)</span> </span>{<br>        unordered_set&lt;<span class=\"hljs-type\">char</span>&gt; map;<br>        <span class=\"hljs-type\">int</span> n=s.<span class=\"hljs-built_in\">length</span>();<br>        <span class=\"hljs-type\">int</span> right=<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> ans=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++){<br>            <span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">0</span>){<br>            map.<span class=\"hljs-built_in\">erase</span>(s[i<span class=\"hljs-number\">-1</span>]);<br>            }<br>            <span class=\"hljs-keyword\">while</span>(right&lt;n<span class=\"hljs-number\">-1</span> &amp;&amp; !map.<span class=\"hljs-built_in\">count</span>(s[right<span class=\"hljs-number\">+1</span>])){<br>                map.<span class=\"hljs-built_in\">insert</span>(s[right<span class=\"hljs-number\">+1</span>]);<br>                right++;<br>            }<br>            ans=<span class=\"hljs-built_in\">max</span>(ans,right-i<span class=\"hljs-number\">+1</span>);<br>        }<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<h2 id=\"Double-Pointer\">Double Pointer</h2>\n<p><strong>双指针</strong>是算法设计中一种<strong>高效且灵活</strong>的技巧，通过两个指针在数据结构中<strong>协同移动</strong>，能够将原本需要<strong>嵌套循环</strong> $ O(n^2) $ 的问题优化为线性时间复杂度 $O(n) $，同时减少空间消耗。</p>\n<h3 id=\"左右指针\">左右指针</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：两个指针分别从<strong>序列的两端</strong>出发，<strong>向中间移动</strong>，通过判断条件调整指针位置，<strong>直至相遇或满足特定条件</strong>。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>有序数组问题（如两数之和、三数之和）</li>\n<li>对称结构判断（如回文串、回文链表）</li>\n<li>二分查找变种（如寻找旋转数组的最小值）</li>\n<li>需要从两端向中间收缩的场景（如盛最多水的容器）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>双指针分别<strong>指向数组两端</strong>：左指针<code>left = 0</code>（<strong>起点</strong>），右指针<code>right = n-1</code>（<strong>终点</strong>）</li>\n<li>循环条件：<code>left &lt; right</code>（指针<strong>未相遇</strong>）</li>\n<li>根据要求<strong>动态移动指针</strong></li>\n</ul>\n</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted\">Leetcode 167. 两数之和 II - 输入有序数组</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">twoSum</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; numbers, <span class=\"hljs-type\">int</span> target)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=numbers.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(right&gt;left)&#123;<br>            <span class=\"hljs-keyword\">if</span>(numbers[right]+numbers[left]&gt;target)&#123;<br>                right--;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(numbers[right]+numbers[left]&lt;target)&#123;<br>                left++;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> &#123;left<span class=\"hljs-number\">+1</span>,right<span class=\"hljs-number\">+1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/container-with-most-water\">Leetcode 11. 盛最多水的容器</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxArea</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> left=<span class=\"hljs-number\">0</span>,right=height.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> max_vol=INT_MIN;<br>        <span class=\"hljs-type\">int</span> vol;<br>        <span class=\"hljs-keyword\">while</span>(right!=left)&#123;<br>            vol=(right-left)*<span class=\"hljs-built_in\">min</span>(height[left],height[right]);<br>            max_vol=<span class=\"hljs-built_in\">max</span>(max_vol,vol);<br>            <span class=\"hljs-keyword\">if</span>(height[left]&gt;height[right])&#123;<br>                right--;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> left++;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> max_vol;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/remove-element\">Leetcode 27. 移除元素</a></p>\n<h4 id=\"方法一：类快慢指针\">方法一：类快慢指针</h4>\n<p>让我们<strong>模拟</strong>一下程序运行的过程：</p>\n<ul>\n<li>当前几个均<code>!=val</code>时：<code>left</code>和<code>right</code>都<strong>指向同一个索引</strong>，<strong>同时向后移动</strong></li>\n<li>当同时指向<code>val</code>时，<code>right</code>向后继续移动寻找<code>!=val</code>，<code>left</code>保持不变，标记<code>val</code>的位置</li>\n<li>当<code>right</code>再次指向<code>!=val</code>时，这时<code>left</code>的<strong>标记起作用</strong>了，与<code>nums[right]</code>进行交换并向后移动</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> right,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(right=<span class=\"hljs-number\">0</span>;right&lt;n;right++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[right]!=val)&#123;<br>                nums[left]=nums[right];<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"方法二：对撞指针\">方法二：对撞指针</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeElement</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums, <span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> right=n<span class=\"hljs-number\">-1</span>,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">while</span>(left&lt;=right)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[left]==val)&#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[right],nums[left]);<br>                right--;<br>            &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>                left++;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> left;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"快慢指针\">快慢指针</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：两个指针从<strong>同一起点出发</strong>，以<strong>不同速度同向移动</strong>，利用<strong>速度差</strong>解决问题。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>链表问题（如检测环、寻找环入口、链表中点）</li>\n<li>数组去重（如删除有序数组中的重复项）</li>\n<li>追及问题（如找到链表中倒数第 k 个节点）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>快指针<code>fast</code>和慢指针<code>slow</code>均<strong>指向起点</strong>（如链表头节点、数组下标 0）</li>\n<li><strong>快指针每次移动 2 步</strong>（<code>fast = fast-&gt;next-&gt;next</code>）</li>\n<li><strong>慢指针每次移动 1 步</strong>（<code>slow = slow-&gt;next</code>）</li>\n<li>直至<strong>快指针到达终点</strong>（<code>fast == nullptr</code>或<code>fast-&gt;next == nullptr</code>）或<strong>两指针相遇</strong></li>\n</ul>\n</li>\n</ul>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-2cbc2e5f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-2cbc2e5f\">\n        <div class=\"fold-arrow\">▶</div> 有环必相遇\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-2cbc2e5f\">\n        <div class=\"fold-content\">\n          <p>若链表存在环，那么环是<strong>闭合的循环结构</strong>。一旦指针进入环，就会在环内<strong>永不停歇地循环移动</strong>（因为环的末尾节点指向环内某个节点，而非<code>nullptr</code>）。</p>\n        </div>\n      </div>\n    </div>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/linked-list-cycle\">Leetcode 141.环形链表</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * Definition for singly-linked list.</span><br><span class=\"hljs-comment\"> * struct ListNode &#123;</span><br><span class=\"hljs-comment\"> *     int val;</span><br><span class=\"hljs-comment\"> *     ListNode *next;</span><br><span class=\"hljs-comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class=\"hljs-comment\"> * &#125;;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hasCycle</span><span class=\"hljs-params\">(ListNode *head)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(head==<span class=\"hljs-literal\">nullptr</span> || head-&gt;next==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//空链表或单节点无环</span><br>        &#125;<br>        ListNode* fast=head-&gt;next;<br>        <span class=\"hljs-comment\">//初始化，防止误判（直接跳过循环）</span><br>        ListNode* slow=head;<br>        <span class=\"hljs-keyword\">while</span>(slow!=fast)&#123;<br>            <span class=\"hljs-keyword\">if</span>(fast == <span class=\"hljs-literal\">nullptr</span> || fast-&gt;next == <span class=\"hljs-literal\">nullptr</span>)&#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            fast=fast-&gt;next-&gt;next;<br>            slow=slow-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array\">Leetcode 26. 删除有序数组中的重复项</a></p>\n<ul>\n<li>使用<code>fast</code>遍历数组，<code>slow</code>前段是<strong>已处理序列</strong>，指向的是下一个替换元素的位置（<code>tag</code>）\n<ul>\n<li>若<code>fast</code>标记重复元素，<code>slow</code>不动</li>\n<li>若<code>fast</code>标记非重复元素，<code>slow</code>交换位置</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> fast=<span class=\"hljs-number\">1</span>,slow=<span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(fast&lt;n)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[fast]!=nums[fast<span class=\"hljs-number\">-1</span>])&#123;<br>                nums[slow]=nums[fast];<br>                slow++;<br>            &#125;<br>            fast++;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"滑动窗口\">滑动窗口</h3>\n<ul>\n<li>\n<p><strong>核心思想</strong>：维护一个由<strong>左右指针界定的「窗口」</strong>（<strong>连续区间</strong>），通过移动左右指针<strong>动态调整窗口范围</strong>，以寻找满足条件的最优子序列。</p>\n</li>\n<li>\n<p><strong>适用场景</strong>：</p>\n<ul>\n<li>子串 / 子数组问题（如最小覆盖子串、最长无重复子串）</li>\n<li>区间求和问题（如长度最小的子数组）</li>\n<li>固定长度区间问题（如滑动窗口最大值）</li>\n</ul>\n</li>\n<li>\n<p><strong>方法</strong>：</p>\n<ul>\n<li>使用两个指针<code>left=0,right=0</code>定义一个窗口，<strong>初始时窗口为空</strong>。</li>\n<li>移动右指针<code>right++</code><strong>扩展窗口</strong>，移动左指针<code>left++</code><strong>缩小窗口</strong>，直到满足条件。</li>\n<li>在收缩过程中<strong>更新满足条件的最优解</strong></li>\n</ul>\n</li>\n</ul>\n<p>基本模版：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//外层循环扩展右边界，内层循环扩展左边界</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, r = <span class=\"hljs-number\">0</span> ; r &lt; n ; r++) &#123;<br>\t<span class=\"hljs-comment\">//当前考虑的元素</span><br>\t<span class=\"hljs-keyword\">while</span> (l &lt;= r &amp;&amp; <span class=\"hljs-built_in\">check</span>()) &#123;<span class=\"hljs-comment\">//区间[left,right]不符合题意</span><br>        <span class=\"hljs-comment\">//扩展左边界</span><br>    &#125;<br>    <span class=\"hljs-comment\">//区间[left,right]符合题意，统计相关信息</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<hr>\n<p><a href=\"https://leetcode.cn/problems/minimum-window-substring\">Leetcode 76. 最小覆盖子串</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    unordered_map &lt;<span class=\"hljs-type\">char</span>, <span class=\"hljs-type\">int</span>&gt; ori, cnt;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;p: ori) &#123;<br>            <span class=\"hljs-keyword\">if</span> (cnt[p.first] &lt; p.second) &#123;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">minWindow</span><span class=\"hljs-params\">(string s, string t)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;c: t) &#123;<br>            ++ori[c];<br>        &#125;<br><br>        <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, r = <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> len = INT_MAX, ansL = <span class=\"hljs-number\">-1</span>, ansR = <span class=\"hljs-number\">-1</span>;<br><br>        <span class=\"hljs-keyword\">while</span> (r &lt; <span class=\"hljs-built_in\">int</span>(s.<span class=\"hljs-built_in\">size</span>())) &#123;<br>            <span class=\"hljs-keyword\">if</span> (ori.<span class=\"hljs-built_in\">find</span>(s[++r]) != ori.<span class=\"hljs-built_in\">end</span>()) &#123;<br>                ++cnt[s[r]];<br>            &#125;<br>            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">check</span>() &amp;&amp; l &lt;= r) &#123;<br>                <span class=\"hljs-keyword\">if</span> (r - l + <span class=\"hljs-number\">1</span> &lt; len) &#123;<br>                    len = r - l + <span class=\"hljs-number\">1</span>;<br>                    ansL = l;<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> (ori.<span class=\"hljs-built_in\">find</span>(s[l]) != ori.<span class=\"hljs-built_in\">end</span>()) &#123;<br>                    --cnt[s[l]];<br>                &#125;<br>                ++l;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> ansL == <span class=\"hljs-number\">-1</span> ? <span class=\"hljs-built_in\">string</span>() : s.<span class=\"hljs-built_in\">substr</span>(ansL, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><a href=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters\">Leetcode 3. 无重复字符的最长子串</a></p>\n<h4 id=\"滑动窗口-哈希表\">滑动窗口+哈希表</h4>\n<p>维持两个指针<code>right``left</code>，两指针之间代表<strong>不重复子序列</strong>，当<code>left++</code>时，会发现终止点<code>right</code>的<strong>索引是递增的</strong>，通过滚动数组记录最大值与当前值进行比较，用哈希表记录已在子序列中的字符。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lengthOfLongestSubstring</span><span class=\"hljs-params\">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class=\"hljs-type\">char</span>&gt; map;<br>        <span class=\"hljs-type\">int</span> n=s.<span class=\"hljs-built_in\">length</span>();<br>        <span class=\"hljs-type\">int</span> right=<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-type\">int</span> ans=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(i!=<span class=\"hljs-number\">0</span>)&#123;<br>            map.<span class=\"hljs-built_in\">erase</span>(s[i<span class=\"hljs-number\">-1</span>]);<br>            &#125;<br>            <span class=\"hljs-keyword\">while</span>(right&lt;n<span class=\"hljs-number\">-1</span> &amp;&amp; !map.<span class=\"hljs-built_in\">count</span>(s[right<span class=\"hljs-number\">+1</span>]))&#123;<br>                map.<span class=\"hljs-built_in\">insert</span>(s[right<span class=\"hljs-number\">+1</span>]);<br>                right++;<br>            &#125;<br>            ans=<span class=\"hljs-built_in\">max</span>(ans,right-i<span class=\"hljs-number\">+1</span>);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"Classes and Objects in C++","date":"2025-07-22T10:33:26.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Object-Oriented-Programming-OOP-in-CPP.png","category_bar":true,"description":"This post dives deep into object-oriented programming (OOP), the true essence of C++!","_content":"\n\n {% note primary%}\n 看到过一个很讽刺的笑话：大多数国内高校学生学到的CPP只是**C语言的cin/cout**。这当然只是一句玩笑话，但很深刻地反映出对于**CPP精髓面向对象编程**的忽视。这是有理可依的：编程语言的学习本身就和传统的课堂授课模式存在较大的出入，**编程重视实践**，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较**大规模的项目工程**，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态··· ”，很容易将CPP学成死记硬背的无聊学科。{% endnote %}\n\n因此，笔者希望通过博客的方式，记录自己**OOP in CPP**的学习笔记，并分享给各位小伙伴！\n\n\n# Why OOP?\n\n- 面向过程的局限性：将描述事物的数据与处理数据的函数分开。\n  - 若所描述事物的数据结构发生变化时，这些成员函数也必须重新设计！  \n  - 在主函数中对数据进行修改，仅仅需要执行一条赋值语句，数据安全性得不到保障！\n\n- 面向对象的优势：将描述事物的数据与处理函数**封装**成一个整体，称为类。  \n  - 封装在类中的函数和数据不受外界的影响，即类使数据具有良好的**独立性**和**可维护性**！\n  - 类中的数据在类的外部不能直接调用，外部只能通过**公共接口函数**来处理类中的数据，从而保障了**数据的安全性**！\n\n\n# 类和对象\n## 类：\n&emsp;&emsp;类描述了某一类事物应该具有哪些**特征**和**行为**。比如我们想描述一个“商品”类别，类就会告诉我们商品的名称、编号、进货价格、售出价格等特征，但是这个“商品”并不是一真正的商品，类只告诉了我们“商品”是什么样的、应该具有的特征。类是对象的抽象表示，它**本身不占用内存空间**。\n\n类```class```与结构体```struct```形式相似，关键字不同！\n\n- ```class```的成员默认是```private```的\n- ```struct```的成员默认是```public```的\n\n```cpp\n  class 类名 {\n     private:\n\t//私有数据成员和成员函数\n     protected:\n\t//保护数据成员和成员函数\n     public:\n\t//共有数据成员和成员函数\n};\n```\n\n- ```private```:只能被类本身的成员函数、友元函数、友元函数的成员函数访问，派生类也无法访问。\n- ```protected```:除派生类可以进行访问，其余与```private```相同。\n- ```public```:可以被程序中任意代码访问。\n\n\n```cpp\nclass cgoods{//商品类\n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     protected://无\n     public:\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        //函数体\n        }\n        ~cgoods(){//析构函数\n        } \n        void SetPurchasingprice(double purchasingprice){//设置进货价格\n        //函数体\n        }\n        void SetSellingprice(double sellingprice){//设置出货价格\n        //函数体\n        }\n        void setSellingcount(int sellcount){//设置出货商品价格\n        //函数体\n        }\n        void Sell(double sellingprice,int sellcount){\n        //函数体\n        }\n        static double getProfit(){//获取总利润，静态成员函数\n        //函数体\n        }\n        void display(){\n        //函数体\n        }\n}\n```\n\n## 对象：\n&emsp;&emsp;对象则是根据类创建出来的具体实例。比如我们创建一个叫“手机”的“商品”，他有自己的具体的编号、进货价格、售出价格等，所有的特征都是独一无二的，不会与其他商品相同。每一个对象都是根据类创建的具有其属性和方法的实例，并且具有唯一的身份标识（如内存地址）和自己独特的属性值。 **对象是占用内存空间的**，它的**属性值可以在运行时动态地改变**。\n\n定义对象的三种方法：\n- 先定义类的类型，再定义对象：\n ```cpp\n class 类名{\n     成员表;\n };\n [class]可选 类名 对象名列表;\n ```\n例如：\n ```cpp\n class cgoods goods1(\"1001001\",\"元气森林\");//创建对象goods1\n cgoods goods(\"1001001\",\"元气森林\");//两种方法等价\n ```\n- 在定义类类型时**同时创建对象**：\n```cpp\n class 类名{\n     成员表;\n }对象名表;\n ```\n例如：\n ```cpp\n class cgoods{\n     private:\n     public:\n }goods1(\"1001001\",\"元气森林\")；\n ```\n- 不出现类名**直接定义对象**：\n```cpp\nclass {\n     成员表;\n }对象名表;\n```\n例如：\n```cpp\n class {\n     private:\n     public:\n }goods1(\"1001001\",\"元气森林\")；\n ```\n此方法由于没有类名，所以只能**一次性声明多个对象**，此后再无法声明此类对象！\n\n## 类的成员访问\n\n- 对于数据成员的访问\n```cpp\n对象名.成员名//数据成员访问\n对象指针名->成员名\n(*对象指针名).成员名\n```\n- 对于成员函数的访问\n```cpp\n对象名.成员函数名(参数表)//成员函数访问\n对象指针名->成员函数名(参数表)\n(*对象指针名).成员函数名(参数表)\n```\n\n## 类的构造函数(Constructor)\n\n- 类的对象太过复杂，一个对象可能有许许多多的数据成员，这就意味着我们要对许许多多的数据成员进行初始化，实现这一过程并不容易。构造函数的作用就是在对象被创建时**利用特定的初始值**构造对象，把对象**置于某一个初始状态**。\n\n1. 有**与类完全相同的名字** \n2. **没有类型说明**，不允许有返回值\n3. **可以进行重载**，即一个类中允许定义多个参数不同的构造函数 \n4. 可以在声明时的**参数表里给予初始值**\n5. 每个类都必须至少有一个构造函数，如果没有显式的为类提供构造函数，则C++**提供一个默认的无参构造函数**，只负责对象的创建，而不做任何初始化的工作\n6.  一旦类定义了构造函数，C++不再提供默认的无参构造函数\n7.  程序中不能直接调用构造函数，他是在**创建类的对象时自动调用**的\n\n***\n\n### 1. 无参构造函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Time {\npublic:\n    Time() { // 定义构造成员函数，函数名与类名相同\n        hour = 22;\n        minute = 22;\n        sec = 22;\n    }\n    void set_time();  // 函数声明\n    void show_time(); // 函数声明\nprivate: // 私有数据成员\n    int hour;\n    int minute;\n    int sec;\n};\n\nvoid Time::set_time() { // 定义成员函数，向数据成员赋值\n    cin >> hour;\n    cin >> minute;\n    cin >> sec;\n}\n\nvoid Time::show_time() { // 定义成员函数，输出数据成员的值\n    cout << \"时间为: \" << hour << \":\" << minute << \":\" << sec << endl;\n}\n\nint main() {\n    Time t1;       // 建立对象t1，同时调用构造函数t1.Time()\n    t1.set_time(); // 对t1的数据成员赋值\n    t1.show_time(); // 显示t1的数据成员的值\n    Time t2;       // 建立对象 t2，同时调用构造函数 t2.Time()\n    t2.show_time(); // 显示t2的数据成员的值\n    return 0;\n}\n```\n```\n12 30 40\n时间为: 12:30:40\n时间为: 22:22:22\n```\n\n### 2. 含参构造函数\n\n```cpp\n构造函数名（类型1 形参1，类型2 形参2，...）\n类名 对象名（实参1，实参2，...）\n```\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\npublic:\n    Cuboid(int, int, int);  // 带有三个参数的构造函数\n    int volume();\nprivate:\n    int height;\n    int width;\n    int length;\n};\n\n// 构造函数的实现\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;\n    width = w;\n    length = len;\n}\n\n// volume成员函数的实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    Cuboid cuboid1(15, 45, 30);  // 定义对象时需要根据构造函数形参提供实参\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n\n    Cuboid cuboid2(10, 30, 22);\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n\n    return 0;\n}\n```\n\n```\ncuboid1的体积为: 20250\ncuboid2的体积为: 6600\n```\n\n### 3. 构造函数重载\n  定义多个构造函数以便给对象提供不同的初始化方法，这些构造函数具有相同的名字而**参数的个数或参数的类型不相同**。可以为一个类声明的构造函数的个数是**无限制的**，只要每个构造函数的**形参表是唯一的**，定义对象时会根据提供的实参决定调用哪一个构造函数。\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\npublic:\n    Cuboid();                  // 默认构造函数（无参数）\n    Cuboid(int h, int w, int len);  // 带参数的构造函数\n    int volume();              // 计算体积方法\n    \nprivate:\n    int height;   // 高度\n    int width;    // 宽度\n    int length;   // 长度\n};\n\n// 默认构造函数实现\nCuboid::Cuboid() {\n    height = 15;\n    width = 15;\n    length = 15;\n}\n\n// 带参数的构造函数实现\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;\n    width = w;\n    length = len;\n}\n\n// 体积计算方法实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    // 创建对象cuboid1，使用默认构造函数\n    Cuboid cuboid1;\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n    \n    // 创建对象cuboid2，使用带参数的构造函数\n    Cuboid cuboid2(20, 30, 45);\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n    \n    return 0;\n}\n```\n```\ncuboid1的体积为: 3375\ncuboid2的体积为: 27000\n```\n\n### 4. 使用默认值的构造函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\nprivate:\n    int height;   // 高度\n    int width;    // 宽度\n    int length;   // 长度\npublic:\n    Cuboid(int h = 15, int w = 15, int len = 15); // 构造函数，全部参数带默认值\n    int volume(); // 计算体积\n};\n\n// 构造函数实现（定义时可不再指定默认值）\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;   \n    width = w;\n    length = len;\n}\n\n// 计算体积方法实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    Cuboid cuboid1; // 没有给出实参，使用全部默认值 height=15,width=15,length=15\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n\n    Cuboid cuboid2(25); // 只给定一个实参，height=25,width=15,length=15\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n\n    Cuboid cuboid3(25, 40); // 只给定2个实参，height=25,width=40,length=15\n    cout << \"cuboid3的体积为: \" << cuboid3.volume() << endl;\n\n    Cuboid cuboid4(25, 30, 40); // 给定3个实参，height=25,width=30,length=40\n    cout << \"cuboid4的体积为: \" << cuboid4.volume() << endl;\n\n    return 0; \n}\n```\n\n```\ncuboid1的体积为: 3375\ncuboid2的体积为: 5625\ncuboid3的体积为: 15000\ncuboid4的体积为: 30000\n```\n\n### 5.子对象和构造函数\n在定义一个新的类时，**将一个已有类作为数据成员**，这个类对象叫做子对象。我们通过调用子对象成员的构造函数来完成对子对象的初始化。\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle {  // 定义矩形类\nprivate:\n    int Width, Length;  // 宽度、长度\npublic:\n    Rectangle(int w, int len) {  // 带参构造函数\n        Width = w;\n        Length = len;\n    }\n    int Area() {  // 计算面积\n        return (Width * Length);\n    }\n};\n\nclass Cuboid {  // 定义长方体类\nprivate:\n    int Height;  // 高度\n    Rectangle r;  // 使用Rectangle类对象作为成员\npublic:\n    Cuboid(int w, int len, int h) : r(w, len) {  // 初始化列表初始化r对象\n        Height = h;  // 原代码这里是Height-h，应该是赋值=\n    }\n    int Volume() {  // 计算体积\n        return (Height * r.Area());\n    }\n};\n\nint main() {\n    Cuboid c1(10, 20, 100);  // 创建长方体对象\n    cout << \"长方体 c1 的体积是: \" << c1.Volume() << endl;\n    return 0;\n}\n```\n\n```\n长方体 c1 的体积是: 20000\n```\n\n```cpp\n Cuboid(int w, int len, int h) : r(w, len) {  // 初始化列表初始化r对象\n        Height = h;  // 原代码这里是Height-h，应该是赋值=\n    }\n```\n实参10、20通过`w`和`len`赋值`r(w, len)`，调用类的成员`Rectangle(int w, int len)`构造函数完成初始化，实参100通过`Height = h`完成对`Cuboid`的初始化。\n\n### 6.拷贝构造函数\n\n设计拷贝构造函数**实现类中的一个对象给另一个对象的每个非静态数据成员赋值**。（**用已经初始化的对象去初始化一个新定义的对象**）\n\n\n1. 拷贝构造函数的函数名必须**与类名一致**，函数的形式参数是本类型的一个**引用变量**，必须为**引用**！\n2. **自定义拷贝构造函数**，能够实现**有选择**的复制原对象中的数据（实现对部分数据的修改）\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Sample {        // 定义Sample类\nprivate:\n    int nTest;        // 私有成员变量，用于存储测试值\npublic:\n    // 构造函数，初始化nTest\n    Sample(int ly) {  // 参数ly用于初始化nTest\n        nTest = ly;   // 将参数值赋给成员变量\n    }\n    \n    // 自定义的拷贝构造函数\n    Sample(Sample &tS) {  // 参数是对另一个Sample对象的引用\n        cout << \"拷贝构造函数被调用\" << endl;  // 输出提示信息\n        nTest = tS.nTest + 8;  // 新对象的nTest值 = 原对象值 + 8\n    }\n    \n    // 获取nTest值的成员函数\n    int readtest() {\n        return nTest;  // 返回当前对象的nTest值\n    }\n    \n    // 设置nTest值的成员函数\n    void settest(int ly) {\n        nTest = ly;    // 修改当前对象的nTest值\n    }\n};\n\nint main() {\n    Sample S1(100);    // 创建S1对象，nTest初始化为100\n    Sample S2(S1);     // 使用拷贝构造函数创建S2对象\n    cout << S2.readtest() << endl;  // 输出S2的nTest值\n    return 0;\n}\n```\n\n```\n拷贝构造函数被调用\n108\n```\n\n## 类的析构函数(Destructor)\n\n相当于创建对象时用new申请了一片内存空间，应在退出前**在析构函数中用delete释放**。析构函数是与构造函数作用相反的函数，当对象生命周期结束时，自动执行析构函数。\n\n1. 有与类完全相同的名字，只是在**函数名前面加一个位取反符“~”**，以区别于构造函数\n2. 不带任何参数，没有返回值\n3. 一个类最多只能有一个析构函数，**无法进行重载**\n4. 如果用户没有编写析构函数，编译系统会**自动的生成一个默认的析构函数**\n\n```cpp\nclass 类名{\n    public:\n    ~类名();{//析构函数\n    //函数体\n    }\n};\n```\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person {\nprivate:\n    //私有数据成员\n    string name;    //姓名\n    int age;        //年龄\n    char gender;    //性别，'f'女性，'m'男性\n    string idNumber; //身份证号码\n\npublic:\n    Person(string, int, char, string);\n    Person(Person&);\n    ~Person();\n    string getName();  // 函数声明\n    void showInfo();   // 函数声明\n};\n\n// 成员函数在类体外实现\nPerson::Person(string theName, int theAge, char theGender, string theIdNumber) {\n    name = theName;\n    age = theAge;\n    gender = theGender;\n    idNumber = theIdNumber;\n    cout << name << \" Constructor called.\" << endl;\n}\n\nPerson::Person(Person& theObject) {\n    name = theObject.name;\n    age = theObject.age;\n    gender = theObject.gender;\n    idNumber = theObject.idNumber;\n    cout << \"Copy Constructor called.\" << endl; //输出有关信息\n}\n\nPerson::~Person() { //析构函数\n    cout << name << \" Destructor called.\" << endl;\n}\n\nstring Person::getName() {\n    return name;\n}\n\nvoid Person::showInfo() {\n    cout << \"name: \" << name << endl;\n    cout << \"age: \" << age << endl;\n    cout << \"gender: \" << gender << endl;\n    cout << \"id number: \" << idNumber << endl;\n}\n\nint main() {\n    Person p1(\"张三\", 12, 'm', \"12345200006061111\"); //建立对象p1\n    Person p2(\"李四\", 31, 'f', \"12345198111091234\"); //建立对象p2\n\n    p1.showInfo();\n    p2.showInfo();\n\n    return 0;\n}\n```\n```\n张三 Constructor called.\n李四 Constructor called.\nname: 张三\nage: 12\ngender: m\nid number: 12345200006061111\nname: 李四\nage: 31\ngender: f\nid number: 12345198111091234\n李四 Destructor called.\n张三 Destructor called.\n```\n**注意观察输出：构造函数和析构函数调用的顺序！**\n{% note warning %}\n1. 析构函数在对象作为函数值返回之后被调用。{% endnote %}\n   \n## 构造函数和析构函数调用顺序\n一般而言，调用构造函数的次序与调用析构函数的**次序相反**，与栈类似：**先调用构造函数的对象，最后调用析构函数**。\n\n\n### 特殊情况：\n{% note warning %}\n1. **全局定义**对象（函数体外定义的对象）：程序开始之前调用构造函数，程序结束或调用exit()函数时调用析构函数。\n2. **局部定义**的对象（函数体内定义的对象）：程序执行到定义对象的地方时调用构造函数，函数结束时调用析构函数。\n3. **static定义**的对象：在首次到达对象定义位置时调用构造函数，程序结束时调用析构函数。\n4. **new动态生成**的对象：产生对象时调用构造函数，用delete释放对象时，才调用析构函数。若不使用delete运算符来撤销动态生成的对象，则析构函数不会被调用。{% endnote %}\n\n\n\n## 对象的动态建立和释放\n- new运算符建立对象：**先为类的对象分配内存空间**，然后**自动调用构造函数初始化**对象的数据成员，最后将变量的起始地址返还给指针变量。\n- delete运算符释放对象：**只有在delete运算符释放对象时，才会调用析构函数将对象销毁**。\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 定义一个复数类\nclass Complex {\npublic:\n    // 构造函数：初始化实部和虚部\n    Complex(double r, double i) {\n        real = r;    // 设置实部值\n        imag = i;    // 设置虚部值\n        cout << \"构造函数被调用\" << endl;\n    }\n\n    // 析构函数：对象销毁时自动调用\n    ~Complex() {\n        cout << \"析构函数被调用\" << endl;\n    }\n\n    // 显示复数的方法\n    void display() {\n        cout << \"(\" << real << \",\" << imag << \")\" << endl;\n    }\n\nprivate:\n    double real;  // 复数的实部\n    double imag;  // 复数的虚部\n};\n\nint main() {\n    // 动态创建一个Complex对象\n    Complex* pc1 = new Complex(3, 4);\n\n    // 调用display方法显示复数\n    pc1->display();  // 等价于 (*pc1).display();\n\n    // 释放对象内存\n    delete pc1;\n\n    cout << \"程序结束\" << endl;\n    return 0;\n}\n```\n```\n构造函数被调用\n(3,4)\n析构函数被调用\n程序结束\n```\n## 静态成员\n声明为static的类成员称为静态成员，可以**被类的所有对象共享**。\n- 静态数据成员：描述这一类对象所共有的数据，所有对象公用这一部分存储空间。\n- 静态数据函数\n\neg:Profit和 static double getProfit() ，总利润是出售所有商品获得的，并不隶属于哪一个商品对象。\n\n### 为什么不使用全局变量？\n{% note warning %} \n1. **违背了OOP封装性的精神**，任何地方都可以对全局变量进行访问，破坏了信息隐藏原则\n2. 过多使用全局变量会产生**重名冲突**\n3. 能够**明确归属**，直接表明它是类的一部分，便于进行初始化{% endnote %}\n\n### 静态数据成员\n\n在类的定义中的数据成员声明前加上关键字`static`，表示该成员是静态数据成员。由于静态数据成员**由类的所有对象共享**，所以静态成员的存储空间**不会随着对象的产生而分配**，也**不会随着对象的消失而释放**，因此静态数据成员不能在类体内进行初始化，而只能在**类体内进行声明**，在**类体外进行初始化**。\n\n```\n数据类型名类名::静态数据成员名=初值;\n```\n\n**注意**：\n- **不需要加`static`关键字**\n- **需要通过作用域运算符`::`限定修饰**\n\n```cpp\nclass cgoods{ \n    private:\n    ......\n    static double Profit;\n    public:\n    ......\n}\ndouble cgoods::Profit=0;\n```\n\n类外的定义是必要的，若没有明确赋初值，则编译系统会自动赋初值为0。\n\n### 静态成员函数\n与类的数据成员相同，在成员函数前加上`static`可以创建一个静态成员函数。静态函数没有`this`指针，通常他只访问属于全体对象的成员————即静态成员。\n```cpp\ndouble cgoods::getProfit(){\n    return Profit;//使用了静态成员变量\n}\n```\n{% note warning %}\n1. 非静态成员函数可以任意地访问静态成员函数和静态数据成员\n2. 静态成员函数不能直接访问非静态成员函数和非静态数据成员{% endnote %}\n\n### 静态成员的访问\n\n用类的对象访问 || 直接用作用域运算符“::”通过类名访问\n\n```cpp\n类名::静态数据成员名\n```\n\n```cpp\n对象名.静态数据成员名\n//容易让人误认为静态数据成员是属于某个对象的\n```\n静态成员函数的访问与静态成员数据的访问的形式相同，不做过多阐释。\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass CStudent {\nprivate:\n    string SName;       // 保存学生姓名\n    float Score;        // 保存学生的成绩\n    static int studentTotal;    // 静态数据成员，保存学生的总人数\n    static float SumScore;      // 静态数据成员，保存所有学生的成绩和\n\npublic:\n    // 构造函数，当新建一个对象时，人数studentTotal加1\n    CStudent(string name, float sc);\n    static float average();     // 计算学生的平均分\n    void Print();               // 打印输出学生的姓名和分数\n    ~CStudent();                // 析构函数，当减少一个对象时，studentTotal减1\n};\n\n// 静态数据成员的初始化必须在类外进行\nint CStudent::studentTotal = 0;\nfloat CStudent::SumScore = 0;\n\nCStudent::CStudent(string name, float sc) {\n    SName = name;\n    Score = sc;\n    studentTotal++;     // 学生人数加1\n    SumScore += sc;     // 总分数增加\n    cout << SName << \" Constructor called.\" << endl;\n}\n\nvoid CStudent::Print() {\n    cout << SName << \": \" << Score << endl;\n}\n\nfloat CStudent::average() {     // 静态成员函数访问静态数据成员\n    if (studentTotal == 0) return 0;  // 防止除以0\n    return (SumScore / studentTotal);\n}\n\nCStudent::~CStudent() {\n    studentTotal--;     // 学生人数减1\n    SumScore -= Score;  // 总分数减少\n    cout << SName << \" Destructor called.\" << endl;\n}\n\nint main() {\n    // 简单测试\n    CStudent stud1(\"Zhang San\", 90);\n    CStudent stud2(\"Li Si\", 80);\n    stud1.Print();\n    stud2.Print();\n    cout << \"平均分为: \" << CStudent::average() << endl;  // 调用静态成员函数\n    return 0;\n}\n```\n\n```\nZhang San Constructor called.\nLi Si Constructor called.\nZhang San: 90\nLi Si: 80\n平均分为: 85\nLi Si Destructor called.\nZhang San Destructor called.\n```\n\n## this指针\n- 用途：当成员函数的**参数名与成员变量名相同**的时候，可以使用`this`来**明确地引用成员变量**\n```cpp\nPonit& setPoint(int x,int y){\n    this->x=x;\n    (*this).y=y+8;\n    return *this;\n}\n```\n{% note warning %}\n1. this指针是一个**指向对象的指针**\n2. this指针是一个隐含于成员函数中的对象指针\n3. this指针是一个指向正在调用成员函数的对象的指针\n4. **类的静态成员函数没有this指针**{% endnote %}\n\n## 常对象\n常对象用`const`进行修饰，常对象必须进行初始化，且不能被更新，常对象的声明如下（两种声明完全相同，没有任何区别）：\n```cpp\nconst 类名 对象名[(实参列表)]；\n类名 const 对象名[(实参列表)]；\n```\n```cpp\nconst Point P1(1,1);\nPoint const P2(2,2);\n```\n以上定义了两个常对象P1、P2。在任何场合，对象P1、P2中的成员值不能进行修改。\n常对象不能调用非const成员函数：\n```cpp\nint Area() const{//常成员函数\n    return x*y;\n}\n``` \n如果一定要修改常对象中的数据成员，可将需要修改的数据成员声明为`mutable`，这样就可以用声明为`const`的成员函数来修改它的值了！\n\n## 友元类\n若我们想要一个不属于某个类的函数存取该类中的数据：\n1. 将类中的数据成员均设置为`public`\n2. **在类内部声明**这个函数为友元（friend），则这个函数可以访问该类的私有成员\n\n第一点有违OOP封装性的精神，显然第二种更好！\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person {\nprivate: \n    string name;  \n    int age;      \n    char gender;  \n    string idNumber; \n\npublic:\n    Person(string, int, char, string);\n    Person(Person&);\n    ~Person() {}\n    string getName();  // 函数声明\n    friend void showInfo(Person& p);  // 声明showInfo为类Person的友元函数\n};\n\nPerson::Person(string theName, int theAge, char theGender, string theIdNumber) {  \n    name = theName;\n    age = theAge;\n    gender = theGender;\n    idNumber = theIdNumber;  \n}\n\nPerson::Person(Person& theObject) {\n    name = theObject.name;\n    age = theObject.age;  \n    gender = theObject.gender;  \n    idNumber = theObject.idNumber;  \n}\n\nstring Person::getName() {\n    return name;\n}\n\nvoid showInfo(Person& p) {  // showInfo为普通函数，是类Person的友元函数\n    cout << \"name: \" << p.name << endl;  \n    cout << \"age: \" << p.age << endl;\n    cout << \"gender: \" << p.gender << endl;  \n    cout << \"id number: \" << p.idNumber << endl; \n}\n\nint main() {\n    Person p1(\"张三\", 12, 'm', \"12345200006061111\");  // 建立对象p1\n    showInfo(p1);\n    return 0;\n}\n```\n\n```cpp\nname: 张三\nage: 12\ngender: m\nid number: 12345200006061111\n```\n\n#### 注意：\n{% note warning %}\n- 友元函数是类外函数，友元函数不能直接访问类中的私有和保护成员，而**需要通过对象参数进行访问**{% endnote %}\n\n这个案例显然并没有那么好，我们可以将`showInfo`函数设计为类内一个普通的成员函数，这没有显示出友元函数的必要性，仅仅是对友元函数用法的一个初步介绍！\n\n### 友元函数是另一个类的成员函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle;  // 前向声明\n\nclass Cuboid {\nprivate:\n    int Height;\npublic:\n    Cuboid(int h) : Height(h) {}  // 使用初始化列表\n    int Volume(Rectangle& r);     // 只能声明，不能定义（因为Rectangle未完全定义）\n};\n\nclass Rectangle {\nprivate:\n    int Width, Length;\npublic:\n    Rectangle(int w, int len) : Width(w), Length(len) {}  // 初始化列表\n    friend int Cuboid::Volume(Rectangle& r);  // 声明友元函数\n};\n\n// 必须在 Rectangle 定义之后才能定义 Volume\nint Cuboid::Volume(Rectangle& r) {\n    return r.Length * r.Width * Height;  // 访问 Rectangle 的私有成员\n}\n\nint main() {\n    Rectangle R(6, 8);\n    Cuboid C(20);\n    cout << \"长方体的体积为：\" << C.Volume(R) << endl;\n    return 0;\n}\n```\n\n```\n长方体的体积为：960\n```\n\n这里将类`Cuboid`的成员函数`Volume()`声明为类`Rectangle`的友元函数，这样在`Volume()`中就可以使用Rectangle中的私有数据成员`Width`、`Length`。\n\n#### 注释：\n{% note warning %}\n程序第三行对`Rectangle`的**提前声明引用**，只包含类名，不包含类体。提前声明的原因是：在类`Cuboid`中调用`Volume()`函数时，需要使用类`Rectangle`中的数据成员`Length`和`Width`，但是类`Rectangle`还没有定义。那如果将`Rectangle`的定义提到前面呢？同样是不可以的，因为在类`Rectangle`中又包含了`Cuboid`的成员！但是不能因为提前声明，而去定义一个对象！{% endnote %}\n例如：\n\n```cpp\nclass Rectangle;//提前引用声明\nRectangle r1;//紧接着定义一个Rectangle对象，这是不允许的！\nclass Rectangle{...};\n```\n\n### 友元类\n将一个类声明为另一个类的友元：\n```cpp\nclass A{\n    ...\n    friend class B;//类B声明为当前类A的友元类\n    ...\n};\n```\n此时，类B中的所有成员函数都是当前类A的友元函数，因此类B中的**所有成员函数**都可以访问当前类A的`private`成员或`protected`成员\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle; // 前向声明\n\nclass Cuboid {\nprivate:\n    int Height;\npublic:\n    Cuboid(int h) {\n        Height = h;\n    }\n    int Volume(Rectangle& r);\n};\n\nclass Rectangle {\nprivate:\n    int Width, Length;\npublic:\n    Rectangle(int w, int len) {\n        Width = w;\n        Length = len;  // 添加了分号\n    }\n    friend class Cuboid; // 声明类Cuboid是类Rectangle的友元类\n};\n\nint Cuboid::Volume(Rectangle& r) {\n    return r.Length * r.Width * Height;  // 正确的体积计算公式\n}\n\nint main() {\n    Rectangle r(6, 8);\n    Cuboid C(20);\n    cout << \"长方体的体积为：\" << C.Volume(r) << endl;\n    return 0;\n}\n```\n\n```\n长方体的体积为：960\n```\n\n### 友元关系的限制：\n{% note warning %}\n1. 友元关系**不具有传递性**，“附庸的附庸不是我的附庸”，比如类A是类B的友元类，类B是类C的友元类，类C不是类A的友元类。\n2. 友元关系**不具有交换性**，比如类A是类B的友元类，类B不一定是类A的友元\n3. 友元关系是**不能继承的**，比如类A是类B的友元类，类C继承类B，类C不是类A的友元类{% endnote %}\n\n\n封面来源：[Fundamental Concepts of Object Oriented Programming](https://www.youtube.com/watch?v=m_MQYyJpIjg)\n\n## References\n以上大部分代码均取自《C++程序设计基础教程》","source":"_posts/CPP/Classes-and-Objects-in-C++.md","raw":"---\ntitle: Classes and Objects in C++\ndate: 2025-07-22 18:33:26\ntags: [C++,OOP]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Object-Oriented-Programming-OOP-in-CPP.png\ncategory: \n- CPP\n- OOP\ncategory_bar: true\ndescription: This post dives deep into object-oriented programming (OOP), the true essence of C++!\n---\n\n\n {% note primary%}\n 看到过一个很讽刺的笑话：大多数国内高校学生学到的CPP只是**C语言的cin/cout**。这当然只是一句玩笑话，但很深刻地反映出对于**CPP精髓面向对象编程**的忽视。这是有理可依的：编程语言的学习本身就和传统的课堂授课模式存在较大的出入，**编程重视实践**，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较**大规模的项目工程**，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态··· ”，很容易将CPP学成死记硬背的无聊学科。{% endnote %}\n\n因此，笔者希望通过博客的方式，记录自己**OOP in CPP**的学习笔记，并分享给各位小伙伴！\n\n\n# Why OOP?\n\n- 面向过程的局限性：将描述事物的数据与处理数据的函数分开。\n  - 若所描述事物的数据结构发生变化时，这些成员函数也必须重新设计！  \n  - 在主函数中对数据进行修改，仅仅需要执行一条赋值语句，数据安全性得不到保障！\n\n- 面向对象的优势：将描述事物的数据与处理函数**封装**成一个整体，称为类。  \n  - 封装在类中的函数和数据不受外界的影响，即类使数据具有良好的**独立性**和**可维护性**！\n  - 类中的数据在类的外部不能直接调用，外部只能通过**公共接口函数**来处理类中的数据，从而保障了**数据的安全性**！\n\n\n# 类和对象\n## 类：\n&emsp;&emsp;类描述了某一类事物应该具有哪些**特征**和**行为**。比如我们想描述一个“商品”类别，类就会告诉我们商品的名称、编号、进货价格、售出价格等特征，但是这个“商品”并不是一真正的商品，类只告诉了我们“商品”是什么样的、应该具有的特征。类是对象的抽象表示，它**本身不占用内存空间**。\n\n类```class```与结构体```struct```形式相似，关键字不同！\n\n- ```class```的成员默认是```private```的\n- ```struct```的成员默认是```public```的\n\n```cpp\n  class 类名 {\n     private:\n\t//私有数据成员和成员函数\n     protected:\n\t//保护数据成员和成员函数\n     public:\n\t//共有数据成员和成员函数\n};\n```\n\n- ```private```:只能被类本身的成员函数、友元函数、友元函数的成员函数访问，派生类也无法访问。\n- ```protected```:除派生类可以进行访问，其余与```private```相同。\n- ```public```:可以被程序中任意代码访问。\n\n\n```cpp\nclass cgoods{//商品类\n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     protected://无\n     public:\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        //函数体\n        }\n        ~cgoods(){//析构函数\n        } \n        void SetPurchasingprice(double purchasingprice){//设置进货价格\n        //函数体\n        }\n        void SetSellingprice(double sellingprice){//设置出货价格\n        //函数体\n        }\n        void setSellingcount(int sellcount){//设置出货商品价格\n        //函数体\n        }\n        void Sell(double sellingprice,int sellcount){\n        //函数体\n        }\n        static double getProfit(){//获取总利润，静态成员函数\n        //函数体\n        }\n        void display(){\n        //函数体\n        }\n}\n```\n\n## 对象：\n&emsp;&emsp;对象则是根据类创建出来的具体实例。比如我们创建一个叫“手机”的“商品”，他有自己的具体的编号、进货价格、售出价格等，所有的特征都是独一无二的，不会与其他商品相同。每一个对象都是根据类创建的具有其属性和方法的实例，并且具有唯一的身份标识（如内存地址）和自己独特的属性值。 **对象是占用内存空间的**，它的**属性值可以在运行时动态地改变**。\n\n定义对象的三种方法：\n- 先定义类的类型，再定义对象：\n ```cpp\n class 类名{\n     成员表;\n };\n [class]可选 类名 对象名列表;\n ```\n例如：\n ```cpp\n class cgoods goods1(\"1001001\",\"元气森林\");//创建对象goods1\n cgoods goods(\"1001001\",\"元气森林\");//两种方法等价\n ```\n- 在定义类类型时**同时创建对象**：\n```cpp\n class 类名{\n     成员表;\n }对象名表;\n ```\n例如：\n ```cpp\n class cgoods{\n     private:\n     public:\n }goods1(\"1001001\",\"元气森林\")；\n ```\n- 不出现类名**直接定义对象**：\n```cpp\nclass {\n     成员表;\n }对象名表;\n```\n例如：\n```cpp\n class {\n     private:\n     public:\n }goods1(\"1001001\",\"元气森林\")；\n ```\n此方法由于没有类名，所以只能**一次性声明多个对象**，此后再无法声明此类对象！\n\n## 类的成员访问\n\n- 对于数据成员的访问\n```cpp\n对象名.成员名//数据成员访问\n对象指针名->成员名\n(*对象指针名).成员名\n```\n- 对于成员函数的访问\n```cpp\n对象名.成员函数名(参数表)//成员函数访问\n对象指针名->成员函数名(参数表)\n(*对象指针名).成员函数名(参数表)\n```\n\n## 类的构造函数(Constructor)\n\n- 类的对象太过复杂，一个对象可能有许许多多的数据成员，这就意味着我们要对许许多多的数据成员进行初始化，实现这一过程并不容易。构造函数的作用就是在对象被创建时**利用特定的初始值**构造对象，把对象**置于某一个初始状态**。\n\n1. 有**与类完全相同的名字** \n2. **没有类型说明**，不允许有返回值\n3. **可以进行重载**，即一个类中允许定义多个参数不同的构造函数 \n4. 可以在声明时的**参数表里给予初始值**\n5. 每个类都必须至少有一个构造函数，如果没有显式的为类提供构造函数，则C++**提供一个默认的无参构造函数**，只负责对象的创建，而不做任何初始化的工作\n6.  一旦类定义了构造函数，C++不再提供默认的无参构造函数\n7.  程序中不能直接调用构造函数，他是在**创建类的对象时自动调用**的\n\n***\n\n### 1. 无参构造函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Time {\npublic:\n    Time() { // 定义构造成员函数，函数名与类名相同\n        hour = 22;\n        minute = 22;\n        sec = 22;\n    }\n    void set_time();  // 函数声明\n    void show_time(); // 函数声明\nprivate: // 私有数据成员\n    int hour;\n    int minute;\n    int sec;\n};\n\nvoid Time::set_time() { // 定义成员函数，向数据成员赋值\n    cin >> hour;\n    cin >> minute;\n    cin >> sec;\n}\n\nvoid Time::show_time() { // 定义成员函数，输出数据成员的值\n    cout << \"时间为: \" << hour << \":\" << minute << \":\" << sec << endl;\n}\n\nint main() {\n    Time t1;       // 建立对象t1，同时调用构造函数t1.Time()\n    t1.set_time(); // 对t1的数据成员赋值\n    t1.show_time(); // 显示t1的数据成员的值\n    Time t2;       // 建立对象 t2，同时调用构造函数 t2.Time()\n    t2.show_time(); // 显示t2的数据成员的值\n    return 0;\n}\n```\n```\n12 30 40\n时间为: 12:30:40\n时间为: 22:22:22\n```\n\n### 2. 含参构造函数\n\n```cpp\n构造函数名（类型1 形参1，类型2 形参2，...）\n类名 对象名（实参1，实参2，...）\n```\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\npublic:\n    Cuboid(int, int, int);  // 带有三个参数的构造函数\n    int volume();\nprivate:\n    int height;\n    int width;\n    int length;\n};\n\n// 构造函数的实现\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;\n    width = w;\n    length = len;\n}\n\n// volume成员函数的实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    Cuboid cuboid1(15, 45, 30);  // 定义对象时需要根据构造函数形参提供实参\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n\n    Cuboid cuboid2(10, 30, 22);\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n\n    return 0;\n}\n```\n\n```\ncuboid1的体积为: 20250\ncuboid2的体积为: 6600\n```\n\n### 3. 构造函数重载\n  定义多个构造函数以便给对象提供不同的初始化方法，这些构造函数具有相同的名字而**参数的个数或参数的类型不相同**。可以为一个类声明的构造函数的个数是**无限制的**，只要每个构造函数的**形参表是唯一的**，定义对象时会根据提供的实参决定调用哪一个构造函数。\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\npublic:\n    Cuboid();                  // 默认构造函数（无参数）\n    Cuboid(int h, int w, int len);  // 带参数的构造函数\n    int volume();              // 计算体积方法\n    \nprivate:\n    int height;   // 高度\n    int width;    // 宽度\n    int length;   // 长度\n};\n\n// 默认构造函数实现\nCuboid::Cuboid() {\n    height = 15;\n    width = 15;\n    length = 15;\n}\n\n// 带参数的构造函数实现\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;\n    width = w;\n    length = len;\n}\n\n// 体积计算方法实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    // 创建对象cuboid1，使用默认构造函数\n    Cuboid cuboid1;\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n    \n    // 创建对象cuboid2，使用带参数的构造函数\n    Cuboid cuboid2(20, 30, 45);\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n    \n    return 0;\n}\n```\n```\ncuboid1的体积为: 3375\ncuboid2的体积为: 27000\n```\n\n### 4. 使用默认值的构造函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Cuboid {\nprivate:\n    int height;   // 高度\n    int width;    // 宽度\n    int length;   // 长度\npublic:\n    Cuboid(int h = 15, int w = 15, int len = 15); // 构造函数，全部参数带默认值\n    int volume(); // 计算体积\n};\n\n// 构造函数实现（定义时可不再指定默认值）\nCuboid::Cuboid(int h, int w, int len) {\n    height = h;   \n    width = w;\n    length = len;\n}\n\n// 计算体积方法实现\nint Cuboid::volume() {\n    return (height * width * length);\n}\n\nint main() {\n    Cuboid cuboid1; // 没有给出实参，使用全部默认值 height=15,width=15,length=15\n    cout << \"cuboid1的体积为: \" << cuboid1.volume() << endl;\n\n    Cuboid cuboid2(25); // 只给定一个实参，height=25,width=15,length=15\n    cout << \"cuboid2的体积为: \" << cuboid2.volume() << endl;\n\n    Cuboid cuboid3(25, 40); // 只给定2个实参，height=25,width=40,length=15\n    cout << \"cuboid3的体积为: \" << cuboid3.volume() << endl;\n\n    Cuboid cuboid4(25, 30, 40); // 给定3个实参，height=25,width=30,length=40\n    cout << \"cuboid4的体积为: \" << cuboid4.volume() << endl;\n\n    return 0; \n}\n```\n\n```\ncuboid1的体积为: 3375\ncuboid2的体积为: 5625\ncuboid3的体积为: 15000\ncuboid4的体积为: 30000\n```\n\n### 5.子对象和构造函数\n在定义一个新的类时，**将一个已有类作为数据成员**，这个类对象叫做子对象。我们通过调用子对象成员的构造函数来完成对子对象的初始化。\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle {  // 定义矩形类\nprivate:\n    int Width, Length;  // 宽度、长度\npublic:\n    Rectangle(int w, int len) {  // 带参构造函数\n        Width = w;\n        Length = len;\n    }\n    int Area() {  // 计算面积\n        return (Width * Length);\n    }\n};\n\nclass Cuboid {  // 定义长方体类\nprivate:\n    int Height;  // 高度\n    Rectangle r;  // 使用Rectangle类对象作为成员\npublic:\n    Cuboid(int w, int len, int h) : r(w, len) {  // 初始化列表初始化r对象\n        Height = h;  // 原代码这里是Height-h，应该是赋值=\n    }\n    int Volume() {  // 计算体积\n        return (Height * r.Area());\n    }\n};\n\nint main() {\n    Cuboid c1(10, 20, 100);  // 创建长方体对象\n    cout << \"长方体 c1 的体积是: \" << c1.Volume() << endl;\n    return 0;\n}\n```\n\n```\n长方体 c1 的体积是: 20000\n```\n\n```cpp\n Cuboid(int w, int len, int h) : r(w, len) {  // 初始化列表初始化r对象\n        Height = h;  // 原代码这里是Height-h，应该是赋值=\n    }\n```\n实参10、20通过`w`和`len`赋值`r(w, len)`，调用类的成员`Rectangle(int w, int len)`构造函数完成初始化，实参100通过`Height = h`完成对`Cuboid`的初始化。\n\n### 6.拷贝构造函数\n\n设计拷贝构造函数**实现类中的一个对象给另一个对象的每个非静态数据成员赋值**。（**用已经初始化的对象去初始化一个新定义的对象**）\n\n\n1. 拷贝构造函数的函数名必须**与类名一致**，函数的形式参数是本类型的一个**引用变量**，必须为**引用**！\n2. **自定义拷贝构造函数**，能够实现**有选择**的复制原对象中的数据（实现对部分数据的修改）\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Sample {        // 定义Sample类\nprivate:\n    int nTest;        // 私有成员变量，用于存储测试值\npublic:\n    // 构造函数，初始化nTest\n    Sample(int ly) {  // 参数ly用于初始化nTest\n        nTest = ly;   // 将参数值赋给成员变量\n    }\n    \n    // 自定义的拷贝构造函数\n    Sample(Sample &tS) {  // 参数是对另一个Sample对象的引用\n        cout << \"拷贝构造函数被调用\" << endl;  // 输出提示信息\n        nTest = tS.nTest + 8;  // 新对象的nTest值 = 原对象值 + 8\n    }\n    \n    // 获取nTest值的成员函数\n    int readtest() {\n        return nTest;  // 返回当前对象的nTest值\n    }\n    \n    // 设置nTest值的成员函数\n    void settest(int ly) {\n        nTest = ly;    // 修改当前对象的nTest值\n    }\n};\n\nint main() {\n    Sample S1(100);    // 创建S1对象，nTest初始化为100\n    Sample S2(S1);     // 使用拷贝构造函数创建S2对象\n    cout << S2.readtest() << endl;  // 输出S2的nTest值\n    return 0;\n}\n```\n\n```\n拷贝构造函数被调用\n108\n```\n\n## 类的析构函数(Destructor)\n\n相当于创建对象时用new申请了一片内存空间，应在退出前**在析构函数中用delete释放**。析构函数是与构造函数作用相反的函数，当对象生命周期结束时，自动执行析构函数。\n\n1. 有与类完全相同的名字，只是在**函数名前面加一个位取反符“~”**，以区别于构造函数\n2. 不带任何参数，没有返回值\n3. 一个类最多只能有一个析构函数，**无法进行重载**\n4. 如果用户没有编写析构函数，编译系统会**自动的生成一个默认的析构函数**\n\n```cpp\nclass 类名{\n    public:\n    ~类名();{//析构函数\n    //函数体\n    }\n};\n```\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person {\nprivate:\n    //私有数据成员\n    string name;    //姓名\n    int age;        //年龄\n    char gender;    //性别，'f'女性，'m'男性\n    string idNumber; //身份证号码\n\npublic:\n    Person(string, int, char, string);\n    Person(Person&);\n    ~Person();\n    string getName();  // 函数声明\n    void showInfo();   // 函数声明\n};\n\n// 成员函数在类体外实现\nPerson::Person(string theName, int theAge, char theGender, string theIdNumber) {\n    name = theName;\n    age = theAge;\n    gender = theGender;\n    idNumber = theIdNumber;\n    cout << name << \" Constructor called.\" << endl;\n}\n\nPerson::Person(Person& theObject) {\n    name = theObject.name;\n    age = theObject.age;\n    gender = theObject.gender;\n    idNumber = theObject.idNumber;\n    cout << \"Copy Constructor called.\" << endl; //输出有关信息\n}\n\nPerson::~Person() { //析构函数\n    cout << name << \" Destructor called.\" << endl;\n}\n\nstring Person::getName() {\n    return name;\n}\n\nvoid Person::showInfo() {\n    cout << \"name: \" << name << endl;\n    cout << \"age: \" << age << endl;\n    cout << \"gender: \" << gender << endl;\n    cout << \"id number: \" << idNumber << endl;\n}\n\nint main() {\n    Person p1(\"张三\", 12, 'm', \"12345200006061111\"); //建立对象p1\n    Person p2(\"李四\", 31, 'f', \"12345198111091234\"); //建立对象p2\n\n    p1.showInfo();\n    p2.showInfo();\n\n    return 0;\n}\n```\n```\n张三 Constructor called.\n李四 Constructor called.\nname: 张三\nage: 12\ngender: m\nid number: 12345200006061111\nname: 李四\nage: 31\ngender: f\nid number: 12345198111091234\n李四 Destructor called.\n张三 Destructor called.\n```\n**注意观察输出：构造函数和析构函数调用的顺序！**\n{% note warning %}\n1. 析构函数在对象作为函数值返回之后被调用。{% endnote %}\n   \n## 构造函数和析构函数调用顺序\n一般而言，调用构造函数的次序与调用析构函数的**次序相反**，与栈类似：**先调用构造函数的对象，最后调用析构函数**。\n\n\n### 特殊情况：\n{% note warning %}\n1. **全局定义**对象（函数体外定义的对象）：程序开始之前调用构造函数，程序结束或调用exit()函数时调用析构函数。\n2. **局部定义**的对象（函数体内定义的对象）：程序执行到定义对象的地方时调用构造函数，函数结束时调用析构函数。\n3. **static定义**的对象：在首次到达对象定义位置时调用构造函数，程序结束时调用析构函数。\n4. **new动态生成**的对象：产生对象时调用构造函数，用delete释放对象时，才调用析构函数。若不使用delete运算符来撤销动态生成的对象，则析构函数不会被调用。{% endnote %}\n\n\n\n## 对象的动态建立和释放\n- new运算符建立对象：**先为类的对象分配内存空间**，然后**自动调用构造函数初始化**对象的数据成员，最后将变量的起始地址返还给指针变量。\n- delete运算符释放对象：**只有在delete运算符释放对象时，才会调用析构函数将对象销毁**。\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 定义一个复数类\nclass Complex {\npublic:\n    // 构造函数：初始化实部和虚部\n    Complex(double r, double i) {\n        real = r;    // 设置实部值\n        imag = i;    // 设置虚部值\n        cout << \"构造函数被调用\" << endl;\n    }\n\n    // 析构函数：对象销毁时自动调用\n    ~Complex() {\n        cout << \"析构函数被调用\" << endl;\n    }\n\n    // 显示复数的方法\n    void display() {\n        cout << \"(\" << real << \",\" << imag << \")\" << endl;\n    }\n\nprivate:\n    double real;  // 复数的实部\n    double imag;  // 复数的虚部\n};\n\nint main() {\n    // 动态创建一个Complex对象\n    Complex* pc1 = new Complex(3, 4);\n\n    // 调用display方法显示复数\n    pc1->display();  // 等价于 (*pc1).display();\n\n    // 释放对象内存\n    delete pc1;\n\n    cout << \"程序结束\" << endl;\n    return 0;\n}\n```\n```\n构造函数被调用\n(3,4)\n析构函数被调用\n程序结束\n```\n## 静态成员\n声明为static的类成员称为静态成员，可以**被类的所有对象共享**。\n- 静态数据成员：描述这一类对象所共有的数据，所有对象公用这一部分存储空间。\n- 静态数据函数\n\neg:Profit和 static double getProfit() ，总利润是出售所有商品获得的，并不隶属于哪一个商品对象。\n\n### 为什么不使用全局变量？\n{% note warning %} \n1. **违背了OOP封装性的精神**，任何地方都可以对全局变量进行访问，破坏了信息隐藏原则\n2. 过多使用全局变量会产生**重名冲突**\n3. 能够**明确归属**，直接表明它是类的一部分，便于进行初始化{% endnote %}\n\n### 静态数据成员\n\n在类的定义中的数据成员声明前加上关键字`static`，表示该成员是静态数据成员。由于静态数据成员**由类的所有对象共享**，所以静态成员的存储空间**不会随着对象的产生而分配**，也**不会随着对象的消失而释放**，因此静态数据成员不能在类体内进行初始化，而只能在**类体内进行声明**，在**类体外进行初始化**。\n\n```\n数据类型名类名::静态数据成员名=初值;\n```\n\n**注意**：\n- **不需要加`static`关键字**\n- **需要通过作用域运算符`::`限定修饰**\n\n```cpp\nclass cgoods{ \n    private:\n    ......\n    static double Profit;\n    public:\n    ......\n}\ndouble cgoods::Profit=0;\n```\n\n类外的定义是必要的，若没有明确赋初值，则编译系统会自动赋初值为0。\n\n### 静态成员函数\n与类的数据成员相同，在成员函数前加上`static`可以创建一个静态成员函数。静态函数没有`this`指针，通常他只访问属于全体对象的成员————即静态成员。\n```cpp\ndouble cgoods::getProfit(){\n    return Profit;//使用了静态成员变量\n}\n```\n{% note warning %}\n1. 非静态成员函数可以任意地访问静态成员函数和静态数据成员\n2. 静态成员函数不能直接访问非静态成员函数和非静态数据成员{% endnote %}\n\n### 静态成员的访问\n\n用类的对象访问 || 直接用作用域运算符“::”通过类名访问\n\n```cpp\n类名::静态数据成员名\n```\n\n```cpp\n对象名.静态数据成员名\n//容易让人误认为静态数据成员是属于某个对象的\n```\n静态成员函数的访问与静态成员数据的访问的形式相同，不做过多阐释。\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass CStudent {\nprivate:\n    string SName;       // 保存学生姓名\n    float Score;        // 保存学生的成绩\n    static int studentTotal;    // 静态数据成员，保存学生的总人数\n    static float SumScore;      // 静态数据成员，保存所有学生的成绩和\n\npublic:\n    // 构造函数，当新建一个对象时，人数studentTotal加1\n    CStudent(string name, float sc);\n    static float average();     // 计算学生的平均分\n    void Print();               // 打印输出学生的姓名和分数\n    ~CStudent();                // 析构函数，当减少一个对象时，studentTotal减1\n};\n\n// 静态数据成员的初始化必须在类外进行\nint CStudent::studentTotal = 0;\nfloat CStudent::SumScore = 0;\n\nCStudent::CStudent(string name, float sc) {\n    SName = name;\n    Score = sc;\n    studentTotal++;     // 学生人数加1\n    SumScore += sc;     // 总分数增加\n    cout << SName << \" Constructor called.\" << endl;\n}\n\nvoid CStudent::Print() {\n    cout << SName << \": \" << Score << endl;\n}\n\nfloat CStudent::average() {     // 静态成员函数访问静态数据成员\n    if (studentTotal == 0) return 0;  // 防止除以0\n    return (SumScore / studentTotal);\n}\n\nCStudent::~CStudent() {\n    studentTotal--;     // 学生人数减1\n    SumScore -= Score;  // 总分数减少\n    cout << SName << \" Destructor called.\" << endl;\n}\n\nint main() {\n    // 简单测试\n    CStudent stud1(\"Zhang San\", 90);\n    CStudent stud2(\"Li Si\", 80);\n    stud1.Print();\n    stud2.Print();\n    cout << \"平均分为: \" << CStudent::average() << endl;  // 调用静态成员函数\n    return 0;\n}\n```\n\n```\nZhang San Constructor called.\nLi Si Constructor called.\nZhang San: 90\nLi Si: 80\n平均分为: 85\nLi Si Destructor called.\nZhang San Destructor called.\n```\n\n## this指针\n- 用途：当成员函数的**参数名与成员变量名相同**的时候，可以使用`this`来**明确地引用成员变量**\n```cpp\nPonit& setPoint(int x,int y){\n    this->x=x;\n    (*this).y=y+8;\n    return *this;\n}\n```\n{% note warning %}\n1. this指针是一个**指向对象的指针**\n2. this指针是一个隐含于成员函数中的对象指针\n3. this指针是一个指向正在调用成员函数的对象的指针\n4. **类的静态成员函数没有this指针**{% endnote %}\n\n## 常对象\n常对象用`const`进行修饰，常对象必须进行初始化，且不能被更新，常对象的声明如下（两种声明完全相同，没有任何区别）：\n```cpp\nconst 类名 对象名[(实参列表)]；\n类名 const 对象名[(实参列表)]；\n```\n```cpp\nconst Point P1(1,1);\nPoint const P2(2,2);\n```\n以上定义了两个常对象P1、P2。在任何场合，对象P1、P2中的成员值不能进行修改。\n常对象不能调用非const成员函数：\n```cpp\nint Area() const{//常成员函数\n    return x*y;\n}\n``` \n如果一定要修改常对象中的数据成员，可将需要修改的数据成员声明为`mutable`，这样就可以用声明为`const`的成员函数来修改它的值了！\n\n## 友元类\n若我们想要一个不属于某个类的函数存取该类中的数据：\n1. 将类中的数据成员均设置为`public`\n2. **在类内部声明**这个函数为友元（friend），则这个函数可以访问该类的私有成员\n\n第一点有违OOP封装性的精神，显然第二种更好！\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Person {\nprivate: \n    string name;  \n    int age;      \n    char gender;  \n    string idNumber; \n\npublic:\n    Person(string, int, char, string);\n    Person(Person&);\n    ~Person() {}\n    string getName();  // 函数声明\n    friend void showInfo(Person& p);  // 声明showInfo为类Person的友元函数\n};\n\nPerson::Person(string theName, int theAge, char theGender, string theIdNumber) {  \n    name = theName;\n    age = theAge;\n    gender = theGender;\n    idNumber = theIdNumber;  \n}\n\nPerson::Person(Person& theObject) {\n    name = theObject.name;\n    age = theObject.age;  \n    gender = theObject.gender;  \n    idNumber = theObject.idNumber;  \n}\n\nstring Person::getName() {\n    return name;\n}\n\nvoid showInfo(Person& p) {  // showInfo为普通函数，是类Person的友元函数\n    cout << \"name: \" << p.name << endl;  \n    cout << \"age: \" << p.age << endl;\n    cout << \"gender: \" << p.gender << endl;  \n    cout << \"id number: \" << p.idNumber << endl; \n}\n\nint main() {\n    Person p1(\"张三\", 12, 'm', \"12345200006061111\");  // 建立对象p1\n    showInfo(p1);\n    return 0;\n}\n```\n\n```cpp\nname: 张三\nage: 12\ngender: m\nid number: 12345200006061111\n```\n\n#### 注意：\n{% note warning %}\n- 友元函数是类外函数，友元函数不能直接访问类中的私有和保护成员，而**需要通过对象参数进行访问**{% endnote %}\n\n这个案例显然并没有那么好，我们可以将`showInfo`函数设计为类内一个普通的成员函数，这没有显示出友元函数的必要性，仅仅是对友元函数用法的一个初步介绍！\n\n### 友元函数是另一个类的成员函数\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle;  // 前向声明\n\nclass Cuboid {\nprivate:\n    int Height;\npublic:\n    Cuboid(int h) : Height(h) {}  // 使用初始化列表\n    int Volume(Rectangle& r);     // 只能声明，不能定义（因为Rectangle未完全定义）\n};\n\nclass Rectangle {\nprivate:\n    int Width, Length;\npublic:\n    Rectangle(int w, int len) : Width(w), Length(len) {}  // 初始化列表\n    friend int Cuboid::Volume(Rectangle& r);  // 声明友元函数\n};\n\n// 必须在 Rectangle 定义之后才能定义 Volume\nint Cuboid::Volume(Rectangle& r) {\n    return r.Length * r.Width * Height;  // 访问 Rectangle 的私有成员\n}\n\nint main() {\n    Rectangle R(6, 8);\n    Cuboid C(20);\n    cout << \"长方体的体积为：\" << C.Volume(R) << endl;\n    return 0;\n}\n```\n\n```\n长方体的体积为：960\n```\n\n这里将类`Cuboid`的成员函数`Volume()`声明为类`Rectangle`的友元函数，这样在`Volume()`中就可以使用Rectangle中的私有数据成员`Width`、`Length`。\n\n#### 注释：\n{% note warning %}\n程序第三行对`Rectangle`的**提前声明引用**，只包含类名，不包含类体。提前声明的原因是：在类`Cuboid`中调用`Volume()`函数时，需要使用类`Rectangle`中的数据成员`Length`和`Width`，但是类`Rectangle`还没有定义。那如果将`Rectangle`的定义提到前面呢？同样是不可以的，因为在类`Rectangle`中又包含了`Cuboid`的成员！但是不能因为提前声明，而去定义一个对象！{% endnote %}\n例如：\n\n```cpp\nclass Rectangle;//提前引用声明\nRectangle r1;//紧接着定义一个Rectangle对象，这是不允许的！\nclass Rectangle{...};\n```\n\n### 友元类\n将一个类声明为另一个类的友元：\n```cpp\nclass A{\n    ...\n    friend class B;//类B声明为当前类A的友元类\n    ...\n};\n```\n此时，类B中的所有成员函数都是当前类A的友元函数，因此类B中的**所有成员函数**都可以访问当前类A的`private`成员或`protected`成员\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle; // 前向声明\n\nclass Cuboid {\nprivate:\n    int Height;\npublic:\n    Cuboid(int h) {\n        Height = h;\n    }\n    int Volume(Rectangle& r);\n};\n\nclass Rectangle {\nprivate:\n    int Width, Length;\npublic:\n    Rectangle(int w, int len) {\n        Width = w;\n        Length = len;  // 添加了分号\n    }\n    friend class Cuboid; // 声明类Cuboid是类Rectangle的友元类\n};\n\nint Cuboid::Volume(Rectangle& r) {\n    return r.Length * r.Width * Height;  // 正确的体积计算公式\n}\n\nint main() {\n    Rectangle r(6, 8);\n    Cuboid C(20);\n    cout << \"长方体的体积为：\" << C.Volume(r) << endl;\n    return 0;\n}\n```\n\n```\n长方体的体积为：960\n```\n\n### 友元关系的限制：\n{% note warning %}\n1. 友元关系**不具有传递性**，“附庸的附庸不是我的附庸”，比如类A是类B的友元类，类B是类C的友元类，类C不是类A的友元类。\n2. 友元关系**不具有交换性**，比如类A是类B的友元类，类B不一定是类A的友元\n3. 友元关系是**不能继承的**，比如类A是类B的友元类，类C继承类B，类C不是类A的友元类{% endnote %}\n\n\n封面来源：[Fundamental Concepts of Object Oriented Programming](https://www.youtube.com/watch?v=m_MQYyJpIjg)\n\n## References\n以上大部分代码均取自《C++程序设计基础教程》","slug":"CPP/Classes-and-Objects-in-C++","published":1,"updated":"2025-09-12T06:20:41.061Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hch000340w36nhhg0aa","content":"<div class=\"note note-primary\">\n            <p>看到过一个很讽刺的笑话：大多数国内高校学生学到的CPP只是<strong>C语言的cin/cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于<strong>CPP精髓面向对象编程</strong>的忽视。这是有理可依的：编程语言的学习本身就和传统的课堂授课模式存在较大的出入，<strong>编程重视实践</strong>，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较<strong>大规模的项目工程</strong>，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态··· ”，很容易将CPP学成死记硬背的无聊学科。</p>\n          </div>\n<p>因此，笔者希望通过博客的方式，记录自己<strong>OOP in CPP</strong>的学习笔记，并分享给各位小伙伴！</p>\n<h1>Why OOP?</h1>\n<ul>\n<li>\n<p>面向过程的局限性：将描述事物的数据与处理数据的函数分开。</p>\n<ul>\n<li>若所描述事物的数据结构发生变化时，这些成员函数也必须重新设计！</li>\n<li>在主函数中对数据进行修改，仅仅需要执行一条赋值语句，数据安全性得不到保障！</li>\n</ul>\n</li>\n<li>\n<p>面向对象的优势：将描述事物的数据与处理函数<strong>封装</strong>成一个整体，称为类。</p>\n<ul>\n<li>封装在类中的函数和数据不受外界的影响，即类使数据具有良好的<strong>独立性</strong>和<strong>可维护性</strong>！</li>\n<li>类中的数据在类的外部不能直接调用，外部只能通过<strong>公共接口函数</strong>来处理类中的数据，从而保障了<strong>数据的安全性</strong>！</li>\n</ul>\n</li>\n</ul>\n<h1>类和对象</h1>\n<h2 id=\"类：\">类：</h2>\n<p>  类描述了某一类事物应该具有哪些<strong>特征</strong>和<strong>行为</strong>。比如我们想描述一个“商品”类别，类就会告诉我们商品的名称、编号、进货价格、售出价格等特征，但是这个“商品”并不是一真正的商品，类只告诉了我们“商品”是什么样的、应该具有的特征。类是对象的抽象表示，它<strong>本身不占用内存空间</strong>。</p>\n<p>类<code>class</code>与结构体<code>struct</code>形式相似，关键字不同！</p>\n<ul>\n<li><code>class</code>的成员默认是<code>private</code>的</li>\n<li><code>struct</code>的成员默认是<code>public</code>的</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">  <span class=\"hljs-keyword\">class</span> 类名 {<br>     <span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">//私有数据成员和成员函数</span><br>     <span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">//保护数据成员和成员函数</span><br>     <span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">//共有数据成员和成员函数</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>private</code>:只能被类本身的成员函数、友元函数、友元函数的成员函数访问，派生类也无法访问。</li>\n<li><code>protected</code>:除派生类可以进行访问，其余与<code>private</code>相同。</li>\n<li><code>public</code>:可以被程序中任意代码访问。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>{<span class=\"hljs-comment\">//商品类</span><br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice){<span class=\"hljs-comment\">//构造函数</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        ~<span class=\"hljs-built_in\">cgoods</span>(){<span class=\"hljs-comment\">//析构函数</span><br>        } <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>{<span class=\"hljs-comment\">//设置进货价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>{<span class=\"hljs-comment\">//设置出货价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setSellingcount</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sellcount)</span></span>{<span class=\"hljs-comment\">//设置出货商品价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Sell</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice,<span class=\"hljs-type\">int</span> sellcount)</span></span>{<br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getProfit</span><span class=\"hljs-params\">()</span></span>{<span class=\"hljs-comment\">//获取总利润，静态成员函数</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>{<br>        <span class=\"hljs-comment\">//函数体</span><br>        }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"对象：\">对象：</h2>\n<p>  对象则是根据类创建出来的具体实例。比如我们创建一个叫“手机”的“商品”，他有自己的具体的编号、进货价格、售出价格等，所有的特征都是独一无二的，不会与其他商品相同。每一个对象都是根据类创建的具有其属性和方法的实例，并且具有唯一的身份标识（如内存地址）和自己独特的属性值。 <strong>对象是占用内存空间的</strong>，它的<strong>属性值可以在运行时动态地改变</strong>。</p>\n<p>定义对象的三种方法：</p>\n<ul>\n<li>先定义类的类型，再定义对象：</li>\n</ul>\n <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名{<br>    成员表;<br>};<br>[<span class=\"hljs-keyword\">class</span>]可选 类名 对象名列表;<br></code></pre></td></tr></tbody></table></figure>\n<p>例如：</p>\n <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">class</span> cgoods <span class=\"hljs-title\">goods1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"1001001\"</span>,<span class=\"hljs-string\">\"元气森林\"</span>)</span></span>;<span class=\"hljs-comment\">//创建对象goods1</span><br><span class=\"hljs-function\">cgoods <span class=\"hljs-title\">goods</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"1001001\"</span>,<span class=\"hljs-string\">\"元气森林\"</span>)</span></span>;<span class=\"hljs-comment\">//两种方法等价</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>在定义类类型时<strong>同时创建对象</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名{<br>    成员表;<br>}对象名表;<br></code></pre></td></tr></tbody></table></figure>\n<p>例如：</p>\n <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>{<br>    <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">public</span>:<br>}<span class=\"hljs-built_in\">goods1</span>(<span class=\"hljs-string\">\"1001001\"</span>,<span class=\"hljs-string\">\"元气森林\"</span>)；<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>不出现类名<strong>直接定义对象</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> {<br>     成员表;<br> }对象名表;<br></code></pre></td></tr></tbody></table></figure>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> {<br>    <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">public</span>:<br>}<span class=\"hljs-built_in\">goods1</span>(<span class=\"hljs-string\">\"1001001\"</span>,<span class=\"hljs-string\">\"元气森林\"</span>)；<br></code></pre></td></tr></tbody></table></figure>\n<p>此方法由于没有类名，所以只能<strong>一次性声明多个对象</strong>，此后再无法声明此类对象！</p>\n<h2 id=\"类的成员访问\">类的成员访问</h2>\n<ul>\n<li>对于数据成员的访问</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.成员名<span class=\"hljs-comment\">//数据成员访问</span><br>对象指针名-&gt;成员名<br>(*对象指针名).成员名<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>对于成员函数的访问</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.成员函数名(参数表)<span class=\"hljs-comment\">//成员函数访问</span><br>对象指针名-&gt;成员函数名(参数表)<br>(*对象指针名).成员函数名(参数表)<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"类的构造函数-Constructor\">类的构造函数(Constructor)</h2>\n<ul>\n<li>类的对象太过复杂，一个对象可能有许许多多的数据成员，这就意味着我们要对许许多多的数据成员进行初始化，实现这一过程并不容易。构造函数的作用就是在对象被创建时<strong>利用特定的初始值</strong>构造对象，把对象<strong>置于某一个初始状态</strong>。</li>\n</ul>\n<ol>\n<li>有<strong>与类完全相同的名字</strong></li>\n<li><strong>没有类型说明</strong>，不允许有返回值</li>\n<li><strong>可以进行重载</strong>，即一个类中允许定义多个参数不同的构造函数</li>\n<li>可以在声明时的<strong>参数表里给予初始值</strong></li>\n<li>每个类都必须至少有一个构造函数，如果没有显式的为类提供构造函数，则C++<strong>提供一个默认的无参构造函数</strong>，只负责对象的创建，而不做任何初始化的工作</li>\n<li>一旦类定义了构造函数，C++不再提供默认的无参构造函数</li>\n<li>程序中不能直接调用构造函数，他是在<strong>创建类的对象时自动调用</strong>的</li>\n</ol>\n<hr>\n<h3 id=\"1-无参构造函数\">1. 无参构造函数</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Time</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Time</span>() { <span class=\"hljs-comment\">// 定义构造成员函数，函数名与类名相同</span><br>        hour = <span class=\"hljs-number\">22</span>;<br>        minute = <span class=\"hljs-number\">22</span>;<br>        sec = <span class=\"hljs-number\">22</span>;<br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_time</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show_time</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 函数声明</span><br><span class=\"hljs-keyword\">private</span>: <span class=\"hljs-comment\">// 私有数据成员</span><br>    <span class=\"hljs-type\">int</span> hour;<br>    <span class=\"hljs-type\">int</span> minute;<br>    <span class=\"hljs-type\">int</span> sec;<br>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Time::set_time</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-comment\">// 定义成员函数，向数据成员赋值</span><br>    cin &gt;&gt; hour;<br>    cin &gt;&gt; minute;<br>    cin &gt;&gt; sec;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Time::show_time</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-comment\">// 定义成员函数，输出数据成员的值</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"时间为: \"</span> &lt;&lt; hour &lt;&lt; <span class=\"hljs-string\">\":\"</span> &lt;&lt; minute &lt;&lt; <span class=\"hljs-string\">\":\"</span> &lt;&lt; sec &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    Time t1;       <span class=\"hljs-comment\">// 建立对象t1，同时调用构造函数t1.Time()</span><br>    t<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">set_time</span>(); <span class=\"hljs-comment\">// 对t1的数据成员赋值</span><br>    t<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">show_time</span>(); <span class=\"hljs-comment\">// 显示t1的数据成员的值</span><br>    Time t2;       <span class=\"hljs-comment\">// 建立对象 t2，同时调用构造函数 t2.Time()</span><br>    t<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">show_time</span>(); <span class=\"hljs-comment\">// 显示t2的数据成员的值</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight makefile\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">12 30 40<br><span class=\"hljs-section\">时间为: 12:30:40</span><br><span class=\"hljs-section\">时间为: 22:22:22</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"2-含参构造函数\">2. 含参构造函数</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">构造函数名（类型<span class=\"hljs-number\">1</span> 形参<span class=\"hljs-number\">1</span>，类型<span class=\"hljs-number\">2</span> 形参<span class=\"hljs-number\">2</span>，...）<br>类名 对象名（实参<span class=\"hljs-number\">1</span>，实参<span class=\"hljs-number\">2</span>，...）<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>);  <span class=\"hljs-comment\">// 带有三个参数的构造函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;<br>    <span class=\"hljs-type\">int</span> width;<br>    <span class=\"hljs-type\">int</span> length;<br>};<br><br><span class=\"hljs-comment\">// 构造函数的实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) {<br>    height = h;<br>    width = w;<br>    length = len;<br>}<br><br><span class=\"hljs-comment\">// volume成员函数的实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">30</span>)</span></span>;  <span class=\"hljs-comment\">// 定义对象时需要根据构造函数形参提供实参</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid1的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">22</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid2的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">20250</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">6600</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"3-构造函数重载\">3. 构造函数重载</h3>\n<p>定义多个构造函数以便给对象提供不同的初始化方法，这些构造函数具有相同的名字而<strong>参数的个数或参数的类型不相同</strong>。可以为一个类声明的构造函数的个数是<strong>无限制的</strong>，只要每个构造函数的<strong>形参表是唯一的</strong>，定义对象时会根据提供的实参决定调用哪一个构造函数。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>();                  <span class=\"hljs-comment\">// 默认构造函数（无参数）</span><br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len);  <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>;              <span class=\"hljs-comment\">// 计算体积方法</span><br>    <br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;   <span class=\"hljs-comment\">// 高度</span><br>    <span class=\"hljs-type\">int</span> width;    <span class=\"hljs-comment\">// 宽度</span><br>    <span class=\"hljs-type\">int</span> length;   <span class=\"hljs-comment\">// 长度</span><br>};<br><br><span class=\"hljs-comment\">// 默认构造函数实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>() {<br>    height = <span class=\"hljs-number\">15</span>;<br>    width = <span class=\"hljs-number\">15</span>;<br>    length = <span class=\"hljs-number\">15</span>;<br>}<br><br><span class=\"hljs-comment\">// 带参数的构造函数实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) {<br>    height = h;<br>    width = w;<br>    length = len;<br>}<br><br><span class=\"hljs-comment\">// 体积计算方法实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-comment\">// 创建对象cuboid1，使用默认构造函数</span><br>    Cuboid cuboid1;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid1的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br>    <br>    <span class=\"hljs-comment\">// 创建对象cuboid2，使用带参数的构造函数</span><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">45</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid2的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">3375</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">27000</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"4-使用默认值的构造函数\">4. 使用默认值的构造函数</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;   <span class=\"hljs-comment\">// 高度</span><br>    <span class=\"hljs-type\">int</span> width;    <span class=\"hljs-comment\">// 宽度</span><br>    <span class=\"hljs-type\">int</span> length;   <span class=\"hljs-comment\">// 长度</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h = <span class=\"hljs-number\">15</span>, <span class=\"hljs-type\">int</span> w = <span class=\"hljs-number\">15</span>, <span class=\"hljs-type\">int</span> len = <span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// 构造函数，全部参数带默认值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 计算体积</span><br>};<br><br><span class=\"hljs-comment\">// 构造函数实现（定义时可不再指定默认值）</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) {<br>    height = h;   <br>    width = w;<br>    length = len;<br>}<br><br><span class=\"hljs-comment\">// 计算体积方法实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    Cuboid cuboid1; <span class=\"hljs-comment\">// 没有给出实参，使用全部默认值 height=15,width=15,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid1的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>)</span></span>; <span class=\"hljs-comment\">// 只给定一个实参，height=25,width=15,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid2的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid3</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">40</span>)</span></span>; <span class=\"hljs-comment\">// 只给定2个实参，height=25,width=40,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid3的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid4</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>)</span></span>; <span class=\"hljs-comment\">// 给定3个实参，height=25,width=30,length=40</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"cuboid4的体积为: \"</span> &lt;&lt; cuboid<span class=\"hljs-number\">4.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">3375</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">5625</span><br><span class=\"hljs-attribute\">cuboid3</span>的体积为: <span class=\"hljs-number\">15000</span><br><span class=\"hljs-attribute\">cuboid4</span>的体积为: <span class=\"hljs-number\">30000</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"5-子对象和构造函数\">5.子对象和构造函数</h3>\n<p>在定义一个新的类时，<strong>将一个已有类作为数据成员</strong>，这个类对象叫做子对象。我们通过调用子对象成员的构造函数来完成对子对象的初始化。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> {  <span class=\"hljs-comment\">// 定义矩形类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;  <span class=\"hljs-comment\">// 宽度、长度</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) {  <span class=\"hljs-comment\">// 带参构造函数</span><br>        Width = w;<br>        Length = len;<br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Area</span><span class=\"hljs-params\">()</span> </span>{  <span class=\"hljs-comment\">// 计算面积</span><br>        <span class=\"hljs-keyword\">return</span> (Width * Length);<br>    }<br>};<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {  <span class=\"hljs-comment\">// 定义长方体类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;  <span class=\"hljs-comment\">// 高度</span><br>    Rectangle r;  <span class=\"hljs-comment\">// 使用Rectangle类对象作为成员</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len, <span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">r</span>(w, len) {  <span class=\"hljs-comment\">// 初始化列表初始化r对象</span><br>        Height = h;  <span class=\"hljs-comment\">// 原代码这里是Height-h，应该是赋值=</span><br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">()</span> </span>{  <span class=\"hljs-comment\">// 计算体积</span><br>        <span class=\"hljs-keyword\">return</span> (Height * r.<span class=\"hljs-built_in\">Area</span>());<br>    }<br>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">100</span>)</span></span>;  <span class=\"hljs-comment\">// 创建长方体对象</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"长方体 c1 的体积是: \"</span> &lt;&lt; c<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">Volume</span>() &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight armasm\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\">长方体 <span class=\"hljs-built_in\">c1</span> 的体积是: <span class=\"hljs-number\">20000</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len, <span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">r</span>(w, len) {  <span class=\"hljs-comment\">// 初始化列表初始化r对象</span><br>       Height = h;  <span class=\"hljs-comment\">// 原代码这里是Height-h，应该是赋值=</span><br>   }<br></code></pre></td></tr></tbody></table></figure>\n<p>实参10、20通过<code>w</code>和<code>len</code>赋值<code>r(w, len)</code>，调用类的成员<code>Rectangle(int w, int len)</code>构造函数完成初始化，实参100通过<code>Height = h</code>完成对<code>Cuboid</code>的初始化。</p>\n<h3 id=\"6-拷贝构造函数\">6.拷贝构造函数</h3>\n<p>设计拷贝构造函数<strong>实现类中的一个对象给另一个对象的每个非静态数据成员赋值</strong>。（<strong>用已经初始化的对象去初始化一个新定义的对象</strong>）</p>\n<ol>\n<li>拷贝构造函数的函数名必须<strong>与类名一致</strong>，函数的形式参数是本类型的一个<strong>引用变量</strong>，必须为<strong>引用</strong>！</li>\n<li><strong>自定义拷贝构造函数</strong>，能够实现<strong>有选择</strong>的复制原对象中的数据（实现对部分数据的修改）</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Sample</span> {        <span class=\"hljs-comment\">// 定义Sample类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> nTest;        <span class=\"hljs-comment\">// 私有成员变量，用于存储测试值</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数，初始化nTest</span><br>    <span class=\"hljs-built_in\">Sample</span>(<span class=\"hljs-type\">int</span> ly) {  <span class=\"hljs-comment\">// 参数ly用于初始化nTest</span><br>        nTest = ly;   <span class=\"hljs-comment\">// 将参数值赋给成员变量</span><br>    }<br>    <br>    <span class=\"hljs-comment\">// 自定义的拷贝构造函数</span><br>    <span class=\"hljs-built_in\">Sample</span>(Sample &amp;tS) {  <span class=\"hljs-comment\">// 参数是对另一个Sample对象的引用</span><br>        cout &lt;&lt; <span class=\"hljs-string\">\"拷贝构造函数被调用\"</span> &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出提示信息</span><br>        nTest = tS.nTest + <span class=\"hljs-number\">8</span>;  <span class=\"hljs-comment\">// 新对象的nTest值 = 原对象值 + 8</span><br>    }<br>    <br>    <span class=\"hljs-comment\">// 获取nTest值的成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">readtest</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> nTest;  <span class=\"hljs-comment\">// 返回当前对象的nTest值</span><br>    }<br>    <br>    <span class=\"hljs-comment\">// 设置nTest值的成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">settest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ly)</span> </span>{<br>        nTest = ly;    <span class=\"hljs-comment\">// 修改当前对象的nTest值</span><br>    }<br>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Sample <span class=\"hljs-title\">S1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">100</span>)</span></span>;    <span class=\"hljs-comment\">// 创建S1对象，nTest初始化为100</span><br>    <span class=\"hljs-function\">Sample <span class=\"hljs-title\">S2</span><span class=\"hljs-params\">(S1)</span></span>;     <span class=\"hljs-comment\">// 使用拷贝构造函数创建S2对象</span><br>    cout &lt;&lt; S<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">readtest</span>() &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出S2的nTest值</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">拷贝构造函数被调用<br>108<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"类的析构函数-Destructor\">类的析构函数(Destructor)</h2>\n<p>相当于创建对象时用new申请了一片内存空间，应在退出前<strong>在析构函数中用delete释放</strong>。析构函数是与构造函数作用相反的函数，当对象生命周期结束时，自动执行析构函数。</p>\n<ol>\n<li>有与类完全相同的名字，只是在<strong>函数名前面加一个位取反符“~”</strong>，以区别于构造函数</li>\n<li>不带任何参数，没有返回值</li>\n<li>一个类最多只能有一个析构函数，<strong>无法进行重载</strong></li>\n<li>如果用户没有编写析构函数，编译系统会<strong>自动的生成一个默认的析构函数</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名{<br>    <span class=\"hljs-keyword\">public</span>:<br>    ~类名();{<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-comment\">//函数体</span><br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">//私有数据成员</span><br>    string name;    <span class=\"hljs-comment\">//姓名</span><br>    <span class=\"hljs-type\">int</span> age;        <span class=\"hljs-comment\">//年龄</span><br>    <span class=\"hljs-type\">char</span> gender;    <span class=\"hljs-comment\">//性别，'f'女性，'m'男性</span><br>    string idNumber; <span class=\"hljs-comment\">//身份证号码</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Person</span>(string, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, string);<br>    <span class=\"hljs-built_in\">Person</span>(Person&amp;);<br>    ~<span class=\"hljs-built_in\">Person</span>();<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">()</span></span>;   <span class=\"hljs-comment\">// 函数声明</span><br>};<br><br><span class=\"hljs-comment\">// 成员函数在类体外实现</span><br>Person::<span class=\"hljs-built_in\">Person</span>(string theName, <span class=\"hljs-type\">int</span> theAge, <span class=\"hljs-type\">char</span> theGender, string theIdNumber) {<br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">\" Constructor called.\"</span> &lt;&lt; endl;<br>}<br><br>Person::<span class=\"hljs-built_in\">Person</span>(Person&amp; theObject) {<br>    name = theObject.name;<br>    age = theObject.age;<br>    gender = theObject.gender;<br>    idNumber = theObject.idNumber;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"Copy Constructor called.\"</span> &lt;&lt; endl; <span class=\"hljs-comment\">//输出有关信息</span><br>}<br><br>Person::~<span class=\"hljs-built_in\">Person</span>() { <span class=\"hljs-comment\">//析构函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">\" Destructor called.\"</span> &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Person::getName</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> name;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Person::showInfo</span><span class=\"hljs-params\">()</span> </span>{<br>    cout &lt;&lt; <span class=\"hljs-string\">\"name: \"</span> &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"age: \"</span> &lt;&lt; age &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"gender: \"</span> &lt;&lt; gender &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"id number: \"</span> &lt;&lt; idNumber &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">'m'</span>, <span class=\"hljs-string\">\"12345200006061111\"</span>)</span></span>; <span class=\"hljs-comment\">//建立对象p1</span><br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"李四\"</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-string\">'f'</span>, <span class=\"hljs-string\">\"12345198111091234\"</span>)</span></span>; <span class=\"hljs-comment\">//建立对象p2</span><br><br>    p<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">showInfo</span>();<br>    p<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">showInfo</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight delphi\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">张三 <span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\">李四 <span class=\"hljs-title\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">name</span>:</span> 张三<br>age: <span class=\"hljs-number\">12</span><br>gender: m<br>id number: <span class=\"hljs-number\">12345200006061111</span><br><span class=\"hljs-keyword\">name</span>: 李四<br>age: <span class=\"hljs-number\">31</span><br>gender: f<br>id number: <span class=\"hljs-number\">12345198111091234</span><br>李四 <span class=\"hljs-function\"><span class=\"hljs-keyword\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\">张三 <span class=\"hljs-title\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>注意观察输出：构造函数和析构函数调用的顺序！</strong></p>\n<div class=\"note note-warning\">\n            <ol><li>析构函数在对象作为函数值返回之后被调用。</li></ol>\n          </div>\n<h2 id=\"构造函数和析构函数调用顺序\">构造函数和析构函数调用顺序</h2>\n<p>一般而言，调用构造函数的次序与调用析构函数的<strong>次序相反</strong>，与栈类似：<strong>先调用构造函数的对象，最后调用析构函数</strong>。</p>\n<h3 id=\"特殊情况：\">特殊情况：</h3>\n<div class=\"note note-warning\">\n            <ol><li><strong>全局定义</strong>对象（函数体外定义的对象）：程序开始之前调用构造函数，程序结束或调用exit()函数时调用析构函数。</li><li><strong>局部定义</strong>的对象（函数体内定义的对象）：程序执行到定义对象的地方时调用构造函数，函数结束时调用析构函数。</li><li><strong>static定义</strong>的对象：在首次到达对象定义位置时调用构造函数，程序结束时调用析构函数。</li><li><strong>new动态生成</strong>的对象：产生对象时调用构造函数，用delete释放对象时，才调用析构函数。若不使用delete运算符来撤销动态生成的对象，则析构函数不会被调用。</li></ol>\n          </div>\n<h2 id=\"对象的动态建立和释放\">对象的动态建立和释放</h2>\n<ul>\n<li>new运算符建立对象：<strong>先为类的对象分配内存空间</strong>，然后<strong>自动调用构造函数初始化</strong>对象的数据成员，最后将变量的起始地址返还给指针变量。</li>\n<li>delete运算符释放对象：<strong>只有在delete运算符释放对象时，才会调用析构函数将对象销毁</strong>。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义一个复数类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数：初始化实部和虚部</span><br>    <span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-type\">double</span> r, <span class=\"hljs-type\">double</span> i) {<br>        real = r;    <span class=\"hljs-comment\">// 设置实部值</span><br>        imag = i;    <span class=\"hljs-comment\">// 设置虚部值</span><br>        cout &lt;&lt; <span class=\"hljs-string\">\"构造函数被调用\"</span> &lt;&lt; endl;<br>    }<br><br>    <span class=\"hljs-comment\">// 析构函数：对象销毁时自动调用</span><br>    ~<span class=\"hljs-built_in\">Complex</span>() {<br>        cout &lt;&lt; <span class=\"hljs-string\">\"析构函数被调用\"</span> &lt;&lt; endl;<br>    }<br><br>    <span class=\"hljs-comment\">// 显示复数的方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span> </span>{<br>        cout &lt;&lt; <span class=\"hljs-string\">\"(\"</span> &lt;&lt; real &lt;&lt; <span class=\"hljs-string\">\",\"</span> &lt;&lt; imag &lt;&lt; <span class=\"hljs-string\">\")\"</span> &lt;&lt; endl;<br>    }<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> real;  <span class=\"hljs-comment\">// 复数的实部</span><br>    <span class=\"hljs-type\">double</span> imag;  <span class=\"hljs-comment\">// 复数的虚部</span><br>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-comment\">// 动态创建一个Complex对象</span><br>    Complex* pc1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);<br><br>    <span class=\"hljs-comment\">// 调用display方法显示复数</span><br>    pc1-&gt;<span class=\"hljs-built_in\">display</span>();  <span class=\"hljs-comment\">// 等价于 (*pc1).display();</span><br><br>    <span class=\"hljs-comment\">// 释放对象内存</span><br>    <span class=\"hljs-keyword\">delete</span> pc1;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">\"程序结束\"</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight scss\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">构造函数被调用<br>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>)<br>析构函数被调用<br>程序结束<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"静态成员\">静态成员</h2>\n<p>声明为static的类成员称为静态成员，可以<strong>被类的所有对象共享</strong>。</p>\n<ul>\n<li>静态数据成员：描述这一类对象所共有的数据，所有对象公用这一部分存储空间。</li>\n<li>静态数据函数</li>\n</ul>\n<p>eg:Profit和 static double getProfit() ，总利润是出售所有商品获得的，并不隶属于哪一个商品对象。</p>\n<h3 id=\"为什么不使用全局变量？\">为什么不使用全局变量？</h3>\n<div class=\"note note-warning\">\n            <ol><li><strong>违背了OOP封装性的精神</strong>，任何地方都可以对全局变量进行访问，破坏了信息隐藏原则</li><li>过多使用全局变量会产生<strong>重名冲突</strong></li><li>能够<strong>明确归属</strong>，直接表明它是类的一部分，便于进行初始化</li></ol>\n          </div>\n<h3 id=\"静态数据成员\">静态数据成员</h3>\n<p>在类的定义中的数据成员声明前加上关键字<code>static</code>，表示该成员是静态数据成员。由于静态数据成员<strong>由类的所有对象共享</strong>，所以静态成员的存储空间<strong>不会随着对象的产生而分配</strong>，也<strong>不会随着对象的消失而释放</strong>，因此静态数据成员不能在类体内进行初始化，而只能在<strong>类体内进行声明</strong>，在<strong>类体外进行初始化</strong>。</p>\n<figure class=\"highlight autohotkey\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-title\">数据类型名类名::</span>静态数据成员名=初值<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><strong>不需要加<code>static</code>关键字</strong></li>\n<li><strong>需要通过作用域运算符<code>::</code>限定修饰</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>{ <br>    <span class=\"hljs-keyword\">private</span>:<br>    ......<br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit;<br>    <span class=\"hljs-keyword\">public</span>:<br>    ......<br>}<br><span class=\"hljs-type\">double</span> cgoods::Profit=<span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></tbody></table></figure>\n<p>类外的定义是必要的，若没有明确赋初值，则编译系统会自动赋初值为0。</p>\n<h3 id=\"静态成员函数\">静态成员函数</h3>\n<p>与类的数据成员相同，在成员函数前加上<code>static</code>可以创建一个静态成员函数。静态函数没有<code>this</code>指针，通常他只访问属于全体对象的成员————即静态成员。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">cgoods::getProfit</span><span class=\"hljs-params\">()</span></span>{<br>    <span class=\"hljs-keyword\">return</span> Profit;<span class=\"hljs-comment\">//使用了静态成员变量</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-warning\">\n            <ol><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员</li><li>静态成员函数不能直接访问非静态成员函数和非静态数据成员</li></ol>\n          </div>\n<h3 id=\"静态成员的访问\">静态成员的访问</h3>\n<p>用类的对象访问 || 直接用作用域运算符“::”通过类名访问</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">类名::静态数据成员名<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.静态数据成员名<br><span class=\"hljs-comment\">//容易让人误认为静态数据成员是属于某个对象的</span><br></code></pre></td></tr></tbody></table></figure>\n<p>静态成员函数的访问与静态成员数据的访问的形式相同，不做过多阐释。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CStudent</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    string SName;       <span class=\"hljs-comment\">// 保存学生姓名</span><br>    <span class=\"hljs-type\">float</span> Score;        <span class=\"hljs-comment\">// 保存学生的成绩</span><br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> studentTotal;    <span class=\"hljs-comment\">// 静态数据成员，保存学生的总人数</span><br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">float</span> SumScore;      <span class=\"hljs-comment\">// 静态数据成员，保存所有学生的成绩和</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数，当新建一个对象时，人数studentTotal加1</span><br>    <span class=\"hljs-built_in\">CStudent</span>(string name, <span class=\"hljs-type\">float</span> sc);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">float</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 计算学生的平均分</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;               <span class=\"hljs-comment\">// 打印输出学生的姓名和分数</span><br>    ~<span class=\"hljs-built_in\">CStudent</span>();                <span class=\"hljs-comment\">// 析构函数，当减少一个对象时，studentTotal减1</span><br>};<br><br><span class=\"hljs-comment\">// 静态数据成员的初始化必须在类外进行</span><br><span class=\"hljs-type\">int</span> CStudent::studentTotal = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">float</span> CStudent::SumScore = <span class=\"hljs-number\">0</span>;<br><br>CStudent::<span class=\"hljs-built_in\">CStudent</span>(string name, <span class=\"hljs-type\">float</span> sc) {<br>    SName = name;<br>    Score = sc;<br>    studentTotal++;     <span class=\"hljs-comment\">// 学生人数加1</span><br>    SumScore += sc;     <span class=\"hljs-comment\">// 总分数增加</span><br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">\" Constructor called.\"</span> &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CStudent::Print</span><span class=\"hljs-params\">()</span> </span>{<br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">\": \"</span> &lt;&lt; Score &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">CStudent::average</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// 静态成员函数访问静态数据成员</span><br>    <span class=\"hljs-keyword\">if</span> (studentTotal == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 防止除以0</span><br>    <span class=\"hljs-keyword\">return</span> (SumScore / studentTotal);<br>}<br><br>CStudent::~<span class=\"hljs-built_in\">CStudent</span>() {<br>    studentTotal--;     <span class=\"hljs-comment\">// 学生人数减1</span><br>    SumScore -= Score;  <span class=\"hljs-comment\">// 总分数减少</span><br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">\" Destructor called.\"</span> &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-comment\">// 简单测试</span><br>    <span class=\"hljs-function\">CStudent <span class=\"hljs-title\">stud1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"Zhang San\"</span>, <span class=\"hljs-number\">90</span>)</span></span>;<br>    <span class=\"hljs-function\">CStudent <span class=\"hljs-title\">stud2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"Li Si\"</span>, <span class=\"hljs-number\">80</span>)</span></span>;<br>    stud<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">Print</span>();<br>    stud<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">\"平均分为: \"</span> &lt;&lt; CStudent::<span class=\"hljs-built_in\">average</span>() &lt;&lt; endl;  <span class=\"hljs-comment\">// 调用静态成员函数</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight delphi\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">Zhang San <span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Li</span> <span class=\"hljs-title\">Si</span> <span class=\"hljs-title\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Zhang</span> <span class=\"hljs-title\">San</span>:</span> <span class=\"hljs-number\">90</span><br>Li Si: <span class=\"hljs-number\">80</span><br>平均分为: <span class=\"hljs-number\">85</span><br>Li Si <span class=\"hljs-function\"><span class=\"hljs-keyword\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Zhang</span> <span class=\"hljs-title\">San</span> <span class=\"hljs-title\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"this指针\">this指针</h2>\n<ul>\n<li>用途：当成员函数的<strong>参数名与成员变量名相同</strong>的时候，可以使用<code>this</code>来<strong>明确地引用成员变量</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Ponit&amp; <span class=\"hljs-title\">setPoint</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x,<span class=\"hljs-type\">int</span> y)</span></span>{<br>    <span class=\"hljs-keyword\">this</span>-&gt;x=x;<br>    (*<span class=\"hljs-keyword\">this</span>).y=y<span class=\"hljs-number\">+8</span>;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-warning\">\n            <ol><li>this指针是一个<strong>指向对象的指针</strong></li><li>this指针是一个隐含于成员函数中的对象指针</li><li>this指针是一个指向正在调用成员函数的对象的指针</li><li><strong>类的静态成员函数没有this指针</strong></li></ol>\n          </div>\n<h2 id=\"常对象\">常对象</h2>\n<p>常对象用<code>const</code>进行修饰，常对象必须进行初始化，且不能被更新，常对象的声明如下（两种声明完全相同，没有任何区别）：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> 类名 对象名[(实参列表)]；<br>类名 <span class=\"hljs-type\">const</span> 对象名[(实参列表)]；<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> Point <span class=\"hljs-title\">P1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>)</span></span>;<br><span class=\"hljs-function\">Point <span class=\"hljs-type\">const</span> <span class=\"hljs-title\">P2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>)</span></span>;<br></code></pre></td></tr></tbody></table></figure>\n<p>以上定义了两个常对象P1、P2。在任何场合，对象P1、P2中的成员值不能进行修改。<br>\n常对象不能调用非const成员函数：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Area</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>{<span class=\"hljs-comment\">//常成员函数</span><br>    <span class=\"hljs-keyword\">return</span> x*y;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>如果一定要修改常对象中的数据成员，可将需要修改的数据成员声明为<code>mutable</code>，这样就可以用声明为<code>const</code>的成员函数来修改它的值了！</p>\n<h2 id=\"友元类\">友元类</h2>\n<p>若我们想要一个不属于某个类的函数存取该类中的数据：</p>\n<ol>\n<li>将类中的数据成员均设置为<code>public</code></li>\n<li><strong>在类内部声明</strong>这个函数为友元（friend），则这个函数可以访问该类的私有成员</li>\n</ol>\n<p>第一点有违OOP封装性的精神，显然第二种更好！</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {<br><span class=\"hljs-keyword\">private</span>: <br>    string name;  <br>    <span class=\"hljs-type\">int</span> age;      <br>    <span class=\"hljs-type\">char</span> gender;  <br>    string idNumber; <br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Person</span>(string, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, string);<br>    <span class=\"hljs-built_in\">Person</span>(Person&amp;);<br>    ~<span class=\"hljs-built_in\">Person</span>() {}<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">(Person&amp; p)</span></span>;  <span class=\"hljs-comment\">// 声明showInfo为类Person的友元函数</span><br>};<br><br>Person::<span class=\"hljs-built_in\">Person</span>(string theName, <span class=\"hljs-type\">int</span> theAge, <span class=\"hljs-type\">char</span> theGender, string theIdNumber) {  <br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;  <br>}<br><br>Person::<span class=\"hljs-built_in\">Person</span>(Person&amp; theObject) {<br>    name = theObject.name;<br>    age = theObject.age;  <br>    gender = theObject.gender;  <br>    idNumber = theObject.idNumber;  <br>}<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Person::getName</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> name;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">(Person&amp; p)</span> </span>{  <span class=\"hljs-comment\">// showInfo为普通函数，是类Person的友元函数</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"name: \"</span> &lt;&lt; p.name &lt;&lt; endl;  <br>    cout &lt;&lt; <span class=\"hljs-string\">\"age: \"</span> &lt;&lt; p.age &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"gender: \"</span> &lt;&lt; p.gender &lt;&lt; endl;  <br>    cout &lt;&lt; <span class=\"hljs-string\">\"id number: \"</span> &lt;&lt; p.idNumber &lt;&lt; endl; <br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"张三\"</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">'m'</span>, <span class=\"hljs-string\">\"12345200006061111\"</span>)</span></span>;  <span class=\"hljs-comment\">// 建立对象p1</span><br>    <span class=\"hljs-built_in\">showInfo</span>(p1);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">name: 张三<br>age: <span class=\"hljs-number\">12</span><br>gender: m<br>id number: <span class=\"hljs-number\">12345200006061111</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"注意：\">注意：</h4>\n<div class=\"note note-warning\">\n            <ul><li>友元函数是类外函数，友元函数不能直接访问类中的私有和保护成员，而<strong>需要通过对象参数进行访问</strong></li></ul>\n          </div>\n<p>这个案例显然并没有那么好，我们可以将<code>showInfo</code>函数设计为类内一个普通的成员函数，这没有显示出友元函数的必要性，仅仅是对友元函数用法的一个初步介绍！</p>\n<h3 id=\"友元函数是另一个类的成员函数\">友元函数是另一个类的成员函数</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>;  <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">Height</span>(h) {}  <span class=\"hljs-comment\">// 使用初始化列表</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;     <span class=\"hljs-comment\">// 只能声明，不能定义（因为Rectangle未完全定义）</span><br>};<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) : <span class=\"hljs-built_in\">Width</span>(w), <span class=\"hljs-built_in\">Length</span>(len) {}  <span class=\"hljs-comment\">// 初始化列表</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;  <span class=\"hljs-comment\">// 声明友元函数</span><br>};<br><br><span class=\"hljs-comment\">// 必须在 Rectangle 定义之后才能定义 Volume</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> r.Length * r.Width * Height;  <span class=\"hljs-comment\">// 访问 Rectangle 的私有成员</span><br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Rectangle <span class=\"hljs-title\">R</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">C</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"长方体的体积为：\"</span> &lt;&lt; C.<span class=\"hljs-built_in\">Volume</span>(R) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">长方体的体积为：960<br></code></pre></td></tr></tbody></table></figure>\n<p>这里将类<code>Cuboid</code>的成员函数<code>Volume()</code>声明为类<code>Rectangle</code>的友元函数，这样在<code>Volume()</code>中就可以使用Rectangle中的私有数据成员<code>Width</code>、<code>Length</code>。</p>\n<h4 id=\"注释：\">注释：</h4>\n<div class=\"note note-warning\">\n            <p>程序第三行对<code>Rectangle</code>的<strong>提前声明引用</strong>，只包含类名，不包含类体。提前声明的原因是：在类<code>Cuboid</code>中调用<code>Volume()</code>函数时，需要使用类<code>Rectangle</code>中的数据成员<code>Length</code>和<code>Width</code>，但是类<code>Rectangle</code>还没有定义。那如果将<code>Rectangle</code>的定义提到前面呢？同样是不可以的，因为在类<code>Rectangle</code>中又包含了<code>Cuboid</code>的成员！但是不能因为提前声明，而去定义一个对象！</p>\n          </div>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>;<span class=\"hljs-comment\">//提前引用声明</span><br>Rectangle r1;<span class=\"hljs-comment\">//紧接着定义一个Rectangle对象，这是不允许的！</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>{...};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"友元类-v2\">友元类</h3>\n<p>将一个类声明为另一个类的友元：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>{<br>    ...<br>    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span>;<span class=\"hljs-comment\">//类B声明为当前类A的友元类</span><br>    ...<br>};<br></code></pre></td></tr></tbody></table></figure>\n<p>此时，类B中的所有成员函数都是当前类A的友元函数，因此类B中的<strong>所有成员函数</strong>都可以访问当前类A的<code>private</code>成员或<code>protected</code>成员</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>; <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h) {<br>        Height = h;<br>    }<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;<br>};<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> {<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) {<br>        Width = w;<br>        Length = len;  <span class=\"hljs-comment\">// 添加了分号</span><br>    }<br>    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span>; <span class=\"hljs-comment\">// 声明类Cuboid是类Rectangle的友元类</span><br>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> r.Length * r.Width * Height;  <span class=\"hljs-comment\">// 正确的体积计算公式</span><br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-function\">Rectangle <span class=\"hljs-title\">r</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">C</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"长方体的体积为：\"</span> &lt;&lt; C.<span class=\"hljs-built_in\">Volume</span>(r) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">长方体的体积为：960<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"友元关系的限制：\">友元关系的限制：</h3>\n<div class=\"note note-warning\">\n            <ol><li>友元关系<strong>不具有传递性</strong>，“附庸的附庸不是我的附庸”，比如类A是类B的友元类，类B是类C的友元类，类C不是类A的友元类。</li><li>友元关系<strong>不具有交换性</strong>，比如类A是类B的友元类，类B不一定是类A的友元</li><li>友元关系是<strong>不能继承的</strong>，比如类A是类B的友元类，类C继承类B，类C不是类A的友元类</li></ol>\n          </div>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=m_MQYyJpIjg\">Fundamental Concepts of Object Oriented Programming</a></p>\n<h2 id=\"References\">References</h2>\n<p>以上大部分代码均取自《C++程序设计基础教程》</p>\n","excerpt":"","more":" <div class=\"note note-primary\">\n            <p>看到过一个很讽刺的笑话：大多数国内高校学生学到的CPP只是<strong>C语言的cin/cout</strong>。这当然只是一句玩笑话，但很深刻地反映出对于<strong>CPP精髓面向对象编程</strong>的忽视。这是有理可依的：编程语言的学习本身就和传统的课堂授课模式存在较大的出入，<strong>编程重视实践</strong>，枯燥的语法讲解如同天书一般晦涩难懂，更不用提OOP所涉及的都是比较<strong>大规模的项目工程</strong>，如果只是在课堂上乏味地讲解“什么是析构函数，什么是继承，什么是多态··· ”，很容易将CPP学成死记硬背的无聊学科。</p>\n          </div>\n<p>因此，笔者希望通过博客的方式，记录自己<strong>OOP in CPP</strong>的学习笔记，并分享给各位小伙伴！</p>\n<h1>Why OOP?</h1>\n<ul>\n<li>\n<p>面向过程的局限性：将描述事物的数据与处理数据的函数分开。</p>\n<ul>\n<li>若所描述事物的数据结构发生变化时，这些成员函数也必须重新设计！</li>\n<li>在主函数中对数据进行修改，仅仅需要执行一条赋值语句，数据安全性得不到保障！</li>\n</ul>\n</li>\n<li>\n<p>面向对象的优势：将描述事物的数据与处理函数<strong>封装</strong>成一个整体，称为类。</p>\n<ul>\n<li>封装在类中的函数和数据不受外界的影响，即类使数据具有良好的<strong>独立性</strong>和<strong>可维护性</strong>！</li>\n<li>类中的数据在类的外部不能直接调用，外部只能通过<strong>公共接口函数</strong>来处理类中的数据，从而保障了<strong>数据的安全性</strong>！</li>\n</ul>\n</li>\n</ul>\n<h1>类和对象</h1>\n<h2 id=\"类：\">类：</h2>\n<p>  类描述了某一类事物应该具有哪些<strong>特征</strong>和<strong>行为</strong>。比如我们想描述一个“商品”类别，类就会告诉我们商品的名称、编号、进货价格、售出价格等特征，但是这个“商品”并不是一真正的商品，类只告诉了我们“商品”是什么样的、应该具有的特征。类是对象的抽象表示，它<strong>本身不占用内存空间</strong>。</p>\n<p>类<code>class</code>与结构体<code>struct</code>形式相似，关键字不同！</p>\n<ul>\n<li><code>class</code>的成员默认是<code>private</code>的</li>\n<li><code>struct</code>的成员默认是<code>public</code>的</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">  <span class=\"hljs-keyword\">class</span> 类名 &#123;<br>     <span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">//私有数据成员和成员函数</span><br>     <span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">//保护数据成员和成员函数</span><br>     <span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">//共有数据成员和成员函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>private</code>:只能被类本身的成员函数、友元函数、友元函数的成员函数访问，派生类也无法访问。</li>\n<li><code>protected</code>:除派生类可以进行访问，其余与<code>private</code>相同。</li>\n<li><code>public</code>:可以被程序中任意代码访问。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>&#123;<span class=\"hljs-comment\">//商品类</span><br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice)&#123;<span class=\"hljs-comment\">//构造函数</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        ~<span class=\"hljs-built_in\">cgoods</span>()&#123;<span class=\"hljs-comment\">//析构函数</span><br>        &#125; <br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置进货价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置出货价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setSellingcount</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sellcount)</span></span>&#123;<span class=\"hljs-comment\">//设置出货商品价格</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Sell</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice,<span class=\"hljs-type\">int</span> sellcount)</span></span>&#123;<br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">getProfit</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//获取总利润，静态成员函数</span><br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>&#123;<br>        <span class=\"hljs-comment\">//函数体</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"对象：\">对象：</h2>\n<p>  对象则是根据类创建出来的具体实例。比如我们创建一个叫“手机”的“商品”，他有自己的具体的编号、进货价格、售出价格等，所有的特征都是独一无二的，不会与其他商品相同。每一个对象都是根据类创建的具有其属性和方法的实例，并且具有唯一的身份标识（如内存地址）和自己独特的属性值。 <strong>对象是占用内存空间的</strong>，它的<strong>属性值可以在运行时动态地改变</strong>。</p>\n<p>定义对象的三种方法：</p>\n<ul>\n<li>先定义类的类型，再定义对象：</li>\n</ul>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名&#123;<br>    成员表;<br>&#125;;<br>[<span class=\"hljs-keyword\">class</span>]可选 类名 对象名列表;<br></code></pre></td></tr></table></figure>\n<p>例如：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">class</span> cgoods <span class=\"hljs-title\">goods1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;1001001&quot;</span>,<span class=\"hljs-string\">&quot;元气森林&quot;</span>)</span></span>;<span class=\"hljs-comment\">//创建对象goods1</span><br><span class=\"hljs-function\">cgoods <span class=\"hljs-title\">goods</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;1001001&quot;</span>,<span class=\"hljs-string\">&quot;元气森林&quot;</span>)</span></span>;<span class=\"hljs-comment\">//两种方法等价</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>在定义类类型时<strong>同时创建对象</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名&#123;<br>    成员表;<br>&#125;对象名表;<br></code></pre></td></tr></table></figure>\n<p>例如：</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>&#123;<br>    <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">public</span>:<br>&#125;<span class=\"hljs-built_in\">goods1</span>(<span class=\"hljs-string\">&quot;1001001&quot;</span>,<span class=\"hljs-string\">&quot;元气森林&quot;</span>)；<br></code></pre></td></tr></table></figure>\n<ul>\n<li>不出现类名<strong>直接定义对象</strong>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> &#123;<br>     成员表;<br> &#125;对象名表;<br></code></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> &#123;<br>    <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-keyword\">public</span>:<br>&#125;<span class=\"hljs-built_in\">goods1</span>(<span class=\"hljs-string\">&quot;1001001&quot;</span>,<span class=\"hljs-string\">&quot;元气森林&quot;</span>)；<br></code></pre></td></tr></table></figure>\n<p>此方法由于没有类名，所以只能<strong>一次性声明多个对象</strong>，此后再无法声明此类对象！</p>\n<h2 id=\"类的成员访问\">类的成员访问</h2>\n<ul>\n<li>对于数据成员的访问</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.成员名<span class=\"hljs-comment\">//数据成员访问</span><br>对象指针名-&gt;成员名<br>(*对象指针名).成员名<br></code></pre></td></tr></table></figure>\n<ul>\n<li>对于成员函数的访问</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.成员函数名(参数表)<span class=\"hljs-comment\">//成员函数访问</span><br>对象指针名-&gt;成员函数名(参数表)<br>(*对象指针名).成员函数名(参数表)<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的构造函数-Constructor\">类的构造函数(Constructor)</h2>\n<ul>\n<li>类的对象太过复杂，一个对象可能有许许多多的数据成员，这就意味着我们要对许许多多的数据成员进行初始化，实现这一过程并不容易。构造函数的作用就是在对象被创建时<strong>利用特定的初始值</strong>构造对象，把对象<strong>置于某一个初始状态</strong>。</li>\n</ul>\n<ol>\n<li>有<strong>与类完全相同的名字</strong></li>\n<li><strong>没有类型说明</strong>，不允许有返回值</li>\n<li><strong>可以进行重载</strong>，即一个类中允许定义多个参数不同的构造函数</li>\n<li>可以在声明时的<strong>参数表里给予初始值</strong></li>\n<li>每个类都必须至少有一个构造函数，如果没有显式的为类提供构造函数，则C++<strong>提供一个默认的无参构造函数</strong>，只负责对象的创建，而不做任何初始化的工作</li>\n<li>一旦类定义了构造函数，C++不再提供默认的无参构造函数</li>\n<li>程序中不能直接调用构造函数，他是在<strong>创建类的对象时自动调用</strong>的</li>\n</ol>\n<hr>\n<h3 id=\"1-无参构造函数\">1. 无参构造函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Time</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Time</span>() &#123; <span class=\"hljs-comment\">// 定义构造成员函数，函数名与类名相同</span><br>        hour = <span class=\"hljs-number\">22</span>;<br>        minute = <span class=\"hljs-number\">22</span>;<br>        sec = <span class=\"hljs-number\">22</span>;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_time</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">show_time</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 函数声明</span><br><span class=\"hljs-keyword\">private</span>: <span class=\"hljs-comment\">// 私有数据成员</span><br>    <span class=\"hljs-type\">int</span> hour;<br>    <span class=\"hljs-type\">int</span> minute;<br>    <span class=\"hljs-type\">int</span> sec;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Time::set_time</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-comment\">// 定义成员函数，向数据成员赋值</span><br>    cin &gt;&gt; hour;<br>    cin &gt;&gt; minute;<br>    cin &gt;&gt; sec;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Time::show_time</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-comment\">// 定义成员函数，输出数据成员的值</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;时间为: &quot;</span> &lt;&lt; hour &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class=\"hljs-string\">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Time t1;       <span class=\"hljs-comment\">// 建立对象t1，同时调用构造函数t1.Time()</span><br>    t<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">set_time</span>(); <span class=\"hljs-comment\">// 对t1的数据成员赋值</span><br>    t<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">show_time</span>(); <span class=\"hljs-comment\">// 显示t1的数据成员的值</span><br>    Time t2;       <span class=\"hljs-comment\">// 建立对象 t2，同时调用构造函数 t2.Time()</span><br>    t<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">show_time</span>(); <span class=\"hljs-comment\">// 显示t2的数据成员的值</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs makefile\">12 30 40<br><span class=\"hljs-section\">时间为: 12:30:40</span><br><span class=\"hljs-section\">时间为: 22:22:22</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"2-含参构造函数\">2. 含参构造函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">构造函数名（类型<span class=\"hljs-number\">1</span> 形参<span class=\"hljs-number\">1</span>，类型<span class=\"hljs-number\">2</span> 形参<span class=\"hljs-number\">2</span>，...）<br>类名 对象名（实参<span class=\"hljs-number\">1</span>，实参<span class=\"hljs-number\">2</span>，...）<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>);  <span class=\"hljs-comment\">// 带有三个参数的构造函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;<br>    <span class=\"hljs-type\">int</span> width;<br>    <span class=\"hljs-type\">int</span> length;<br>&#125;;<br><br><span class=\"hljs-comment\">// 构造函数的实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) &#123;<br>    height = h;<br>    width = w;<br>    length = len;<br>&#125;<br><br><span class=\"hljs-comment\">// volume成员函数的实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">45</span>, <span class=\"hljs-number\">30</span>)</span></span>;  <span class=\"hljs-comment\">// 定义对象时需要根据构造函数形参提供实参</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid1的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">22</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid2的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">20250</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">6600</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"3-构造函数重载\">3. 构造函数重载</h3>\n<p>定义多个构造函数以便给对象提供不同的初始化方法，这些构造函数具有相同的名字而<strong>参数的个数或参数的类型不相同</strong>。可以为一个类声明的构造函数的个数是<strong>无限制的</strong>，只要每个构造函数的<strong>形参表是唯一的</strong>，定义对象时会根据提供的实参决定调用哪一个构造函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>();                  <span class=\"hljs-comment\">// 默认构造函数（无参数）</span><br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len);  <span class=\"hljs-comment\">// 带参数的构造函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>;              <span class=\"hljs-comment\">// 计算体积方法</span><br>    <br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;   <span class=\"hljs-comment\">// 高度</span><br>    <span class=\"hljs-type\">int</span> width;    <span class=\"hljs-comment\">// 宽度</span><br>    <span class=\"hljs-type\">int</span> length;   <span class=\"hljs-comment\">// 长度</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 默认构造函数实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>() &#123;<br>    height = <span class=\"hljs-number\">15</span>;<br>    width = <span class=\"hljs-number\">15</span>;<br>    length = <span class=\"hljs-number\">15</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 带参数的构造函数实现</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) &#123;<br>    height = h;<br>    width = w;<br>    length = len;<br>&#125;<br><br><span class=\"hljs-comment\">// 体积计算方法实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 创建对象cuboid1，使用默认构造函数</span><br>    Cuboid cuboid1;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid1的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br>    <br>    <span class=\"hljs-comment\">// 创建对象cuboid2，使用带参数的构造函数</span><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">45</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid2的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">3375</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">27000</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"4-使用默认值的构造函数\">4. 使用默认值的构造函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> height;   <span class=\"hljs-comment\">// 高度</span><br>    <span class=\"hljs-type\">int</span> width;    <span class=\"hljs-comment\">// 宽度</span><br>    <span class=\"hljs-type\">int</span> length;   <span class=\"hljs-comment\">// 长度</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h = <span class=\"hljs-number\">15</span>, <span class=\"hljs-type\">int</span> w = <span class=\"hljs-number\">15</span>, <span class=\"hljs-type\">int</span> len = <span class=\"hljs-number\">15</span>); <span class=\"hljs-comment\">// 构造函数，全部参数带默认值</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">volume</span><span class=\"hljs-params\">()</span></span>; <span class=\"hljs-comment\">// 计算体积</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 构造函数实现（定义时可不再指定默认值）</span><br>Cuboid::<span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h, <span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) &#123;<br>    height = h;   <br>    width = w;<br>    length = len;<br>&#125;<br><br><span class=\"hljs-comment\">// 计算体积方法实现</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::volume</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> (height * width * length);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    Cuboid cuboid1; <span class=\"hljs-comment\">// 没有给出实参，使用全部默认值 height=15,width=15,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid1的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>)</span></span>; <span class=\"hljs-comment\">// 只给定一个实参，height=25,width=15,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid2的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid3</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">40</span>)</span></span>; <span class=\"hljs-comment\">// 只给定2个实参，height=25,width=40,length=15</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid3的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">3.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">cuboid4</span><span class=\"hljs-params\">(<span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>)</span></span>; <span class=\"hljs-comment\">// 给定3个实参，height=25,width=30,length=40</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;cuboid4的体积为: &quot;</span> &lt;&lt; cuboid<span class=\"hljs-number\">4.</span><span class=\"hljs-built_in\">volume</span>() &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">cuboid1</span>的体积为: <span class=\"hljs-number\">3375</span><br><span class=\"hljs-attribute\">cuboid2</span>的体积为: <span class=\"hljs-number\">5625</span><br><span class=\"hljs-attribute\">cuboid3</span>的体积为: <span class=\"hljs-number\">15000</span><br><span class=\"hljs-attribute\">cuboid4</span>的体积为: <span class=\"hljs-number\">30000</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"5-子对象和构造函数\">5.子对象和构造函数</h3>\n<p>在定义一个新的类时，<strong>将一个已有类作为数据成员</strong>，这个类对象叫做子对象。我们通过调用子对象成员的构造函数来完成对子对象的初始化。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> &#123;  <span class=\"hljs-comment\">// 定义矩形类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;  <span class=\"hljs-comment\">// 宽度、长度</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) &#123;  <span class=\"hljs-comment\">// 带参构造函数</span><br>        Width = w;<br>        Length = len;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Area</span><span class=\"hljs-params\">()</span> </span>&#123;  <span class=\"hljs-comment\">// 计算面积</span><br>        <span class=\"hljs-keyword\">return</span> (Width * Length);<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;  <span class=\"hljs-comment\">// 定义长方体类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;  <span class=\"hljs-comment\">// 高度</span><br>    Rectangle r;  <span class=\"hljs-comment\">// 使用Rectangle类对象作为成员</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len, <span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">r</span>(w, len) &#123;  <span class=\"hljs-comment\">// 初始化列表初始化r对象</span><br>        Height = h;  <span class=\"hljs-comment\">// 原代码这里是Height-h，应该是赋值=</span><br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">()</span> </span>&#123;  <span class=\"hljs-comment\">// 计算体积</span><br>        <span class=\"hljs-keyword\">return</span> (Height * r.<span class=\"hljs-built_in\">Area</span>());<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">c1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">100</span>)</span></span>;  <span class=\"hljs-comment\">// 创建长方体对象</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;长方体 c1 的体积是: &quot;</span> &lt;&lt; c<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">Volume</span>() &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\">长方体 <span class=\"hljs-built_in\">c1</span> 的体积是: <span class=\"hljs-number\">20000</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len, <span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">r</span>(w, len) &#123;  <span class=\"hljs-comment\">// 初始化列表初始化r对象</span><br>       Height = h;  <span class=\"hljs-comment\">// 原代码这里是Height-h，应该是赋值=</span><br>   &#125;<br></code></pre></td></tr></table></figure>\n<p>实参10、20通过<code>w</code>和<code>len</code>赋值<code>r(w, len)</code>，调用类的成员<code>Rectangle(int w, int len)</code>构造函数完成初始化，实参100通过<code>Height = h</code>完成对<code>Cuboid</code>的初始化。</p>\n<h3 id=\"6-拷贝构造函数\">6.拷贝构造函数</h3>\n<p>设计拷贝构造函数<strong>实现类中的一个对象给另一个对象的每个非静态数据成员赋值</strong>。（<strong>用已经初始化的对象去初始化一个新定义的对象</strong>）</p>\n<ol>\n<li>拷贝构造函数的函数名必须<strong>与类名一致</strong>，函数的形式参数是本类型的一个<strong>引用变量</strong>，必须为<strong>引用</strong>！</li>\n<li><strong>自定义拷贝构造函数</strong>，能够实现<strong>有选择</strong>的复制原对象中的数据（实现对部分数据的修改）</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Sample</span> &#123;        <span class=\"hljs-comment\">// 定义Sample类</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> nTest;        <span class=\"hljs-comment\">// 私有成员变量，用于存储测试值</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数，初始化nTest</span><br>    <span class=\"hljs-built_in\">Sample</span>(<span class=\"hljs-type\">int</span> ly) &#123;  <span class=\"hljs-comment\">// 参数ly用于初始化nTest</span><br>        nTest = ly;   <span class=\"hljs-comment\">// 将参数值赋给成员变量</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 自定义的拷贝构造函数</span><br>    <span class=\"hljs-built_in\">Sample</span>(Sample &amp;tS) &#123;  <span class=\"hljs-comment\">// 参数是对另一个Sample对象的引用</span><br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;拷贝构造函数被调用&quot;</span> &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出提示信息</span><br>        nTest = tS.nTest + <span class=\"hljs-number\">8</span>;  <span class=\"hljs-comment\">// 新对象的nTest值 = 原对象值 + 8</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 获取nTest值的成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">readtest</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> nTest;  <span class=\"hljs-comment\">// 返回当前对象的nTest值</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 设置nTest值的成员函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">settest</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ly)</span> </span>&#123;<br>        nTest = ly;    <span class=\"hljs-comment\">// 修改当前对象的nTest值</span><br>    &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Sample <span class=\"hljs-title\">S1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">100</span>)</span></span>;    <span class=\"hljs-comment\">// 创建S1对象，nTest初始化为100</span><br>    <span class=\"hljs-function\">Sample <span class=\"hljs-title\">S2</span><span class=\"hljs-params\">(S1)</span></span>;     <span class=\"hljs-comment\">// 使用拷贝构造函数创建S2对象</span><br>    cout &lt;&lt; S<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">readtest</span>() &lt;&lt; endl;  <span class=\"hljs-comment\">// 输出S2的nTest值</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">拷贝构造函数被调用<br>108<br></code></pre></td></tr></table></figure>\n<h2 id=\"类的析构函数-Destructor\">类的析构函数(Destructor)</h2>\n<p>相当于创建对象时用new申请了一片内存空间，应在退出前<strong>在析构函数中用delete释放</strong>。析构函数是与构造函数作用相反的函数，当对象生命周期结束时，自动执行析构函数。</p>\n<ol>\n<li>有与类完全相同的名字，只是在<strong>函数名前面加一个位取反符“~”</strong>，以区别于构造函数</li>\n<li>不带任何参数，没有返回值</li>\n<li>一个类最多只能有一个析构函数，<strong>无法进行重载</strong></li>\n<li>如果用户没有编写析构函数，编译系统会<strong>自动的生成一个默认的析构函数</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> 类名&#123;<br>    <span class=\"hljs-keyword\">public</span>:<br>    ~类名();&#123;<span class=\"hljs-comment\">//析构函数</span><br>    <span class=\"hljs-comment\">//函数体</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">//私有数据成员</span><br>    string name;    <span class=\"hljs-comment\">//姓名</span><br>    <span class=\"hljs-type\">int</span> age;        <span class=\"hljs-comment\">//年龄</span><br>    <span class=\"hljs-type\">char</span> gender;    <span class=\"hljs-comment\">//性别，&#x27;f&#x27;女性，&#x27;m&#x27;男性</span><br>    string idNumber; <span class=\"hljs-comment\">//身份证号码</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Person</span>(string, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, string);<br>    <span class=\"hljs-built_in\">Person</span>(Person&amp;);<br>    ~<span class=\"hljs-built_in\">Person</span>();<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">()</span></span>;   <span class=\"hljs-comment\">// 函数声明</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 成员函数在类体外实现</span><br>Person::<span class=\"hljs-built_in\">Person</span>(string theName, <span class=\"hljs-type\">int</span> theAge, <span class=\"hljs-type\">char</span> theGender, string theIdNumber) &#123;<br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;<br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot; Constructor called.&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Person::<span class=\"hljs-built_in\">Person</span>(Person&amp; theObject) &#123;<br>    name = theObject.name;<br>    age = theObject.age;<br>    gender = theObject.gender;<br>    idNumber = theObject.idNumber;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Copy Constructor called.&quot;</span> &lt;&lt; endl; <span class=\"hljs-comment\">//输出有关信息</span><br>&#125;<br><br>Person::~<span class=\"hljs-built_in\">Person</span>() &#123; <span class=\"hljs-comment\">//析构函数</span><br>    cout &lt;&lt; name &lt;&lt; <span class=\"hljs-string\">&quot; Destructor called.&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Person::getName</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Person::showInfo</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;name: &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;age: &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;gender: &quot;</span> &lt;&lt; gender &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;id number: &quot;</span> &lt;&lt; idNumber &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;张三&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&#x27;m&#x27;</span>, <span class=\"hljs-string\">&quot;12345200006061111&quot;</span>)</span></span>; <span class=\"hljs-comment\">//建立对象p1</span><br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;李四&quot;</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-string\">&#x27;f&#x27;</span>, <span class=\"hljs-string\">&quot;12345198111091234&quot;</span>)</span></span>; <span class=\"hljs-comment\">//建立对象p2</span><br><br>    p<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">showInfo</span>();<br>    p<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">showInfo</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">张三 <span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\">李四 <span class=\"hljs-title\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">name</span>:</span> 张三<br>age: <span class=\"hljs-number\">12</span><br>gender: m<br>id number: <span class=\"hljs-number\">12345200006061111</span><br><span class=\"hljs-keyword\">name</span>: 李四<br>age: <span class=\"hljs-number\">31</span><br>gender: f<br>id number: <span class=\"hljs-number\">12345198111091234</span><br>李四 <span class=\"hljs-function\"><span class=\"hljs-keyword\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\">张三 <span class=\"hljs-title\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br></code></pre></td></tr></table></figure>\n<p><strong>注意观察输出：构造函数和析构函数调用的顺序！</strong></p>\n<div class=\"note note-warning\">\n            <ol><li>析构函数在对象作为函数值返回之后被调用。</li></ol>\n          </div>\n<h2 id=\"构造函数和析构函数调用顺序\">构造函数和析构函数调用顺序</h2>\n<p>一般而言，调用构造函数的次序与调用析构函数的<strong>次序相反</strong>，与栈类似：<strong>先调用构造函数的对象，最后调用析构函数</strong>。</p>\n<h3 id=\"特殊情况：\">特殊情况：</h3>\n<div class=\"note note-warning\">\n            <ol><li><strong>全局定义</strong>对象（函数体外定义的对象）：程序开始之前调用构造函数，程序结束或调用exit()函数时调用析构函数。</li><li><strong>局部定义</strong>的对象（函数体内定义的对象）：程序执行到定义对象的地方时调用构造函数，函数结束时调用析构函数。</li><li><strong>static定义</strong>的对象：在首次到达对象定义位置时调用构造函数，程序结束时调用析构函数。</li><li><strong>new动态生成</strong>的对象：产生对象时调用构造函数，用delete释放对象时，才调用析构函数。若不使用delete运算符来撤销动态生成的对象，则析构函数不会被调用。</li></ol>\n          </div>\n<h2 id=\"对象的动态建立和释放\">对象的动态建立和释放</h2>\n<ul>\n<li>new运算符建立对象：<strong>先为类的对象分配内存空间</strong>，然后<strong>自动调用构造函数初始化</strong>对象的数据成员，最后将变量的起始地址返还给指针变量。</li>\n<li>delete运算符释放对象：<strong>只有在delete运算符释放对象时，才会调用析构函数将对象销毁</strong>。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-comment\">// 定义一个复数类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Complex</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数：初始化实部和虚部</span><br>    <span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-type\">double</span> r, <span class=\"hljs-type\">double</span> i) &#123;<br>        real = r;    <span class=\"hljs-comment\">// 设置实部值</span><br>        imag = i;    <span class=\"hljs-comment\">// 设置虚部值</span><br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;构造函数被调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 析构函数：对象销毁时自动调用</span><br>    ~<span class=\"hljs-built_in\">Complex</span>() &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;析构函数被调用&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 显示复数的方法</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; imag &lt;&lt; <span class=\"hljs-string\">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">double</span> real;  <span class=\"hljs-comment\">// 复数的实部</span><br>    <span class=\"hljs-type\">double</span> imag;  <span class=\"hljs-comment\">// 复数的虚部</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 动态创建一个Complex对象</span><br>    Complex* pc1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Complex</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>);<br><br>    <span class=\"hljs-comment\">// 调用display方法显示复数</span><br>    pc1-&gt;<span class=\"hljs-built_in\">display</span>();  <span class=\"hljs-comment\">// 等价于 (*pc1).display();</span><br><br>    <span class=\"hljs-comment\">// 释放对象内存</span><br>    <span class=\"hljs-keyword\">delete</span> pc1;<br><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;程序结束&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">构造函数被调用<br>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>)<br>析构函数被调用<br>程序结束<br></code></pre></td></tr></table></figure>\n<h2 id=\"静态成员\">静态成员</h2>\n<p>声明为static的类成员称为静态成员，可以<strong>被类的所有对象共享</strong>。</p>\n<ul>\n<li>静态数据成员：描述这一类对象所共有的数据，所有对象公用这一部分存储空间。</li>\n<li>静态数据函数</li>\n</ul>\n<p>eg:Profit和 static double getProfit() ，总利润是出售所有商品获得的，并不隶属于哪一个商品对象。</p>\n<h3 id=\"为什么不使用全局变量？\">为什么不使用全局变量？</h3>\n<div class=\"note note-warning\">\n            <ol><li><strong>违背了OOP封装性的精神</strong>，任何地方都可以对全局变量进行访问，破坏了信息隐藏原则</li><li>过多使用全局变量会产生<strong>重名冲突</strong></li><li>能够<strong>明确归属</strong>，直接表明它是类的一部分，便于进行初始化</li></ol>\n          </div>\n<h3 id=\"静态数据成员\">静态数据成员</h3>\n<p>在类的定义中的数据成员声明前加上关键字<code>static</code>，表示该成员是静态数据成员。由于静态数据成员<strong>由类的所有对象共享</strong>，所以静态成员的存储空间<strong>不会随着对象的产生而分配</strong>，也<strong>不会随着对象的消失而释放</strong>，因此静态数据成员不能在类体内进行初始化，而只能在<strong>类体内进行声明</strong>，在<strong>类体外进行初始化</strong>。</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs autohotkey\"><span class=\"hljs-title\">数据类型名类名::</span>静态数据成员名=初值<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><strong>不需要加<code>static</code>关键字</strong></li>\n<li><strong>需要通过作用域运算符<code>::</code>限定修饰</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>&#123; <br>    <span class=\"hljs-keyword\">private</span>:<br>    ......<br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit;<br>    <span class=\"hljs-keyword\">public</span>:<br>    ......<br>&#125;<br><span class=\"hljs-type\">double</span> cgoods::Profit=<span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>类外的定义是必要的，若没有明确赋初值，则编译系统会自动赋初值为0。</p>\n<h3 id=\"静态成员函数\">静态成员函数</h3>\n<p>与类的数据成员相同，在成员函数前加上<code>static</code>可以创建一个静态成员函数。静态函数没有<code>this</code>指针，通常他只访问属于全体对象的成员————即静态成员。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">cgoods::getProfit</span><span class=\"hljs-params\">()</span></span>&#123;<br>    <span class=\"hljs-keyword\">return</span> Profit;<span class=\"hljs-comment\">//使用了静态成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-warning\">\n            <ol><li>非静态成员函数可以任意地访问静态成员函数和静态数据成员</li><li>静态成员函数不能直接访问非静态成员函数和非静态数据成员</li></ol>\n          </div>\n<h3 id=\"静态成员的访问\">静态成员的访问</h3>\n<p>用类的对象访问 || 直接用作用域运算符“::”通过类名访问</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">类名::静态数据成员名<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">对象名.静态数据成员名<br><span class=\"hljs-comment\">//容易让人误认为静态数据成员是属于某个对象的</span><br></code></pre></td></tr></table></figure>\n<p>静态成员函数的访问与静态成员数据的访问的形式相同，不做过多阐释。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CStudent</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    string SName;       <span class=\"hljs-comment\">// 保存学生姓名</span><br>    <span class=\"hljs-type\">float</span> Score;        <span class=\"hljs-comment\">// 保存学生的成绩</span><br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> studentTotal;    <span class=\"hljs-comment\">// 静态数据成员，保存学生的总人数</span><br>    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">float</span> SumScore;      <span class=\"hljs-comment\">// 静态数据成员，保存所有学生的成绩和</span><br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">// 构造函数，当新建一个对象时，人数studentTotal加1</span><br>    <span class=\"hljs-built_in\">CStudent</span>(string name, <span class=\"hljs-type\">float</span> sc);<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">float</span> <span class=\"hljs-title\">average</span><span class=\"hljs-params\">()</span></span>;     <span class=\"hljs-comment\">// 计算学生的平均分</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">()</span></span>;               <span class=\"hljs-comment\">// 打印输出学生的姓名和分数</span><br>    ~<span class=\"hljs-built_in\">CStudent</span>();                <span class=\"hljs-comment\">// 析构函数，当减少一个对象时，studentTotal减1</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 静态数据成员的初始化必须在类外进行</span><br><span class=\"hljs-type\">int</span> CStudent::studentTotal = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-type\">float</span> CStudent::SumScore = <span class=\"hljs-number\">0</span>;<br><br>CStudent::<span class=\"hljs-built_in\">CStudent</span>(string name, <span class=\"hljs-type\">float</span> sc) &#123;<br>    SName = name;<br>    Score = sc;<br>    studentTotal++;     <span class=\"hljs-comment\">// 学生人数加1</span><br>    SumScore += sc;     <span class=\"hljs-comment\">// 总分数增加</span><br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">&quot; Constructor called.&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CStudent::Print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; Score &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">CStudent::average</span><span class=\"hljs-params\">()</span> </span>&#123;     <span class=\"hljs-comment\">// 静态成员函数访问静态数据成员</span><br>    <span class=\"hljs-keyword\">if</span> (studentTotal == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 防止除以0</span><br>    <span class=\"hljs-keyword\">return</span> (SumScore / studentTotal);<br>&#125;<br><br>CStudent::~<span class=\"hljs-built_in\">CStudent</span>() &#123;<br>    studentTotal--;     <span class=\"hljs-comment\">// 学生人数减1</span><br>    SumScore -= Score;  <span class=\"hljs-comment\">// 总分数减少</span><br>    cout &lt;&lt; SName &lt;&lt; <span class=\"hljs-string\">&quot; Destructor called.&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 简单测试</span><br>    <span class=\"hljs-function\">CStudent <span class=\"hljs-title\">stud1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Zhang San&quot;</span>, <span class=\"hljs-number\">90</span>)</span></span>;<br>    <span class=\"hljs-function\">CStudent <span class=\"hljs-title\">stud2</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;Li Si&quot;</span>, <span class=\"hljs-number\">80</span>)</span></span>;<br>    stud<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">Print</span>();<br>    stud<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">Print</span>();<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;平均分为: &quot;</span> &lt;&lt; CStudent::<span class=\"hljs-built_in\">average</span>() &lt;&lt; endl;  <span class=\"hljs-comment\">// 调用静态成员函数</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs delphi\">Zhang San <span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Li</span> <span class=\"hljs-title\">Si</span> <span class=\"hljs-title\">Constructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Zhang</span> <span class=\"hljs-title\">San</span>:</span> <span class=\"hljs-number\">90</span><br>Li Si: <span class=\"hljs-number\">80</span><br>平均分为: <span class=\"hljs-number\">85</span><br>Li Si <span class=\"hljs-function\"><span class=\"hljs-keyword\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">Zhang</span> <span class=\"hljs-title\">San</span> <span class=\"hljs-title\">Destructor</span> <span class=\"hljs-title\">called</span>.</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"this指针\">this指针</h2>\n<ul>\n<li>用途：当成员函数的<strong>参数名与成员变量名相同</strong>的时候，可以使用<code>this</code>来<strong>明确地引用成员变量</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">Ponit&amp; <span class=\"hljs-title\">setPoint</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x,<span class=\"hljs-type\">int</span> y)</span></span>&#123;<br>    <span class=\"hljs-keyword\">this</span>-&gt;x=x;<br>    (*<span class=\"hljs-keyword\">this</span>).y=y<span class=\"hljs-number\">+8</span>;<br>    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-warning\">\n            <ol><li>this指针是一个<strong>指向对象的指针</strong></li><li>this指针是一个隐含于成员函数中的对象指针</li><li>this指针是一个指向正在调用成员函数的对象的指针</li><li><strong>类的静态成员函数没有this指针</strong></li></ol>\n          </div>\n<h2 id=\"常对象\">常对象</h2>\n<p>常对象用<code>const</code>进行修饰，常对象必须进行初始化，且不能被更新，常对象的声明如下（两种声明完全相同，没有任何区别）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> 类名 对象名[(实参列表)]；<br>类名 <span class=\"hljs-type\">const</span> 对象名[(实参列表)]；<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> Point <span class=\"hljs-title\">P1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>)</span></span>;<br><span class=\"hljs-function\">Point <span class=\"hljs-type\">const</span> <span class=\"hljs-title\">P2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n<p>以上定义了两个常对象P1、P2。在任何场合，对象P1、P2中的成员值不能进行修改。<br>\n常对象不能调用非const成员函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Area</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>&#123;<span class=\"hljs-comment\">//常成员函数</span><br>    <span class=\"hljs-keyword\">return</span> x*y;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>如果一定要修改常对象中的数据成员，可将需要修改的数据成员声明为<code>mutable</code>，这样就可以用声明为<code>const</code>的成员函数来修改它的值了！</p>\n<h2 id=\"友元类\">友元类</h2>\n<p>若我们想要一个不属于某个类的函数存取该类中的数据：</p>\n<ol>\n<li>将类中的数据成员均设置为<code>public</code></li>\n<li><strong>在类内部声明</strong>这个函数为友元（friend），则这个函数可以访问该类的私有成员</li>\n</ol>\n<p>第一点有违OOP封装性的精神，显然第二种更好！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> &#123;<br><span class=\"hljs-keyword\">private</span>: <br>    string name;  <br>    <span class=\"hljs-type\">int</span> age;      <br>    <span class=\"hljs-type\">char</span> gender;  <br>    string idNumber; <br><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Person</span>(string, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span>, string);<br>    <span class=\"hljs-built_in\">Person</span>(Person&amp;);<br>    ~<span class=\"hljs-built_in\">Person</span>() &#123;&#125;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>;  <span class=\"hljs-comment\">// 函数声明</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">(Person&amp; p)</span></span>;  <span class=\"hljs-comment\">// 声明showInfo为类Person的友元函数</span><br>&#125;;<br><br>Person::<span class=\"hljs-built_in\">Person</span>(string theName, <span class=\"hljs-type\">int</span> theAge, <span class=\"hljs-type\">char</span> theGender, string theIdNumber) &#123;  <br>    name = theName;<br>    age = theAge;<br>    gender = theGender;<br>    idNumber = theIdNumber;  <br>&#125;<br><br>Person::<span class=\"hljs-built_in\">Person</span>(Person&amp; theObject) &#123;<br>    name = theObject.name;<br>    age = theObject.age;  <br>    gender = theObject.gender;  <br>    idNumber = theObject.idNumber;  <br>&#125;<br><br><span class=\"hljs-function\">string <span class=\"hljs-title\">Person::getName</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> name;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">showInfo</span><span class=\"hljs-params\">(Person&amp; p)</span> </span>&#123;  <span class=\"hljs-comment\">// showInfo为普通函数，是类Person的友元函数</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;name: &quot;</span> &lt;&lt; p.name &lt;&lt; endl;  <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;age: &quot;</span> &lt;&lt; p.age &lt;&lt; endl;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;gender: &quot;</span> &lt;&lt; p.gender &lt;&lt; endl;  <br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;id number: &quot;</span> &lt;&lt; p.idNumber &lt;&lt; endl; <br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Person <span class=\"hljs-title\">p1</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;张三&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-string\">&#x27;m&#x27;</span>, <span class=\"hljs-string\">&quot;12345200006061111&quot;</span>)</span></span>;  <span class=\"hljs-comment\">// 建立对象p1</span><br>    <span class=\"hljs-built_in\">showInfo</span>(p1);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">name: 张三<br>age: <span class=\"hljs-number\">12</span><br>gender: m<br>id number: <span class=\"hljs-number\">12345200006061111</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"注意：\">注意：</h4>\n<div class=\"note note-warning\">\n            <ul><li>友元函数是类外函数，友元函数不能直接访问类中的私有和保护成员，而<strong>需要通过对象参数进行访问</strong></li></ul>\n          </div>\n<p>这个案例显然并没有那么好，我们可以将<code>showInfo</code>函数设计为类内一个普通的成员函数，这没有显示出友元函数的必要性，仅仅是对友元函数用法的一个初步介绍！</p>\n<h3 id=\"友元函数是另一个类的成员函数\">友元函数是另一个类的成员函数</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>;  <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h) : <span class=\"hljs-built_in\">Height</span>(h) &#123;&#125;  <span class=\"hljs-comment\">// 使用初始化列表</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;     <span class=\"hljs-comment\">// 只能声明，不能定义（因为Rectangle未完全定义）</span><br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) : <span class=\"hljs-built_in\">Width</span>(w), <span class=\"hljs-built_in\">Length</span>(len) &#123;&#125;  <span class=\"hljs-comment\">// 初始化列表</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">friend</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;  <span class=\"hljs-comment\">// 声明友元函数</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 必须在 Rectangle 定义之后才能定义 Volume</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> r.Length * r.Width * Height;  <span class=\"hljs-comment\">// 访问 Rectangle 的私有成员</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Rectangle <span class=\"hljs-title\">R</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">C</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;长方体的体积为：&quot;</span> &lt;&lt; C.<span class=\"hljs-built_in\">Volume</span>(R) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">长方体的体积为：960<br></code></pre></td></tr></table></figure>\n<p>这里将类<code>Cuboid</code>的成员函数<code>Volume()</code>声明为类<code>Rectangle</code>的友元函数，这样在<code>Volume()</code>中就可以使用Rectangle中的私有数据成员<code>Width</code>、<code>Length</code>。</p>\n<h4 id=\"注释：\">注释：</h4>\n<div class=\"note note-warning\">\n            <p>程序第三行对<code>Rectangle</code>的<strong>提前声明引用</strong>，只包含类名，不包含类体。提前声明的原因是：在类<code>Cuboid</code>中调用<code>Volume()</code>函数时，需要使用类<code>Rectangle</code>中的数据成员<code>Length</code>和<code>Width</code>，但是类<code>Rectangle</code>还没有定义。那如果将<code>Rectangle</code>的定义提到前面呢？同样是不可以的，因为在类<code>Rectangle</code>中又包含了<code>Cuboid</code>的成员！但是不能因为提前声明，而去定义一个对象！</p>\n          </div>\n<p>例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>;<span class=\"hljs-comment\">//提前引用声明</span><br>Rectangle r1;<span class=\"hljs-comment\">//紧接着定义一个Rectangle对象，这是不允许的！</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>&#123;...&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"友元类-v2\">友元类</h3>\n<p>将一个类声明为另一个类的友元：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&#123;<br>    ...<br>    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span>;<span class=\"hljs-comment\">//类B声明为当前类A的友元类</span><br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>此时，类B中的所有成员函数都是当前类A的友元函数，因此类B中的<strong>所有成员函数</strong>都可以访问当前类A的<code>private</code>成员或<code>protected</code>成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span>; <span class=\"hljs-comment\">// 前向声明</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Height;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Cuboid</span>(<span class=\"hljs-type\">int</span> h) &#123;<br>        Height = h;<br>    &#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span></span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rectangle</span> &#123;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> Width, Length;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">Rectangle</span>(<span class=\"hljs-type\">int</span> w, <span class=\"hljs-type\">int</span> len) &#123;<br>        Width = w;<br>        Length = len;  <span class=\"hljs-comment\">// 添加了分号</span><br>    &#125;<br>    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cuboid</span>; <span class=\"hljs-comment\">// 声明类Cuboid是类Rectangle的友元类</span><br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Cuboid::Volume</span><span class=\"hljs-params\">(Rectangle&amp; r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> r.Length * r.Width * Height;  <span class=\"hljs-comment\">// 正确的体积计算公式</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-function\">Rectangle <span class=\"hljs-title\">r</span><span class=\"hljs-params\">(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>)</span></span>;<br>    <span class=\"hljs-function\">Cuboid <span class=\"hljs-title\">C</span><span class=\"hljs-params\">(<span class=\"hljs-number\">20</span>)</span></span>;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;长方体的体积为：&quot;</span> &lt;&lt; C.<span class=\"hljs-built_in\">Volume</span>(r) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">长方体的体积为：960<br></code></pre></td></tr></table></figure>\n<h3 id=\"友元关系的限制：\">友元关系的限制：</h3>\n<div class=\"note note-warning\">\n            <ol><li>友元关系<strong>不具有传递性</strong>，“附庸的附庸不是我的附庸”，比如类A是类B的友元类，类B是类C的友元类，类C不是类A的友元类。</li><li>友元关系<strong>不具有交换性</strong>，比如类A是类B的友元类，类B不一定是类A的友元</li><li>友元关系是<strong>不能继承的</strong>，比如类A是类B的友元类，类C继承类B，类C不是类A的友元类</li></ol>\n          </div>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=m_MQYyJpIjg\">Fundamental Concepts of Object Oriented Programming</a></p>\n<h2 id=\"References\">References</h2>\n<p>以上大部分代码均取自《C++程序设计基础教程》</p>\n"},{"title":"Essential Sorting Algorithms Explained","date":"2025-07-24T15:28:06.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Essential-Sorting-Algorithms-Explained.png","category_bar":true,"description":"This article explores some of the most essential sorting algorithms in Datastructure!","math":true,"_content":"{%fold into @ 排序算法测试样例题目 %}\n## 题目\n文章中排序算法均已经通过此题的OJ测试点！\n#### 题目描述\n给你N个自然数，编程输出排序后的这N个数。\n\n#### 输入\n第一行是整数的个数N（N<=100）。第二行是用空格隔开的N个数。\n\n#### 输出\n排序输出N个数，每个数间用一个空格间隔。\n\n#### 样例输入\n```\n5\n9 6 8 7 5\n```\n#### 样例输出\n```\n5 6 7 8 9\n```\n{%endfold%}\n*** \n![排序算法图](https://github.com/Richard110206/Blog-image/blob/main/article/Algorithm/Sorting.png?raw=true)\n\n## 1.直接插入排序（Straight Insertion Sort）\n### 核心思想\n&emsp;&emsp;将待排数组分为“已排序”和“未排序”两个部分，`R[0,1...i-1]`前面序列是已经排好的有序区，`R[i,...n]`后面的序列是未排序的无序区，直接插入排序每次操作将当前无序区的首元素`R[i]`插入到有序区`R[0,1...i-1]`的适当位置，使得`R[0,1...i]`成为新的有序区，减小无序区,直至无序区为空，从而全部数据有序！\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nbool cmp(int a, int b) { return a < b; }\nint main() {\n    int N;\n    cin >> N;\n    vector<int> R;\n    for (int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        R.push_back(a);\n    }\n    for (int i = 1; i < N; i++) {\n        int temp = R[i];//用temp临时存储待排元素\n        int j = i - 1;//让temp从i-1开始逐个向前比较\n            while (j >= 0 && cmp(temp, R[j])) {\n                R[j + 1] = R[j];\n                j--;\n            }\n            R[j + 1] = temp;\n    }\n    for (int i = 0; i < N; i++) {\n        cout << R[i] << \" \";\n    }\n    return 0;\n} \n```\n这里将比较逻辑模块化：\n```cpp\nbool cmp(int a, int b) { return a > b; }  \n```\n若未来需要修改排序规则（降序排序）只需要将`cmp`函数中的`>`修改为`<`即可！\n### 算法分析\n&emsp;&emsp;直接插入排序由**两重循环**构成，对于具有`n`个元素的数组`R`，外循环要进行`n-1`趟排序（`1到n-1`），在每趟排序中，仅当待插入序列元素`R[i]`小于有序区尾元素时才进入内层循环，因此直接插入排序的**时间性能与初始排序表相关**。\n\n- 比较次数 \n- 元素移动次数 \n\n1. 最好情况分析：初始排序表正序，无需进入内层循环时间复杂度为`O(n)`\n2. 最坏情况分析：初始排序表反序，每次排序均需要进入内层循环进行`i`次比较，等差数列`n(n-1)/2`，时间复杂度为`O(n^2)`\n3. 平均情况分析：在每趟排序中，平均情况是将`R[i]`插入到有序区的中间位置`R[0,1...i-1]`，等差数列`n(n-1)/4`，时间复杂度为`O(n^2)`。\n\n&emsp;&emsp;由于其**平均时间性能接近最坏性能**，所以是一种**低效**的排序方法。在该算法中只使用了`i`,`j`,`temp`三个辅助变量，与问题规模`n`无关，故空间复杂度为`O(1)`，是一个**就地排序**算法，同时相等时排序不变，是种**稳定**的排序算法。\n\n***\n## 2.折半插入排序（Binary Insertion Sort）\n### 核心思想\n&emsp;&emsp;在直接插入排序的基础上，用折半查找的方法找到无序区元素插入的位置。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int N;\n    cin >> N;\n    vector<int> R; \n    for (int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        R.push_back(a); \n    }\n    for (int i = 1; i < N; i++) {\n        int temp = R[i];\n        int low = 0, high = i - 1;\n        while (low <= high) {//退出循环时low=high+1\n            int mid = (low + high) / 2;\n            if (temp > R[mid]) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        for (int j = i - 1; j >= high + 1; j--) {  \n            R[j + 1] = R[j];\n        }\n        R[high + 1] = temp;\n    }\n    for (int i = 0; i < N; i++) {\n        cout << R[i] << \" \";\n    }\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;平均情况下时间复杂度为`O(n^2)`,从时间复杂度来看，折半插入与直接插入排序相同，但是当**元素数量较多时，折半查找优于顺序查找**，减少了关键字比较的次数，所以折半插入排序优于直接插入排序。同时其空间复杂度为`O(1)`，也是种**稳定**的排序算法。\n*** \n## 3.希尔排序（Shell Sort）\n### 核心思想\n&emsp;&emsp;希尔排序是一种**采用分组插入排序**的方法，先取一个小于`n`的整数${d}_{1}$作为第一个增量，将全部元素`R`中所有相距为 ${d}_{1}$的元素分成一组，在组内进行直接插入排序，然后取第二个增量 ${d}_{2}$（${d}_{2}$<${d}_{1}$），重复上述的分组和排序，直至增量 ${d}_{t}$=1，即**所有的元素为一组，在进行一次直接插入排序**，从而使得所有元素有序！\n&emsp;&emsp;从理论上讲，增量序列的取值只要满足初始值小于`n`再递减并且最后等于`1`就可以了。最常见的是**Shell增量序列**，即取 ${d}_{1}$=`n/2`，${d}_{i+1}$=${d}_{i}$/2，直到 ${d}_{t}$=0为止！\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n\tvector <int> R;\n\tint N;\n\tcin >> N;\n\tfor (int i = 0;i < N;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tR.push_back(a);\n\t}\n\tint d = N / 2;\n\twhile (d != 0) {\n\t\tfor (int i= d;i< N;i++) {\n\t\t\tint temp = R[i];\n\t\t\tint j = i;\n\t\t\twhile (j >= d && R[j - d] > temp) {\n\t\t\t\tR[j] = R[j - d];\n\t\t\t\tj -= d;\n\t\t\t}\n\t\t\tR[j] = temp;\n\t\t}\n\t\td /= 2;\n\t}\n\tfor (int i = 0;i < N;i++) {\n\t\tcout << R[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n### 算法分析\n&emsp;&emsp;由于希尔排序的增量序列不确定，算法的时间复杂度难以分析，我们一般认为其平均时间复杂度为`O(n^1.58)`，**希尔排序通常要比直接插入排序快**，在希尔排序中我们使用了`i`,`j`,`temp`,`d`四个辅助变量，与问题规模`n`无关，故算法空间复杂度为`O(1)`，也就是说是一种**就地排序**。但是希尔排序过程中相同元素的相对位置可能发生变化，因而是一种**不稳定**的排序算法。\n\n***\n## 4.快速排序（Quick Sort）\n### 核心思想\n&emsp;&emsp;在排序表中取一个元素为基准（一般是第一个），**将基准归位**（即将基准放在他最终的位置上），同时将所有小于基准的元素放到基准的前面（构成**左子表**），将所有大于基准的元素放到基准的后面（构成**右子表**），这个过程叫作**划分**。然后用递归的思想对左、右子表分别重复上述过程，直至每个子表只有一个元素或空为止。\n&emsp;&emsp;快速排序每次**仅将一个元素归位**，在最后一趟排序结束前并不产生明确的连续有序区。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint partition(vector <int>&arr, int low, int high) {\n\tint base = arr[low];\n\tint i = low + 1, j = high;\n\twhile (i <= j) {\n\t\twhile ( i <= j && arr[i] <= base) {\n\t\t\ti++;\n\t\t}\n\t\twhile (i <= j && arr[j] >= base) {\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(arr[i], arr[j]);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tswap(arr[low], arr[j]);\n\treturn i;\n}\nvoid quicksort(vector <int>& arr, int low, int high) {\n\tif (low >= high)return;\n\tint pi = partition(arr, low, high);\n\tquicksort(arr, low, pi-1);\n\tquicksort(arr, pi+1, high);\n}\nint main() {\n\tvector <int> R;\n\tint N;\n\tcin >> N;\n\tfor (int i = 0;i < N;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tR.push_back(a);\n\t}\n\tquicksort(R, 0, N - 1);\n\tfor (int i = 0;i < N;i++) {\n\t\tcout << R[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n### 算法分析\n1. 最好情况分析：如果初始排序表随机分布，使得**每次划分恰好分为两个长度相同的子表**，则递归树最小，性能最好，此时排序的时间复杂度为`O(nlog2n)`。\n2. 最坏情况分析：如果初始排序表**正序或反序**，使得**每次划分的两个子表中一个为空**，另一个长度为`n-1`，则递归树的高度最高，性能最差，此时排序的时间复杂度为`O(n^2)`。\n3. 平均情况分析：排序的平均时间复杂度为`O(nlog2n)`，这**接近最好情况**，所以快速排序是一种**高效**的排序方法。\n\n&emsp;&emsp;快速排序使用的是**递归算法**，尽管每一次划分仅仅使用固定的几个辅助变量，但是**递归树的高度**最好为`O(log2n)`，对应最好的空间复杂度为`O(log2n)`，最坏情况下递归树的高度为`O(n)`，对应最坏的空间复杂度为`O(n)`。\n&emsp;&emsp;另外，快速排序是一种**不稳定**的排序算法。（STL的`sort()`函数就是使用快速排序实现的，当划分的区间长度较小时，采用直接插入排序，所以`sort()`是不稳定的，且时间复杂度为`O(nlog2n)`）\n\n***\n\n## 5.堆排序（Heap Sort）\n### 核心思想\n&emsp;&emsp;堆排序是对**选择排序的一种改进**，采用**二叉树**来代替简单的选择方法来找最大或者最小元素，属于一种**树形选择排序方法**。我们采用数组隐式构建二叉树：\n1.  **小根堆**：根节点小于其两个子节点，即：$k_{i} \\leq k_{2i+1}$ 且 $k_{i} \\leq k_{2i+2}$，显然此时根节点是最小的。\n\n2.  **大根堆**：根节点大于其两个子节点，即：$k_{i} \\geq k_{2i+1}$ 且 $k_{i} \\geq k_{2i+2}$，显然此时根节点是最大的。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid heapify(vector<int>& arr, int n, int root) {\n    int largest = root; \n    int left = 2 * root + 1; \n    int right = 2 * root + 2; \n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n    if (largest != root) {\n        swap(arr[root], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\nvoid heapSort(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    heapSort(arr);\n    for (int i = 0; i < N; i++) {\n        if (i > 0) cout << \" \";\n        cout << arr[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;堆排序的时间主要由**建立初始堆**和**反复重建堆**这两部分的时间构成，建立初始堆的时间复杂度为`O(nlog2n)`，后面反复归位元素和重建堆的时间复杂度为`O(nlog2n)`，因此最好、最坏、平均时间复杂度均为`O(nlog2n)`。\n&emsp;&emsp;堆排序只使用了固定的几个辅助变量，其算法的空间复杂度为`O(1)`，同时是一种**不稳定**的排序算法。\n\n***\n## 6.归并排序（Merge Sort）\n### 核心思想\n&emsp;&emsp;通过多次将两个或两个以上的相邻有序表合并成一个新的有序表。可以分为二路归并、三路归并、多路归并排序。其中二路归并排序又可以分为**自底向上**和**自顶向下**两种方法。\n&emsp;&emsp;二路归并先将`R[0...n-1]`看成`n`个长度为`1`的有序子表，然后在进行两两相邻有序子表的合并，得到`n/2`个长度为`2`的有序子表，在进行**两两有序子表的合并**，以此类推，直到得到一个长度为`n`的有序表为止。\n&emsp;&emsp;二路归并时，先将两段有序**合并到一个新的局部变量**`R1`中，待合并完成后再将`R1`**复制回**`R`中。\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid merge(vector<int>& arr, int left, int mid, int right) {\n    vector<int> temp(right - left + 1);\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        }\n        else {\n            temp[k++] = arr[j++];\n        }\n    }\n    while (i <= mid) {\n        temp[k++] = arr[i++];\n    }\n    while (j <= right) {\n        temp[k++] = arr[j++];\n    }\n    for (int p = 0; p < k; p++) {\n        arr[left + p] = temp[p];\n    }\n}\n\nvoid mergeSort(vector<int>& arr, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);      \n    mergeSort(arr, mid + 1, right); \n    merge(arr, left, mid, right); \n}\nint main() {\n    int N;\n    cin >> N;\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    mergeSort(arr, 0, arr.size() - 1);\n    for (int i = 0; i < N; i++) {\n        if (i > 0) cout << \" \";\n        cout << arr[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;在二路归并排序中，长度为`n`的排序表需要做`log2n`趟排序，对应的**归并树**高度为`log2n+1`，每趟归并时间为`O(n)`，故其时间复杂度的最好、最坏、平均情况都是`O(nlog2n)`。\n&emsp;&emsp;在归并排序中每次都需要用到**局部变量**`R1`，最后一趟的排序一定是全部`n`个元素参与归并，所以总的辅助空间复杂度为`O(n)`。\n&emsp;&emsp;同时`Merge`算法不会改变相同关键字元素的相对次序，所以二路归并算法是一种**稳定**的排序方法！\n\n***\n有关**冒泡排序**、**选择排序**和`sort()`函数排序的相关代码在：[数据结构实验2](https://blog.csdn.net/2401_86849688/article/details/148566285?spm=1001.2014.3001.5501)中，有兴趣的可以直接传送门！\n***\n## 各种排序方法的比较和选择\n| 排序方法       | 平均情况         | 最坏情况         | 最好情况         | 空间复杂度     | 稳定性 |\n|:----------------:|:------------------:|:------------------:|:------------------:|:----------------:|:--------:|\n| 直接插入排序   | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 折半插入排序   | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 希尔排序       | $O(n^{1.58})$    | -                | -                | $O(1)$         | 不稳定 |\n| 冒泡排序       | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 快速排序       | $O(n \\log_2 n)$  | $O(n^2)$         | $O(n \\log_2 n)$  | $O(\\log_2 n)$  | 不稳定 |\n| 简单选择排序   | $O(n^2)$         | $O(n^2)$         | $O(n^2)$         | $O(1)$         | 不稳定 |\n| 堆排序         | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(1)$         | 不稳定 |\n| 归并排序       | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n)$         | 稳定   |\n\n\n封面来源：[Explaining EVERY Sorting Algorithm (part 1)](https://www.youtube.com/watch?v=AAwYzYkjNTg)\n","source":"_posts/Algorithm/Essential-Sorting-Algorithms-Explained.md","raw":"---\ntitle: Essential Sorting Algorithms Explained\ndate: 2025-07-24 23:28:06\ntags: [sort,algorithm]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Essential-Sorting-Algorithms-Explained.png\ncategory: Algorithm\ncategory_bar: true\ndescription: This article explores some of the most essential sorting algorithms in Datastructure!\nmath: true\n---\n{%fold into @ 排序算法测试样例题目 %}\n## 题目\n文章中排序算法均已经通过此题的OJ测试点！\n#### 题目描述\n给你N个自然数，编程输出排序后的这N个数。\n\n#### 输入\n第一行是整数的个数N（N<=100）。第二行是用空格隔开的N个数。\n\n#### 输出\n排序输出N个数，每个数间用一个空格间隔。\n\n#### 样例输入\n```\n5\n9 6 8 7 5\n```\n#### 样例输出\n```\n5 6 7 8 9\n```\n{%endfold%}\n*** \n![排序算法图](https://github.com/Richard110206/Blog-image/blob/main/article/Algorithm/Sorting.png?raw=true)\n\n## 1.直接插入排序（Straight Insertion Sort）\n### 核心思想\n&emsp;&emsp;将待排数组分为“已排序”和“未排序”两个部分，`R[0,1...i-1]`前面序列是已经排好的有序区，`R[i,...n]`后面的序列是未排序的无序区，直接插入排序每次操作将当前无序区的首元素`R[i]`插入到有序区`R[0,1...i-1]`的适当位置，使得`R[0,1...i]`成为新的有序区，减小无序区,直至无序区为空，从而全部数据有序！\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nbool cmp(int a, int b) { return a < b; }\nint main() {\n    int N;\n    cin >> N;\n    vector<int> R;\n    for (int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        R.push_back(a);\n    }\n    for (int i = 1; i < N; i++) {\n        int temp = R[i];//用temp临时存储待排元素\n        int j = i - 1;//让temp从i-1开始逐个向前比较\n            while (j >= 0 && cmp(temp, R[j])) {\n                R[j + 1] = R[j];\n                j--;\n            }\n            R[j + 1] = temp;\n    }\n    for (int i = 0; i < N; i++) {\n        cout << R[i] << \" \";\n    }\n    return 0;\n} \n```\n这里将比较逻辑模块化：\n```cpp\nbool cmp(int a, int b) { return a > b; }  \n```\n若未来需要修改排序规则（降序排序）只需要将`cmp`函数中的`>`修改为`<`即可！\n### 算法分析\n&emsp;&emsp;直接插入排序由**两重循环**构成，对于具有`n`个元素的数组`R`，外循环要进行`n-1`趟排序（`1到n-1`），在每趟排序中，仅当待插入序列元素`R[i]`小于有序区尾元素时才进入内层循环，因此直接插入排序的**时间性能与初始排序表相关**。\n\n- 比较次数 \n- 元素移动次数 \n\n1. 最好情况分析：初始排序表正序，无需进入内层循环时间复杂度为`O(n)`\n2. 最坏情况分析：初始排序表反序，每次排序均需要进入内层循环进行`i`次比较，等差数列`n(n-1)/2`，时间复杂度为`O(n^2)`\n3. 平均情况分析：在每趟排序中，平均情况是将`R[i]`插入到有序区的中间位置`R[0,1...i-1]`，等差数列`n(n-1)/4`，时间复杂度为`O(n^2)`。\n\n&emsp;&emsp;由于其**平均时间性能接近最坏性能**，所以是一种**低效**的排序方法。在该算法中只使用了`i`,`j`,`temp`三个辅助变量，与问题规模`n`无关，故空间复杂度为`O(1)`，是一个**就地排序**算法，同时相等时排序不变，是种**稳定**的排序算法。\n\n***\n## 2.折半插入排序（Binary Insertion Sort）\n### 核心思想\n&emsp;&emsp;在直接插入排序的基础上，用折半查找的方法找到无序区元素插入的位置。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int N;\n    cin >> N;\n    vector<int> R; \n    for (int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        R.push_back(a); \n    }\n    for (int i = 1; i < N; i++) {\n        int temp = R[i];\n        int low = 0, high = i - 1;\n        while (low <= high) {//退出循环时low=high+1\n            int mid = (low + high) / 2;\n            if (temp > R[mid]) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        for (int j = i - 1; j >= high + 1; j--) {  \n            R[j + 1] = R[j];\n        }\n        R[high + 1] = temp;\n    }\n    for (int i = 0; i < N; i++) {\n        cout << R[i] << \" \";\n    }\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;平均情况下时间复杂度为`O(n^2)`,从时间复杂度来看，折半插入与直接插入排序相同，但是当**元素数量较多时，折半查找优于顺序查找**，减少了关键字比较的次数，所以折半插入排序优于直接插入排序。同时其空间复杂度为`O(1)`，也是种**稳定**的排序算法。\n*** \n## 3.希尔排序（Shell Sort）\n### 核心思想\n&emsp;&emsp;希尔排序是一种**采用分组插入排序**的方法，先取一个小于`n`的整数${d}_{1}$作为第一个增量，将全部元素`R`中所有相距为 ${d}_{1}$的元素分成一组，在组内进行直接插入排序，然后取第二个增量 ${d}_{2}$（${d}_{2}$<${d}_{1}$），重复上述的分组和排序，直至增量 ${d}_{t}$=1，即**所有的元素为一组，在进行一次直接插入排序**，从而使得所有元素有序！\n&emsp;&emsp;从理论上讲，增量序列的取值只要满足初始值小于`n`再递减并且最后等于`1`就可以了。最常见的是**Shell增量序列**，即取 ${d}_{1}$=`n/2`，${d}_{i+1}$=${d}_{i}$/2，直到 ${d}_{t}$=0为止！\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n\tvector <int> R;\n\tint N;\n\tcin >> N;\n\tfor (int i = 0;i < N;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tR.push_back(a);\n\t}\n\tint d = N / 2;\n\twhile (d != 0) {\n\t\tfor (int i= d;i< N;i++) {\n\t\t\tint temp = R[i];\n\t\t\tint j = i;\n\t\t\twhile (j >= d && R[j - d] > temp) {\n\t\t\t\tR[j] = R[j - d];\n\t\t\t\tj -= d;\n\t\t\t}\n\t\t\tR[j] = temp;\n\t\t}\n\t\td /= 2;\n\t}\n\tfor (int i = 0;i < N;i++) {\n\t\tcout << R[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n### 算法分析\n&emsp;&emsp;由于希尔排序的增量序列不确定，算法的时间复杂度难以分析，我们一般认为其平均时间复杂度为`O(n^1.58)`，**希尔排序通常要比直接插入排序快**，在希尔排序中我们使用了`i`,`j`,`temp`,`d`四个辅助变量，与问题规模`n`无关，故算法空间复杂度为`O(1)`，也就是说是一种**就地排序**。但是希尔排序过程中相同元素的相对位置可能发生变化，因而是一种**不稳定**的排序算法。\n\n***\n## 4.快速排序（Quick Sort）\n### 核心思想\n&emsp;&emsp;在排序表中取一个元素为基准（一般是第一个），**将基准归位**（即将基准放在他最终的位置上），同时将所有小于基准的元素放到基准的前面（构成**左子表**），将所有大于基准的元素放到基准的后面（构成**右子表**），这个过程叫作**划分**。然后用递归的思想对左、右子表分别重复上述过程，直至每个子表只有一个元素或空为止。\n&emsp;&emsp;快速排序每次**仅将一个元素归位**，在最后一趟排序结束前并不产生明确的连续有序区。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint partition(vector <int>&arr, int low, int high) {\n\tint base = arr[low];\n\tint i = low + 1, j = high;\n\twhile (i <= j) {\n\t\twhile ( i <= j && arr[i] <= base) {\n\t\t\ti++;\n\t\t}\n\t\twhile (i <= j && arr[j] >= base) {\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(arr[i], arr[j]);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n\tswap(arr[low], arr[j]);\n\treturn i;\n}\nvoid quicksort(vector <int>& arr, int low, int high) {\n\tif (low >= high)return;\n\tint pi = partition(arr, low, high);\n\tquicksort(arr, low, pi-1);\n\tquicksort(arr, pi+1, high);\n}\nint main() {\n\tvector <int> R;\n\tint N;\n\tcin >> N;\n\tfor (int i = 0;i < N;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tR.push_back(a);\n\t}\n\tquicksort(R, 0, N - 1);\n\tfor (int i = 0;i < N;i++) {\n\t\tcout << R[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n### 算法分析\n1. 最好情况分析：如果初始排序表随机分布，使得**每次划分恰好分为两个长度相同的子表**，则递归树最小，性能最好，此时排序的时间复杂度为`O(nlog2n)`。\n2. 最坏情况分析：如果初始排序表**正序或反序**，使得**每次划分的两个子表中一个为空**，另一个长度为`n-1`，则递归树的高度最高，性能最差，此时排序的时间复杂度为`O(n^2)`。\n3. 平均情况分析：排序的平均时间复杂度为`O(nlog2n)`，这**接近最好情况**，所以快速排序是一种**高效**的排序方法。\n\n&emsp;&emsp;快速排序使用的是**递归算法**，尽管每一次划分仅仅使用固定的几个辅助变量，但是**递归树的高度**最好为`O(log2n)`，对应最好的空间复杂度为`O(log2n)`，最坏情况下递归树的高度为`O(n)`，对应最坏的空间复杂度为`O(n)`。\n&emsp;&emsp;另外，快速排序是一种**不稳定**的排序算法。（STL的`sort()`函数就是使用快速排序实现的，当划分的区间长度较小时，采用直接插入排序，所以`sort()`是不稳定的，且时间复杂度为`O(nlog2n)`）\n\n***\n\n## 5.堆排序（Heap Sort）\n### 核心思想\n&emsp;&emsp;堆排序是对**选择排序的一种改进**，采用**二叉树**来代替简单的选择方法来找最大或者最小元素，属于一种**树形选择排序方法**。我们采用数组隐式构建二叉树：\n1.  **小根堆**：根节点小于其两个子节点，即：$k_{i} \\leq k_{2i+1}$ 且 $k_{i} \\leq k_{2i+2}$，显然此时根节点是最小的。\n\n2.  **大根堆**：根节点大于其两个子节点，即：$k_{i} \\geq k_{2i+1}$ 且 $k_{i} \\geq k_{2i+2}$，显然此时根节点是最大的。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid heapify(vector<int>& arr, int n, int root) {\n    int largest = root; \n    int left = 2 * root + 1; \n    int right = 2 * root + 2; \n    if (left < n && arr[left] > arr[largest])\n        largest = left;\n    if (right < n && arr[right] > arr[largest])\n        largest = right;\n    if (largest != root) {\n        swap(arr[root], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\nvoid heapSort(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = n / 2 - 1; i >= 0; i--)\n        heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    heapSort(arr);\n    for (int i = 0; i < N; i++) {\n        if (i > 0) cout << \" \";\n        cout << arr[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;堆排序的时间主要由**建立初始堆**和**反复重建堆**这两部分的时间构成，建立初始堆的时间复杂度为`O(nlog2n)`，后面反复归位元素和重建堆的时间复杂度为`O(nlog2n)`，因此最好、最坏、平均时间复杂度均为`O(nlog2n)`。\n&emsp;&emsp;堆排序只使用了固定的几个辅助变量，其算法的空间复杂度为`O(1)`，同时是一种**不稳定**的排序算法。\n\n***\n## 6.归并排序（Merge Sort）\n### 核心思想\n&emsp;&emsp;通过多次将两个或两个以上的相邻有序表合并成一个新的有序表。可以分为二路归并、三路归并、多路归并排序。其中二路归并排序又可以分为**自底向上**和**自顶向下**两种方法。\n&emsp;&emsp;二路归并先将`R[0...n-1]`看成`n`个长度为`1`的有序子表，然后在进行两两相邻有序子表的合并，得到`n/2`个长度为`2`的有序子表，在进行**两两有序子表的合并**，以此类推，直到得到一个长度为`n`的有序表为止。\n&emsp;&emsp;二路归并时，先将两段有序**合并到一个新的局部变量**`R1`中，待合并完成后再将`R1`**复制回**`R`中。\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid merge(vector<int>& arr, int left, int mid, int right) {\n    vector<int> temp(right - left + 1);\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if (arr[i] <= arr[j]) {\n            temp[k++] = arr[i++];\n        }\n        else {\n            temp[k++] = arr[j++];\n        }\n    }\n    while (i <= mid) {\n        temp[k++] = arr[i++];\n    }\n    while (j <= right) {\n        temp[k++] = arr[j++];\n    }\n    for (int p = 0; p < k; p++) {\n        arr[left + p] = temp[p];\n    }\n}\n\nvoid mergeSort(vector<int>& arr, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);      \n    mergeSort(arr, mid + 1, right); \n    merge(arr, left, mid, right); \n}\nint main() {\n    int N;\n    cin >> N;\n    vector<int> arr(N);\n    for (int i = 0; i < N; i++) {\n        cin >> arr[i];\n    }\n    mergeSort(arr, 0, arr.size() - 1);\n    for (int i = 0; i < N; i++) {\n        if (i > 0) cout << \" \";\n        cout << arr[i];\n    }\n    cout << endl;\n    return 0;\n}\n```\n### 算法分析\n&emsp;&emsp;在二路归并排序中，长度为`n`的排序表需要做`log2n`趟排序，对应的**归并树**高度为`log2n+1`，每趟归并时间为`O(n)`，故其时间复杂度的最好、最坏、平均情况都是`O(nlog2n)`。\n&emsp;&emsp;在归并排序中每次都需要用到**局部变量**`R1`，最后一趟的排序一定是全部`n`个元素参与归并，所以总的辅助空间复杂度为`O(n)`。\n&emsp;&emsp;同时`Merge`算法不会改变相同关键字元素的相对次序，所以二路归并算法是一种**稳定**的排序方法！\n\n***\n有关**冒泡排序**、**选择排序**和`sort()`函数排序的相关代码在：[数据结构实验2](https://blog.csdn.net/2401_86849688/article/details/148566285?spm=1001.2014.3001.5501)中，有兴趣的可以直接传送门！\n***\n## 各种排序方法的比较和选择\n| 排序方法       | 平均情况         | 最坏情况         | 最好情况         | 空间复杂度     | 稳定性 |\n|:----------------:|:------------------:|:------------------:|:------------------:|:----------------:|:--------:|\n| 直接插入排序   | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 折半插入排序   | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 希尔排序       | $O(n^{1.58})$    | -                | -                | $O(1)$         | 不稳定 |\n| 冒泡排序       | $O(n^2)$         | $O(n^2)$         | $O(n)$           | $O(1)$         | 稳定   |\n| 快速排序       | $O(n \\log_2 n)$  | $O(n^2)$         | $O(n \\log_2 n)$  | $O(\\log_2 n)$  | 不稳定 |\n| 简单选择排序   | $O(n^2)$         | $O(n^2)$         | $O(n^2)$         | $O(1)$         | 不稳定 |\n| 堆排序         | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(1)$         | 不稳定 |\n| 归并排序       | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n \\log_2 n)$  | $O(n)$         | 稳定   |\n\n\n封面来源：[Explaining EVERY Sorting Algorithm (part 1)](https://www.youtube.com/watch?v=AAwYzYkjNTg)\n","slug":"Algorithm/Essential-Sorting-Algorithms-Explained","published":1,"updated":"2025-09-03T02:50:36.975Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hci000640w3cqyo2zay","content":"<div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-d2d6ea06\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-d2d6ea06\">\n        <div class=\"fold-arrow\">▶</div> 排序算法测试样例题目\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-d2d6ea06\">\n        <div class=\"fold-content\">\n          <h2 id=\"题目\">题目</h2><p>文章中排序算法均已经通过此题的OJ测试点！</p><h4 id=\"题目描述\">题目描述</h4><p>给你N个自然数，编程输出排序后的这N个数。</p><h4 id=\"输入\">输入</h4><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h4 id=\"输出\">输出</h4><p>排序输出N个数，每个数间用一个空格间隔。</p><h4 id=\"样例输入\">样例输入</h4><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure><h4 id=\"样例输出\">样例输出</h4><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Algorithm/Sorting.png?raw=true\" alt=\"排序算法图\"></p>\n<h2 id=\"1-直接插入排序（Straight-Insertion-Sort）\">1.直接插入排序（Straight Insertion Sort）</h2>\n<h3 id=\"核心思想\">核心思想</h3>\n<p>  将待排数组分为“已排序”和“未排序”两个部分，<code>R[0,1...i-1]</code>前面序列是已经排好的有序区，<code>R[i,...n]</code>后面的序列是未排序的无序区，直接插入排序每次操作将当前无序区的首元素<code>R[i]</code>插入到有序区<code>R[0,1...i-1]</code>的适当位置，使得<code>R[0,1...i]</code>成为新的有序区，减小无序区,直至无序区为空，从而全部数据有序！</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{ <span class=\"hljs-keyword\">return</span> a &lt; b; }<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; R;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        <span class=\"hljs-type\">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class=\"hljs-built_in\">push_back</span>(a);<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; N; i++) {<br>        <span class=\"hljs-type\">int</span> temp = R[i];<span class=\"hljs-comment\">//用temp临时存储待排元素</span><br>        <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//让temp从i-1开始逐个向前比较</span><br>            <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">cmp</span>(temp, R[j])) {<br>                R[j + <span class=\"hljs-number\">1</span>] = R[j];<br>                j--;<br>            }<br>            R[j + <span class=\"hljs-number\">1</span>] = temp;<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        cout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>} <br></code></pre></td></tr></tbody></table></figure>\n<p>这里将比较逻辑模块化：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{ <span class=\"hljs-keyword\">return</span> a &gt; b; }  <br></code></pre></td></tr></tbody></table></figure>\n<p>若未来需要修改排序规则（降序排序）只需要将<code>cmp</code>函数中的<code>&gt;</code>修改为<code>&lt;</code>即可！</p>\n<h3 id=\"算法分析\">算法分析</h3>\n<p>  直接插入排序由<strong>两重循环</strong>构成，对于具有<code>n</code>个元素的数组<code>R</code>，外循环要进行<code>n-1</code>趟排序（<code>1到n-1</code>），在每趟排序中，仅当待插入序列元素<code>R[i]</code>小于有序区尾元素时才进入内层循环，因此直接插入排序的<strong>时间性能与初始排序表相关</strong>。</p>\n<ul>\n<li>比较次数</li>\n<li>元素移动次数</li>\n</ul>\n<ol>\n<li>最好情况分析：初始排序表正序，无需进入内层循环时间复杂度为<code>O(n)</code></li>\n<li>最坏情况分析：初始排序表反序，每次排序均需要进入内层循环进行<code>i</code>次比较，等差数列<code>n(n-1)/2</code>，时间复杂度为<code>O(n^2)</code></li>\n<li>平均情况分析：在每趟排序中，平均情况是将<code>R[i]</code>插入到有序区的中间位置<code>R[0,1...i-1]</code>，等差数列<code>n(n-1)/4</code>，时间复杂度为<code>O(n^2)</code>。</li>\n</ol>\n<p>  由于其<strong>平均时间性能接近最坏性能</strong>，所以是一种<strong>低效</strong>的排序方法。在该算法中只使用了<code>i</code>,<code>j</code>,<code>temp</code>三个辅助变量，与问题规模<code>n</code>无关，故空间复杂度为<code>O(1)</code>，是一个<strong>就地排序</strong>算法，同时相等时排序不变，是种<strong>稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"2-折半插入排序（Binary-Insertion-Sort）\">2.折半插入排序（Binary Insertion Sort）</h2>\n<h3 id=\"核心思想-v2\">核心思想</h3>\n<p>  在直接插入排序的基础上，用折半查找的方法找到无序区元素插入的位置。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; R; <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        <span class=\"hljs-type\">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class=\"hljs-built_in\">push_back</span>(a); <br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; N; i++) {<br>        <span class=\"hljs-type\">int</span> temp = R[i];<br>        <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">0</span>, high = i - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (low &lt;= high) {<span class=\"hljs-comment\">//退出循环时low=high+1</span><br>            <span class=\"hljs-type\">int</span> mid = (low + high) / <span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span> (temp &gt; R[mid]) {<br>                low = mid + <span class=\"hljs-number\">1</span>;<br>            }<br>            <span class=\"hljs-keyword\">else</span> {<br>                high = mid - <span class=\"hljs-number\">1</span>;<br>            }<br>        }<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>; j &gt;= high + <span class=\"hljs-number\">1</span>; j--) {  <br>            R[j + <span class=\"hljs-number\">1</span>] = R[j];<br>        }<br>        R[high + <span class=\"hljs-number\">1</span>] = temp;<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        cout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"算法分析-v2\">算法分析</h3>\n<p>  平均情况下时间复杂度为<code>O(n^2)</code>,从时间复杂度来看，折半插入与直接插入排序相同，但是当<strong>元素数量较多时，折半查找优于顺序查找</strong>，减少了关键字比较的次数，所以折半插入排序优于直接插入排序。同时其空间复杂度为<code>O(1)</code>，也是种<strong>稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"3-希尔排序（Shell-Sort）\">3.希尔排序（Shell Sort）</h2>\n<h3 id=\"核心思想-v3\">核心思想</h3>\n<p>  希尔排序是一种<strong>采用分组插入排序</strong>的方法，先取一个小于<code>n</code>的整数${d}<em>{1}$作为第一个增量，将全部元素<code>R</code>中所有相距为 ${d}</em>{1}$的元素分成一组，在组内进行直接插入排序，然后取第二个增量 ${d}<em>{2}$（${d}</em>{2}$&lt;${d}<em>{1}$），重复上述的分组和排序，直至增量 ${d}</em>{t}$=1，即<strong>所有的元素为一组，在进行一次直接插入排序</strong>，从而使得所有元素有序！<br>\n  从理论上讲，增量序列的取值只要满足初始值小于<code>n</code>再递减并且最后等于<code>1</code>就可以了。最常见的是<strong>Shell增量序列</strong>，即取 ${d}<em>{1}$=<code>n/2</code>，${d}</em>{i+1}$=${d}<em>{i}$/2，直到 ${d}</em>{t}$=0为止！</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; R;<br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tR.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t}<br>\t<span class=\"hljs-type\">int</span> d = N / <span class=\"hljs-number\">2</span>;<br>\t<span class=\"hljs-keyword\">while</span> (d != <span class=\"hljs-number\">0</span>) {<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i= d;i&lt; N;i++) {<br>\t\t\t<span class=\"hljs-type\">int</span> temp = R[i];<br>\t\t\t<span class=\"hljs-type\">int</span> j = i;<br>\t\t\t<span class=\"hljs-keyword\">while</span> (j &gt;= d &amp;&amp; R[j - d] &gt; temp) {<br>\t\t\t\tR[j] = R[j - d];<br>\t\t\t\tj -= d;<br>\t\t\t}<br>\t\t\tR[j] = temp;<br>\t\t}<br>\t\td /= <span class=\"hljs-number\">2</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) {<br>\t\tcout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"算法分析-v3\">算法分析</h3>\n<p>  由于希尔排序的增量序列不确定，算法的时间复杂度难以分析，我们一般认为其平均时间复杂度为<code>O(n^1.58)</code>，<strong>希尔排序通常要比直接插入排序快</strong>，在希尔排序中我们使用了<code>i</code>,<code>j</code>,<code>temp</code>,<code>d</code>四个辅助变量，与问题规模<code>n</code>无关，故算法空间复杂度为<code>O(1)</code>，也就是说是一种<strong>就地排序</strong>。但是希尔排序过程中相同元素的相对位置可能发生变化，因而是一种<strong>不稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"4-快速排序（Quick-Sort）\">4.快速排序（Quick Sort）</h2>\n<h3 id=\"核心思想-v4\">核心思想</h3>\n<p>  在排序表中取一个元素为基准（一般是第一个），<strong>将基准归位</strong>（即将基准放在他最终的位置上），同时将所有小于基准的元素放到基准的前面（构成<strong>左子表</strong>），将所有大于基准的元素放到基准的后面（构成<strong>右子表</strong>），这个过程叫作<strong>划分</strong>。然后用递归的思想对左、右子表分别重复上述过程，直至每个子表只有一个元素或空为止。<br>\n  快速排序每次<strong>仅将一个元素归位</strong>，在最后一趟排序结束前并不产生明确的连续有序区。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(vector &lt;<span class=\"hljs-type\">int</span>&gt;&amp;arr, <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<br>\t<span class=\"hljs-type\">int</span> base = arr[low];<br>\t<span class=\"hljs-type\">int</span> i = low + <span class=\"hljs-number\">1</span>, j = high;<br>\t<span class=\"hljs-keyword\">while</span> (i &lt;= j) {<br>\t\t<span class=\"hljs-keyword\">while</span> ( i &lt;= j &amp;&amp; arr[i] &lt;= base) {<br>\t\t\ti++;<br>\t\t}<br>\t\t<span class=\"hljs-keyword\">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= base) {<br>\t\t\tj--;<br>\t\t}<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; j) {<br>\t\t\t<span class=\"hljs-built_in\">swap</span>(arr[i], arr[j]);<br>\t\t\ti++;<br>\t\t\tj--;<br>\t\t}<br>\t}<br>\t<span class=\"hljs-built_in\">swap</span>(arr[low], arr[j]);<br>\t<span class=\"hljs-keyword\">return</span> i;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">quicksort</span><span class=\"hljs-params\">(vector &lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>{<br>\t<span class=\"hljs-keyword\">if</span> (low &gt;= high)<span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-type\">int</span> pi = <span class=\"hljs-built_in\">partition</span>(arr, low, high);<br>\t<span class=\"hljs-built_in\">quicksort</span>(arr, low, pi<span class=\"hljs-number\">-1</span>);<br>\t<span class=\"hljs-built_in\">quicksort</span>(arr, pi<span class=\"hljs-number\">+1</span>, high);<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; R;<br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tR.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t}<br>\t<span class=\"hljs-built_in\">quicksort</span>(R, <span class=\"hljs-number\">0</span>, N - <span class=\"hljs-number\">1</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) {<br>\t\tcout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"算法分析-v4\">算法分析</h3>\n<ol>\n<li>最好情况分析：如果初始排序表随机分布，使得<strong>每次划分恰好分为两个长度相同的子表</strong>，则递归树最小，性能最好，此时排序的时间复杂度为<code>O(nlog2n)</code>。</li>\n<li>最坏情况分析：如果初始排序表<strong>正序或反序</strong>，使得<strong>每次划分的两个子表中一个为空</strong>，另一个长度为<code>n-1</code>，则递归树的高度最高，性能最差，此时排序的时间复杂度为<code>O(n^2)</code>。</li>\n<li>平均情况分析：排序的平均时间复杂度为<code>O(nlog2n)</code>，这<strong>接近最好情况</strong>，所以快速排序是一种<strong>高效</strong>的排序方法。</li>\n</ol>\n<p>  快速排序使用的是<strong>递归算法</strong>，尽管每一次划分仅仅使用固定的几个辅助变量，但是<strong>递归树的高度</strong>最好为<code>O(log2n)</code>，对应最好的空间复杂度为<code>O(log2n)</code>，最坏情况下递归树的高度为<code>O(n)</code>，对应最坏的空间复杂度为<code>O(n)</code>。<br>\n  另外，快速排序是一种<strong>不稳定</strong>的排序算法。（STL的<code>sort()</code>函数就是使用快速排序实现的，当划分的区间长度较小时，采用直接插入排序，所以<code>sort()</code>是不稳定的，且时间复杂度为<code>O(nlog2n)</code>）</p>\n<hr>\n<h2 id=\"5-堆排序（Heap-Sort）\">5.堆排序（Heap Sort）</h2>\n<h3 id=\"核心思想-v5\">核心思想</h3>\n<p>  堆排序是对<strong>选择排序的一种改进</strong>，采用<strong>二叉树</strong>来代替简单的选择方法来找最大或者最小元素，属于一种<strong>树形选择排序方法</strong>。我们采用数组隐式构建二叉树：</p>\n<ol>\n<li>\n<p><strong>小根堆</strong>：根节点小于其两个子节点，即：$k_{i} \\leq k_{2i+1}$ 且 $k_{i} \\leq k_{2i+2}$，显然此时根节点是最小的。</p>\n</li>\n<li>\n<p><strong>大根堆</strong>：根节点大于其两个子节点，即：$k_{i} \\geq k_{2i+1}$ 且 $k_{i} \\geq k_{2i+2}$，显然此时根节点是最大的。</p>\n</li>\n</ol>\n<h3 id=\"完整代码-v5\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapify</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> root)</span> </span>{<br>    <span class=\"hljs-type\">int</span> largest = root; <br>    <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * root + <span class=\"hljs-number\">1</span>; <br>    <span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * root + <span class=\"hljs-number\">2</span>; <br>    <span class=\"hljs-keyword\">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br>    <span class=\"hljs-keyword\">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br>    <span class=\"hljs-keyword\">if</span> (largest != root) {<br>        <span class=\"hljs-built_in\">swap</span>(arr[root], arr[largest]);<br>        <span class=\"hljs-built_in\">heapify</span>(arr, n, largest);<br>    }<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr)</span> </span>{<br>    <span class=\"hljs-type\">int</span> n = arr.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>        <span class=\"hljs-built_in\">heapify</span>(arr, n, i);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) {<br>        <span class=\"hljs-built_in\">swap</span>(arr[<span class=\"hljs-number\">0</span>], arr[i]);<br>        <span class=\"hljs-built_in\">heapify</span>(arr, i, <span class=\"hljs-number\">0</span>);<br>    }<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class=\"hljs-built_in\">heapSort</span>(arr);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) cout &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>        cout &lt;&lt; arr[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"算法分析-v5\">算法分析</h3>\n<p>  堆排序的时间主要由<strong>建立初始堆</strong>和<strong>反复重建堆</strong>这两部分的时间构成，建立初始堆的时间复杂度为<code>O(nlog2n)</code>，后面反复归位元素和重建堆的时间复杂度为<code>O(nlog2n)</code>，因此最好、最坏、平均时间复杂度均为<code>O(nlog2n)</code>。<br>\n  堆排序只使用了固定的几个辅助变量，其算法的空间复杂度为<code>O(1)</code>，同时是一种<strong>不稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"6-归并排序（Merge-Sort）\">6.归并排序（Merge Sort）</h2>\n<h3 id=\"核心思想-v6\">核心思想</h3>\n<p>  通过多次将两个或两个以上的相邻有序表合并成一个新的有序表。可以分为二路归并、三路归并、多路归并排序。其中二路归并排序又可以分为<strong>自底向上</strong>和<strong>自顶向下</strong>两种方法。<br>\n  二路归并先将<code>R[0...n-1]</code>看成<code>n</code>个长度为<code>1</code>的有序子表，然后在进行两两相邻有序子表的合并，得到<code>n/2</code>个长度为<code>2</code>的有序子表，在进行<strong>两两有序子表的合并</strong>，以此类推，直到得到一个长度为<code>n</code>的有序表为止。<br>\n  二路归并时，先将两段有序<strong>合并到一个新的局部变量</strong><code>R1</code>中，待合并完成后再将<code>R1</code><strong>复制回</strong><code>R</code>中。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> mid, <span class=\"hljs-type\">int</span> right)</span> </span>{<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">temp</span><span class=\"hljs-params\">(right - left + <span class=\"hljs-number\">1</span>)</span></span>;<br>    <span class=\"hljs-type\">int</span> i = left, j = mid + <span class=\"hljs-number\">1</span>, k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {<br>        <span class=\"hljs-keyword\">if</span> (arr[i] &lt;= arr[j]) {<br>            temp[k++] = arr[i++];<br>        }<br>        <span class=\"hljs-keyword\">else</span> {<br>            temp[k++] = arr[j++];<br>        }<br>    }<br>    <span class=\"hljs-keyword\">while</span> (i &lt;= mid) {<br>        temp[k++] = arr[i++];<br>    }<br>    <span class=\"hljs-keyword\">while</span> (j &lt;= right) {<br>        temp[k++] = arr[j++];<br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++) {<br>        arr[left + p] = temp[p];<br>    }<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span> </span>{<br>    <span class=\"hljs-keyword\">if</span> (left &gt;= right) {<br>        <span class=\"hljs-keyword\">return</span>;<br>    }<br>    <span class=\"hljs-type\">int</span> mid = left + (right - left) / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, left, mid);      <br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, mid + <span class=\"hljs-number\">1</span>, right); <br>    <span class=\"hljs-built_in\">merge</span>(arr, left, mid, right); <br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, <span class=\"hljs-number\">0</span>, arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {<br>        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) cout &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>        cout &lt;&lt; arr[i];<br>    }<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"算法分析-v6\">算法分析</h3>\n<p>  在二路归并排序中，长度为<code>n</code>的排序表需要做<code>log2n</code>趟排序，对应的<strong>归并树</strong>高度为<code>log2n+1</code>，每趟归并时间为<code>O(n)</code>，故其时间复杂度的最好、最坏、平均情况都是<code>O(nlog2n)</code>。<br>\n  在归并排序中每次都需要用到<strong>局部变量</strong><code>R1</code>，最后一趟的排序一定是全部<code>n</code>个元素参与归并，所以总的辅助空间复杂度为<code>O(n)</code>。<br>\n  同时<code>Merge</code>算法不会改变相同关键字元素的相对次序，所以二路归并算法是一种<strong>稳定</strong>的排序方法！</p>\n<hr>\n<p>有关<strong>冒泡排序</strong>、<strong>选择排序</strong>和<code>sort()</code>函数排序的相关代码在：<a href=\"https://blog.csdn.net/2401_86849688/article/details/148566285?spm=1001.2014.3001.5501\">数据结构实验2</a>中，有兴趣的可以直接传送门！</p>\n<hr>\n<h2 id=\"各种排序方法的比较和选择\">各种排序方法的比较和选择</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">排序方法</th>\n<th style=\"text-align:center\">平均情况</th>\n<th style=\"text-align:center\">最坏情况</th>\n<th style=\"text-align:center\">最好情况</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">直接插入排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">折半插入排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">希尔排序</td>\n<td style=\"text-align:center\">$O(n^{1.58})$</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">冒泡排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">快速排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(\\log_2 n)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">简单选择排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">堆排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">归并排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n</tbody>\n</table>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=AAwYzYkjNTg\">Explaining EVERY Sorting Algorithm (part 1)</a></p>\n","excerpt":"","more":"\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-d2d6ea06\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-d2d6ea06\">\n        <div class=\"fold-arrow\">▶</div> 排序算法测试样例题目\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-d2d6ea06\">\n        <div class=\"fold-content\">\n          <h2 id=\"题目\">题目</h2><p>文章中排序算法均已经通过此题的OJ测试点！</p><h4 id=\"题目描述\">题目描述</h4><p>给你N个自然数，编程输出排序后的这N个数。</p><h4 id=\"输入\">输入</h4><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h4 id=\"输出\">输出</h4><p>排序输出N个数，每个数间用一个空格间隔。</p><h4 id=\"样例输入\">样例输入</h4><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure><h4 id=\"样例输出\">样例输出</h4><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Algorithm/Sorting.png?raw=true\" alt=\"排序算法图\"></p>\n<h2 id=\"1-直接插入排序（Straight-Insertion-Sort）\">1.直接插入排序（Straight Insertion Sort）</h2>\n<h3 id=\"核心思想\">核心思想</h3>\n<p>  将待排数组分为“已排序”和“未排序”两个部分，<code>R[0,1...i-1]</code>前面序列是已经排好的有序区，<code>R[i,...n]</code>后面的序列是未排序的无序区，直接插入排序每次操作将当前无序区的首元素<code>R[i]</code>插入到有序区<code>R[0,1...i-1]</code>的适当位置，使得<code>R[0,1...i]</code>成为新的有序区，减小无序区,直至无序区为空，从而全部数据有序！</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a &lt; b; &#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; R;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-type\">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class=\"hljs-built_in\">push_back</span>(a);<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-type\">int</span> temp = R[i];<span class=\"hljs-comment\">//用temp临时存储待排元素</span><br>        <span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//让temp从i-1开始逐个向前比较</span><br>            <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-built_in\">cmp</span>(temp, R[j])) &#123;<br>                R[j + <span class=\"hljs-number\">1</span>] = R[j];<br>                j--;<br>            &#125;<br>            R[j + <span class=\"hljs-number\">1</span>] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        cout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>\n<p>这里将比较逻辑模块化：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cmp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a &gt; b; &#125;  <br></code></pre></td></tr></table></figure>\n<p>若未来需要修改排序规则（降序排序）只需要将<code>cmp</code>函数中的<code>&gt;</code>修改为<code>&lt;</code>即可！</p>\n<h3 id=\"算法分析\">算法分析</h3>\n<p>  直接插入排序由<strong>两重循环</strong>构成，对于具有<code>n</code>个元素的数组<code>R</code>，外循环要进行<code>n-1</code>趟排序（<code>1到n-1</code>），在每趟排序中，仅当待插入序列元素<code>R[i]</code>小于有序区尾元素时才进入内层循环，因此直接插入排序的<strong>时间性能与初始排序表相关</strong>。</p>\n<ul>\n<li>比较次数</li>\n<li>元素移动次数</li>\n</ul>\n<ol>\n<li>最好情况分析：初始排序表正序，无需进入内层循环时间复杂度为<code>O(n)</code></li>\n<li>最坏情况分析：初始排序表反序，每次排序均需要进入内层循环进行<code>i</code>次比较，等差数列<code>n(n-1)/2</code>，时间复杂度为<code>O(n^2)</code></li>\n<li>平均情况分析：在每趟排序中，平均情况是将<code>R[i]</code>插入到有序区的中间位置<code>R[0,1...i-1]</code>，等差数列<code>n(n-1)/4</code>，时间复杂度为<code>O(n^2)</code>。</li>\n</ol>\n<p>  由于其<strong>平均时间性能接近最坏性能</strong>，所以是一种<strong>低效</strong>的排序方法。在该算法中只使用了<code>i</code>,<code>j</code>,<code>temp</code>三个辅助变量，与问题规模<code>n</code>无关，故空间复杂度为<code>O(1)</code>，是一个<strong>就地排序</strong>算法，同时相等时排序不变，是种<strong>稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"2-折半插入排序（Binary-Insertion-Sort）\">2.折半插入排序（Binary Insertion Sort）</h2>\n<h3 id=\"核心思想-v2\">核心思想</h3>\n<p>  在直接插入排序的基础上，用折半查找的方法找到无序区元素插入的位置。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; R; <br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-type\">int</span> a;<br>        cin &gt;&gt; a;<br>        R.<span class=\"hljs-built_in\">push_back</span>(a); <br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-type\">int</span> temp = R[i];<br>        <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">0</span>, high = i - <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (low &lt;= high) &#123;<span class=\"hljs-comment\">//退出循环时low=high+1</span><br>            <span class=\"hljs-type\">int</span> mid = (low + high) / <span class=\"hljs-number\">2</span>;<br>            <span class=\"hljs-keyword\">if</span> (temp &gt; R[mid]) &#123;<br>                low = mid + <span class=\"hljs-number\">1</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                high = mid - <span class=\"hljs-number\">1</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = i - <span class=\"hljs-number\">1</span>; j &gt;= high + <span class=\"hljs-number\">1</span>; j--) &#123;  <br>            R[j + <span class=\"hljs-number\">1</span>] = R[j];<br>        &#125;<br>        R[high + <span class=\"hljs-number\">1</span>] = temp;<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        cout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"算法分析-v2\">算法分析</h3>\n<p>  平均情况下时间复杂度为<code>O(n^2)</code>,从时间复杂度来看，折半插入与直接插入排序相同，但是当<strong>元素数量较多时，折半查找优于顺序查找</strong>，减少了关键字比较的次数，所以折半插入排序优于直接插入排序。同时其空间复杂度为<code>O(1)</code>，也是种<strong>稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"3-希尔排序（Shell-Sort）\">3.希尔排序（Shell Sort）</h2>\n<h3 id=\"核心思想-v3\">核心思想</h3>\n<p>  希尔排序是一种<strong>采用分组插入排序</strong>的方法，先取一个小于<code>n</code>的整数${d}<em>{1}$作为第一个增量，将全部元素<code>R</code>中所有相距为 ${d}</em>{1}$的元素分成一组，在组内进行直接插入排序，然后取第二个增量 ${d}<em>{2}$（${d}</em>{2}$&lt;${d}<em>{1}$），重复上述的分组和排序，直至增量 ${d}</em>{t}$=1，即<strong>所有的元素为一组，在进行一次直接插入排序</strong>，从而使得所有元素有序！<br>\n  从理论上讲，增量序列的取值只要满足初始值小于<code>n</code>再递减并且最后等于<code>1</code>就可以了。最常见的是<strong>Shell增量序列</strong>，即取 ${d}<em>{1}$=<code>n/2</code>，${d}</em>{i+1}$=${d}<em>{i}$/2，直到 ${d}</em>{t}$=0为止！</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; R;<br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tR.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> d = N / <span class=\"hljs-number\">2</span>;<br>\t<span class=\"hljs-keyword\">while</span> (d != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i= d;i&lt; N;i++) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span> temp = R[i];<br>\t\t\t<span class=\"hljs-type\">int</span> j = i;<br>\t\t\t<span class=\"hljs-keyword\">while</span> (j &gt;= d &amp;&amp; R[j - d] &gt; temp) &#123;<br>\t\t\t\tR[j] = R[j - d];<br>\t\t\t\tj -= d;<br>\t\t\t&#125;<br>\t\t\tR[j] = temp;<br>\t\t&#125;<br>\t\td /= <span class=\"hljs-number\">2</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) &#123;<br>\t\tcout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"算法分析-v3\">算法分析</h3>\n<p>  由于希尔排序的增量序列不确定，算法的时间复杂度难以分析，我们一般认为其平均时间复杂度为<code>O(n^1.58)</code>，<strong>希尔排序通常要比直接插入排序快</strong>，在希尔排序中我们使用了<code>i</code>,<code>j</code>,<code>temp</code>,<code>d</code>四个辅助变量，与问题规模<code>n</code>无关，故算法空间复杂度为<code>O(1)</code>，也就是说是一种<strong>就地排序</strong>。但是希尔排序过程中相同元素的相对位置可能发生变化，因而是一种<strong>不稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"4-快速排序（Quick-Sort）\">4.快速排序（Quick Sort）</h2>\n<h3 id=\"核心思想-v4\">核心思想</h3>\n<p>  在排序表中取一个元素为基准（一般是第一个），<strong>将基准归位</strong>（即将基准放在他最终的位置上），同时将所有小于基准的元素放到基准的前面（构成<strong>左子表</strong>），将所有大于基准的元素放到基准的后面（构成<strong>右子表</strong>），这个过程叫作<strong>划分</strong>。然后用递归的思想对左、右子表分别重复上述过程，直至每个子表只有一个元素或空为止。<br>\n  快速排序每次<strong>仅将一个元素归位</strong>，在最后一趟排序结束前并不产生明确的连续有序区。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">partition</span><span class=\"hljs-params\">(vector &lt;<span class=\"hljs-type\">int</span>&gt;&amp;arr, <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> base = arr[low];<br>\t<span class=\"hljs-type\">int</span> i = low + <span class=\"hljs-number\">1</span>, j = high;<br>\t<span class=\"hljs-keyword\">while</span> (i &lt;= j) &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> ( i &lt;= j &amp;&amp; arr[i] &lt;= base) &#123;<br>\t\t\ti++;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">while</span> (i &lt;= j &amp;&amp; arr[j] &gt;= base) &#123;<br>\t\t\tj--;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; j) &#123;<br>\t\t\t<span class=\"hljs-built_in\">swap</span>(arr[i], arr[j]);<br>\t\t\ti++;<br>\t\t\tj--;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">swap</span>(arr[low], arr[j]);<br>\t<span class=\"hljs-keyword\">return</span> i;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">quicksort</span><span class=\"hljs-params\">(vector &lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> low, <span class=\"hljs-type\">int</span> high)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (low &gt;= high)<span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-type\">int</span> pi = <span class=\"hljs-built_in\">partition</span>(arr, low, high);<br>\t<span class=\"hljs-built_in\">quicksort</span>(arr, low, pi<span class=\"hljs-number\">-1</span>);<br>\t<span class=\"hljs-built_in\">quicksort</span>(arr, pi<span class=\"hljs-number\">+1</span>, high);<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; R;<br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tR.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">quicksort</span>(R, <span class=\"hljs-number\">0</span>, N - <span class=\"hljs-number\">1</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) &#123;<br>\t\tcout &lt;&lt; R[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"算法分析-v4\">算法分析</h3>\n<ol>\n<li>最好情况分析：如果初始排序表随机分布，使得<strong>每次划分恰好分为两个长度相同的子表</strong>，则递归树最小，性能最好，此时排序的时间复杂度为<code>O(nlog2n)</code>。</li>\n<li>最坏情况分析：如果初始排序表<strong>正序或反序</strong>，使得<strong>每次划分的两个子表中一个为空</strong>，另一个长度为<code>n-1</code>，则递归树的高度最高，性能最差，此时排序的时间复杂度为<code>O(n^2)</code>。</li>\n<li>平均情况分析：排序的平均时间复杂度为<code>O(nlog2n)</code>，这<strong>接近最好情况</strong>，所以快速排序是一种<strong>高效</strong>的排序方法。</li>\n</ol>\n<p>  快速排序使用的是<strong>递归算法</strong>，尽管每一次划分仅仅使用固定的几个辅助变量，但是<strong>递归树的高度</strong>最好为<code>O(log2n)</code>，对应最好的空间复杂度为<code>O(log2n)</code>，最坏情况下递归树的高度为<code>O(n)</code>，对应最坏的空间复杂度为<code>O(n)</code>。<br>\n  另外，快速排序是一种<strong>不稳定</strong>的排序算法。（STL的<code>sort()</code>函数就是使用快速排序实现的，当划分的区间长度较小时，采用直接插入排序，所以<code>sort()</code>是不稳定的，且时间复杂度为<code>O(nlog2n)</code>）</p>\n<hr>\n<h2 id=\"5-堆排序（Heap-Sort）\">5.堆排序（Heap Sort）</h2>\n<h3 id=\"核心思想-v5\">核心思想</h3>\n<p>  堆排序是对<strong>选择排序的一种改进</strong>，采用<strong>二叉树</strong>来代替简单的选择方法来找最大或者最小元素，属于一种<strong>树形选择排序方法</strong>。我们采用数组隐式构建二叉树：</p>\n<ol>\n<li>\n<p><strong>小根堆</strong>：根节点小于其两个子节点，即：$k_{i} \\leq k_{2i+1}$ 且 $k_{i} \\leq k_{2i+2}$，显然此时根节点是最小的。</p>\n</li>\n<li>\n<p><strong>大根堆</strong>：根节点大于其两个子节点，即：$k_{i} \\geq k_{2i+1}$ 且 $k_{i} \\geq k_{2i+2}$，显然此时根节点是最大的。</p>\n</li>\n</ol>\n<h3 id=\"完整代码-v5\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapify</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> root)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> largest = root; <br>    <span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * root + <span class=\"hljs-number\">1</span>; <br>    <span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * root + <span class=\"hljs-number\">2</span>; <br>    <span class=\"hljs-keyword\">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])<br>        largest = left;<br>    <span class=\"hljs-keyword\">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])<br>        largest = right;<br>    <span class=\"hljs-keyword\">if</span> (largest != root) &#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[root], arr[largest]);<br>        <span class=\"hljs-built_in\">heapify</span>(arr, n, largest);<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">heapSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n = arr.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--)<br>        <span class=\"hljs-built_in\">heapify</span>(arr, n, i);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; i--) &#123;<br>        <span class=\"hljs-built_in\">swap</span>(arr[<span class=\"hljs-number\">0</span>], arr[i]);<br>        <span class=\"hljs-built_in\">heapify</span>(arr, i, <span class=\"hljs-number\">0</span>);<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br>    <span class=\"hljs-built_in\">heapSort</span>(arr);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        cout &lt;&lt; arr[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"算法分析-v5\">算法分析</h3>\n<p>  堆排序的时间主要由<strong>建立初始堆</strong>和<strong>反复重建堆</strong>这两部分的时间构成，建立初始堆的时间复杂度为<code>O(nlog2n)</code>，后面反复归位元素和重建堆的时间复杂度为<code>O(nlog2n)</code>，因此最好、最坏、平均时间复杂度均为<code>O(nlog2n)</code>。<br>\n  堆排序只使用了固定的几个辅助变量，其算法的空间复杂度为<code>O(1)</code>，同时是一种<strong>不稳定</strong>的排序算法。</p>\n<hr>\n<h2 id=\"6-归并排序（Merge-Sort）\">6.归并排序（Merge Sort）</h2>\n<h3 id=\"核心思想-v6\">核心思想</h3>\n<p>  通过多次将两个或两个以上的相邻有序表合并成一个新的有序表。可以分为二路归并、三路归并、多路归并排序。其中二路归并排序又可以分为<strong>自底向上</strong>和<strong>自顶向下</strong>两种方法。<br>\n  二路归并先将<code>R[0...n-1]</code>看成<code>n</code>个长度为<code>1</code>的有序子表，然后在进行两两相邻有序子表的合并，得到<code>n/2</code>个长度为<code>2</code>的有序子表，在进行<strong>两两有序子表的合并</strong>，以此类推，直到得到一个长度为<code>n</code>的有序表为止。<br>\n  二路归并时，先将两段有序<strong>合并到一个新的局部变量</strong><code>R1</code>中，待合并完成后再将<code>R1</code><strong>复制回</strong><code>R</code>中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">merge</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> mid, <span class=\"hljs-type\">int</span> right)</span> </span>&#123;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">temp</span><span class=\"hljs-params\">(right - left + <span class=\"hljs-number\">1</span>)</span></span>;<br>    <span class=\"hljs-type\">int</span> i = left, j = mid + <span class=\"hljs-number\">1</span>, k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<br>        <span class=\"hljs-keyword\">if</span> (arr[i] &lt;= arr[j]) &#123;<br>            temp[k++] = arr[i++];<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            temp[k++] = arr[j++];<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (i &lt;= mid) &#123;<br>        temp[k++] = arr[i++];<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (j &lt;= right) &#123;<br>        temp[k++] = arr[j++];<br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">0</span>; p &lt; k; p++) &#123;<br>        arr[left + p] = temp[p];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mergeSort</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; arr, <span class=\"hljs-type\">int</span> left, <span class=\"hljs-type\">int</span> right)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (left &gt;= right) &#123;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> mid = left + (right - left) / <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, left, mid);      <br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, mid + <span class=\"hljs-number\">1</span>, right); <br>    <span class=\"hljs-built_in\">merge</span>(arr, left, mid, right); <br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(N)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br>    <span class=\"hljs-built_in\">mergeSort</span>(arr, <span class=\"hljs-number\">0</span>, arr.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>);<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span> (i &gt; <span class=\"hljs-number\">0</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        cout &lt;&lt; arr[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"算法分析-v6\">算法分析</h3>\n<p>  在二路归并排序中，长度为<code>n</code>的排序表需要做<code>log2n</code>趟排序，对应的<strong>归并树</strong>高度为<code>log2n+1</code>，每趟归并时间为<code>O(n)</code>，故其时间复杂度的最好、最坏、平均情况都是<code>O(nlog2n)</code>。<br>\n  在归并排序中每次都需要用到<strong>局部变量</strong><code>R1</code>，最后一趟的排序一定是全部<code>n</code>个元素参与归并，所以总的辅助空间复杂度为<code>O(n)</code>。<br>\n  同时<code>Merge</code>算法不会改变相同关键字元素的相对次序，所以二路归并算法是一种<strong>稳定</strong>的排序方法！</p>\n<hr>\n<p>有关<strong>冒泡排序</strong>、<strong>选择排序</strong>和<code>sort()</code>函数排序的相关代码在：<a href=\"https://blog.csdn.net/2401_86849688/article/details/148566285?spm=1001.2014.3001.5501\">数据结构实验2</a>中，有兴趣的可以直接传送门！</p>\n<hr>\n<h2 id=\"各种排序方法的比较和选择\">各种排序方法的比较和选择</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">排序方法</th>\n<th style=\"text-align:center\">平均情况</th>\n<th style=\"text-align:center\">最坏情况</th>\n<th style=\"text-align:center\">最好情况</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">稳定性</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">直接插入排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">折半插入排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">希尔排序</td>\n<td style=\"text-align:center\">$O(n^{1.58})$</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">冒泡排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">快速排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(\\log_2 n)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">简单选择排序</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(n^2)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">堆排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(1)$</td>\n<td style=\"text-align:center\">不稳定</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">归并排序</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n \\log_2 n)$</td>\n<td style=\"text-align:center\">$O(n)$</td>\n<td style=\"text-align:center\">稳定</td>\n</tr>\n</tbody>\n</table>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=AAwYzYkjNTg\">Explaining EVERY Sorting Algorithm (part 1)</a></p>\n"},{"title":"CPP Syntax Bits and Bobs","date":"2025-08-25T02:56:48.000Z","category_bar":true,"index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/CPPmemo.png?raw=true","description":"The article serves as a memo for the C++ syntax that I have forgotten, which mainly includes the new features of C++14 and C++17.","_content":"\n对在Leetcode刷题过程中遗漏的CPP语法进行补充，内容较为零碎，就先委屈一点挤挤吧:grinning:，可能较多的是C++14/17**新特性**，如若后期深入学习Modern CPP，可能就会删减单拉出去为一章节了，敬请期待！\n\n## auto\n`auto`是一个**类型占位符**，它指示编译器**自动推导变量的类型**。编译器会根据**初始化表达式**（等号右边的值）来确定`auto`变量的实际类型。\n```cpp\nint x=10;\n//等效于\nauto x=10;\n```\n```cpp\ndouble y=10.0;\n//等效于\nauto y=10.0;\n```\n```cpp\nauto f = 3.14;  //double\nauto s(\"hello\");  //const char*\nauto z = new auto(9);  //int *\nauto x1 = 5, x2 = 5.0, x3 = 'r';   //错误，必须是初始化为同一类型\n```\n但是显然，这么简单的类型推导，`auto`的作用并不大。\n\n### auto常用场景\n`auto`的真正作用是在**复杂的类型推导**中，例如**迭代器**、**lambda表达式**等，使程序更清晰易读。\n\n#### 简化复杂类型声明\n```cpp\nstd::vector<int> v = {1, 2, 3, 4, 5};\n// for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << std::endl;\n}\n```\n\n#### 范围 for 循环\n```cpp\nfor (auto element : container) {\n    // 使用 element\n}\n```\n\n#### Lambda 表达式\n```cpp\nauto lambda = [](int x, int y) { return x + y; };\n```\n\n### Limitations\n{%note info %}\n- 必须**初始化**\n```cpp\nauto x;  // 错误：无法推导类型\n```\n- 不能用于**函数参数**\n```cpp\nvoid func(auto x) {  // 错误：不能用于函数参数\n    // ...\n}\n```\n- 多变量声明需**类型一致**\n```cpp\nauto x = 10, y = 20.0;  // 错误：类型不一致\n```\n{%endnote%}\n\n## 结构化绑定\n**结构化绑定**（Structured Bindings）是C++17这是一个非常实用的**语法特性**，它允许我们**同时声明多个变量并从一个聚合类型**（如struct、pair 等）中**提取其成员**，使代码更加简洁易读。\n```cpp\nauto [var1, var2, ...] = 聚合类型;\n```\n### 解构函数\n结构化绑定可以非常方便地处理**多个返回值**的函数，例如返回`tuple`或`pair`的函数。\n```cpp\n#include <iostream>\n#include <tuple>\nusing namespace std;\ntuple<int,int> calculate(int a,int b) {\n    return {a+b,a-b};\n}\nint main() {\n    auto [add,sub]=calculate(3,1);\n    cout<<add<<endl;\n    cout<<sub<<endl;\n    return 0;\n}\n```\n### 解构结构体（类）\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct Product {\n    string name;\n    double price;\n    int stock;\n};\nProduct apple={\"apple\",4.1,50};\n\nint main() {\n    auto [name,val,stock]=apple;\n    cout<<name<<val<<stock;\n    return 0;\n}\n```\n### 解构数组（静态）\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n    int numbers[5] = {10, 20, 30, 40, 50};\n    auto [a, b, c, d, e] = numbers;\n    cout << \"Array elements: \" << a << \", \" << b << \", \" << c << \", \" << d << \", \" << e << std::endl;\n    \n    // 二维数组解构\n    int matrix[2][2] = {{1, 2}, {3, 4}};\n    auto [row1, row2] = matrix;\n    auto [r1c1, r1c2] = row1;\n    auto [r2c1, r2c2] = row2;\n    cout << \"Matrix: \" << r1c1 << \",\" << r1c2 << \" | \" << r2c1 << \",\" << r2c2 << endl;\n    \n    return 0;\n}\n```\n### 遍历容器+范围for循环\n```cpp\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\nint main() {\n    unordered_map<int, string> myMap = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\n    for (const auto& [key, value] : myMap) {\n        cout << key << \": \" << value << endl;\n    }\n}\n```\n\n## 容器函数\n### 查找最大值、最小值\n- `max_element`返回指向容器中最大元素的**迭代器**\n- `min_element`返回指向容器中最小元素的**迭代器**\n- `minmax_element`：返回一个**pair容器**，其中 first 是最小元素的**迭代器**，second 是最大元素的**迭代器**\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v={1,2,3,4,5};\n    auto [min_it,max_it]=minmax_element(v.begin(),v.end());\n    cout<<*min_it<<endl;\n    cout<<*max_it<<endl;\n    return 0;\n}\n```\n\n{%note danger%}\n:warning: 使用`*`**解引用迭代器**\n`*max_element`和`*min_element`返回是**元素值**\n{%endnote%}\n\n### 判断排序\n- `is_sorted`判断容器是否已排序(默认**升序**)：若满足`*(i+1)>=*i`时，判断**已排序**\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1={1,2,3,4,5};\n    vector<int> v2={1,3,2,4,5};\n    cout<<\"v1排序情况：\"<<is_sorted(v1.begin(),v1.end())<<endl;\n    cout<<\"v2排序情况：\"<<is_sorted(v2.begin(),v2.end())<<endl;\n    return 0;\n}\n```\n\n#### 重载比较函数\n- `is_sorted`提供**重载版本**，可以接受**自定义比较函数**（**使用lambda expression**）\n\n[Leetcode 665.非递减数列](https://leetcode.cn/problems/non-decreasing-array)\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v={5,4,3,2,1};\n    bool is_descending=is_sorted(v.begin(),v.end(),[](int a,int b){return a>b;});\n    cout<<\"v是否降序排序：\"<<is_descending<<endl;\n    return 0;\n}\n```\n\n","source":"_posts/CPP/CPP-Syntax-Bits-and-Bobs.md","raw":"---\ntitle: CPP Syntax Bits and Bobs\ndate: 2025-08-25 10:56:48\ntags: [CPP, syntax,updating]\ncategory: CPP\ncategory_bar: true\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/CPPmemo.png?raw=true\ndescription: The article serves as a memo for the C++ syntax that I have forgotten, which mainly includes the new features of C++14 and C++17.\n---\n\n对在Leetcode刷题过程中遗漏的CPP语法进行补充，内容较为零碎，就先委屈一点挤挤吧:grinning:，可能较多的是C++14/17**新特性**，如若后期深入学习Modern CPP，可能就会删减单拉出去为一章节了，敬请期待！\n\n## auto\n`auto`是一个**类型占位符**，它指示编译器**自动推导变量的类型**。编译器会根据**初始化表达式**（等号右边的值）来确定`auto`变量的实际类型。\n```cpp\nint x=10;\n//等效于\nauto x=10;\n```\n```cpp\ndouble y=10.0;\n//等效于\nauto y=10.0;\n```\n```cpp\nauto f = 3.14;  //double\nauto s(\"hello\");  //const char*\nauto z = new auto(9);  //int *\nauto x1 = 5, x2 = 5.0, x3 = 'r';   //错误，必须是初始化为同一类型\n```\n但是显然，这么简单的类型推导，`auto`的作用并不大。\n\n### auto常用场景\n`auto`的真正作用是在**复杂的类型推导**中，例如**迭代器**、**lambda表达式**等，使程序更清晰易读。\n\n#### 简化复杂类型声明\n```cpp\nstd::vector<int> v = {1, 2, 3, 4, 5};\n// for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\nfor (auto it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << std::endl;\n}\n```\n\n#### 范围 for 循环\n```cpp\nfor (auto element : container) {\n    // 使用 element\n}\n```\n\n#### Lambda 表达式\n```cpp\nauto lambda = [](int x, int y) { return x + y; };\n```\n\n### Limitations\n{%note info %}\n- 必须**初始化**\n```cpp\nauto x;  // 错误：无法推导类型\n```\n- 不能用于**函数参数**\n```cpp\nvoid func(auto x) {  // 错误：不能用于函数参数\n    // ...\n}\n```\n- 多变量声明需**类型一致**\n```cpp\nauto x = 10, y = 20.0;  // 错误：类型不一致\n```\n{%endnote%}\n\n## 结构化绑定\n**结构化绑定**（Structured Bindings）是C++17这是一个非常实用的**语法特性**，它允许我们**同时声明多个变量并从一个聚合类型**（如struct、pair 等）中**提取其成员**，使代码更加简洁易读。\n```cpp\nauto [var1, var2, ...] = 聚合类型;\n```\n### 解构函数\n结构化绑定可以非常方便地处理**多个返回值**的函数，例如返回`tuple`或`pair`的函数。\n```cpp\n#include <iostream>\n#include <tuple>\nusing namespace std;\ntuple<int,int> calculate(int a,int b) {\n    return {a+b,a-b};\n}\nint main() {\n    auto [add,sub]=calculate(3,1);\n    cout<<add<<endl;\n    cout<<sub<<endl;\n    return 0;\n}\n```\n### 解构结构体（类）\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct Product {\n    string name;\n    double price;\n    int stock;\n};\nProduct apple={\"apple\",4.1,50};\n\nint main() {\n    auto [name,val,stock]=apple;\n    cout<<name<<val<<stock;\n    return 0;\n}\n```\n### 解构数组（静态）\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n    int numbers[5] = {10, 20, 30, 40, 50};\n    auto [a, b, c, d, e] = numbers;\n    cout << \"Array elements: \" << a << \", \" << b << \", \" << c << \", \" << d << \", \" << e << std::endl;\n    \n    // 二维数组解构\n    int matrix[2][2] = {{1, 2}, {3, 4}};\n    auto [row1, row2] = matrix;\n    auto [r1c1, r1c2] = row1;\n    auto [r2c1, r2c2] = row2;\n    cout << \"Matrix: \" << r1c1 << \",\" << r1c2 << \" | \" << r2c1 << \",\" << r2c2 << endl;\n    \n    return 0;\n}\n```\n### 遍历容器+范围for循环\n```cpp\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\nint main() {\n    unordered_map<int, string> myMap = {{1, \"one\"}, {2, \"two\"}, {3, \"three\"}};\n    for (const auto& [key, value] : myMap) {\n        cout << key << \": \" << value << endl;\n    }\n}\n```\n\n## 容器函数\n### 查找最大值、最小值\n- `max_element`返回指向容器中最大元素的**迭代器**\n- `min_element`返回指向容器中最小元素的**迭代器**\n- `minmax_element`：返回一个**pair容器**，其中 first 是最小元素的**迭代器**，second 是最大元素的**迭代器**\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v={1,2,3,4,5};\n    auto [min_it,max_it]=minmax_element(v.begin(),v.end());\n    cout<<*min_it<<endl;\n    cout<<*max_it<<endl;\n    return 0;\n}\n```\n\n{%note danger%}\n:warning: 使用`*`**解引用迭代器**\n`*max_element`和`*min_element`返回是**元素值**\n{%endnote%}\n\n### 判断排序\n- `is_sorted`判断容器是否已排序(默认**升序**)：若满足`*(i+1)>=*i`时，判断**已排序**\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v1={1,2,3,4,5};\n    vector<int> v2={1,3,2,4,5};\n    cout<<\"v1排序情况：\"<<is_sorted(v1.begin(),v1.end())<<endl;\n    cout<<\"v2排序情况：\"<<is_sorted(v2.begin(),v2.end())<<endl;\n    return 0;\n}\n```\n\n#### 重载比较函数\n- `is_sorted`提供**重载版本**，可以接受**自定义比较函数**（**使用lambda expression**）\n\n[Leetcode 665.非递减数列](https://leetcode.cn/problems/non-decreasing-array)\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n    vector<int> v={5,4,3,2,1};\n    bool is_descending=is_sorted(v.begin(),v.end(),[](int a,int b){return a>b;});\n    cout<<\"v是否降序排序：\"<<is_descending<<endl;\n    return 0;\n}\n```\n\n","slug":"CPP/CPP-Syntax-Bits-and-Bobs","published":1,"updated":"2025-09-03T08:17:23.199Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcj000740w37wgp1345","content":"<p>对在Leetcode刷题过程中遗漏的CPP语法进行补充，内容较为零碎，就先委屈一点挤挤吧😀，可能较多的是C++14/17<strong>新特性</strong>，如若后期深入学习Modern CPP，可能就会删减单拉出去为一章节了，敬请期待！</p>\n<h2 id=\"auto\">auto</h2>\n<p><code>auto</code>是一个<strong>类型占位符</strong>，它指示编译器<strong>自动推导变量的类型</strong>。编译器会根据<strong>初始化表达式</strong>（等号右边的值）来确定<code>auto</code>变量的实际类型。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">//等效于</span><br><span class=\"hljs-keyword\">auto</span> x=<span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">double</span> y=<span class=\"hljs-number\">10.0</span>;<br><span class=\"hljs-comment\">//等效于</span><br><span class=\"hljs-keyword\">auto</span> y=<span class=\"hljs-number\">10.0</span>;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> f = <span class=\"hljs-number\">3.14</span>;  <span class=\"hljs-comment\">//double</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">s</span><span class=\"hljs-params\">(<span class=\"hljs-string\">\"hello\"</span>)</span></span>;  <span class=\"hljs-comment\">//const char*</span><br><span class=\"hljs-keyword\">auto</span> z = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">auto</span>(<span class=\"hljs-number\">9</span>);  <span class=\"hljs-comment\">//int *</span><br><span class=\"hljs-keyword\">auto</span> x1 = <span class=\"hljs-number\">5</span>, x2 = <span class=\"hljs-number\">5.0</span>, x3 = <span class=\"hljs-string\">'r'</span>;   <span class=\"hljs-comment\">//错误，必须是初始化为同一类型</span><br></code></pre></td></tr></tbody></table></figure>\n<p>但是显然，这么简单的类型推导，<code>auto</code>的作用并不大。</p>\n<h3 id=\"auto常用场景\">auto常用场景</h3>\n<p><code>auto</code>的真正作用是在<strong>复杂的类型推导</strong>中，例如<strong>迭代器</strong>、<strong>lambda表达式</strong>等，使程序更清晰易读。</p>\n<h4 id=\"简化复杂类型声明\">简化复杂类型声明</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; v = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};<br><span class=\"hljs-comment\">// for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) {</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = v.<span class=\"hljs-built_in\">begin</span>(); it != v.<span class=\"hljs-built_in\">end</span>(); ++it) {<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"范围-for-循环\">范围 for 循环</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> element : container) {<br>    <span class=\"hljs-comment\">// 使用 element</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"Lambda-表达式\">Lambda 表达式</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> lambda = [](<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y) { <span class=\"hljs-keyword\">return</span> x + y; };<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"Limitations\">Limitations</h3>\n<div class=\"note note-info\">\n            <ul><li>必须<strong>初始化</strong></li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> x;  <span class=\"hljs-comment\">// 错误：无法推导类型</span><br></code></pre></td></tr></tbody></table></figure><ul><li>不能用于<strong>函数参数</strong></li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">auto</span> x)</span> </span>{  <span class=\"hljs-comment\">// 错误：不能用于函数参数</span><br>    <span class=\"hljs-comment\">// ...</span><br>}<br></code></pre></td></tr></tbody></table></figure><ul><li>多变量声明需<strong>类型一致</strong></li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> x = <span class=\"hljs-number\">10</span>, y = <span class=\"hljs-number\">20.0</span>;  <span class=\"hljs-comment\">// 错误：类型不一致</span><br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<h2 id=\"结构化绑定\">结构化绑定</h2>\n<p><strong>结构化绑定</strong>（Structured Bindings）是C++17这是一个非常实用的<strong>语法特性</strong>，它允许我们<strong>同时声明多个变量并从一个聚合类型</strong>（如struct、pair 等）中<strong>提取其成员</strong>，使代码更加简洁易读。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> [var1, var2, ...] = 聚合类型;<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"解构函数\">解构函数</h3>\n<p>结构化绑定可以非常方便地处理<strong>多个返回值</strong>的函数，例如返回<code>tuple</code>或<code>pair</code>的函数。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tuple&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">tuple&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">calculate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> {a+b,a-b};<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">auto</span> [add,sub]=<span class=\"hljs-built_in\">calculate</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>);<br>    cout&lt;&lt;add&lt;&lt;endl;<br>    cout&lt;&lt;sub&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"解构结构体（类）\">解构结构体（类）</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Product</span> {<br>    string name;<br>    <span class=\"hljs-type\">double</span> price;<br>    <span class=\"hljs-type\">int</span> stock;<br>};<br>Product apple={<span class=\"hljs-string\">\"apple\"</span>,<span class=\"hljs-number\">4.1</span>,<span class=\"hljs-number\">50</span>};<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">auto</span> [name,val,stock]=apple;<br>    cout&lt;&lt;name&lt;&lt;val&lt;&lt;stock;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"解构数组（静态）\">解构数组（静态）</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> numbers[<span class=\"hljs-number\">5</span>] = {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>};<br>    <span class=\"hljs-keyword\">auto</span> [a, b, c, d, e] = numbers;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"Array elements: \"</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">\", \"</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">\", \"</span> &lt;&lt; c &lt;&lt; <span class=\"hljs-string\">\", \"</span> &lt;&lt; d &lt;&lt; <span class=\"hljs-string\">\", \"</span> &lt;&lt; e &lt;&lt; std::endl;<br>    <br>    <span class=\"hljs-comment\">// 二维数组解构</span><br>    <span class=\"hljs-type\">int</span> matrix[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}};<br>    <span class=\"hljs-keyword\">auto</span> [row1, row2] = matrix;<br>    <span class=\"hljs-keyword\">auto</span> [r1c1, r1c2] = row1;<br>    <span class=\"hljs-keyword\">auto</span> [r2c1, r2c2] = row2;<br>    cout &lt;&lt; <span class=\"hljs-string\">\"Matrix: \"</span> &lt;&lt; r1c1 &lt;&lt; <span class=\"hljs-string\">\",\"</span> &lt;&lt; r1c2 &lt;&lt; <span class=\"hljs-string\">\" | \"</span> &lt;&lt; r2c1 &lt;&lt; <span class=\"hljs-string\">\",\"</span> &lt;&lt; r2c2 &lt;&lt; endl;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"遍历容器-范围for循环\">遍历容器+范围for循环</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    unordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; myMap = {{<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"one\"</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">\"two\"</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">\"three\"</span>}};<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; [key, value] : myMap) {<br>        cout &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">\": \"</span> &lt;&lt; value &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"容器函数\">容器函数</h2>\n<h3 id=\"查找最大值、最小值\">查找最大值、最小值</h3>\n<ul>\n<li><code>max_element</code>返回指向容器中最大元素的<strong>迭代器</strong></li>\n<li><code>min_element</code>返回指向容器中最小元素的<strong>迭代器</strong></li>\n<li><code>minmax_element</code>：返回一个<strong>pair容器</strong>，其中 first 是最小元素的<strong>迭代器</strong>，second 是最大元素的<strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v={<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>};<br>    <span class=\"hljs-keyword\">auto</span> [min_it,max_it]=<span class=\"hljs-built_in\">minmax_element</span>(v.<span class=\"hljs-built_in\">begin</span>(),v.<span class=\"hljs-built_in\">end</span>());<br>    cout&lt;&lt;*min_it&lt;&lt;endl;<br>    cout&lt;&lt;*max_it&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-danger\">\n            <p>⚠️ 使用<code>*</code><strong>解引用迭代器</strong><br><code>*max_element</code>和<code>*min_element</code>返回是<strong>元素值</strong></p>\n          </div>\n<h3 id=\"判断排序\">判断排序</h3>\n<ul>\n<li><code>is_sorted</code>判断容器是否已排序(默认<strong>升序</strong>)：若满足<code>*(i+1)&gt;=*i</code>时，判断<strong>已排序</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v1={<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>};<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v2={<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>};<br>    cout&lt;&lt;<span class=\"hljs-string\">\"v1排序情况：\"</span>&lt;&lt;<span class=\"hljs-built_in\">is_sorted</span>(v<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">begin</span>(),v<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">end</span>())&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">\"v2排序情况：\"</span>&lt;&lt;<span class=\"hljs-built_in\">is_sorted</span>(v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">begin</span>(),v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">end</span>())&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"重载比较函数\">重载比较函数</h4>\n<ul>\n<li><code>is_sorted</code>提供<strong>重载版本</strong>，可以接受<strong>自定义比较函数</strong>（<strong>使用lambda expression</strong>）</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/non-decreasing-array\">Leetcode 665.非递减数列</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v={<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>};<br>    <span class=\"hljs-type\">bool</span> is_descending=<span class=\"hljs-built_in\">is_sorted</span>(v.<span class=\"hljs-built_in\">begin</span>(),v.<span class=\"hljs-built_in\">end</span>(),[](<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b){<span class=\"hljs-keyword\">return</span> a&gt;b;});<br>    cout&lt;&lt;<span class=\"hljs-string\">\"v是否降序排序：\"</span>&lt;&lt;is_descending&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<p>对在Leetcode刷题过程中遗漏的CPP语法进行补充，内容较为零碎，就先委屈一点挤挤吧😀，可能较多的是C++14/17<strong>新特性</strong>，如若后期深入学习Modern CPP，可能就会删减单拉出去为一章节了，敬请期待！</p>\n<h2 id=\"auto\">auto</h2>\n<p><code>auto</code>是一个<strong>类型占位符</strong>，它指示编译器<strong>自动推导变量的类型</strong>。编译器会根据<strong>初始化表达式</strong>（等号右边的值）来确定<code>auto</code>变量的实际类型。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-comment\">//等效于</span><br><span class=\"hljs-keyword\">auto</span> x=<span class=\"hljs-number\">10</span>;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">double</span> y=<span class=\"hljs-number\">10.0</span>;<br><span class=\"hljs-comment\">//等效于</span><br><span class=\"hljs-keyword\">auto</span> y=<span class=\"hljs-number\">10.0</span>;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> f = <span class=\"hljs-number\">3.14</span>;  <span class=\"hljs-comment\">//double</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">auto</span> <span class=\"hljs-title\">s</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;hello&quot;</span>)</span></span>;  <span class=\"hljs-comment\">//const char*</span><br><span class=\"hljs-keyword\">auto</span> z = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">auto</span>(<span class=\"hljs-number\">9</span>);  <span class=\"hljs-comment\">//int *</span><br><span class=\"hljs-keyword\">auto</span> x1 = <span class=\"hljs-number\">5</span>, x2 = <span class=\"hljs-number\">5.0</span>, x3 = <span class=\"hljs-string\">&#x27;r&#x27;</span>;   <span class=\"hljs-comment\">//错误，必须是初始化为同一类型</span><br></code></pre></td></tr></table></figure>\n<p>但是显然，这么简单的类型推导，<code>auto</code>的作用并不大。</p>\n<h3 id=\"auto常用场景\">auto常用场景</h3>\n<p><code>auto</code>的真正作用是在<strong>复杂的类型推导</strong>中，例如<strong>迭代器</strong>、<strong>lambda表达式</strong>等，使程序更清晰易读。</p>\n<h4 id=\"简化复杂类型声明\">简化复杂类型声明</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; v = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br><span class=\"hljs-comment\">// for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123;</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = v.<span class=\"hljs-built_in\">begin</span>(); it != v.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"范围-for-循环\">范围 for 循环</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> element : container) &#123;<br>    <span class=\"hljs-comment\">// 使用 element</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"Lambda-表达式\">Lambda 表达式</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> lambda = [](<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y) &#123; <span class=\"hljs-keyword\">return</span> x + y; &#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"Limitations\">Limitations</h3>\n<div class=\"note note-info\">\n            <ul><li>必须<strong>初始化</strong></li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> x;  <span class=\"hljs-comment\">// 错误：无法推导类型</span><br></code></pre></td></tr></table></figure><ul><li>不能用于<strong>函数参数</strong></li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">auto</span> x)</span> </span>&#123;  <span class=\"hljs-comment\">// 错误：不能用于函数参数</span><br>    <span class=\"hljs-comment\">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>多变量声明需<strong>类型一致</strong></li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> x = <span class=\"hljs-number\">10</span>, y = <span class=\"hljs-number\">20.0</span>;  <span class=\"hljs-comment\">// 错误：类型不一致</span><br></code></pre></td></tr></table></figure>\n          </div>\n<h2 id=\"结构化绑定\">结构化绑定</h2>\n<p><strong>结构化绑定</strong>（Structured Bindings）是C++17这是一个非常实用的<strong>语法特性</strong>，它允许我们<strong>同时声明多个变量并从一个聚合类型</strong>（如struct、pair 等）中<strong>提取其成员</strong>，使代码更加简洁易读。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> [var1, var2, ...] = 聚合类型;<br></code></pre></td></tr></table></figure>\n<h3 id=\"解构函数\">解构函数</h3>\n<p>结构化绑定可以非常方便地处理<strong>多个返回值</strong>的函数，例如返回<code>tuple</code>或<code>pair</code>的函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;tuple&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\">tuple&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">calculate</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> &#123;a+b,a-b&#125;;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">auto</span> [add,sub]=<span class=\"hljs-built_in\">calculate</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>);<br>    cout&lt;&lt;add&lt;&lt;endl;<br>    cout&lt;&lt;sub&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"解构结构体（类）\">解构结构体（类）</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Product</span> &#123;<br>    string name;<br>    <span class=\"hljs-type\">double</span> price;<br>    <span class=\"hljs-type\">int</span> stock;<br>&#125;;<br>Product apple=&#123;<span class=\"hljs-string\">&quot;apple&quot;</span>,<span class=\"hljs-number\">4.1</span>,<span class=\"hljs-number\">50</span>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">auto</span> [name,val,stock]=apple;<br>    cout&lt;&lt;name&lt;&lt;val&lt;&lt;stock;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"解构数组（静态）\">解构数组（静态）</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> numbers[<span class=\"hljs-number\">5</span>] = &#123;<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>&#125;;<br>    <span class=\"hljs-keyword\">auto</span> [a, b, c, d, e] = numbers;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Array elements: &quot;</span> &lt;&lt; a &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; d &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>    <br>    <span class=\"hljs-comment\">// 二维数组解构</span><br>    <span class=\"hljs-type\">int</span> matrix[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = &#123;&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>&#125;, &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>&#125;&#125;;<br>    <span class=\"hljs-keyword\">auto</span> [row1, row2] = matrix;<br>    <span class=\"hljs-keyword\">auto</span> [r1c1, r1c2] = row1;<br>    <span class=\"hljs-keyword\">auto</span> [r2c1, r2c2] = row2;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Matrix: &quot;</span> &lt;&lt; r1c1 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; r1c2 &lt;&lt; <span class=\"hljs-string\">&quot; | &quot;</span> &lt;&lt; r2c1 &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; r2c2 &lt;&lt; endl;<br>    <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"遍历容器-范围for循环\">遍历容器+范围for循环</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    unordered_map&lt;<span class=\"hljs-type\">int</span>, string&gt; myMap = &#123;&#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;one&quot;</span>&#125;, &#123;<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;two&quot;</span>&#125;, &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">&quot;three&quot;</span>&#125;&#125;;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; [key, value] : myMap) &#123;<br>        cout &lt;&lt; key &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; value &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"容器函数\">容器函数</h2>\n<h3 id=\"查找最大值、最小值\">查找最大值、最小值</h3>\n<ul>\n<li><code>max_element</code>返回指向容器中最大元素的<strong>迭代器</strong></li>\n<li><code>min_element</code>返回指向容器中最小元素的<strong>迭代器</strong></li>\n<li><code>minmax_element</code>：返回一个<strong>pair容器</strong>，其中 first 是最小元素的<strong>迭代器</strong>，second 是最大元素的<strong>迭代器</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;;<br>    <span class=\"hljs-keyword\">auto</span> [min_it,max_it]=<span class=\"hljs-built_in\">minmax_element</span>(v.<span class=\"hljs-built_in\">begin</span>(),v.<span class=\"hljs-built_in\">end</span>());<br>    cout&lt;&lt;*min_it&lt;&lt;endl;<br>    cout&lt;&lt;*max_it&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-danger\">\n            <p>⚠️ 使用<code>*</code><strong>解引用迭代器</strong><br><code>*max_element</code>和<code>*min_element</code>返回是<strong>元素值</strong></p>\n          </div>\n<h3 id=\"判断排序\">判断排序</h3>\n<ul>\n<li><code>is_sorted</code>判断容器是否已排序(默认<strong>升序</strong>)：若满足<code>*(i+1)&gt;=*i</code>时，判断<strong>已排序</strong></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v1=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v2=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>&#125;;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;v1排序情况：&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">is_sorted</span>(v<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">begin</span>(),v<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">end</span>())&lt;&lt;endl;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;v2排序情况：&quot;</span>&lt;&lt;<span class=\"hljs-built_in\">is_sorted</span>(v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">begin</span>(),v<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">end</span>())&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"重载比较函数\">重载比较函数</h4>\n<ul>\n<li><code>is_sorted</code>提供<strong>重载版本</strong>，可以接受<strong>自定义比较函数</strong>（<strong>使用lambda expression</strong>）</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/non-decreasing-array\">Leetcode 665.非递减数列</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; v=&#123;<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">1</span>&#125;;<br>    <span class=\"hljs-type\">bool</span> is_descending=<span class=\"hljs-built_in\">is_sorted</span>(v.<span class=\"hljs-built_in\">begin</span>(),v.<span class=\"hljs-built_in\">end</span>(),[](<span class=\"hljs-type\">int</span> a,<span class=\"hljs-type\">int</span> b)&#123;<span class=\"hljs-keyword\">return</span> a&gt;b;&#125;);<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;v是否降序排序：&quot;</span>&lt;&lt;is_descending&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Lambda Expression in CPP","date":"2025-08-25T03:36:54.000Z","category_bar":true,"index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/LambdaExpression.png?raw=true","description":"This article provides a straightforward introduction to the basic usage of lambda expressions in C++.","_content":"\n## What's Lambda Expression?\n\n`Lambda` 表达式是 C++11 标准引入的一种用于**创建匿名函数对象**的强大特性。它允许你在需要函数的地方内联地定义函数，而无需单独命名和定义函数或函数对象，这使得代码**更简洁**、**更易读**，尤其在使用 STL 算法时。\n\n## Basic Syntax\n```cpp\n[ 捕获列表 ] ( 参数列表 ) -> 返回类型 {\n    // 函数体\n}\n```\n\n1. 捕获列表 (Capture Clause) [ ]\n这是 `Lambda` 表达式的开端，也是它最独特和强大的部分。它定义了`Lambda`函数体中可以访问的外部作用域中的变量及其访问方式。\n\n{%note info %}\n- [] ：**空捕获列表**，表示不捕获任何外部变量。\n- [=] ：以**值捕获**的方式捕获**所有外部变量**。`Lambda` 体内使用的是这些变量的副本，修改副本不会影响外部变量。\n- [&] ：以**引用捕获**的方式捕获**所有外部变量**。`Lambda` 体内使用的是这些变量本身，修改它们会影响外部变量。\n```cpp\nint x = 10,y =5;\nauto f = [=]() { return x + y; };  // 按值捕获所有变量\nauto g = [&]() { x += y; };        // 按引用捕获所有变量\n```\n- [var] ：仅以**值捕获**的方式捕获**特定变量** var。\n```cpp\nint x=10;\nauto f=[x]() -> int{ //按值捕获x\n    return x+1;\n};\nstd::cout<<f(); //输出11，x的值为10未改变\n```\n- [&var] ：仅以**引用捕获**的方式捕获**特定变量** var。\n```cpp\nint x = 10;\nauto f = [&x]() { x += 1; };\nf();\nstd::cout << x;  // 输出11，x被修改\n```\n- 混合捕获：可以**组合使用**，例如 [=, &x] 表示以值捕获所有外部变量，但变量 x 除外，它以引用方式捕获。[&, x] 则表示以引用捕获所有外部变量，但变量 x 以值方式捕获。\n```cpp\nint x = 10, y = 20;\nauto f = [x, &y]() { \n    y+=x;\n    return x + y; \n};  // x按值，y按引用\n    std::cout << f();\n```\n\n{% endnote %}\n\n2. 参数列表 (Parameter List) ( )\n3. 返回类型 (Return Type) -> return_type\n{%note info %}\n可以显式地使用 `->` 后缀语法来指定 `Lambda` 的返回类型。在大多数情况下，编译器可以**自动推导出返回类型**\n```cpp\n// 自动推导返回类型为 int\nauto simple = [](int x) { return x * 2; };\n```\n```cpp\n// 显式指定返回类型为 double（即使 x 是 int）\nauto explicit_return = [](int x) -> double { return x * 2.5; };\n```\n\n当函数体包含**多个返回语句且类型不同**，或者返回语句过于复杂编译器无法推导时，需要**显式指定**。\n\n```cpp\n// 需要显式指定返回类型的例子：多个返回语句\n// auto ambiguous = [](bool test) {\n//     if (test) return 10; // 返回 int\n//     else return 20.0;    // 返回 double -> 错误！编译器无法推导\n// };\n```\n```cpp\nauto fixed = [](bool test) -> double { // 显式指定为 double\n    if (test) return 10; // int 可隐式转换为 double\n    else return 20.0;\n};\n```\n{% endnote %}\n\n4. 函数体 (Body) { }\n和普通函数一样，包含了 `Lambda` 被调用时要执行的代码。\n\n## Application\n1. 与 STL 算法配合使用\n简单的说就是STL算法用来**遍历容器**，使用`Lambda`表达式设定**特定的程序**，来处理不同的任务！\n{%note info %}\n### `std::sort` 自定义排序规则\n\n\n#### 方法1：使用默认排序（升序）\n\n```cpp\n    std::vector<int> numbers = {4, 2, 8, 5, 1};\n    std::sort(numbers.begin(), numbers.end());\n    // numbers 变为 {1, 2, 4, 5, 8}\n```\n\n#### 方法2：使用函数指针（传统方式，不推荐）\n\n```cpp\n// 传统方式：定义一个独立的比较函数\nbool compareDescending(int a, int b) {\n    return a > b; // 如果a大于b，返回true，这样a就会排在b前面\n}\n    std::sort(numbers.begin(), numbers.end(), compareDescending);\n// numbers 变为 {8, 5, 4, 2, 1}\n```\n\n#### 方法3：使用Lambda表达式（现代方式，推荐！）\n\n```cpp\n// 语法：std::sort(开始迭代器, 结束迭代器, [](参数){ 比较逻辑 });\n    std::sort(numbers.begin(), numbers.end(),\n              [](int a, int b) {\n                  return a < b; // 升序排序\n              });\n\n    std::sort(numbers.begin(), numbers.end(),\n              [](int a, int b) {\n                  return a > b; // 降序排序\n              });\n```\n```cpp\n    // 更复杂的排序规则：按奇偶性排，偶数在前，奇数在后，各自内部从小到大\n    std::vector<int> mixed = {3, 6, 1, 8, 2, 7};\n    std::sort(mixed.begin(), mixed.end(),\n              [](int a, int b) {\n                  if (a % 2 == 0 && b % 2 != 0) return true;  // a是偶数，b是奇数 -> a在前\n                  if (a % 2 != 0 && b % 2 == 0) return false; // a是奇数，b是偶数 -> b在前\n                  return a < b; // 同为奇数或同为偶数，数值小的在前\n              });\n    // mixed 变为 {2, 6, 8, 1, 3, 7}\n```\n\n\n### `std::for_each` 对每个元素执行操作\n\n```cpp\n    std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};\n    // 传统for循环\n    for (const auto& word : words) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // 使用 std::for_each + Lambda\n    // 语法：std::for_each(开始迭代器, 结束迭代器, [](元素){ 操作 });\n    std::for_each(words.begin(), words.end(),\n                  [](const std::string& w) {\n                      std::cout << w << \" \";\n                  });\n    std::cout << std::endl;\n\n    // 更实用的例子：修改元素（注意这里用引用捕获&，或者直接传引用）\n    std::vector<int> nums = {1, 2, 3, 4, 5};\n    std::for_each(nums.begin(), nums.end(),\n                  [](int& n) { // 注意参数是 int&，这样才能修改原值\n                      n *= 2; // 每个元素乘以2\n                  });\n    // nums 变为 {2, 4, 6, 8, 10}\n```\n\n### `std::find_if` 按条件查找元素\n\n```cpp\nstruct Person {\n    std::string name;\n    int age;\n};\n    std::vector<Person> people = {\n        {\"Alice\", 25},\n        {\"Bob\", 17},\n        {\"Charlie\", 30},\n        {\"David\", 16}\n    };\n\n    // 查找第一个年龄大于18岁的人\n    // 语法：auto result = std::find_if(开始, 结束, [](元素){ 判断条件 });\n    auto adultIt = std::find_if(people.begin(), people.end(),\n                                [](const Person& p) {\n                                    return p.age >= 18;\n                                });\n\n    if (adultIt != people.end()) {\n        std::cout << \"First adult: \" << adultIt->name << std::endl;\n    }\n\n    // 查找名字以'C'开头的人\n    auto nameIt = std::find_if(people.begin(), people.end(),\n                               [](const Person& p) {\n                                   return !p.name.empty() && p.name[0] == 'C';\n                               });\n```\n### `std::count_if` 统计满足条件的元素个数\n\n```cpp\n    std::vector<int> scores = {85, 92, 78, 90, 65, 88, 72, 95, 60, 81};\n\n    // 统计及格（>=60）的人数\n    int passCount = std::count_if(scores.begin(), scores.end(),\n                                  [](int score) {\n                                      return score >= 60;\n                                  });\n\n    // 统计优秀（>=90）的人数\n    int excellentCount = std::count_if(scores.begin(), scores.end(),\n                                       [](int score) {\n                                           return score >= 90;\n                                       });\n\n    std::cout << \"Pass: \" << passCount << \", Excellent: \" << excellentCount << std::endl;\n```\n### `std::transform` 转换容器中的元素 \n```cpp\n    std::vector<int> numbers = {1, 4, 9, 16, 25};\n\n    // 计算每个数的平方根\n    std::vector<double> roots(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), roots.begin(),\n                   [](int n) {\n                       return std::sqrt(n);\n                   });\n    // roots = {1, 2, 3, 4, 5}\n\n    // 将所有数字转为字符串\n    std::vector<std::string> strNumbers(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), strNumbers.begin(),\n                   [](int n) {\n                       return std::to_string(n);\n                   });\n```\n{% endnote %}\n\n2. 简化代码，增强可读性","source":"_posts/CPP/Lambda-Expression-in-CPP.md","raw":"---\ntitle: Lambda Expression in CPP\ndate: 2025-08-25 11:36:54\ntags: [CPP, syntax]\ncategory: CPP\ncategory_bar: true\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/LambdaExpression.png?raw=true\ndescription: This article provides a straightforward introduction to the basic usage of lambda expressions in C++. \n---\n\n## What's Lambda Expression?\n\n`Lambda` 表达式是 C++11 标准引入的一种用于**创建匿名函数对象**的强大特性。它允许你在需要函数的地方内联地定义函数，而无需单独命名和定义函数或函数对象，这使得代码**更简洁**、**更易读**，尤其在使用 STL 算法时。\n\n## Basic Syntax\n```cpp\n[ 捕获列表 ] ( 参数列表 ) -> 返回类型 {\n    // 函数体\n}\n```\n\n1. 捕获列表 (Capture Clause) [ ]\n这是 `Lambda` 表达式的开端，也是它最独特和强大的部分。它定义了`Lambda`函数体中可以访问的外部作用域中的变量及其访问方式。\n\n{%note info %}\n- [] ：**空捕获列表**，表示不捕获任何外部变量。\n- [=] ：以**值捕获**的方式捕获**所有外部变量**。`Lambda` 体内使用的是这些变量的副本，修改副本不会影响外部变量。\n- [&] ：以**引用捕获**的方式捕获**所有外部变量**。`Lambda` 体内使用的是这些变量本身，修改它们会影响外部变量。\n```cpp\nint x = 10,y =5;\nauto f = [=]() { return x + y; };  // 按值捕获所有变量\nauto g = [&]() { x += y; };        // 按引用捕获所有变量\n```\n- [var] ：仅以**值捕获**的方式捕获**特定变量** var。\n```cpp\nint x=10;\nauto f=[x]() -> int{ //按值捕获x\n    return x+1;\n};\nstd::cout<<f(); //输出11，x的值为10未改变\n```\n- [&var] ：仅以**引用捕获**的方式捕获**特定变量** var。\n```cpp\nint x = 10;\nauto f = [&x]() { x += 1; };\nf();\nstd::cout << x;  // 输出11，x被修改\n```\n- 混合捕获：可以**组合使用**，例如 [=, &x] 表示以值捕获所有外部变量，但变量 x 除外，它以引用方式捕获。[&, x] 则表示以引用捕获所有外部变量，但变量 x 以值方式捕获。\n```cpp\nint x = 10, y = 20;\nauto f = [x, &y]() { \n    y+=x;\n    return x + y; \n};  // x按值，y按引用\n    std::cout << f();\n```\n\n{% endnote %}\n\n2. 参数列表 (Parameter List) ( )\n3. 返回类型 (Return Type) -> return_type\n{%note info %}\n可以显式地使用 `->` 后缀语法来指定 `Lambda` 的返回类型。在大多数情况下，编译器可以**自动推导出返回类型**\n```cpp\n// 自动推导返回类型为 int\nauto simple = [](int x) { return x * 2; };\n```\n```cpp\n// 显式指定返回类型为 double（即使 x 是 int）\nauto explicit_return = [](int x) -> double { return x * 2.5; };\n```\n\n当函数体包含**多个返回语句且类型不同**，或者返回语句过于复杂编译器无法推导时，需要**显式指定**。\n\n```cpp\n// 需要显式指定返回类型的例子：多个返回语句\n// auto ambiguous = [](bool test) {\n//     if (test) return 10; // 返回 int\n//     else return 20.0;    // 返回 double -> 错误！编译器无法推导\n// };\n```\n```cpp\nauto fixed = [](bool test) -> double { // 显式指定为 double\n    if (test) return 10; // int 可隐式转换为 double\n    else return 20.0;\n};\n```\n{% endnote %}\n\n4. 函数体 (Body) { }\n和普通函数一样，包含了 `Lambda` 被调用时要执行的代码。\n\n## Application\n1. 与 STL 算法配合使用\n简单的说就是STL算法用来**遍历容器**，使用`Lambda`表达式设定**特定的程序**，来处理不同的任务！\n{%note info %}\n### `std::sort` 自定义排序规则\n\n\n#### 方法1：使用默认排序（升序）\n\n```cpp\n    std::vector<int> numbers = {4, 2, 8, 5, 1};\n    std::sort(numbers.begin(), numbers.end());\n    // numbers 变为 {1, 2, 4, 5, 8}\n```\n\n#### 方法2：使用函数指针（传统方式，不推荐）\n\n```cpp\n// 传统方式：定义一个独立的比较函数\nbool compareDescending(int a, int b) {\n    return a > b; // 如果a大于b，返回true，这样a就会排在b前面\n}\n    std::sort(numbers.begin(), numbers.end(), compareDescending);\n// numbers 变为 {8, 5, 4, 2, 1}\n```\n\n#### 方法3：使用Lambda表达式（现代方式，推荐！）\n\n```cpp\n// 语法：std::sort(开始迭代器, 结束迭代器, [](参数){ 比较逻辑 });\n    std::sort(numbers.begin(), numbers.end(),\n              [](int a, int b) {\n                  return a < b; // 升序排序\n              });\n\n    std::sort(numbers.begin(), numbers.end(),\n              [](int a, int b) {\n                  return a > b; // 降序排序\n              });\n```\n```cpp\n    // 更复杂的排序规则：按奇偶性排，偶数在前，奇数在后，各自内部从小到大\n    std::vector<int> mixed = {3, 6, 1, 8, 2, 7};\n    std::sort(mixed.begin(), mixed.end(),\n              [](int a, int b) {\n                  if (a % 2 == 0 && b % 2 != 0) return true;  // a是偶数，b是奇数 -> a在前\n                  if (a % 2 != 0 && b % 2 == 0) return false; // a是奇数，b是偶数 -> b在前\n                  return a < b; // 同为奇数或同为偶数，数值小的在前\n              });\n    // mixed 变为 {2, 6, 8, 1, 3, 7}\n```\n\n\n### `std::for_each` 对每个元素执行操作\n\n```cpp\n    std::vector<std::string> words = {\"apple\", \"banana\", \"cherry\", \"date\"};\n    // 传统for循环\n    for (const auto& word : words) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // 使用 std::for_each + Lambda\n    // 语法：std::for_each(开始迭代器, 结束迭代器, [](元素){ 操作 });\n    std::for_each(words.begin(), words.end(),\n                  [](const std::string& w) {\n                      std::cout << w << \" \";\n                  });\n    std::cout << std::endl;\n\n    // 更实用的例子：修改元素（注意这里用引用捕获&，或者直接传引用）\n    std::vector<int> nums = {1, 2, 3, 4, 5};\n    std::for_each(nums.begin(), nums.end(),\n                  [](int& n) { // 注意参数是 int&，这样才能修改原值\n                      n *= 2; // 每个元素乘以2\n                  });\n    // nums 变为 {2, 4, 6, 8, 10}\n```\n\n### `std::find_if` 按条件查找元素\n\n```cpp\nstruct Person {\n    std::string name;\n    int age;\n};\n    std::vector<Person> people = {\n        {\"Alice\", 25},\n        {\"Bob\", 17},\n        {\"Charlie\", 30},\n        {\"David\", 16}\n    };\n\n    // 查找第一个年龄大于18岁的人\n    // 语法：auto result = std::find_if(开始, 结束, [](元素){ 判断条件 });\n    auto adultIt = std::find_if(people.begin(), people.end(),\n                                [](const Person& p) {\n                                    return p.age >= 18;\n                                });\n\n    if (adultIt != people.end()) {\n        std::cout << \"First adult: \" << adultIt->name << std::endl;\n    }\n\n    // 查找名字以'C'开头的人\n    auto nameIt = std::find_if(people.begin(), people.end(),\n                               [](const Person& p) {\n                                   return !p.name.empty() && p.name[0] == 'C';\n                               });\n```\n### `std::count_if` 统计满足条件的元素个数\n\n```cpp\n    std::vector<int> scores = {85, 92, 78, 90, 65, 88, 72, 95, 60, 81};\n\n    // 统计及格（>=60）的人数\n    int passCount = std::count_if(scores.begin(), scores.end(),\n                                  [](int score) {\n                                      return score >= 60;\n                                  });\n\n    // 统计优秀（>=90）的人数\n    int excellentCount = std::count_if(scores.begin(), scores.end(),\n                                       [](int score) {\n                                           return score >= 90;\n                                       });\n\n    std::cout << \"Pass: \" << passCount << \", Excellent: \" << excellentCount << std::endl;\n```\n### `std::transform` 转换容器中的元素 \n```cpp\n    std::vector<int> numbers = {1, 4, 9, 16, 25};\n\n    // 计算每个数的平方根\n    std::vector<double> roots(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), roots.begin(),\n                   [](int n) {\n                       return std::sqrt(n);\n                   });\n    // roots = {1, 2, 3, 4, 5}\n\n    // 将所有数字转为字符串\n    std::vector<std::string> strNumbers(numbers.size());\n    std::transform(numbers.begin(), numbers.end(), strNumbers.begin(),\n                   [](int n) {\n                       return std::to_string(n);\n                   });\n```\n{% endnote %}\n\n2. 简化代码，增强可读性","slug":"CPP/Lambda-Expression-in-CPP","published":1,"updated":"2025-09-12T06:20:41.062Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcj000840w34dzjdw10","content":"<h2 id=\"What’s-Lambda-Expression\">What’s Lambda Expression?</h2>\n<p><code>Lambda</code> 表达式是 C++11 标准引入的一种用于<strong>创建匿名函数对象</strong>的强大特性。它允许你在需要函数的地方内联地定义函数，而无需单独命名和定义函数或函数对象，这使得代码<strong>更简洁</strong>、<strong>更易读</strong>，尤其在使用 STL 算法时。</p>\n<h2 id=\"Basic-Syntax\">Basic Syntax</h2>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">[ 捕获列表 ] ( 参数列表 ) -&gt; 返回类型 {<br>    <span class=\"hljs-comment\">// 函数体</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<ol>\n<li>捕获列表 (Capture Clause) [ ]<br>\n这是 <code>Lambda</code> 表达式的开端，也是它最独特和强大的部分。它定义了<code>Lambda</code>函数体中可以访问的外部作用域中的变量及其访问方式。</li>\n</ol>\n<div class=\"note note-info\">\n            <ul><li>[] ：<strong>空捕获列表</strong>，表示不捕获任何外部变量。</li><li>[=] ：以<strong>值捕获</strong>的方式捕获<strong>所有外部变量</strong>。<code>Lambda</code> 体内使用的是这些变量的副本，修改副本不会影响外部变量。</li><li>[&amp;] ：以<strong>引用捕获</strong>的方式捕获<strong>所有外部变量</strong>。<code>Lambda</code> 体内使用的是这些变量本身，修改它们会影响外部变量。</li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>,y =<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">auto</span> f = [=]() { <span class=\"hljs-keyword\">return</span> x + y; };  <span class=\"hljs-comment\">// 按值捕获所有变量</span><br><span class=\"hljs-keyword\">auto</span> g = [&amp;]() { x += y; };        <span class=\"hljs-comment\">// 按引用捕获所有变量</span><br></code></pre></td></tr></tbody></table></figure><ul><li>[var] ：仅以<strong>值捕获</strong>的方式捕获<strong>特定变量</strong> var。</li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> f=[x]() -&gt; <span class=\"hljs-type\">int</span>{ <span class=\"hljs-comment\">//按值捕获x</span><br>    <span class=\"hljs-keyword\">return</span> x<span class=\"hljs-number\">+1</span>;<br>};<br>std::cout&lt;&lt;<span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">//输出11，x的值为10未改变</span><br></code></pre></td></tr></tbody></table></figure><ul><li>[&amp;var] ：仅以<strong>引用捕获</strong>的方式捕获<strong>特定变量</strong> var。</li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> f = [&amp;x]() { x += <span class=\"hljs-number\">1</span>; };<br><span class=\"hljs-built_in\">f</span>();<br>std::cout &lt;&lt; x;  <span class=\"hljs-comment\">// 输出11，x被修改</span><br></code></pre></td></tr></tbody></table></figure><ul><li>混合捕获：可以<strong>组合使用</strong>，例如 [=, &amp;x] 表示以值捕获所有外部变量，但变量 x 除外，它以引用方式捕获。[&amp;, x] 则表示以引用捕获所有外部变量，但变量 x 以值方式捕获。</li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>, y = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-keyword\">auto</span> f = [x, &amp;y]() { <br>    y+=x;<br>    <span class=\"hljs-keyword\">return</span> x + y; <br>};  <span class=\"hljs-comment\">// x按值，y按引用</span><br>    std::cout &lt;&lt; <span class=\"hljs-built_in\">f</span>();<br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<ol start=\"2\">\n<li>参数列表 (Parameter List) ( )</li>\n<li>返回类型 (Return Type) -&gt; return_type</li>\n</ol>\n<div class=\"note note-info\">\n            <p>可以显式地使用 <code>-&gt;</code> 后缀语法来指定 <code>Lambda</code> 的返回类型。在大多数情况下，编译器可以<strong>自动推导出返回类型</strong></p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 自动推导返回类型为 int</span><br><span class=\"hljs-keyword\">auto</span> simple = [](<span class=\"hljs-type\">int</span> x) { <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; };<br></code></pre></td></tr></tbody></table></figure><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 显式指定返回类型为 double（即使 x 是 int）</span><br><span class=\"hljs-keyword\">auto</span> explicit_return = [](<span class=\"hljs-type\">int</span> x) -&gt; <span class=\"hljs-type\">double</span> { <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2.5</span>; };<br></code></pre></td></tr></tbody></table></figure><p>当函数体包含<strong>多个返回语句且类型不同</strong>，或者返回语句过于复杂编译器无法推导时，需要<strong>显式指定</strong>。</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 需要显式指定返回类型的例子：多个返回语句</span><br><span class=\"hljs-comment\">// auto ambiguous = [](bool test) {</span><br><span class=\"hljs-comment\">//     if (test) return 10; // 返回 int</span><br><span class=\"hljs-comment\">//     else return 20.0;    // 返回 double -&gt; 错误！编译器无法推导</span><br><span class=\"hljs-comment\">// };</span><br></code></pre></td></tr></tbody></table></figure><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> fixed = [](<span class=\"hljs-type\">bool</span> test) -&gt; <span class=\"hljs-type\">double</span> { <span class=\"hljs-comment\">// 显式指定为 double</span><br>    <span class=\"hljs-keyword\">if</span> (test) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// int 可隐式转换为 double</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">20.0</span>;<br>};<br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<ol start=\"4\">\n<li>函数体 (Body) { }<br>\n和普通函数一样，包含了 <code>Lambda</code> 被调用时要执行的代码。</li>\n</ol>\n<h2 id=\"Application\">Application</h2>\n<ol>\n<li>与 STL 算法配合使用<br>\n简单的说就是STL算法用来<strong>遍历容器</strong>，使用<code>Lambda</code>表达式设定<strong>特定的程序</strong>，来处理不同的任务！</li>\n</ol>\n<div class=\"note note-info\">\n            <h3 id=\"std-sort-自定义排序规则\"><code>std::sort</code> 自定义排序规则</h3><h4 id=\"方法1：使用默认排序（升序）\">方法1：使用默认排序（升序）</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>};<br>std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-comment\">// numbers 变为 {1, 2, 4, 5, 8}</span><br></code></pre></td></tr></tbody></table></figure><h4 id=\"方法2：使用函数指针（传统方式，不推荐）\">方法2：使用函数指针（传统方式，不推荐）</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 传统方式：定义一个独立的比较函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compareDescending</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> a &gt; b; <span class=\"hljs-comment\">// 如果a大于b，返回true，这样a就会排在b前面</span><br>}<br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), compareDescending);<br><span class=\"hljs-comment\">// numbers 变为 {8, 5, 4, 2, 1}</span><br></code></pre></td></tr></tbody></table></figure><h4 id=\"方法3：使用Lambda表达式（现代方式，推荐！）\">方法3：使用Lambda表达式（现代方式，推荐！）</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 语法：std::sort(开始迭代器, 结束迭代器, [](参数){ 比较逻辑 });</span><br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) {<br>                  <span class=\"hljs-keyword\">return</span> a &lt; b; <span class=\"hljs-comment\">// 升序排序</span><br>              });<br><br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) {<br>                  <span class=\"hljs-keyword\">return</span> a &gt; b; <span class=\"hljs-comment\">// 降序排序</span><br>              });<br></code></pre></td></tr></tbody></table></figure><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 更复杂的排序规则：按奇偶性排，偶数在前，奇数在后，各自内部从小到大</span><br>std::vector&lt;<span class=\"hljs-type\">int</span>&gt; mixed = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>};<br>std::<span class=\"hljs-built_in\">sort</span>(mixed.<span class=\"hljs-built_in\">begin</span>(), mixed.<span class=\"hljs-built_in\">end</span>(),<br>          [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) {<br>              <span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> &amp;&amp; b % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">// a是偶数，b是奇数 -&gt; a在前</span><br>              <span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> &amp;&amp; b % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// a是奇数，b是偶数 -&gt; b在前</span><br>              <span class=\"hljs-keyword\">return</span> a &lt; b; <span class=\"hljs-comment\">// 同为奇数或同为偶数，数值小的在前</span><br>          });<br><span class=\"hljs-comment\">// mixed 变为 {2, 6, 8, 1, 3, 7}</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"std-for-each-对每个元素执行操作\"><code>std::for_each</code> 对每个元素执行操作</h3><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;std::string&gt; words = {<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-string\">\"banana\"</span>, <span class=\"hljs-string\">\"cherry\"</span>, <span class=\"hljs-string\">\"date\"</span>};<br><span class=\"hljs-comment\">// 传统for循环</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; word : words) {<br>    std::cout &lt;&lt; word &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>}<br>std::cout &lt;&lt; std::endl;<br><br><span class=\"hljs-comment\">// 使用 std::for_each + Lambda</span><br><span class=\"hljs-comment\">// 语法：std::for_each(开始迭代器, 结束迭代器, [](元素){ 操作 });</span><br>std::for_each(words.<span class=\"hljs-built_in\">begin</span>(), words.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">const</span> std::string&amp; w) {<br>                  std::cout &lt;&lt; w &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>              });<br>std::cout &lt;&lt; std::endl;<br><br><span class=\"hljs-comment\">// 更实用的例子：修改元素（注意这里用引用捕获&amp;，或者直接传引用）</span><br>std::vector&lt;<span class=\"hljs-type\">int</span>&gt; nums = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};<br>std::for_each(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span>&amp; n) { <span class=\"hljs-comment\">// 注意参数是 int&amp;，这样才能修改原值</span><br>                  n *= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 每个元素乘以2</span><br>              });<br><span class=\"hljs-comment\">// nums 变为 {2, 4, 6, 8, 10}</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"std-find-if-按条件查找元素\"><code>std::find_if</code> 按条件查找元素</h3><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Person</span> {<br>    std::string name;<br>    <span class=\"hljs-type\">int</span> age;<br>};<br>    std::vector&lt;Person&gt; people = {<br>        {<span class=\"hljs-string\">\"Alice\"</span>, <span class=\"hljs-number\">25</span>},<br>        {<span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-number\">17</span>},<br>        {<span class=\"hljs-string\">\"Charlie\"</span>, <span class=\"hljs-number\">30</span>},<br>        {<span class=\"hljs-string\">\"David\"</span>, <span class=\"hljs-number\">16</span>}<br>    };<br><br>    <span class=\"hljs-comment\">// 查找第一个年龄大于18岁的人</span><br>    <span class=\"hljs-comment\">// 语法：auto result = std::find_if(开始, 结束, [](元素){ 判断条件 });</span><br>    <span class=\"hljs-keyword\">auto</span> adultIt = std::<span class=\"hljs-built_in\">find_if</span>(people.<span class=\"hljs-built_in\">begin</span>(), people.<span class=\"hljs-built_in\">end</span>(),<br>                                [](<span class=\"hljs-type\">const</span> Person&amp; p) {<br>                                    <span class=\"hljs-keyword\">return</span> p.age &gt;= <span class=\"hljs-number\">18</span>;<br>                                });<br><br>    <span class=\"hljs-keyword\">if</span> (adultIt != people.<span class=\"hljs-built_in\">end</span>()) {<br>        std::cout &lt;&lt; <span class=\"hljs-string\">\"First adult: \"</span> &lt;&lt; adultIt-&gt;name &lt;&lt; std::endl;<br>    }<br><br>    <span class=\"hljs-comment\">// 查找名字以'C'开头的人</span><br>    <span class=\"hljs-keyword\">auto</span> nameIt = std::<span class=\"hljs-built_in\">find_if</span>(people.<span class=\"hljs-built_in\">begin</span>(), people.<span class=\"hljs-built_in\">end</span>(),<br>                               [](<span class=\"hljs-type\">const</span> Person&amp; p) {<br>                                   <span class=\"hljs-keyword\">return</span> !p.name.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; p.name[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-string\">'C'</span>;<br>                               });<br></code></pre></td></tr></tbody></table></figure><h3 id=\"std-count-if-统计满足条件的元素个数\"><code>std::count_if</code> 统计满足条件的元素个数</h3><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; scores = {<span class=\"hljs-number\">85</span>, <span class=\"hljs-number\">92</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">65</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">72</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">60</span>, <span class=\"hljs-number\">81</span>};<br><br><span class=\"hljs-comment\">// 统计及格（&gt;=60）的人数</span><br><span class=\"hljs-type\">int</span> passCount = std::<span class=\"hljs-built_in\">count_if</span>(scores.<span class=\"hljs-built_in\">begin</span>(), scores.<span class=\"hljs-built_in\">end</span>(),<br>                              [](<span class=\"hljs-type\">int</span> score) {<br>                                  <span class=\"hljs-keyword\">return</span> score &gt;= <span class=\"hljs-number\">60</span>;<br>                              });<br><br><span class=\"hljs-comment\">// 统计优秀（&gt;=90）的人数</span><br><span class=\"hljs-type\">int</span> excellentCount = std::<span class=\"hljs-built_in\">count_if</span>(scores.<span class=\"hljs-built_in\">begin</span>(), scores.<span class=\"hljs-built_in\">end</span>(),<br>                                   [](<span class=\"hljs-type\">int</span> score) {<br>                                       <span class=\"hljs-keyword\">return</span> score &gt;= <span class=\"hljs-number\">90</span>;<br>                                   });<br><br>std::cout &lt;&lt; <span class=\"hljs-string\">\"Pass: \"</span> &lt;&lt; passCount &lt;&lt; <span class=\"hljs-string\">\", Excellent: \"</span> &lt;&lt; excellentCount &lt;&lt; std::endl;<br></code></pre></td></tr></tbody></table></figure><h3 id=\"std-transform-转换容器中的元素\"><code>std::transform</code> 转换容器中的元素</h3><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">25</span>};<br><br><span class=\"hljs-comment\">// 计算每个数的平方根</span><br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">roots</span><span class=\"hljs-params\">(numbers.size())</span></span>;<br>std::<span class=\"hljs-built_in\">transform</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), roots.<span class=\"hljs-built_in\">begin</span>(),<br>               [](<span class=\"hljs-type\">int</span> n) {<br>                   <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sqrt</span>(n);<br>               });<br><span class=\"hljs-comment\">// roots = {1, 2, 3, 4, 5}</span><br><br><span class=\"hljs-comment\">// 将所有数字转为字符串</span><br><span class=\"hljs-function\">std::vector&lt;std::string&gt; <span class=\"hljs-title\">strNumbers</span><span class=\"hljs-params\">(numbers.size())</span></span>;<br>std::<span class=\"hljs-built_in\">transform</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), strNumbers.<span class=\"hljs-built_in\">begin</span>(),<br>               [](<span class=\"hljs-type\">int</span> n) {<br>                   <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">to_string</span>(n);<br>               });<br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<ol start=\"2\">\n<li>简化代码，增强可读性</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"What’s-Lambda-Expression\">What’s Lambda Expression?</h2>\n<p><code>Lambda</code> 表达式是 C++11 标准引入的一种用于<strong>创建匿名函数对象</strong>的强大特性。它允许你在需要函数的地方内联地定义函数，而无需单独命名和定义函数或函数对象，这使得代码<strong>更简洁</strong>、<strong>更易读</strong>，尤其在使用 STL 算法时。</p>\n<h2 id=\"Basic-Syntax\">Basic Syntax</h2>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">[ 捕获列表 ] ( 参数列表 ) -&gt; 返回类型 &#123;<br>    <span class=\"hljs-comment\">// 函数体</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ol>\n<li>捕获列表 (Capture Clause) [ ]<br>\n这是 <code>Lambda</code> 表达式的开端，也是它最独特和强大的部分。它定义了<code>Lambda</code>函数体中可以访问的外部作用域中的变量及其访问方式。</li>\n</ol>\n<div class=\"note note-info\">\n            <ul><li>[] ：<strong>空捕获列表</strong>，表示不捕获任何外部变量。</li><li>[=] ：以<strong>值捕获</strong>的方式捕获<strong>所有外部变量</strong>。<code>Lambda</code> 体内使用的是这些变量的副本，修改副本不会影响外部变量。</li><li>[&amp;] ：以<strong>引用捕获</strong>的方式捕获<strong>所有外部变量</strong>。<code>Lambda</code> 体内使用的是这些变量本身，修改它们会影响外部变量。</li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>,y =<span class=\"hljs-number\">5</span>;<br><span class=\"hljs-keyword\">auto</span> f = [=]() &#123; <span class=\"hljs-keyword\">return</span> x + y; &#125;;  <span class=\"hljs-comment\">// 按值捕获所有变量</span><br><span class=\"hljs-keyword\">auto</span> g = [&amp;]() &#123; x += y; &#125;;        <span class=\"hljs-comment\">// 按引用捕获所有变量</span><br></code></pre></td></tr></table></figure><ul><li>[var] ：仅以<strong>值捕获</strong>的方式捕获<strong>特定变量</strong> var。</li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x=<span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> f=[x]() -&gt; <span class=\"hljs-type\">int</span>&#123; <span class=\"hljs-comment\">//按值捕获x</span><br>    <span class=\"hljs-keyword\">return</span> x<span class=\"hljs-number\">+1</span>;<br>&#125;;<br>std::cout&lt;&lt;<span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">//输出11，x的值为10未改变</span><br></code></pre></td></tr></table></figure><ul><li>[&amp;var] ：仅以<strong>引用捕获</strong>的方式捕获<strong>特定变量</strong> var。</li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">auto</span> f = [&amp;x]() &#123; x += <span class=\"hljs-number\">1</span>; &#125;;<br><span class=\"hljs-built_in\">f</span>();<br>std::cout &lt;&lt; x;  <span class=\"hljs-comment\">// 输出11，x被修改</span><br></code></pre></td></tr></table></figure><ul><li>混合捕获：可以<strong>组合使用</strong>，例如 [=, &amp;x] 表示以值捕获所有外部变量，但变量 x 除外，它以引用方式捕获。[&amp;, x] 则表示以引用捕获所有外部变量，但变量 x 以值方式捕获。</li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">10</span>, y = <span class=\"hljs-number\">20</span>;<br><span class=\"hljs-keyword\">auto</span> f = [x, &amp;y]() &#123; <br>    y+=x;<br>    <span class=\"hljs-keyword\">return</span> x + y; <br>&#125;;  <span class=\"hljs-comment\">// x按值，y按引用</span><br>    std::cout &lt;&lt; <span class=\"hljs-built_in\">f</span>();<br></code></pre></td></tr></table></figure>\n          </div>\n<ol start=\"2\">\n<li>参数列表 (Parameter List) ( )</li>\n<li>返回类型 (Return Type) -&gt; return_type</li>\n</ol>\n<div class=\"note note-info\">\n            <p>可以显式地使用 <code>-&gt;</code> 后缀语法来指定 <code>Lambda</code> 的返回类型。在大多数情况下，编译器可以<strong>自动推导出返回类型</strong></p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 自动推导返回类型为 int</span><br><span class=\"hljs-keyword\">auto</span> simple = [](<span class=\"hljs-type\">int</span> x) &#123; <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; &#125;;<br></code></pre></td></tr></table></figure><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 显式指定返回类型为 double（即使 x 是 int）</span><br><span class=\"hljs-keyword\">auto</span> explicit_return = [](<span class=\"hljs-type\">int</span> x) -&gt; <span class=\"hljs-type\">double</span> &#123; <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2.5</span>; &#125;;<br></code></pre></td></tr></table></figure><p>当函数体包含<strong>多个返回语句且类型不同</strong>，或者返回语句过于复杂编译器无法推导时，需要<strong>显式指定</strong>。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 需要显式指定返回类型的例子：多个返回语句</span><br><span class=\"hljs-comment\">// auto ambiguous = [](bool test) &#123;</span><br><span class=\"hljs-comment\">//     if (test) return 10; // 返回 int</span><br><span class=\"hljs-comment\">//     else return 20.0;    // 返回 double -&gt; 错误！编译器无法推导</span><br><span class=\"hljs-comment\">// &#125;;</span><br></code></pre></td></tr></table></figure><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> fixed = [](<span class=\"hljs-type\">bool</span> test) -&gt; <span class=\"hljs-type\">double</span> &#123; <span class=\"hljs-comment\">// 显式指定为 double</span><br>    <span class=\"hljs-keyword\">if</span> (test) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// int 可隐式转换为 double</span><br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">20.0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n          </div>\n<ol start=\"4\">\n<li>函数体 (Body) { }<br>\n和普通函数一样，包含了 <code>Lambda</code> 被调用时要执行的代码。</li>\n</ol>\n<h2 id=\"Application\">Application</h2>\n<ol>\n<li>与 STL 算法配合使用<br>\n简单的说就是STL算法用来<strong>遍历容器</strong>，使用<code>Lambda</code>表达式设定<strong>特定的程序</strong>，来处理不同的任务！</li>\n</ol>\n<div class=\"note note-info\">\n            <h3 id=\"std-sort-自定义排序规则\"><code>std::sort</code> 自定义排序规则</h3><h4 id=\"方法1：使用默认排序（升序）\">方法1：使用默认排序（升序）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = &#123;<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>&#125;;<br>std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>());<br><span class=\"hljs-comment\">// numbers 变为 &#123;1, 2, 4, 5, 8&#125;</span><br></code></pre></td></tr></table></figure><h4 id=\"方法2：使用函数指针（传统方式，不推荐）\">方法2：使用函数指针（传统方式，不推荐）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 传统方式：定义一个独立的比较函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">compareDescending</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> a &gt; b; <span class=\"hljs-comment\">// 如果a大于b，返回true，这样a就会排在b前面</span><br>&#125;<br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), compareDescending);<br><span class=\"hljs-comment\">// numbers 变为 &#123;8, 5, 4, 2, 1&#125;</span><br></code></pre></td></tr></table></figure><h4 id=\"方法3：使用Lambda表达式（现代方式，推荐！）\">方法3：使用Lambda表达式（现代方式，推荐！）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 语法：std::sort(开始迭代器, 结束迭代器, [](参数)&#123; 比较逻辑 &#125;);</span><br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) &#123;<br>                  <span class=\"hljs-keyword\">return</span> a &lt; b; <span class=\"hljs-comment\">// 升序排序</span><br>              &#125;);<br><br>    std::<span class=\"hljs-built_in\">sort</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) &#123;<br>                  <span class=\"hljs-keyword\">return</span> a &gt; b; <span class=\"hljs-comment\">// 降序排序</span><br>              &#125;);<br></code></pre></td></tr></table></figure><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 更复杂的排序规则：按奇偶性排，偶数在前，奇数在后，各自内部从小到大</span><br>std::vector&lt;<span class=\"hljs-type\">int</span>&gt; mixed = &#123;<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>&#125;;<br>std::<span class=\"hljs-built_in\">sort</span>(mixed.<span class=\"hljs-built_in\">begin</span>(), mixed.<span class=\"hljs-built_in\">end</span>(),<br>          [](<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b) &#123;<br>              <span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> &amp;&amp; b % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">// a是偶数，b是奇数 -&gt; a在前</span><br>              <span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> &amp;&amp; b % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">// a是奇数，b是偶数 -&gt; b在前</span><br>              <span class=\"hljs-keyword\">return</span> a &lt; b; <span class=\"hljs-comment\">// 同为奇数或同为偶数，数值小的在前</span><br>          &#125;);<br><span class=\"hljs-comment\">// mixed 变为 &#123;2, 6, 8, 1, 3, 7&#125;</span><br></code></pre></td></tr></table></figure><h3 id=\"std-for-each-对每个元素执行操作\"><code>std::for_each</code> 对每个元素执行操作</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;std::string&gt; words = &#123;<span class=\"hljs-string\">&quot;apple&quot;</span>, <span class=\"hljs-string\">&quot;banana&quot;</span>, <span class=\"hljs-string\">&quot;cherry&quot;</span>, <span class=\"hljs-string\">&quot;date&quot;</span>&#125;;<br><span class=\"hljs-comment\">// 传统for循环</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; word : words) &#123;<br>    std::cout &lt;&lt; word &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><br><span class=\"hljs-comment\">// 使用 std::for_each + Lambda</span><br><span class=\"hljs-comment\">// 语法：std::for_each(开始迭代器, 结束迭代器, [](元素)&#123; 操作 &#125;);</span><br>std::for_each(words.<span class=\"hljs-built_in\">begin</span>(), words.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">const</span> std::string&amp; w) &#123;<br>                  std::cout &lt;&lt; w &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>              &#125;);<br>std::cout &lt;&lt; std::endl;<br><br><span class=\"hljs-comment\">// 更实用的例子：修改元素（注意这里用引用捕获&amp;，或者直接传引用）</span><br>std::vector&lt;<span class=\"hljs-type\">int</span>&gt; nums = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br>std::for_each(nums.<span class=\"hljs-built_in\">begin</span>(), nums.<span class=\"hljs-built_in\">end</span>(),<br>              [](<span class=\"hljs-type\">int</span>&amp; n) &#123; <span class=\"hljs-comment\">// 注意参数是 int&amp;，这样才能修改原值</span><br>                  n *= <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 每个元素乘以2</span><br>              &#125;);<br><span class=\"hljs-comment\">// nums 变为 &#123;2, 4, 6, 8, 10&#125;</span><br></code></pre></td></tr></table></figure><h3 id=\"std-find-if-按条件查找元素\"><code>std::find_if</code> 按条件查找元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Person</span> &#123;<br>    std::string name;<br>    <span class=\"hljs-type\">int</span> age;<br>&#125;;<br>    std::vector&lt;Person&gt; people = &#123;<br>        &#123;<span class=\"hljs-string\">&quot;Alice&quot;</span>, <span class=\"hljs-number\">25</span>&#125;,<br>        &#123;<span class=\"hljs-string\">&quot;Bob&quot;</span>, <span class=\"hljs-number\">17</span>&#125;,<br>        &#123;<span class=\"hljs-string\">&quot;Charlie&quot;</span>, <span class=\"hljs-number\">30</span>&#125;,<br>        &#123;<span class=\"hljs-string\">&quot;David&quot;</span>, <span class=\"hljs-number\">16</span>&#125;<br>    &#125;;<br><br>    <span class=\"hljs-comment\">// 查找第一个年龄大于18岁的人</span><br>    <span class=\"hljs-comment\">// 语法：auto result = std::find_if(开始, 结束, [](元素)&#123; 判断条件 &#125;);</span><br>    <span class=\"hljs-keyword\">auto</span> adultIt = std::<span class=\"hljs-built_in\">find_if</span>(people.<span class=\"hljs-built_in\">begin</span>(), people.<span class=\"hljs-built_in\">end</span>(),<br>                                [](<span class=\"hljs-type\">const</span> Person&amp; p) &#123;<br>                                    <span class=\"hljs-keyword\">return</span> p.age &gt;= <span class=\"hljs-number\">18</span>;<br>                                &#125;);<br><br>    <span class=\"hljs-keyword\">if</span> (adultIt != people.<span class=\"hljs-built_in\">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;First adult: &quot;</span> &lt;&lt; adultIt-&gt;name &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class=\"hljs-comment\">// 查找名字以&#x27;C&#x27;开头的人</span><br>    <span class=\"hljs-keyword\">auto</span> nameIt = std::<span class=\"hljs-built_in\">find_if</span>(people.<span class=\"hljs-built_in\">begin</span>(), people.<span class=\"hljs-built_in\">end</span>(),<br>                               [](<span class=\"hljs-type\">const</span> Person&amp; p) &#123;<br>                                   <span class=\"hljs-keyword\">return</span> !p.name.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; p.name[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-string\">&#x27;C&#x27;</span>;<br>                               &#125;);<br></code></pre></td></tr></table></figure><h3 id=\"std-count-if-统计满足条件的元素个数\"><code>std::count_if</code> 统计满足条件的元素个数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; scores = &#123;<span class=\"hljs-number\">85</span>, <span class=\"hljs-number\">92</span>, <span class=\"hljs-number\">78</span>, <span class=\"hljs-number\">90</span>, <span class=\"hljs-number\">65</span>, <span class=\"hljs-number\">88</span>, <span class=\"hljs-number\">72</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">60</span>, <span class=\"hljs-number\">81</span>&#125;;<br><br><span class=\"hljs-comment\">// 统计及格（&gt;=60）的人数</span><br><span class=\"hljs-type\">int</span> passCount = std::<span class=\"hljs-built_in\">count_if</span>(scores.<span class=\"hljs-built_in\">begin</span>(), scores.<span class=\"hljs-built_in\">end</span>(),<br>                              [](<span class=\"hljs-type\">int</span> score) &#123;<br>                                  <span class=\"hljs-keyword\">return</span> score &gt;= <span class=\"hljs-number\">60</span>;<br>                              &#125;);<br><br><span class=\"hljs-comment\">// 统计优秀（&gt;=90）的人数</span><br><span class=\"hljs-type\">int</span> excellentCount = std::<span class=\"hljs-built_in\">count_if</span>(scores.<span class=\"hljs-built_in\">begin</span>(), scores.<span class=\"hljs-built_in\">end</span>(),<br>                                   [](<span class=\"hljs-type\">int</span> score) &#123;<br>                                       <span class=\"hljs-keyword\">return</span> score &gt;= <span class=\"hljs-number\">90</span>;<br>                                   &#125;);<br><br>std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Pass: &quot;</span> &lt;&lt; passCount &lt;&lt; <span class=\"hljs-string\">&quot;, Excellent: &quot;</span> &lt;&lt; excellentCount &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h3 id=\"std-transform-转换容器中的元素\"><code>std::transform</code> 转换容器中的元素</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">std::vector&lt;<span class=\"hljs-type\">int</span>&gt; numbers = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">25</span>&#125;;<br><br><span class=\"hljs-comment\">// 计算每个数的平方根</span><br><span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">roots</span><span class=\"hljs-params\">(numbers.size())</span></span>;<br>std::<span class=\"hljs-built_in\">transform</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), roots.<span class=\"hljs-built_in\">begin</span>(),<br>               [](<span class=\"hljs-type\">int</span> n) &#123;<br>                   <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sqrt</span>(n);<br>               &#125;);<br><span class=\"hljs-comment\">// roots = &#123;1, 2, 3, 4, 5&#125;</span><br><br><span class=\"hljs-comment\">// 将所有数字转为字符串</span><br><span class=\"hljs-function\">std::vector&lt;std::string&gt; <span class=\"hljs-title\">strNumbers</span><span class=\"hljs-params\">(numbers.size())</span></span>;<br>std::<span class=\"hljs-built_in\">transform</span>(numbers.<span class=\"hljs-built_in\">begin</span>(), numbers.<span class=\"hljs-built_in\">end</span>(), strNumbers.<span class=\"hljs-built_in\">begin</span>(),<br>               [](<span class=\"hljs-type\">int</span> n) &#123;<br>                   <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">to_string</span>(n);<br>               &#125;);<br></code></pre></td></tr></table></figure>\n          </div>\n<ol start=\"2\">\n<li>简化代码，增强可读性</li>\n</ol>\n"},{"title":"The Four Pillars of OOP in C++","date":"2025-07-17T14:40:23.000Z","category_bar":true,"archive":true,"_content":"\n\n## 抽象性 (Abstract)\n\n提取事物的本质特征，找出共性，忽略非本质特征！\n\n- ### 数据抽象\n\n抽象出对象的属性和状态的描述。（变量）\n\n- ### 行为抽象\n\n抽象出对象行为的描述。（成员函数）\n\n## 封装性 (Encapsulation)\n\n1. 设计者将对象的全部属性和行为封装在对象内部，对象的属性值（变量）只能由这个对象的行为（成员函数）来读取和修改！\n   \n2. 使用者无需关心内部结构，只需关心能做什么、如何使用！\n   \n### 成员函数的定义：\n\n- 关键词```private```、```protected```、```public```在类中使用的先后次序无关紧要，且**可以多次使用**。\n  \n- 因为类是一种数据类型，系统**不会为其分配内存空间**，所以在定义类中的数据成员时，不能对其进行初始化，也不能指定其存储类型。对于类内**非static数据成员的初始化**通常**使用构造函数**进行。\n\n1. 在**类内**定义成员函数\n\n```cpp\nclass cgoods{//商品类\n     \n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     \n     protected://无\n     \n     public:\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        }\n\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        Purchasingprice=purchasingprice;\n        }\n\n        ~cgoods(){//析构函数\n        } \n\n        void SetPurchasingprice(double purchasingprice){//设置进货价格\n        Purchasingprice=purchasingprice;\n        }\n\n        void SetSellingprice(double sellingprice){//设置出货价格\n        Sellingprice=sellingprice;\n        }\n\n        void display(){\n        cout<<\"编号\"<<ID<<endl;\n        cout<<\"名称\"<<Name<<endl;\n        cout<<\"进货价格\"<<Purchasingprice<<endl;\n        cout<<\"出货价格\"<<Sellingprice<<endl;\n        }\n}\n```\n   \n2. 在**类外**定义成员函数\n\n成员函数**在类体内进行声明**，而将成员函数的**定义放在类外**，相比于类内定义成员函数，成员函数名前要多**加上“类名::”**,“::”是作用于运算符，以说明这个函数是属于那类的成员函数，否则编译器就会认为该函数是一个普通函数。\n\n```cpp\n返回类型 类名::成员函数名(参数说明){\n     函数体\n}\n```\n```cpp\nclass cgoods{//商品类\n     \n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     \n     protected://无\n     \n     public:\n        \n        cgoods(string id, string name, double purchasingprice);//构造函数\n        \n        cgoods(string id, string name, double purchasingprice);//构造函数\n        \n        ~cgoods();//析构函数\n\n        void SetPurchasingprice(double purchasingprice);//设置进货价格\n\n        void SetSellingprice(double sellingprice);//设置出货价格\n\n        void display();//显示商品信息\n}\n\n        cgoods::cgoods(string id, string name){//构造函数\n        ID=id;\n        Name=name;\n        }\n\n        cgoods::cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        Purchasingprice=purchasingprice;\n        }\n\n        void cgoods::SetPurchasingprice(double purchasingprice){//设置进货价格\n        Purchasingprice=purchasingprice;\n        }\n\n        void cgoods::SetSellingprice(double sellingprice){//设置出货价格\n        Sellingprice=sellingprice;\n        }\n\n        void cgoods::display(){//显示商品信息\n        cout<<\"编号\"<<ID<<endl;\n        cout<<\"名称\"<<Name<<endl;\n        cout<<\"进货价格\"<<Purchasingprice<<endl;\n        cout<<\"出货价格\"<<Sellingprice<<endl;\n        }\n```\n\n## 继承性 (Inherit)\n\n派生类既能有自己新定义的属性和行为，又能够继承父类的所有属性和行为，无需重复定义，这种允许和鼓励类的重用的继承设计对于提高软件开发效率有着重要意义！\n\n## 多态性 (Polymorphism)\n\n多态性使得可以通过相同的调用方式来调用这些具有不同功能的同名函数，这样同一个属性在父类和派生类中具有不同的语义！","source":"_posts/CPP/The-Four-Pillars-of-OOP-in-C++.md","raw":"---\ntitle: The Four Pillars of OOP in C++\ndate: 2025-07-17 22:40:23\ntags: [CPP,OOP,updating]\ncategory: \n- CPP\n- OOP\ncategory_bar: true\narchive: true\n---\n\n\n## 抽象性 (Abstract)\n\n提取事物的本质特征，找出共性，忽略非本质特征！\n\n- ### 数据抽象\n\n抽象出对象的属性和状态的描述。（变量）\n\n- ### 行为抽象\n\n抽象出对象行为的描述。（成员函数）\n\n## 封装性 (Encapsulation)\n\n1. 设计者将对象的全部属性和行为封装在对象内部，对象的属性值（变量）只能由这个对象的行为（成员函数）来读取和修改！\n   \n2. 使用者无需关心内部结构，只需关心能做什么、如何使用！\n   \n### 成员函数的定义：\n\n- 关键词```private```、```protected```、```public```在类中使用的先后次序无关紧要，且**可以多次使用**。\n  \n- 因为类是一种数据类型，系统**不会为其分配内存空间**，所以在定义类中的数据成员时，不能对其进行初始化，也不能指定其存储类型。对于类内**非static数据成员的初始化**通常**使用构造函数**进行。\n\n1. 在**类内**定义成员函数\n\n```cpp\nclass cgoods{//商品类\n     \n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     \n     protected://无\n     \n     public:\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        }\n\n        cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        Purchasingprice=purchasingprice;\n        }\n\n        ~cgoods(){//析构函数\n        } \n\n        void SetPurchasingprice(double purchasingprice){//设置进货价格\n        Purchasingprice=purchasingprice;\n        }\n\n        void SetSellingprice(double sellingprice){//设置出货价格\n        Sellingprice=sellingprice;\n        }\n\n        void display(){\n        cout<<\"编号\"<<ID<<endl;\n        cout<<\"名称\"<<Name<<endl;\n        cout<<\"进货价格\"<<Purchasingprice<<endl;\n        cout<<\"出货价格\"<<Sellingprice<<endl;\n        }\n}\n```\n   \n2. 在**类外**定义成员函数\n\n成员函数**在类体内进行声明**，而将成员函数的**定义放在类外**，相比于类内定义成员函数，成员函数名前要多**加上“类名::”**,“::”是作用于运算符，以说明这个函数是属于那类的成员函数，否则编译器就会认为该函数是一个普通函数。\n\n```cpp\n返回类型 类名::成员函数名(参数说明){\n     函数体\n}\n```\n```cpp\nclass cgoods{//商品类\n     \n     private:\n        string ID; //商品编号\n        string name; //商品名称\n        double Purchasingprice; //进货价格\n        double Sellingprice; //售出价格\n        int SellCount; //售出数量\n        static double Profit; //总利润\n     \n     protected://无\n     \n     public:\n        \n        cgoods(string id, string name, double purchasingprice);//构造函数\n        \n        cgoods(string id, string name, double purchasingprice);//构造函数\n        \n        ~cgoods();//析构函数\n\n        void SetPurchasingprice(double purchasingprice);//设置进货价格\n\n        void SetSellingprice(double sellingprice);//设置出货价格\n\n        void display();//显示商品信息\n}\n\n        cgoods::cgoods(string id, string name){//构造函数\n        ID=id;\n        Name=name;\n        }\n\n        cgoods::cgoods(string id, string name, double purchasingprice){//构造函数\n        ID=id;\n        Name=name;\n        Purchasingprice=purchasingprice;\n        }\n\n        void cgoods::SetPurchasingprice(double purchasingprice){//设置进货价格\n        Purchasingprice=purchasingprice;\n        }\n\n        void cgoods::SetSellingprice(double sellingprice){//设置出货价格\n        Sellingprice=sellingprice;\n        }\n\n        void cgoods::display(){//显示商品信息\n        cout<<\"编号\"<<ID<<endl;\n        cout<<\"名称\"<<Name<<endl;\n        cout<<\"进货价格\"<<Purchasingprice<<endl;\n        cout<<\"出货价格\"<<Sellingprice<<endl;\n        }\n```\n\n## 继承性 (Inherit)\n\n派生类既能有自己新定义的属性和行为，又能够继承父类的所有属性和行为，无需重复定义，这种允许和鼓励类的重用的继承设计对于提高软件开发效率有着重要意义！\n\n## 多态性 (Polymorphism)\n\n多态性使得可以通过相同的调用方式来调用这些具有不同功能的同名函数，这样同一个属性在父类和派生类中具有不同的语义！","slug":"CPP/The-Four-Pillars-of-OOP-in-C++","published":1,"updated":"2025-08-26T03:53:35.169Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hck000b40w3dmgp8mdt","content":"<h2 id=\"抽象性-Abstract\">抽象性 (Abstract)</h2>\n<p>提取事物的本质特征，找出共性，忽略非本质特征！</p>\n<ul>\n<li>\n<h3 id=\"数据抽象\">数据抽象</h3>\n</li>\n</ul>\n<p>抽象出对象的属性和状态的描述。（变量）</p>\n<ul>\n<li>\n<h3 id=\"行为抽象\">行为抽象</h3>\n</li>\n</ul>\n<p>抽象出对象行为的描述。（成员函数）</p>\n<h2 id=\"封装性-Encapsulation\">封装性 (Encapsulation)</h2>\n<ol>\n<li>\n<p>设计者将对象的全部属性和行为封装在对象内部，对象的属性值（变量）只能由这个对象的行为（成员函数）来读取和修改！</p>\n</li>\n<li>\n<p>使用者无需关心内部结构，只需关心能做什么、如何使用！</p>\n</li>\n</ol>\n<h3 id=\"成员函数的定义：\">成员函数的定义：</h3>\n<ul>\n<li>\n<p>关键词<code>private</code>、<code>protected</code>、<code>public</code>在类中使用的先后次序无关紧要，且<strong>可以多次使用</strong>。</p>\n</li>\n<li>\n<p>因为类是一种数据类型，系统<strong>不会为其分配内存空间</strong>，所以在定义类中的数据成员时，不能对其进行初始化，也不能指定其存储类型。对于类内<strong>非static数据成员的初始化</strong>通常<strong>使用构造函数</strong>进行。</p>\n</li>\n</ul>\n<ol>\n<li>在<strong>类内</strong>定义成员函数</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>{<span class=\"hljs-comment\">//商品类</span><br>     <br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <br>     <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice){<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        }<br><br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice){<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        }<br><br>        ~<span class=\"hljs-built_in\">cgoods</span>(){<span class=\"hljs-comment\">//析构函数</span><br>        } <br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>{<span class=\"hljs-comment\">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>{<span class=\"hljs-comment\">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        }<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>{<br>        cout&lt;&lt;<span class=\"hljs-string\">\"编号\"</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"名称\"</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"进货价格\"</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"出货价格\"</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"2\">\n<li>在<strong>类外</strong>定义成员函数</li>\n</ol>\n<p>成员函数<strong>在类体内进行声明</strong>，而将成员函数的<strong>定义放在类外</strong>，相比于类内定义成员函数，成员函数名前要多<strong>加上“类名::”</strong>,“::”是作用于运算符，以说明这个函数是属于那类的成员函数，否则编译器就会认为该函数是一个普通函数。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">返回类型 类名::成员函数名(参数说明){<br>     函数体<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>{<span class=\"hljs-comment\">//商品类</span><br>     <br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <br>     <span class=\"hljs-keyword\">public</span>:<br>        <br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice);<span class=\"hljs-comment\">//构造函数</span><br>        <br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice);<span class=\"hljs-comment\">//构造函数</span><br>        <br>        ~<span class=\"hljs-built_in\">cgoods</span>();<span class=\"hljs-comment\">//析构函数</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>;<span class=\"hljs-comment\">//设置进货价格</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>;<span class=\"hljs-comment\">//设置出货价格</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//显示商品信息</span><br>}<br><br>        cgoods::<span class=\"hljs-built_in\">cgoods</span>(string id, string name){<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        }<br><br>        cgoods::<span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice){<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>{<span class=\"hljs-comment\">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        }<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>{<span class=\"hljs-comment\">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        }<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::display</span><span class=\"hljs-params\">()</span></span>{<span class=\"hljs-comment\">//显示商品信息</span><br>        cout&lt;&lt;<span class=\"hljs-string\">\"编号\"</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"名称\"</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"进货价格\"</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">\"出货价格\"</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        }<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"继承性-Inherit\">继承性 (Inherit)</h2>\n<p>派生类既能有自己新定义的属性和行为，又能够继承父类的所有属性和行为，无需重复定义，这种允许和鼓励类的重用的继承设计对于提高软件开发效率有着重要意义！</p>\n<h2 id=\"多态性-Polymorphism\">多态性 (Polymorphism)</h2>\n<p>多态性使得可以通过相同的调用方式来调用这些具有不同功能的同名函数，这样同一个属性在父类和派生类中具有不同的语义！</p>\n","excerpt":"","more":"<h2 id=\"抽象性-Abstract\">抽象性 (Abstract)</h2>\n<p>提取事物的本质特征，找出共性，忽略非本质特征！</p>\n<ul>\n<li>\n<h3 id=\"数据抽象\">数据抽象</h3>\n</li>\n</ul>\n<p>抽象出对象的属性和状态的描述。（变量）</p>\n<ul>\n<li>\n<h3 id=\"行为抽象\">行为抽象</h3>\n</li>\n</ul>\n<p>抽象出对象行为的描述。（成员函数）</p>\n<h2 id=\"封装性-Encapsulation\">封装性 (Encapsulation)</h2>\n<ol>\n<li>\n<p>设计者将对象的全部属性和行为封装在对象内部，对象的属性值（变量）只能由这个对象的行为（成员函数）来读取和修改！</p>\n</li>\n<li>\n<p>使用者无需关心内部结构，只需关心能做什么、如何使用！</p>\n</li>\n</ol>\n<h3 id=\"成员函数的定义：\">成员函数的定义：</h3>\n<ul>\n<li>\n<p>关键词<code>private</code>、<code>protected</code>、<code>public</code>在类中使用的先后次序无关紧要，且<strong>可以多次使用</strong>。</p>\n</li>\n<li>\n<p>因为类是一种数据类型，系统<strong>不会为其分配内存空间</strong>，所以在定义类中的数据成员时，不能对其进行初始化，也不能指定其存储类型。对于类内<strong>非static数据成员的初始化</strong>通常<strong>使用构造函数</strong>进行。</p>\n</li>\n</ul>\n<ol>\n<li>在<strong>类内</strong>定义成员函数</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>&#123;<span class=\"hljs-comment\">//商品类</span><br>     <br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <br>     <span class=\"hljs-keyword\">public</span>:<br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice)&#123;<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        &#125;<br><br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice)&#123;<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        &#125;<br><br>        ~<span class=\"hljs-built_in\">cgoods</span>()&#123;<span class=\"hljs-comment\">//析构函数</span><br>        &#125; <br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>&#123;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;编号&quot;</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;名称&quot;</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;进货价格&quot;</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;出货价格&quot;</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在<strong>类外</strong>定义成员函数</li>\n</ol>\n<p>成员函数<strong>在类体内进行声明</strong>，而将成员函数的<strong>定义放在类外</strong>，相比于类内定义成员函数，成员函数名前要多<strong>加上“类名::”</strong>,“::”是作用于运算符，以说明这个函数是属于那类的成员函数，否则编译器就会认为该函数是一个普通函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">返回类型 类名::成员函数名(参数说明)&#123;<br>     函数体<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">cgoods</span>&#123;<span class=\"hljs-comment\">//商品类</span><br>     <br>     <span class=\"hljs-keyword\">private</span>:<br>        string ID; <span class=\"hljs-comment\">//商品编号</span><br>        string name; <span class=\"hljs-comment\">//商品名称</span><br>        <span class=\"hljs-type\">double</span> Purchasingprice; <span class=\"hljs-comment\">//进货价格</span><br>        <span class=\"hljs-type\">double</span> Sellingprice; <span class=\"hljs-comment\">//售出价格</span><br>        <span class=\"hljs-type\">int</span> SellCount; <span class=\"hljs-comment\">//售出数量</span><br>        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> Profit; <span class=\"hljs-comment\">//总利润</span><br>     <br>     <span class=\"hljs-keyword\">protected</span>:<span class=\"hljs-comment\">//无</span><br>     <br>     <span class=\"hljs-keyword\">public</span>:<br>        <br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice);<span class=\"hljs-comment\">//构造函数</span><br>        <br>        <span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice);<span class=\"hljs-comment\">//构造函数</span><br>        <br>        ~<span class=\"hljs-built_in\">cgoods</span>();<span class=\"hljs-comment\">//析构函数</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>;<span class=\"hljs-comment\">//设置进货价格</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>;<span class=\"hljs-comment\">//设置出货价格</span><br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">display</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//显示商品信息</span><br>&#125;<br><br>        cgoods::<span class=\"hljs-built_in\">cgoods</span>(string id, string name)&#123;<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        &#125;<br><br>        cgoods::<span class=\"hljs-built_in\">cgoods</span>(string id, string name, <span class=\"hljs-type\">double</span> purchasingprice)&#123;<span class=\"hljs-comment\">//构造函数</span><br>        ID=id;<br>        Name=name;<br>        Purchasingprice=purchasingprice;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::SetPurchasingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> purchasingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置进货价格</span><br>        Purchasingprice=purchasingprice;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::SetSellingprice</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> sellingprice)</span></span>&#123;<span class=\"hljs-comment\">//设置出货价格</span><br>        Sellingprice=sellingprice;<br>        &#125;<br><br>        <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">cgoods::display</span><span class=\"hljs-params\">()</span></span>&#123;<span class=\"hljs-comment\">//显示商品信息</span><br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;编号&quot;</span>&lt;&lt;ID&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;名称&quot;</span>&lt;&lt;Name&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;进货价格&quot;</span>&lt;&lt;Purchasingprice&lt;&lt;endl;<br>        cout&lt;&lt;<span class=\"hljs-string\">&quot;出货价格&quot;</span>&lt;&lt;Sellingprice&lt;&lt;endl;<br>        &#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"继承性-Inherit\">继承性 (Inherit)</h2>\n<p>派生类既能有自己新定义的属性和行为，又能够继承父类的所有属性和行为，无需重复定义，这种允许和鼓励类的重用的继承设计对于提高软件开发效率有着重要意义！</p>\n<h2 id=\"多态性-Polymorphism\">多态性 (Polymorphism)</h2>\n<p>多态性使得可以通过相同的调用方式来调用这些具有不同功能的同名函数，这样同一个属性在父类和派生类中具有不同的语义！</p>\n"},{"title":"CUMT-Datastructure-Assignment 1","date":"2025-06-08T14:29:13.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Assignment-1.png","category_bar":true,"description":"The Josephus problem involving circular linked lists and stack-related problems","_content":"\n\n\n\n## E题： 约瑟夫问题\n{%fold into @ E题：约瑟夫问题 %}\n### 题目描述\n\n编写一个程序求解约瑟夫（Joseph）问题。有n个小孩围成一圈，给他们从1开始依次编号，从编号为1的小孩开始报数，数到第m（0<m<n）个小孩出列，然后从出列的下一个小孩重新开始报数，数到第m个小孩又出列，…，如此反复直到所有的小孩全部出列为止，求整个出列序列。\n\n### 输入\n占一行为n和m（n<100）。\n### 输出\n整个出列序列。\n### 样例输入\n```\n6 5\n```\n### 样例输出\n```\n5 4 6 2 3 1\n```\n{%endfold%}\n### 问题分析\n  约瑟夫问题是一个经典的使用循环链表的问题，**解题思路**如下：  \n1. **创建循环链表**：通过结构体`struct`创建孩子结点，创建`head`**头结点**和指向当前结点**可供遍历进行移动**的指针`cur`，再通过`for`循环遍历，用`new`运算**动态分配内存**，给每个孩子结点的`num`域赋上编号的初值，最后**将尾结点的指针域指向头结点**，完成链表的闭合，实现循环链表的功能。\n2. **模拟报数过程**：通过`cur`指针，计数`m-1`个孩子后，`delete`**删除下一个结点释放内存**。\n3. **重复过程**：重复执行，直至有`cur==cur->next`时，即链表中只剩下一个孩子时终止遍历。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\n//定义孩子结点的结构体\n\tstruct Child{\n\t\tint num;//孩子编号\n\t\tChild* next;//指向下一个孩子的指针\n\t};\n\t//约瑟夫问题解决主函数\n\tvoid Joseph(int n,int m) {\n\t\tChild* head = new Child;//创建第一个孩子的头结点\n\t\t\thead->num = 1;//头结点的编号\n\t\t   head->next = nullptr;//定义头结点的指针为空\n\t\t\tChild* cur = head;//当前指针指向头结点\n\t\t\t//构建循环链表\n\t\t\tfor (int i = 2;i <= n;i++) {\n\t\t\t\tChild* node = new Child;//创建后续新的孩子结点\n\t\t\t\tnode->num = i;//给后续孩子孩子结点编号\n\t\t\t\tcur->next = node;//指针指向新的结点\n\t\t\t\tcur = cur->next;//指针向后移动\n\t\t\t}//链表构建完成\n\t\t\tcur->next = head;//将链表首尾相接形成循环\n\t\t\twhile (cur != cur->next) {//当剩下的孩子不止一个时\n\t\t\t\tfor (int i = 1;i < m;i++) {//数m-1个孩子\n\t\t\t\t\tcur = cur->next;\n\t\t\t\t}\n\t\t\t\tChild* victim = cur->next;//用新的victim记录删除的节点\n\t\t\t\tcout << victim->num << \" \";\n\t\t\t\tcur->next = victim->next;//跳过第m个结点，指针域进行连接\n\t\t\t\tdelete victim;//释放内存\n\t\t}\n\t\t\tcout << cur->num << \" \";\n\t\t\tdelete cur;\n\t}\n\tint main() {//执行主函数\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tJoseph(n, m);\n\t\treturn 0;\n}\n```\n##  F题：括号配对\n{%fold into @ F题：括号配对 %}\n### 题目描述\n设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号()、中括号[]和大括号{}）。\n### 输入\n占一行为含有三种括号的表达式（最长100个符号）。\n### 输出\n匹配时输出YES，小括号不匹配输出NO1，中括号不匹配时输出NO2，大括号不匹配时输出NO3。\n### 样例输入\n\n```\n{([a])}\n```\n### 样例输出\n```\nYES\n```\n{%endfold%}\n### 问题分析\n栈\"后进先出\"(LIFO)的特性正好匹配括号嵌套的顺序，**解题思路**如下：\n - 如果检测输入为**左括号**，压入栈中；\n - 如果检测输入为**右括号**：检测栈是否为空、如果相匹配则弹出栈，不匹配则输出错误。\n\n### 注意点\n1. 执行有关栈的操作，如`.top()`、`.pop()`时，需要**先检查栈非空**，否则会导致未定义行为。输入遍历结束后也需要检查是否非空。\n2. 需要考虑输入的**特殊情况**，如只有左、右括号，左括号多余，无输入的情况。\n3. 根据左括号是否匹配进行输出NO，而不是根据右括号匹配判断。\n4. 注意处理**当输入字符为非括号时**的情况。\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main() {\n    char a;\n    stack<char> match;//用于存储左括号的栈\n    bool hasInput = false;//标记是否有输入\n\n    while (cin >> a) {\n        hasInput = true;\n        if (a == '(' || a == '[' || a == '{') {\n            match.push(a);\n        }//处理左括号，输入后压进栈内\n        else if (a == ')' || a == ']' || a == '}') {\n            if (match.empty()) {\n                if (a == ')') cout << \"NO1\" << endl;\n                else if (a == ']') cout << \"NO2\" << endl;\n                else if (a == '}') cout << \"NO3\" << endl;\n                return 0;\n            }\n            char top = match.top();//查看栈顶元素\n            if ((a == ')' && top == '(') ||\n                (a == ']' && top == '[') ||\n                (a == '}' && top == '{')) {\n                match.pop();//匹配则弹出栈顶\n            }\n            else {\n                if (top == '(') cout << \"NO1\" << endl;\n                else if (top == '[') cout << \"NO2\" << endl;\n                else if (top == '{') cout << \"NO3\" << endl;\n                return 0;\n            }\n        }\n    }\n    if (!hasInput) {\n        cout << \"YES\" << endl;\n        return 0;\n    }\n    if (match.empty()) {\n        cout << \"YES\" << endl;\n    }\n    else {\n        char top = match.top();\n        if (top == '(') cout << \"NO1\" << endl;\n        else if (top == '[') cout << \"NO2\" << endl;\n        else if (top == '{') cout << \"NO3\" << endl;\n    }\n    return 0;\n}\n```\n##  G题：后缀表达式 \n{%fold into @ G题：后缀表达式 %}\n### 题目描述\n给出一个中缀表达式，输出该表达式的后缀表达式。\n### 输入\n占一行，一个中缀表达式（运算符只有+ - * /，最多1000个字符），输出后缀表达式。\n### 输出\n输出后缀表达式。\n### 样例输入\n\n```\n(56-20)/(4+2)\n```\n### 样例输出\n```\n56 20 - 4 2 + /\n```\n{%endfold%}\n\n\n### 问题分析\n本题也是栈的经典问题，**解题思路**如下：\n1. 根据**先乘除后加减的原则**，**数字划分优先级**\n\n2. 对不同的输入**分类处理**：\n- 若读入的输入是**数字**时，直接将其输出\n- 若读入的是**运算符**，则先检查栈内：\n     \n     - **栈空**，则压入栈内；\n     - **栈非空**，则与栈顶元素比较：将栈中**优先级不低于**当前运算符的运算符弹出并输出，然后将当前运算符入栈\n\n\n{%note danger%}\n1. 遇到左括号时**直接入栈**；遇到右括号时，**不断弹出栈顶运算符并输出**，直到遇到左括号（左括号弹出但不输出）\n2. 表达式扫描完毕后，将**栈中剩余运算符全部弹出并输出**\n{%endnote%}\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\n#include <cctype>\nusing namespace std;\n//定义运算符优先级函数\nint pre(char ch) {\n    if (ch == '+' || ch == '-') return 1;\n    if (ch == '*' || ch == '/') return 2;\n    return 0;\n}\nint main() {\n    stack<char> cal;\n    char ch;\n    bool read = false;\n    while (cin >> noskipws >> ch) { //不跳过空格读入\n    if (ch == ' ' || ch == '\\n') continue;\n            if (isdigit(ch)) {//如果是数字\n            cout << ch;\n            read = true;//标记读入的是数字\n        }\n        else {\n            if (read) {\n                cout << \" \";\n                read = false;\n            }\n            if (ch == '(') {//左括号直接入栈\n                cal.push(ch);\n            }\n            else if (ch == ')') {//处理读入的右括号\n            //弹出栈顶元素直至栈顶为左括号\n                while (!cal.empty() && cal.top() != '(') {\n                    cout << cal.top() << \" \";\n                    cal.pop();\n                }\n                if (!cal.empty()) cal.pop();//弹出左括号但不输出\n            }\n            else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {\n                while (!cal.empty() && cal.top() != '(' && pre(cal.top()) >= pre(ch)) {\n                    cout << cal.top() << \" \";\n                    cal.pop();\n                }\n                cal.push(ch);\n            }\n        }\n    }\n    //弹出栈内所有运算符\n    while (!cal.empty()) {\n        cout << cal.top() << \" \";\n        cal.pop();\n    }\n\n    return 0;\n}\n```\n### 注释\n\n`<cctype>` 是 C++ 标准库中的头文件，提供了一系列用于字符分类和处理的函数（通常传入的参数类型为 `char`）。\n\n| 字符分类函数 | 作用                              |\n|--------------|-----------------------------------|\n| `isalpha()`  | 检查是否是字母（a-z, A-Z）        |\n| `isdigit()`  | 检查是否是数字（0-9）             |\n| `isalnum()`  | 检查是否是字母或数字              |\n| `isspace()`  | 检查是否是空白字符（空格、制表符、换行等）|\n| `islower()`  | 检查是否是小写字母                |\n| `isupper()`  | 检查是否是大写字母                |\n\n字符转换函数     | 作用\n-------- | -----\n`tolower()`| 将字符转换为小写\n`toupper()`| 将字符转换为大写\n\n**字符串翻转函数**：`reverse(s.begin(),s.end())`\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main() { \n    string s=\"hello world\";\n    reverse(s.begin(),s.end());\n    cout<<s<<endl;\n    return 0;\n}\n```\n{%note danger%}\n`reverse()`**返回值**为`void`，而不是`string`\n{%endnote%}\n{%note info%}\n若是想**保留原字符串**：\n- 复制**原字符串**\n```cpp\nstring rev=s;\nreverse(rev.begin(),rev.end());\n```\n- 调用**字符翻转迭代器**\n```cpp\nstring rev(s.rbegin(),s.rend());\n```\n{%endnote%}\n\n`noskipws`是定义在 `<iomanip>`头文件中的一个 I/O 操纵符（manipulator），全称是 **\"no skip whitespace\"**。\n\n```cpp\nchar ch;\ncin >> ch;       // 自动跳过空白，读取第一个非空白字符\ncin >> noskipws >> ch;  // 不跳过空白，读取下一个字符（可能是空白）\n```\n\n如果需要恢复默认的跳过空白行为（作用相当于一个开关激活函数）：\n\n```cpp\ncin >> noskipws;  // 关闭跳过空白\n// ... 读取包含空格的输入 ...\ncin >> skipws;    // 恢复默认行为\n```\n与`cin.get`相比更加灵活可控：\n```cpp\ncin.get(ch);  // 总是读取下一个字符（包括空白），不需要 noskipws\n```\n\n##  H题：字符串反转\n{%fold into @ H题：字符串反转 %}\n### 题目描述\n小C很喜欢倒着写单词，现在给你一行小C写的文本，你能把每个单词都反转并输出它们吗？\n### 输入\n输入包含多组测试样例。第一行为一个整数T，代表测试样例的数量，后面跟着T个测试样例。每个测试样例占一行，包含多个单词。一行最多有1000个字符。\n### 输出\n对于每一个测试样例，你应该输出转换后的文本。\n### 样例输入\n```\n3\nolleh !dlrow\nI ekil .bulcmca\nI evol .mca\n```\n### 样例输出\n```\nhello world!\nI like acmclub.\nI love acm.\n```\n{%endfold%}\n\n### 问题分析\n\n本题适合用栈“先进后出”的特性来进行字符串的反转，**解题思路**如下：\n1. 逐个字符处理进行读入，压入栈内\n2. 当遇到**空格**时，将栈内的字符全部弹出\n3. 循环结束后单独处理栈内剩余元素\n\n\n{%note danger%}\n:warning:注意：是**逐个单词进行逆序**，不是**整段文本所有字母的逆序**，因此需要**根据输入的空格和回车来确定分段点**。\n{%endnote%}\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nvoid reverseWords() {\n    string line;\n    getline(cin, line);//整行读入输入\n    stack<char> st;//用于反转字符的栈\n    for (char c : line) {//遍历每一个字符\n    //line可以是字符串也可以是字符数组\n        if (c == ' ') {//遇到空格，开始输出字符\n            while (!st.empty()) {\n                cout << st.top();\n                st.pop();\n            }\n            cout << ' ';\n        }\n        else {\n            st.push(c);\n        }\n    }\n    while (!st.empty()) {//循环结束，处理最后一个没有空格的单词\n        cout << st.top();\n        st.pop();\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cin.ignore(); //忽略换行符\n    for (int i = 0; i < n; i++) {\n        reverseWords();\n    }\n    return 0;\n}\n```\n### 注释\n\n特性 | getline(cin, line) |cin.get()\n-------- | --------- |------------\n读取方式  | 读取整行直到`\\n`|可读取单个字符或一行\n存储类型|`string`|`char`或`char[]`\n是否跳过空白字符  | 不会跳过（读取所有字符）|不会跳过（读取所有字符）\n换行符处理 | 丢弃'\\n'（不存储） | 可以读取'\\n'\n\n封面来源：[Data Structures: Crash Course Computer Science #14](https://www.youtube.com/watch?v=DuDz6B4cqVc&t=92s)\n","source":"_posts/Data structure/CUMT-Datastructure-Assignment-1.md","raw":"---\ntitle: CUMT-Datastructure-Assignment 1\ndate: 2025-06-8 22:29:13 \ntags: [Linear List，stack]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Assignment-1.png\ncategory: Data Structure\ncategory_bar: true\ndescription: The Josephus problem involving circular linked lists and stack-related problems\n---\n\n\n\n\n## E题： 约瑟夫问题\n{%fold into @ E题：约瑟夫问题 %}\n### 题目描述\n\n编写一个程序求解约瑟夫（Joseph）问题。有n个小孩围成一圈，给他们从1开始依次编号，从编号为1的小孩开始报数，数到第m（0<m<n）个小孩出列，然后从出列的下一个小孩重新开始报数，数到第m个小孩又出列，…，如此反复直到所有的小孩全部出列为止，求整个出列序列。\n\n### 输入\n占一行为n和m（n<100）。\n### 输出\n整个出列序列。\n### 样例输入\n```\n6 5\n```\n### 样例输出\n```\n5 4 6 2 3 1\n```\n{%endfold%}\n### 问题分析\n  约瑟夫问题是一个经典的使用循环链表的问题，**解题思路**如下：  \n1. **创建循环链表**：通过结构体`struct`创建孩子结点，创建`head`**头结点**和指向当前结点**可供遍历进行移动**的指针`cur`，再通过`for`循环遍历，用`new`运算**动态分配内存**，给每个孩子结点的`num`域赋上编号的初值，最后**将尾结点的指针域指向头结点**，完成链表的闭合，实现循环链表的功能。\n2. **模拟报数过程**：通过`cur`指针，计数`m-1`个孩子后，`delete`**删除下一个结点释放内存**。\n3. **重复过程**：重复执行，直至有`cur==cur->next`时，即链表中只剩下一个孩子时终止遍历。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\n//定义孩子结点的结构体\n\tstruct Child{\n\t\tint num;//孩子编号\n\t\tChild* next;//指向下一个孩子的指针\n\t};\n\t//约瑟夫问题解决主函数\n\tvoid Joseph(int n,int m) {\n\t\tChild* head = new Child;//创建第一个孩子的头结点\n\t\t\thead->num = 1;//头结点的编号\n\t\t   head->next = nullptr;//定义头结点的指针为空\n\t\t\tChild* cur = head;//当前指针指向头结点\n\t\t\t//构建循环链表\n\t\t\tfor (int i = 2;i <= n;i++) {\n\t\t\t\tChild* node = new Child;//创建后续新的孩子结点\n\t\t\t\tnode->num = i;//给后续孩子孩子结点编号\n\t\t\t\tcur->next = node;//指针指向新的结点\n\t\t\t\tcur = cur->next;//指针向后移动\n\t\t\t}//链表构建完成\n\t\t\tcur->next = head;//将链表首尾相接形成循环\n\t\t\twhile (cur != cur->next) {//当剩下的孩子不止一个时\n\t\t\t\tfor (int i = 1;i < m;i++) {//数m-1个孩子\n\t\t\t\t\tcur = cur->next;\n\t\t\t\t}\n\t\t\t\tChild* victim = cur->next;//用新的victim记录删除的节点\n\t\t\t\tcout << victim->num << \" \";\n\t\t\t\tcur->next = victim->next;//跳过第m个结点，指针域进行连接\n\t\t\t\tdelete victim;//释放内存\n\t\t}\n\t\t\tcout << cur->num << \" \";\n\t\t\tdelete cur;\n\t}\n\tint main() {//执行主函数\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tJoseph(n, m);\n\t\treturn 0;\n}\n```\n##  F题：括号配对\n{%fold into @ F题：括号配对 %}\n### 题目描述\n设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号()、中括号[]和大括号{}）。\n### 输入\n占一行为含有三种括号的表达式（最长100个符号）。\n### 输出\n匹配时输出YES，小括号不匹配输出NO1，中括号不匹配时输出NO2，大括号不匹配时输出NO3。\n### 样例输入\n\n```\n{([a])}\n```\n### 样例输出\n```\nYES\n```\n{%endfold%}\n### 问题分析\n栈\"后进先出\"(LIFO)的特性正好匹配括号嵌套的顺序，**解题思路**如下：\n - 如果检测输入为**左括号**，压入栈中；\n - 如果检测输入为**右括号**：检测栈是否为空、如果相匹配则弹出栈，不匹配则输出错误。\n\n### 注意点\n1. 执行有关栈的操作，如`.top()`、`.pop()`时，需要**先检查栈非空**，否则会导致未定义行为。输入遍历结束后也需要检查是否非空。\n2. 需要考虑输入的**特殊情况**，如只有左、右括号，左括号多余，无输入的情况。\n3. 根据左括号是否匹配进行输出NO，而不是根据右括号匹配判断。\n4. 注意处理**当输入字符为非括号时**的情况。\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main() {\n    char a;\n    stack<char> match;//用于存储左括号的栈\n    bool hasInput = false;//标记是否有输入\n\n    while (cin >> a) {\n        hasInput = true;\n        if (a == '(' || a == '[' || a == '{') {\n            match.push(a);\n        }//处理左括号，输入后压进栈内\n        else if (a == ')' || a == ']' || a == '}') {\n            if (match.empty()) {\n                if (a == ')') cout << \"NO1\" << endl;\n                else if (a == ']') cout << \"NO2\" << endl;\n                else if (a == '}') cout << \"NO3\" << endl;\n                return 0;\n            }\n            char top = match.top();//查看栈顶元素\n            if ((a == ')' && top == '(') ||\n                (a == ']' && top == '[') ||\n                (a == '}' && top == '{')) {\n                match.pop();//匹配则弹出栈顶\n            }\n            else {\n                if (top == '(') cout << \"NO1\" << endl;\n                else if (top == '[') cout << \"NO2\" << endl;\n                else if (top == '{') cout << \"NO3\" << endl;\n                return 0;\n            }\n        }\n    }\n    if (!hasInput) {\n        cout << \"YES\" << endl;\n        return 0;\n    }\n    if (match.empty()) {\n        cout << \"YES\" << endl;\n    }\n    else {\n        char top = match.top();\n        if (top == '(') cout << \"NO1\" << endl;\n        else if (top == '[') cout << \"NO2\" << endl;\n        else if (top == '{') cout << \"NO3\" << endl;\n    }\n    return 0;\n}\n```\n##  G题：后缀表达式 \n{%fold into @ G题：后缀表达式 %}\n### 题目描述\n给出一个中缀表达式，输出该表达式的后缀表达式。\n### 输入\n占一行，一个中缀表达式（运算符只有+ - * /，最多1000个字符），输出后缀表达式。\n### 输出\n输出后缀表达式。\n### 样例输入\n\n```\n(56-20)/(4+2)\n```\n### 样例输出\n```\n56 20 - 4 2 + /\n```\n{%endfold%}\n\n\n### 问题分析\n本题也是栈的经典问题，**解题思路**如下：\n1. 根据**先乘除后加减的原则**，**数字划分优先级**\n\n2. 对不同的输入**分类处理**：\n- 若读入的输入是**数字**时，直接将其输出\n- 若读入的是**运算符**，则先检查栈内：\n     \n     - **栈空**，则压入栈内；\n     - **栈非空**，则与栈顶元素比较：将栈中**优先级不低于**当前运算符的运算符弹出并输出，然后将当前运算符入栈\n\n\n{%note danger%}\n1. 遇到左括号时**直接入栈**；遇到右括号时，**不断弹出栈顶运算符并输出**，直到遇到左括号（左括号弹出但不输出）\n2. 表达式扫描完毕后，将**栈中剩余运算符全部弹出并输出**\n{%endnote%}\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\n#include <cctype>\nusing namespace std;\n//定义运算符优先级函数\nint pre(char ch) {\n    if (ch == '+' || ch == '-') return 1;\n    if (ch == '*' || ch == '/') return 2;\n    return 0;\n}\nint main() {\n    stack<char> cal;\n    char ch;\n    bool read = false;\n    while (cin >> noskipws >> ch) { //不跳过空格读入\n    if (ch == ' ' || ch == '\\n') continue;\n            if (isdigit(ch)) {//如果是数字\n            cout << ch;\n            read = true;//标记读入的是数字\n        }\n        else {\n            if (read) {\n                cout << \" \";\n                read = false;\n            }\n            if (ch == '(') {//左括号直接入栈\n                cal.push(ch);\n            }\n            else if (ch == ')') {//处理读入的右括号\n            //弹出栈顶元素直至栈顶为左括号\n                while (!cal.empty() && cal.top() != '(') {\n                    cout << cal.top() << \" \";\n                    cal.pop();\n                }\n                if (!cal.empty()) cal.pop();//弹出左括号但不输出\n            }\n            else if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {\n                while (!cal.empty() && cal.top() != '(' && pre(cal.top()) >= pre(ch)) {\n                    cout << cal.top() << \" \";\n                    cal.pop();\n                }\n                cal.push(ch);\n            }\n        }\n    }\n    //弹出栈内所有运算符\n    while (!cal.empty()) {\n        cout << cal.top() << \" \";\n        cal.pop();\n    }\n\n    return 0;\n}\n```\n### 注释\n\n`<cctype>` 是 C++ 标准库中的头文件，提供了一系列用于字符分类和处理的函数（通常传入的参数类型为 `char`）。\n\n| 字符分类函数 | 作用                              |\n|--------------|-----------------------------------|\n| `isalpha()`  | 检查是否是字母（a-z, A-Z）        |\n| `isdigit()`  | 检查是否是数字（0-9）             |\n| `isalnum()`  | 检查是否是字母或数字              |\n| `isspace()`  | 检查是否是空白字符（空格、制表符、换行等）|\n| `islower()`  | 检查是否是小写字母                |\n| `isupper()`  | 检查是否是大写字母                |\n\n字符转换函数     | 作用\n-------- | -----\n`tolower()`| 将字符转换为小写\n`toupper()`| 将字符转换为大写\n\n**字符串翻转函数**：`reverse(s.begin(),s.end())`\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint main() { \n    string s=\"hello world\";\n    reverse(s.begin(),s.end());\n    cout<<s<<endl;\n    return 0;\n}\n```\n{%note danger%}\n`reverse()`**返回值**为`void`，而不是`string`\n{%endnote%}\n{%note info%}\n若是想**保留原字符串**：\n- 复制**原字符串**\n```cpp\nstring rev=s;\nreverse(rev.begin(),rev.end());\n```\n- 调用**字符翻转迭代器**\n```cpp\nstring rev(s.rbegin(),s.rend());\n```\n{%endnote%}\n\n`noskipws`是定义在 `<iomanip>`头文件中的一个 I/O 操纵符（manipulator），全称是 **\"no skip whitespace\"**。\n\n```cpp\nchar ch;\ncin >> ch;       // 自动跳过空白，读取第一个非空白字符\ncin >> noskipws >> ch;  // 不跳过空白，读取下一个字符（可能是空白）\n```\n\n如果需要恢复默认的跳过空白行为（作用相当于一个开关激活函数）：\n\n```cpp\ncin >> noskipws;  // 关闭跳过空白\n// ... 读取包含空格的输入 ...\ncin >> skipws;    // 恢复默认行为\n```\n与`cin.get`相比更加灵活可控：\n```cpp\ncin.get(ch);  // 总是读取下一个字符（包括空白），不需要 noskipws\n```\n\n##  H题：字符串反转\n{%fold into @ H题：字符串反转 %}\n### 题目描述\n小C很喜欢倒着写单词，现在给你一行小C写的文本，你能把每个单词都反转并输出它们吗？\n### 输入\n输入包含多组测试样例。第一行为一个整数T，代表测试样例的数量，后面跟着T个测试样例。每个测试样例占一行，包含多个单词。一行最多有1000个字符。\n### 输出\n对于每一个测试样例，你应该输出转换后的文本。\n### 样例输入\n```\n3\nolleh !dlrow\nI ekil .bulcmca\nI evol .mca\n```\n### 样例输出\n```\nhello world!\nI like acmclub.\nI love acm.\n```\n{%endfold%}\n\n### 问题分析\n\n本题适合用栈“先进后出”的特性来进行字符串的反转，**解题思路**如下：\n1. 逐个字符处理进行读入，压入栈内\n2. 当遇到**空格**时，将栈内的字符全部弹出\n3. 循环结束后单独处理栈内剩余元素\n\n\n{%note danger%}\n:warning:注意：是**逐个单词进行逆序**，不是**整段文本所有字母的逆序**，因此需要**根据输入的空格和回车来确定分段点**。\n{%endnote%}\n### 完整代码\n```cpp\n#include <iostream>\n#include <stack>\n#include <string>\nusing namespace std;\nvoid reverseWords() {\n    string line;\n    getline(cin, line);//整行读入输入\n    stack<char> st;//用于反转字符的栈\n    for (char c : line) {//遍历每一个字符\n    //line可以是字符串也可以是字符数组\n        if (c == ' ') {//遇到空格，开始输出字符\n            while (!st.empty()) {\n                cout << st.top();\n                st.pop();\n            }\n            cout << ' ';\n        }\n        else {\n            st.push(c);\n        }\n    }\n    while (!st.empty()) {//循环结束，处理最后一个没有空格的单词\n        cout << st.top();\n        st.pop();\n    }\n    cout << endl;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    cin.ignore(); //忽略换行符\n    for (int i = 0; i < n; i++) {\n        reverseWords();\n    }\n    return 0;\n}\n```\n### 注释\n\n特性 | getline(cin, line) |cin.get()\n-------- | --------- |------------\n读取方式  | 读取整行直到`\\n`|可读取单个字符或一行\n存储类型|`string`|`char`或`char[]`\n是否跳过空白字符  | 不会跳过（读取所有字符）|不会跳过（读取所有字符）\n换行符处理 | 丢弃'\\n'（不存储） | 可以读取'\\n'\n\n封面来源：[Data Structures: Crash Course Computer Science #14](https://www.youtube.com/watch?v=DuDz6B4cqVc&t=92s)\n","slug":"Data structure/CUMT-Datastructure-Assignment-1","published":1,"updated":"2025-08-29T09:35:47.127Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hck000c40w39sd9142c","content":"<h2 id=\"E题：-约瑟夫问题\">E题： 约瑟夫问题</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-c86b7b1f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-c86b7b1f\">\n        <div class=\"fold-arrow\">▶</div> E题：约瑟夫问题\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-c86b7b1f\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>编写一个程序求解约瑟夫（Joseph）问题。有n个小孩围成一圈，给他们从1开始依次编号，从编号为1的小孩开始报数，数到第m（0&lt;m&lt;n）个小孩出列，然后从出列的下一个小孩重新开始报数，数到第m个小孩又出列，…，如此反复直到所有的小孩全部出列为止，求整个出列序列。</p><h3 id=\"输入\">输入</h3><p>占一行为n和m（n&lt;100）。</p><h3 id=\"输出\">输出</h3><p>整个出列序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>约瑟夫问题是一个经典的使用循环链表的问题，<strong>解题思路</strong>如下：</p>\n<ol>\n<li><strong>创建循环链表</strong>：通过结构体<code>struct</code>创建孩子结点，创建<code>head</code><strong>头结点</strong>和指向当前结点<strong>可供遍历进行移动</strong>的指针<code>cur</code>，再通过<code>for</code>循环遍历，用<code>new</code>运算<strong>动态分配内存</strong>，给每个孩子结点的<code>num</code>域赋上编号的初值，最后<strong>将尾结点的指针域指向头结点</strong>，完成链表的闭合，实现循环链表的功能。</li>\n<li><strong>模拟报数过程</strong>：通过<code>cur</code>指针，计数<code>m-1</code>个孩子后，<code>delete</code><strong>删除下一个结点释放内存</strong>。</li>\n<li><strong>重复过程</strong>：重复执行，直至有<code>cur==cur-&gt;next</code>时，即链表中只剩下一个孩子时终止遍历。</li>\n</ol>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//定义孩子结点的结构体</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Child</span>{<br>\t\t<span class=\"hljs-type\">int</span> num;<span class=\"hljs-comment\">//孩子编号</span><br>\t\tChild* next;<span class=\"hljs-comment\">//指向下一个孩子的指针</span><br>\t};<br>\t<span class=\"hljs-comment\">//约瑟夫问题解决主函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> m)</span> </span>{<br>\t\tChild* head = <span class=\"hljs-keyword\">new</span> Child;<span class=\"hljs-comment\">//创建第一个孩子的头结点</span><br>\t\t\thead-&gt;num = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//头结点的编号</span><br>\t\t   head-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<span class=\"hljs-comment\">//定义头结点的指针为空</span><br>\t\t\tChild* cur = head;<span class=\"hljs-comment\">//当前指针指向头结点</span><br>\t\t\t<span class=\"hljs-comment\">//构建循环链表</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>;i &lt;= n;i++) {<br>\t\t\t\tChild* node = <span class=\"hljs-keyword\">new</span> Child;<span class=\"hljs-comment\">//创建后续新的孩子结点</span><br>\t\t\t\tnode-&gt;num = i;<span class=\"hljs-comment\">//给后续孩子孩子结点编号</span><br>\t\t\t\tcur-&gt;next = node;<span class=\"hljs-comment\">//指针指向新的结点</span><br>\t\t\t\tcur = cur-&gt;next;<span class=\"hljs-comment\">//指针向后移动</span><br>\t\t\t}<span class=\"hljs-comment\">//链表构建完成</span><br>\t\t\tcur-&gt;next = head;<span class=\"hljs-comment\">//将链表首尾相接形成循环</span><br>\t\t\t<span class=\"hljs-keyword\">while</span> (cur != cur-&gt;next) {<span class=\"hljs-comment\">//当剩下的孩子不止一个时</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; m;i++) {<span class=\"hljs-comment\">//数m-1个孩子</span><br>\t\t\t\t\tcur = cur-&gt;next;<br>\t\t\t\t}<br>\t\t\t\tChild* victim = cur-&gt;next;<span class=\"hljs-comment\">//用新的victim记录删除的节点</span><br>\t\t\t\tcout &lt;&lt; victim-&gt;num &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t\t\t\tcur-&gt;next = victim-&gt;next;<span class=\"hljs-comment\">//跳过第m个结点，指针域进行连接</span><br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> victim;<span class=\"hljs-comment\">//释放内存</span><br>\t\t}<br>\t\t\tcout &lt;&lt; cur-&gt;num &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> cur;<br>\t}<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<span class=\"hljs-comment\">//执行主函数</span><br>\t\t<span class=\"hljs-type\">int</span> n, m;<br>\t\tcin &gt;&gt; n &gt;&gt; m;<br>\t\t<span class=\"hljs-built_in\">Joseph</span>(n, m);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"F题：括号配对\">F题：括号配对</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-0515e248\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-0515e248\">\n        <div class=\"fold-arrow\">▶</div> F题：括号配对\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-0515e248\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号()、中括号[]和大括号{}）。</p><h3 id=\"输入\">输入</h3><p>占一行为含有三种括号的表达式（最长100个符号）。</p><h3 id=\"输出\">输出</h3><p>匹配时输出YES，小括号不匹配输出NO1，中括号不匹配时输出NO2，大括号不匹配时输出NO3。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight clojure\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\">{([a])}<br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">YES</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>栈\"后进先出\"(LIFO)的特性正好匹配括号嵌套的顺序，<strong>解题思路</strong>如下：</p>\n<ul>\n<li>如果检测输入为<strong>左括号</strong>，压入栈中；</li>\n<li>如果检测输入为<strong>右括号</strong>：检测栈是否为空、如果相匹配则弹出栈，不匹配则输出错误。</li>\n</ul>\n<h3 id=\"注意点\">注意点</h3>\n<ol>\n<li>执行有关栈的操作，如<code>.top()</code>、<code>.pop()</code>时，需要<strong>先检查栈非空</strong>，否则会导致未定义行为。输入遍历结束后也需要检查是否非空。</li>\n<li>需要考虑输入的<strong>特殊情况</strong>，如只有左、右括号，左括号多余，无输入的情况。</li>\n<li>根据左括号是否匹配进行输出NO，而不是根据右括号匹配判断。</li>\n<li>注意处理<strong>当输入字符为非括号时</strong>的情况。</li>\n</ol>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">char</span> a;<br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; match;<span class=\"hljs-comment\">//用于存储左括号的栈</span><br>    <span class=\"hljs-type\">bool</span> hasInput = <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//标记是否有输入</span><br><br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; a) {<br>        hasInput = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">'('</span> || a == <span class=\"hljs-string\">'['</span> || a == <span class=\"hljs-string\">'{'</span>) {<br>            match.<span class=\"hljs-built_in\">push</span>(a);<br>        }<span class=\"hljs-comment\">//处理左括号，输入后压进栈内</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">')'</span> || a == <span class=\"hljs-string\">']'</span> || a == <span class=\"hljs-string\">'}'</span>) {<br>            <span class=\"hljs-keyword\">if</span> (match.<span class=\"hljs-built_in\">empty</span>()) {<br>                <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">')'</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO1\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">']'</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO2\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">'}'</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO3\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>            }<br>            <span class=\"hljs-type\">char</span> top = match.<span class=\"hljs-built_in\">top</span>();<span class=\"hljs-comment\">//查看栈顶元素</span><br>            <span class=\"hljs-keyword\">if</span> ((a == <span class=\"hljs-string\">')'</span> &amp;&amp; top == <span class=\"hljs-string\">'('</span>) ||<br>                (a == <span class=\"hljs-string\">']'</span> &amp;&amp; top == <span class=\"hljs-string\">'['</span>) ||<br>                (a == <span class=\"hljs-string\">'}'</span> &amp;&amp; top == <span class=\"hljs-string\">'{'</span>)) {<br>                match.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//匹配则弹出栈顶</span><br>            }<br>            <span class=\"hljs-keyword\">else</span> {<br>                <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'('</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO1\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'['</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO2\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'{'</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO3\"</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>            }<br>        }<br>    }<br>    <span class=\"hljs-keyword\">if</span> (!hasInput) {<br>        cout &lt;&lt; <span class=\"hljs-string\">\"YES\"</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (match.<span class=\"hljs-built_in\">empty</span>()) {<br>        cout &lt;&lt; <span class=\"hljs-string\">\"YES\"</span> &lt;&lt; endl;<br>    }<br>    <span class=\"hljs-keyword\">else</span> {<br>        <span class=\"hljs-type\">char</span> top = match.<span class=\"hljs-built_in\">top</span>();<br>        <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'('</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO1\"</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'['</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO2\"</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">'{'</span>) cout &lt;&lt; <span class=\"hljs-string\">\"NO3\"</span> &lt;&lt; endl;<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"G题：后缀表达式\">G题：后缀表达式</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a987457e\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a987457e\">\n        <div class=\"fold-arrow\">▶</div> G题：后缀表达式\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a987457e\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给出一个中缀表达式，输出该表达式的后缀表达式。</p><h3 id=\"输入\">输入</h3><p>占一行，一个中缀表达式（运算符只有+ - * /，最多1000个字符），输出后缀表达式。</p><h3 id=\"输出\">输出</h3><p>输出后缀表达式。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight lisp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lisp\">(<span class=\"hljs-number\">56</span><span class=\"hljs-number\">-20</span>)/(<span class=\"hljs-number\">4</span><span class=\"hljs-number\">+2</span>)<br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">56 </span><span class=\"hljs-number\">20</span> - <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span> + /<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>本题也是栈的经典问题，<strong>解题思路</strong>如下：</p>\n<ol>\n<li>\n<p>根据<strong>先乘除后加减的原则</strong>，<strong>数字划分优先级</strong></p>\n</li>\n<li>\n<p>对不同的输入<strong>分类处理</strong>：</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>若读入的输入是<strong>数字</strong>时，直接将其输出</p>\n</li>\n<li>\n<p>若读入的是<strong>运算符</strong>，则先检查栈内：</p>\n<ul>\n<li><strong>栈空</strong>，则压入栈内；</li>\n<li><strong>栈非空</strong>，则与栈顶元素比较：将栈中<strong>优先级不低于</strong>当前运算符的运算符弹出并输出，然后将当前运算符入栈</li>\n</ul>\n</li>\n</ul>\n<div class=\"note note-danger\">\n            <ol><li>遇到左括号时<strong>直接入栈</strong>；遇到右括号时，<strong>不断弹出栈顶运算符并输出</strong>，直到遇到左括号（左括号弹出但不输出）</li><li>表达式扫描完毕后，将<strong>栈中剩余运算符全部弹出并输出</strong></li></ol>\n          </div>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cctype&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//定义运算符优先级函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pre</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> ch)</span> </span>{<br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">'+'</span> || ch == <span class=\"hljs-string\">'-'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">'*'</span> || ch == <span class=\"hljs-string\">'/'</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; cal;<br>    <span class=\"hljs-type\">char</span> ch;<br>    <span class=\"hljs-type\">bool</span> read = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; noskipws &gt;&gt; ch) { <span class=\"hljs-comment\">//不跳过空格读入</span><br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">' '</span> || ch == <span class=\"hljs-string\">'\\n'</span>) <span class=\"hljs-keyword\">continue</span>;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isdigit</span>(ch)) {<span class=\"hljs-comment\">//如果是数字</span><br>            cout &lt;&lt; ch;<br>            read = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记读入的是数字</span><br>        }<br>        <span class=\"hljs-keyword\">else</span> {<br>            <span class=\"hljs-keyword\">if</span> (read) {<br>                cout &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>                read = <span class=\"hljs-literal\">false</span>;<br>            }<br>            <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">'('</span>) {<span class=\"hljs-comment\">//左括号直接入栈</span><br>                cal.<span class=\"hljs-built_in\">push</span>(ch);<br>            }<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">')'</span>) {<span class=\"hljs-comment\">//处理读入的右括号</span><br>            <span class=\"hljs-comment\">//弹出栈顶元素直至栈顶为左括号</span><br>                <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; cal.<span class=\"hljs-built_in\">top</span>() != <span class=\"hljs-string\">'('</span>) {<br>                    cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>                    cal.<span class=\"hljs-built_in\">pop</span>();<br>                }<br>                <span class=\"hljs-keyword\">if</span> (!cal.<span class=\"hljs-built_in\">empty</span>()) cal.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//弹出左括号但不输出</span><br>            }<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">'+'</span> || ch == <span class=\"hljs-string\">'-'</span> || ch == <span class=\"hljs-string\">'*'</span> || ch == <span class=\"hljs-string\">'/'</span>) {<br>                <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; cal.<span class=\"hljs-built_in\">top</span>() != <span class=\"hljs-string\">'('</span> &amp;&amp; <span class=\"hljs-built_in\">pre</span>(cal.<span class=\"hljs-built_in\">top</span>()) &gt;= <span class=\"hljs-built_in\">pre</span>(ch)) {<br>                    cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>                    cal.<span class=\"hljs-built_in\">pop</span>();<br>                }<br>                cal.<span class=\"hljs-built_in\">push</span>(ch);<br>            }<br>        }<br>    }<br>    <span class=\"hljs-comment\">//弹出栈内所有运算符</span><br>    <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>()) {<br>        cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>        cal.<span class=\"hljs-built_in\">pop</span>();<br>    }<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><code>&lt;cctype&gt;</code> 是 C++ 标准库中的头文件，提供了一系列用于字符分类和处理的函数（通常传入的参数类型为 <code>char</code>）。</p>\n<table>\n<thead>\n<tr>\n<th>字符分类函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>isalpha()</code></td>\n<td>检查是否是字母（a-z, A-Z）</td>\n</tr>\n<tr>\n<td><code>isdigit()</code></td>\n<td>检查是否是数字（0-9）</td>\n</tr>\n<tr>\n<td><code>isalnum()</code></td>\n<td>检查是否是字母或数字</td>\n</tr>\n<tr>\n<td><code>isspace()</code></td>\n<td>检查是否是空白字符（空格、制表符、换行等）</td>\n</tr>\n<tr>\n<td><code>islower()</code></td>\n<td>检查是否是小写字母</td>\n</tr>\n<tr>\n<td><code>isupper()</code></td>\n<td>检查是否是大写字母</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>字符转换函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tolower()</code></td>\n<td>将字符转换为小写</td>\n</tr>\n<tr>\n<td><code>toupper()</code></td>\n<td>将字符转换为大写</td>\n</tr>\n</tbody>\n</table>\n<p><strong>字符串翻转函数</strong>：<code>reverse(s.begin(),s.end())</code></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{ <br>    string s=<span class=\"hljs-string\">\"hello world\"</span>;<br>    <span class=\"hljs-built_in\">reverse</span>(s.<span class=\"hljs-built_in\">begin</span>(),s.<span class=\"hljs-built_in\">end</span>());<br>    cout&lt;&lt;s&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-danger\">\n            <p><code>reverse()</code><strong>返回值</strong>为<code>void</code>，而不是<code>string</code></p>\n          </div>\n<div class=\"note note-info\">\n            <p>若是想<strong>保留原字符串</strong>：</p><ul><li>复制<strong>原字符串</strong></li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string rev=s;<br><span class=\"hljs-built_in\">reverse</span>(rev.<span class=\"hljs-built_in\">begin</span>(),rev.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></tbody></table></figure><ul><li>调用<strong>字符翻转迭代器</strong></li></ul><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">rev</span><span class=\"hljs-params\">(s.rbegin(),s.rend())</span></span>;<br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<p><code>noskipws</code>是定义在 <code>&lt;iomanip&gt;</code>头文件中的一个 I/O 操纵符（manipulator），全称是 <strong>“no skip whitespace”</strong>。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">char</span> ch;<br>cin &gt;&gt; ch;       <span class=\"hljs-comment\">// 自动跳过空白，读取第一个非空白字符</span><br>cin &gt;&gt; noskipws &gt;&gt; ch;  <span class=\"hljs-comment\">// 不跳过空白，读取下一个字符（可能是空白）</span><br></code></pre></td></tr></tbody></table></figure>\n<p>如果需要恢复默认的跳过空白行为（作用相当于一个开关激活函数）：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cin &gt;&gt; noskipws;  <span class=\"hljs-comment\">// 关闭跳过空白</span><br><span class=\"hljs-comment\">// ... 读取包含空格的输入 ...</span><br>cin &gt;&gt; skipws;    <span class=\"hljs-comment\">// 恢复默认行为</span><br></code></pre></td></tr></tbody></table></figure>\n<p>与<code>cin.get</code>相比更加灵活可控：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cin.<span class=\"hljs-built_in\">get</span>(ch);  <span class=\"hljs-comment\">// 总是读取下一个字符（包括空白），不需要 noskipws</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"H题：字符串反转\">H题：字符串反转</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e8ab38ca\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e8ab38ca\">\n        <div class=\"fold-arrow\">▶</div> H题：字符串反转\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e8ab38ca\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小C很喜欢倒着写单词，现在给你一行小C写的文本，你能把每个单词都反转并输出它们吗？</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试样例。第一行为一个整数T，代表测试样例的数量，后面跟着T个测试样例。每个测试样例占一行，包含多个单词。一行最多有1000个字符。</p><h3 id=\"输出\">输出</h3><p>对于每一个测试样例，你应该输出转换后的文本。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-number\">3</span><br>olleh !dlrow<br><span class=\"hljs-selector-tag\">I</span> ekil <span class=\"hljs-selector-class\">.bulcmca</span><br><span class=\"hljs-selector-tag\">I</span> evol <span class=\"hljs-selector-class\">.mca</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">hello world!<br><span class=\"hljs-selector-tag\">I</span> like acmclub.<br><span class=\"hljs-selector-tag\">I</span> love acm.<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>本题适合用栈“先进后出”的特性来进行字符串的反转，<strong>解题思路</strong>如下：</p>\n<ol>\n<li>逐个字符处理进行读入，压入栈内</li>\n<li>当遇到<strong>空格</strong>时，将栈内的字符全部弹出</li>\n<li>循环结束后单独处理栈内剩余元素</li>\n</ol>\n<div class=\"note note-danger\">\n            <p>⚠️注意：是<strong>逐个单词进行逆序</strong>，不是<strong>整段文本所有字母的逆序</strong>，因此需要<strong>根据输入的空格和回车来确定分段点</strong>。</p>\n          </div>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">reverseWords</span><span class=\"hljs-params\">()</span> </span>{<br>    string line;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);<span class=\"hljs-comment\">//整行读入输入</span><br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; st;<span class=\"hljs-comment\">//用于反转字符的栈</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> c : line) {<span class=\"hljs-comment\">//遍历每一个字符</span><br>    <span class=\"hljs-comment\">//line可以是字符串也可以是字符数组</span><br>        <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">' '</span>) {<span class=\"hljs-comment\">//遇到空格，开始输出字符</span><br>            <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) {<br>                cout &lt;&lt; st.<span class=\"hljs-built_in\">top</span>();<br>                st.<span class=\"hljs-built_in\">pop</span>();<br>            }<br>            cout &lt;&lt; <span class=\"hljs-string\">' '</span>;<br>        }<br>        <span class=\"hljs-keyword\">else</span> {<br>            st.<span class=\"hljs-built_in\">push</span>(c);<br>        }<br>    }<br>    <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) {<span class=\"hljs-comment\">//循环结束，处理最后一个没有空格的单词</span><br>        cout &lt;&lt; st.<span class=\"hljs-built_in\">top</span>();<br>        st.<span class=\"hljs-built_in\">pop</span>();<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    cin.<span class=\"hljs-built_in\">ignore</span>(); <span class=\"hljs-comment\">//忽略换行符</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {<br>        <span class=\"hljs-built_in\">reverseWords</span>();<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释-v2\">注释</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>getline(cin, line)</th>\n<th>cin.get()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取方式</td>\n<td>读取整行直到<code>\\n</code></td>\n<td>可读取单个字符或一行</td>\n</tr>\n<tr>\n<td>存储类型</td>\n<td><code>string</code></td>\n<td><code>char</code>或<code>char[]</code></td>\n</tr>\n<tr>\n<td>是否跳过空白字符</td>\n<td>不会跳过（读取所有字符）</td>\n<td>不会跳过（读取所有字符）</td>\n</tr>\n<tr>\n<td>换行符处理</td>\n<td>丢弃’\\n’（不存储）</td>\n<td>可以读取’\\n’</td>\n</tr>\n</tbody>\n</table>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=DuDz6B4cqVc&amp;t=92s\">Data Structures: Crash Course Computer Science #14</a></p>\n","excerpt":"","more":"<h2 id=\"E题：-约瑟夫问题\">E题： 约瑟夫问题</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-c86b7b1f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-c86b7b1f\">\n        <div class=\"fold-arrow\">▶</div> E题：约瑟夫问题\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-c86b7b1f\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>编写一个程序求解约瑟夫（Joseph）问题。有n个小孩围成一圈，给他们从1开始依次编号，从编号为1的小孩开始报数，数到第m（0&lt;m&lt;n）个小孩出列，然后从出列的下一个小孩重新开始报数，数到第m个小孩又出列，…，如此反复直到所有的小孩全部出列为止，求整个出列序列。</p><h3 id=\"输入\">输入</h3><p>占一行为n和m（n&lt;100）。</p><h3 id=\"输出\">输出</h3><p>整个出列序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>约瑟夫问题是一个经典的使用循环链表的问题，<strong>解题思路</strong>如下：</p>\n<ol>\n<li><strong>创建循环链表</strong>：通过结构体<code>struct</code>创建孩子结点，创建<code>head</code><strong>头结点</strong>和指向当前结点<strong>可供遍历进行移动</strong>的指针<code>cur</code>，再通过<code>for</code>循环遍历，用<code>new</code>运算<strong>动态分配内存</strong>，给每个孩子结点的<code>num</code>域赋上编号的初值，最后<strong>将尾结点的指针域指向头结点</strong>，完成链表的闭合，实现循环链表的功能。</li>\n<li><strong>模拟报数过程</strong>：通过<code>cur</code>指针，计数<code>m-1</code>个孩子后，<code>delete</code><strong>删除下一个结点释放内存</strong>。</li>\n<li><strong>重复过程</strong>：重复执行，直至有<code>cur==cur-&gt;next</code>时，即链表中只剩下一个孩子时终止遍历。</li>\n</ol>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//定义孩子结点的结构体</span><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Child</span>&#123;<br>\t\t<span class=\"hljs-type\">int</span> num;<span class=\"hljs-comment\">//孩子编号</span><br>\t\tChild* next;<span class=\"hljs-comment\">//指向下一个孩子的指针</span><br>\t&#125;;<br>\t<span class=\"hljs-comment\">//约瑟夫问题解决主函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Joseph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n,<span class=\"hljs-type\">int</span> m)</span> </span>&#123;<br>\t\tChild* head = <span class=\"hljs-keyword\">new</span> Child;<span class=\"hljs-comment\">//创建第一个孩子的头结点</span><br>\t\t\thead-&gt;num = <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//头结点的编号</span><br>\t\t   head-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<span class=\"hljs-comment\">//定义头结点的指针为空</span><br>\t\t\tChild* cur = head;<span class=\"hljs-comment\">//当前指针指向头结点</span><br>\t\t\t<span class=\"hljs-comment\">//构建循环链表</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>;i &lt;= n;i++) &#123;<br>\t\t\t\tChild* node = <span class=\"hljs-keyword\">new</span> Child;<span class=\"hljs-comment\">//创建后续新的孩子结点</span><br>\t\t\t\tnode-&gt;num = i;<span class=\"hljs-comment\">//给后续孩子孩子结点编号</span><br>\t\t\t\tcur-&gt;next = node;<span class=\"hljs-comment\">//指针指向新的结点</span><br>\t\t\t\tcur = cur-&gt;next;<span class=\"hljs-comment\">//指针向后移动</span><br>\t\t\t&#125;<span class=\"hljs-comment\">//链表构建完成</span><br>\t\t\tcur-&gt;next = head;<span class=\"hljs-comment\">//将链表首尾相接形成循环</span><br>\t\t\t<span class=\"hljs-keyword\">while</span> (cur != cur-&gt;next) &#123;<span class=\"hljs-comment\">//当剩下的孩子不止一个时</span><br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt; m;i++) &#123;<span class=\"hljs-comment\">//数m-1个孩子</span><br>\t\t\t\t\tcur = cur-&gt;next;<br>\t\t\t\t&#125;<br>\t\t\t\tChild* victim = cur-&gt;next;<span class=\"hljs-comment\">//用新的victim记录删除的节点</span><br>\t\t\t\tcout &lt;&lt; victim-&gt;num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t\t\tcur-&gt;next = victim-&gt;next;<span class=\"hljs-comment\">//跳过第m个结点，指针域进行连接</span><br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> victim;<span class=\"hljs-comment\">//释放内存</span><br>\t\t&#125;<br>\t\t\tcout &lt;&lt; cur-&gt;num &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> cur;<br>\t&#125;<br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<span class=\"hljs-comment\">//执行主函数</span><br>\t\t<span class=\"hljs-type\">int</span> n, m;<br>\t\tcin &gt;&gt; n &gt;&gt; m;<br>\t\t<span class=\"hljs-built_in\">Joseph</span>(n, m);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"F题：括号配对\">F题：括号配对</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-0515e248\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-0515e248\">\n        <div class=\"fold-arrow\">▶</div> F题：括号配对\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-0515e248\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>设计一个算法利用顺序栈检查用户输入的表达式中括号是否配对（假设表达式中可能含有圆括号()、中括号[]和大括号{}）。</p><h3 id=\"输入\">输入</h3><p>占一行为含有三种括号的表达式（最长100个符号）。</p><h3 id=\"输出\">输出</h3><p>匹配时输出YES，小括号不匹配输出NO1，中括号不匹配时输出NO2，大括号不匹配时输出NO3。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs clojure\">&#123;([a])&#125;<br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">YES</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>栈&quot;后进先出&quot;(LIFO)的特性正好匹配括号嵌套的顺序，<strong>解题思路</strong>如下：</p>\n<ul>\n<li>如果检测输入为<strong>左括号</strong>，压入栈中；</li>\n<li>如果检测输入为<strong>右括号</strong>：检测栈是否为空、如果相匹配则弹出栈，不匹配则输出错误。</li>\n</ul>\n<h3 id=\"注意点\">注意点</h3>\n<ol>\n<li>执行有关栈的操作，如<code>.top()</code>、<code>.pop()</code>时，需要<strong>先检查栈非空</strong>，否则会导致未定义行为。输入遍历结束后也需要检查是否非空。</li>\n<li>需要考虑输入的<strong>特殊情况</strong>，如只有左、右括号，左括号多余，无输入的情况。</li>\n<li>根据左括号是否匹配进行输出NO，而不是根据右括号匹配判断。</li>\n<li>注意处理<strong>当输入字符为非括号时</strong>的情况。</li>\n</ol>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">char</span> a;<br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; match;<span class=\"hljs-comment\">//用于存储左括号的栈</span><br>    <span class=\"hljs-type\">bool</span> hasInput = <span class=\"hljs-literal\">false</span>;<span class=\"hljs-comment\">//标记是否有输入</span><br><br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; a) &#123;<br>        hasInput = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">&#x27;(&#x27;</span> || a == <span class=\"hljs-string\">&#x27;[&#x27;</span> || a == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) &#123;<br>            match.<span class=\"hljs-built_in\">push</span>(a);<br>        &#125;<span class=\"hljs-comment\">//处理左括号，输入后压进栈内</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">&#x27;)&#x27;</span> || a == <span class=\"hljs-string\">&#x27;]&#x27;</span> || a == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (match.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>                <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">&#x27;)&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO1&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">&#x27;]&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO2&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO3&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>            &#125;<br>            <span class=\"hljs-type\">char</span> top = match.<span class=\"hljs-built_in\">top</span>();<span class=\"hljs-comment\">//查看栈顶元素</span><br>            <span class=\"hljs-keyword\">if</span> ((a == <span class=\"hljs-string\">&#x27;)&#x27;</span> &amp;&amp; top == <span class=\"hljs-string\">&#x27;(&#x27;</span>) ||<br>                (a == <span class=\"hljs-string\">&#x27;]&#x27;</span> &amp;&amp; top == <span class=\"hljs-string\">&#x27;[&#x27;</span>) ||<br>                (a == <span class=\"hljs-string\">&#x27;&#125;&#x27;</span> &amp;&amp; top == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>)) &#123;<br>                match.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//匹配则弹出栈顶</span><br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;(&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO1&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;[&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO2&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO3&quot;</span> &lt;&lt; endl;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (!hasInput) &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (match.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;YES&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-type\">char</span> top = match.<span class=\"hljs-built_in\">top</span>();<br>        <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;(&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO1&quot;</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;[&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO2&quot;</span> &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top == <span class=\"hljs-string\">&#x27;&#123;&#x27;</span>) cout &lt;&lt; <span class=\"hljs-string\">&quot;NO3&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"G题：后缀表达式\">G题：后缀表达式</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a987457e\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a987457e\">\n        <div class=\"fold-arrow\">▶</div> G题：后缀表达式\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a987457e\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给出一个中缀表达式，输出该表达式的后缀表达式。</p><h3 id=\"输入\">输入</h3><p>占一行，一个中缀表达式（运算符只有+ - * /，最多1000个字符），输出后缀表达式。</p><h3 id=\"输出\">输出</h3><p>输出后缀表达式。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs lisp\">(<span class=\"hljs-number\">56</span><span class=\"hljs-number\">-20</span>)/(<span class=\"hljs-number\">4</span><span class=\"hljs-number\">+2</span>)<br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">56 </span><span class=\"hljs-number\">20</span> - <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span> + /<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>本题也是栈的经典问题，<strong>解题思路</strong>如下：</p>\n<ol>\n<li>\n<p>根据<strong>先乘除后加减的原则</strong>，<strong>数字划分优先级</strong></p>\n</li>\n<li>\n<p>对不同的输入<strong>分类处理</strong>：</p>\n</li>\n</ol>\n<ul>\n<li>\n<p>若读入的输入是<strong>数字</strong>时，直接将其输出</p>\n</li>\n<li>\n<p>若读入的是<strong>运算符</strong>，则先检查栈内：</p>\n<ul>\n<li><strong>栈空</strong>，则压入栈内；</li>\n<li><strong>栈非空</strong>，则与栈顶元素比较：将栈中<strong>优先级不低于</strong>当前运算符的运算符弹出并输出，然后将当前运算符入栈</li>\n</ul>\n</li>\n</ul>\n<div class=\"note note-danger\">\n            <ol><li>遇到左括号时<strong>直接入栈</strong>；遇到右括号时，<strong>不断弹出栈顶运算符并输出</strong>，直到遇到左括号（左括号弹出但不输出）</li><li>表达式扫描完毕后，将<strong>栈中剩余运算符全部弹出并输出</strong></li></ol>\n          </div>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cctype&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//定义运算符优先级函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pre</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> ch)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27;+&#x27;</span> || ch == <span class=\"hljs-string\">&#x27;-&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27;*&#x27;</span> || ch == <span class=\"hljs-string\">&#x27;/&#x27;</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; cal;<br>    <span class=\"hljs-type\">char</span> ch;<br>    <span class=\"hljs-type\">bool</span> read = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; noskipws &gt;&gt; ch) &#123; <span class=\"hljs-comment\">//不跳过空格读入</span><br>    <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27; &#x27;</span> || ch == <span class=\"hljs-string\">&#x27;\\n&#x27;</span>) <span class=\"hljs-keyword\">continue</span>;<br>            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isdigit</span>(ch)) &#123;<span class=\"hljs-comment\">//如果是数字</span><br>            cout &lt;&lt; ch;<br>            read = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记读入的是数字</span><br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-keyword\">if</span> (read) &#123;<br>                cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>                read = <span class=\"hljs-literal\">false</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<span class=\"hljs-comment\">//左括号直接入栈</span><br>                cal.<span class=\"hljs-built_in\">push</span>(ch);<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27;)&#x27;</span>) &#123;<span class=\"hljs-comment\">//处理读入的右括号</span><br>            <span class=\"hljs-comment\">//弹出栈顶元素直至栈顶为左括号</span><br>                <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; cal.<span class=\"hljs-built_in\">top</span>() != <span class=\"hljs-string\">&#x27;(&#x27;</span>) &#123;<br>                    cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>                    cal.<span class=\"hljs-built_in\">pop</span>();<br>                &#125;<br>                <span class=\"hljs-keyword\">if</span> (!cal.<span class=\"hljs-built_in\">empty</span>()) cal.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//弹出左括号但不输出</span><br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ch == <span class=\"hljs-string\">&#x27;+&#x27;</span> || ch == <span class=\"hljs-string\">&#x27;-&#x27;</span> || ch == <span class=\"hljs-string\">&#x27;*&#x27;</span> || ch == <span class=\"hljs-string\">&#x27;/&#x27;</span>) &#123;<br>                <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; cal.<span class=\"hljs-built_in\">top</span>() != <span class=\"hljs-string\">&#x27;(&#x27;</span> &amp;&amp; <span class=\"hljs-built_in\">pre</span>(cal.<span class=\"hljs-built_in\">top</span>()) &gt;= <span class=\"hljs-built_in\">pre</span>(ch)) &#123;<br>                    cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>                    cal.<span class=\"hljs-built_in\">pop</span>();<br>                &#125;<br>                cal.<span class=\"hljs-built_in\">push</span>(ch);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-comment\">//弹出栈内所有运算符</span><br>    <span class=\"hljs-keyword\">while</span> (!cal.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        cout &lt;&lt; cal.<span class=\"hljs-built_in\">top</span>() &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        cal.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><code>&lt;cctype&gt;</code> 是 C++ 标准库中的头文件，提供了一系列用于字符分类和处理的函数（通常传入的参数类型为 <code>char</code>）。</p>\n<table>\n<thead>\n<tr>\n<th>字符分类函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>isalpha()</code></td>\n<td>检查是否是字母（a-z, A-Z）</td>\n</tr>\n<tr>\n<td><code>isdigit()</code></td>\n<td>检查是否是数字（0-9）</td>\n</tr>\n<tr>\n<td><code>isalnum()</code></td>\n<td>检查是否是字母或数字</td>\n</tr>\n<tr>\n<td><code>isspace()</code></td>\n<td>检查是否是空白字符（空格、制表符、换行等）</td>\n</tr>\n<tr>\n<td><code>islower()</code></td>\n<td>检查是否是小写字母</td>\n</tr>\n<tr>\n<td><code>isupper()</code></td>\n<td>检查是否是大写字母</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>字符转换函数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>tolower()</code></td>\n<td>将字符转换为小写</td>\n</tr>\n<tr>\n<td><code>toupper()</code></td>\n<td>将字符转换为大写</td>\n</tr>\n</tbody>\n</table>\n<p><strong>字符串翻转函数</strong>：<code>reverse(s.begin(),s.end())</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123; <br>    string s=<span class=\"hljs-string\">&quot;hello world&quot;</span>;<br>    <span class=\"hljs-built_in\">reverse</span>(s.<span class=\"hljs-built_in\">begin</span>(),s.<span class=\"hljs-built_in\">end</span>());<br>    cout&lt;&lt;s&lt;&lt;endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-danger\">\n            <p><code>reverse()</code><strong>返回值</strong>为<code>void</code>，而不是<code>string</code></p>\n          </div>\n<div class=\"note note-info\">\n            <p>若是想<strong>保留原字符串</strong>：</p><ul><li>复制<strong>原字符串</strong></li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">string rev=s;<br><span class=\"hljs-built_in\">reverse</span>(rev.<span class=\"hljs-built_in\">begin</span>(),rev.<span class=\"hljs-built_in\">end</span>());<br></code></pre></td></tr></table></figure><ul><li>调用<strong>字符翻转迭代器</strong></li></ul><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">string <span class=\"hljs-title\">rev</span><span class=\"hljs-params\">(s.rbegin(),s.rend())</span></span>;<br></code></pre></td></tr></table></figure>\n          </div>\n<p><code>noskipws</code>是定义在 <code>&lt;iomanip&gt;</code>头文件中的一个 I/O 操纵符（manipulator），全称是 <strong>“no skip whitespace”</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">char</span> ch;<br>cin &gt;&gt; ch;       <span class=\"hljs-comment\">// 自动跳过空白，读取第一个非空白字符</span><br>cin &gt;&gt; noskipws &gt;&gt; ch;  <span class=\"hljs-comment\">// 不跳过空白，读取下一个字符（可能是空白）</span><br></code></pre></td></tr></table></figure>\n<p>如果需要恢复默认的跳过空白行为（作用相当于一个开关激活函数）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cin &gt;&gt; noskipws;  <span class=\"hljs-comment\">// 关闭跳过空白</span><br><span class=\"hljs-comment\">// ... 读取包含空格的输入 ...</span><br>cin &gt;&gt; skipws;    <span class=\"hljs-comment\">// 恢复默认行为</span><br></code></pre></td></tr></table></figure>\n<p>与<code>cin.get</code>相比更加灵活可控：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">cin.<span class=\"hljs-built_in\">get</span>(ch);  <span class=\"hljs-comment\">// 总是读取下一个字符（包括空白），不需要 noskipws</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"H题：字符串反转\">H题：字符串反转</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e8ab38ca\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e8ab38ca\">\n        <div class=\"fold-arrow\">▶</div> H题：字符串反转\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e8ab38ca\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小C很喜欢倒着写单词，现在给你一行小C写的文本，你能把每个单词都反转并输出它们吗？</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试样例。第一行为一个整数T，代表测试样例的数量，后面跟着T个测试样例。每个测试样例占一行，包含多个单词。一行最多有1000个字符。</p><h3 id=\"输出\">输出</h3><p>对于每一个测试样例，你应该输出转换后的文本。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-number\">3</span><br>olleh !dlrow<br><span class=\"hljs-selector-tag\">I</span> ekil <span class=\"hljs-selector-class\">.bulcmca</span><br><span class=\"hljs-selector-tag\">I</span> evol <span class=\"hljs-selector-class\">.mca</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">hello world!<br><span class=\"hljs-selector-tag\">I</span> like acmclub.<br><span class=\"hljs-selector-tag\">I</span> love acm.<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>本题适合用栈“先进后出”的特性来进行字符串的反转，<strong>解题思路</strong>如下：</p>\n<ol>\n<li>逐个字符处理进行读入，压入栈内</li>\n<li>当遇到<strong>空格</strong>时，将栈内的字符全部弹出</li>\n<li>循环结束后单独处理栈内剩余元素</li>\n</ol>\n<div class=\"note note-danger\">\n            <p>⚠️注意：是<strong>逐个单词进行逆序</strong>，不是<strong>整段文本所有字母的逆序</strong>，因此需要<strong>根据输入的空格和回车来确定分段点</strong>。</p>\n          </div>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">reverseWords</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    string line;<br>    <span class=\"hljs-built_in\">getline</span>(cin, line);<span class=\"hljs-comment\">//整行读入输入</span><br>    stack&lt;<span class=\"hljs-type\">char</span>&gt; st;<span class=\"hljs-comment\">//用于反转字符的栈</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> c : line) &#123;<span class=\"hljs-comment\">//遍历每一个字符</span><br>    <span class=\"hljs-comment\">//line可以是字符串也可以是字符数组</span><br>        <span class=\"hljs-keyword\">if</span> (c == <span class=\"hljs-string\">&#x27; &#x27;</span>) &#123;<span class=\"hljs-comment\">//遇到空格，开始输出字符</span><br>            <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>                cout &lt;&lt; st.<span class=\"hljs-built_in\">top</span>();<br>                st.<span class=\"hljs-built_in\">pop</span>();<br>            &#125;<br>            cout &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            st.<span class=\"hljs-built_in\">push</span>(c);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) &#123;<span class=\"hljs-comment\">//循环结束，处理最后一个没有空格的单词</span><br>        cout &lt;&lt; st.<span class=\"hljs-built_in\">top</span>();<br>        st.<span class=\"hljs-built_in\">pop</span>();<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    cin.<span class=\"hljs-built_in\">ignore</span>(); <span class=\"hljs-comment\">//忽略换行符</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>        <span class=\"hljs-built_in\">reverseWords</span>();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释-v2\">注释</h3>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>getline(cin, line)</th>\n<th>cin.get()</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读取方式</td>\n<td>读取整行直到<code>\\n</code></td>\n<td>可读取单个字符或一行</td>\n</tr>\n<tr>\n<td>存储类型</td>\n<td><code>string</code></td>\n<td><code>char</code>或<code>char[]</code></td>\n</tr>\n<tr>\n<td>是否跳过空白字符</td>\n<td>不会跳过（读取所有字符）</td>\n<td>不会跳过（读取所有字符）</td>\n</tr>\n<tr>\n<td>换行符处理</td>\n<td>丢弃’\\n’（不存储）</td>\n<td>可以读取’\\n’</td>\n</tr>\n</tbody>\n</table>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=DuDz6B4cqVc&amp;t=92s\">Data Structures: Crash Course Computer Science #14</a></p>\n"},{"title":"Operator Overloading in C++","date":"2025-07-19T15:00:29.000Z","category_bar":true,"archive":true,"_content":"\n\n","source":"_posts/CPP/Operator-Overloading-in-C++.md","raw":"---\ntitle: Operator Overloading in C++\ndate: 2025-07-19 23:00:29\ntags: [C++,OOP]\ncategory: \n- CPP\n- OOP\ncategory_bar: true\narchive: true\n---\n\n\n","slug":"CPP/Operator-Overloading-in-C++","published":1,"updated":"2025-07-19T15:26:25.197Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcl000g40w350yn5l5w","content":"","excerpt":"","more":""},{"title":"CUMT-Datastructure-Assignment 2","date":"2025-06-18T05:02:54.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Assignment-2.png","category_bar":true,"description":"Problems involving the construction of binary trees, pre-order, in-order, and post-order traversal, as well as stack-related issues","_content":"\n\n## A题：统计回文字符串\n{%fold into @ A题：统计回文字符串 %}\n### 题目描述\n现在给你一个字符串S，请你计算S中有多少连续子串是回文串。\n### 输入\n输入包含多组测试数据。每组输入是一个非空字符串，长度不超过5000。\n### 输出\n对于每组输入，输出回文子串的个数。\n### 样例输入\n```\naba\naa\n```\n### 样例输出\n```\n4\n3\n```\n{%endfold%}\n\n### 问题分析\n先读取字符串```s```，采取从中心向两边进行扩展的方法，若回文字符串为奇数个字符则起始时中心均为```i```；若回文字符串为偶数个字符则起始时中心```i```和```i+1```，直至字符不匹配或者数组越界。\n### 注意点\n```cpp\nwhile (left >= 0 && right < n && s[left] == s[right])\n```\n和\n```cpp\nwhile (s[left] == s[right]&&left >= 0 && right < n )\n```\n在编译器中并不等同：应该先检查是否越界，否则可能出现未定义行为而报错\n**短路求值规则**：逻辑运算符 && 会从左到右依次求值，如果前面的条件为 false，后面的条件不会被计算。第一种写法利用了短路规则，避免了非法内存访问；第二种写法则可能引发问题。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint countnumber(string s) {\n\tint n = s.size();\n\tint num=0;\n\tfor (int i = 0;i < n;i++) {\n\t\tint left = i;\n\t\tint right = i;\n\t\t\n\t\twhile (left >= 0 && right < n && s[left] == s[right]) {\n\t\t\tnum++;\n\t\t\t--left;\n\t\t\t++right;\n\t\t}\n\t\tleft = i, right = i + 1;\n\t\twhile (left >= 0 && right < n && s[left] == s[right]) {\n\t\t\tnum++;\n\t\t\t--left;\n\t\t\t++right;\n\t\t}\n\t}\n\treturn num;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s) {\n\tcout << countnumber(s) << endl;\n}\n\treturn 0;\n}\n```\n## B题：构建矩阵\n{%fold into @ B题：构建矩阵 %}\n### 题目描述\n现请你构建一个N*N的矩阵，第i行j列的元素为i与j的乘积。（i，j均从1开始）\n### 输入\n输入的第一行为一个正整数C，表示测试样例的个数。\n然后是C行测试样例，每行为一个整数N（1<=N<=9），表示矩阵的行列数。\n### 输出\n对于每一组输入，输出构建的矩阵。\n### 样例输入\n```\n2\n1\n4\n```\n### 样例输出\n```\n1\n1 2 3 4\n2 4 6 8\n3 6 9 12\n4 8 12 16\n```\n{%endfold%}\n\n### 问题分析\n1. 构造```printmatrix```的函数，主函数中每读入一个数，调用一次函数\n2. 观察矩阵，相当于每行是一个等差数列，公差等于所在行行数，每换一次行其公差+1即可。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\nvoid matrix(int i) {\n\tint d = 1;\n\tfor (int n = 1;n <= i * i && d<=i;n += d) {\n\t\tcout << n << \" \";\n\t\t\tif (n == i * d) {\n\t\t\t\tcout << endl;\n\t\t\t\td++;\n\t\t\t\tn = 0;\n\t\t\t}\n\t}\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tint i;\n\tfor (int j = 0;j < n;j++) {\n\t\tcin >> i;\n\t\tmatrix(i);\n\t}\n\treturn 0;\n}\n```\n构造打印矩阵函数的另外一种做法，双层嵌套**for**循环，这个方法显然更加直观:\n```cpp\nvoid printMatrix(int N) {\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            cout << i * j;\n            if (j < N) {\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n}\n```\n## C题：找规律填数字\n{%fold into @ C题：找规律填数字 %}\n### 题目描述\n小宇正在读小学，今天老师布置了几道数学题目。小宇平时上课经常不专心，这些他可发愁了，怎么办呢？看看你能不能帮帮他。\n题目是给你一组有规律序列的前面5个整数，请你给出它后面跟着的5个整数，如：1,2,3,4,5,_, _, _, _, _, _。这是个等差数列，后面应该是6,7,8,9,10，就这么简单。而且现在小宇已经知道这串序列要么是等差数列，要么是等比数列或者是斐波那契数列。\n### 输入\n输入包含多组测试数据。每组输入5个整数，每个数字之间隔一个空格，当5个数字都为0时输入结束。\n### 输出\n对于每组输入，输出这串数列的后面5个数字，每个数字之间隔一个空格。\n### 样例输入\n```\n1 2 3 4 5\n1 2 4 8 16\n1 2 3 5 8\n0 0 0 0 0\n```\n### 样例输出\n```\n6 7 8 9 10\n32 64 128 256 512\n13 21 34 55 89\n```\n{%endfold%}\n### 注意点\n参数变量较多，在```if```条件判断语句中要尽可能的将每个参数都包含进去，减小数据巧合而错判数列类型发生的可能性，博主一开始只通过三个参数就判断了数列的类型，就被特殊情况爆破了。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid predictNext(int a, int b, int c, int d, int e) {\n    if (a == 0 && b == 0 && c == 0 && d == 0 && e == 0) return;\n\n    int d = b - a;\n    if (b + d == c && c + d == d && d + d == e) {\n        cout << e + d << \" \" << e + 2 * d << \" \" << e + 3 * d\n            << \" \" << e + 4 * d << \" \" << e + 5 * d << endl;\n        return;\n    }\n\n    if (a != 0 && b != 0 && c != 0 && d != 0 && e != 0) {\n        int q = b / a;\n        if (a * q == b && b * q == c && c * q == d && d * q == e) {\n            int next = e;\n            for (int i = 0; i < 5; ++i) {\n                next *= q;\n                cout << next << \" \";\n            }\n            cout << endl;\n            return;\n        }\n    }\n\n    if (a + b == c && b + c == d && c + d == e) {\n        int x = d, y = e;\n        for (int i = 0; i < 5; ++i) {\n            int z = x + y;\n            cout << z << \" \";\n            x = y;\n            y = z;\n        }\n        cout << endl;\n        return;\n    }\n\n    int x = d, y = e;\n    for (int i = 0; i < 5; ++i) {\n        int z = x + y;\n        cout << z << \" \";\n        x = y;\n        y = z;\n    }\n    cout << endl;\n}\n\nint main() {\n    int a, b, c, d, e;\n    while (cin >> a >> b >> c >> d >> e) {\n        if (a == 0 && b == 0 && c == 0 && d == 0 && e == 0) break;\n        predictNext(a, b, c, d, e);\n    }\n    return 0;\n}\n```\n## D题：复原二叉树\n{%fold into @ D题：复原二叉树 %}\n### 题目描述\n小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。\n### 输入\n输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。\n### 输出\n对于每组输入，输出对应的二叉树的后续遍历结果。\n### 样例输入\n```\nDBACEGF ABCDEFG\nBCAD CBAD\n```\n### 样例输出\n```\nACBFGED\nCDAB\n```\n{%endfold%}\n\n### 问题分析\n题目给前序和中序求后序遍历结果，前序是根左右（NLR），中序是左根右（LNR），也就是说前序遍历的第一个字母是二叉树的根节点，在中序遍历根节点前面的是根的左子树，后面的是右子树，这样我们可以不断找到树的前序遍历和中序遍历结果，从而进行递归。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid postOrder(string pre, string in) {\n\tif (pre.empty()) return;\n\tchar root;\n\troot = pre[0];\n\tint position;\n\tposition = in.find(root);\n\tpostOrder(pre.substr(1, position), in.substr(0, position));\n\tpostOrder(pre.substr(position + 1), in.substr(position + 1));\n\tcout << root;\n}\nint main() {\n\tstring pre, in;\n\twhile (cin >> pre >> in) {\n\t\tpostOrder(pre, in);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n## E题：子树的后序遍历\n{%fold into @ E题：子树的后序遍历 %}\n### 题目描述\n给你一颗二叉树的中序和后序遍历序列，请编程输出该二叉树左子树或右子树的后序遍历序列。\n### 输入\n占三行，第一行表示二叉树的中序遍历序列，第二行表示后序遍历序列。用大写字母标识结点，二叉树的结点最多26个。\n第三行是单个字母，L表示要求输出该二叉树的左子树的后序遍历序列，R表示要求输出该二叉树的右子树的后序遍历序列。\n### 输出\n按要求输出该二叉树左子树或右子树的后序遍历序列。\n### 样例输入\n```\nBDCEAFHG\nDECBHGFA\nR\n```\n### 样例输出\n```\nHGF\n```\n{%endfold%}\n### 问题分析\n题目给中序和后序遍历，中序是左根右（LNR），后序是左右根（LRN），后序遍历的最后一个即为二叉树的根结点，从而在中序遍历中，根结点前面的是的左子树，后面的是右子树；由于本题输出后序遍历结果，而后序遍历结果题目已经给出，现只需计算左、右子树长度，从后序遍历中提取相应字符串长度即可。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n\tstring in, post;\n\tcin >> in >> post;\n\tchar side, root;\n\tcin >> side;\n\troot=post.back();// 后序最后一个字符是根节点\n\tint position = in.find(root);\n\tint length;\n\tif (side == 'R') { \n\t\tlength = in.size() - position - 1;\n\t\tcout << post.substr(post.size() - length - 1,length) << endl; }\n\telse { \n\t\tlength = position;\n\t\tcout << post.substr(0,length); }\n\treturn 0;\n}\n```\n### 注意\n1. 提取字符串最后一个字符时用 ```post.back()```或```post[post.size() - 1]```\n 获取最后一个字符（而不是 ```post[-1]```，C++不支持负数索引）。\n2. 有关字符串```string```的函数：\n\n用法示例     | 作用 | 注意事项\n-------- | ------- | -------- | \n`str.find()` | 查找字符或子串|返回首次出现字符的位置（`size_t`）\n`str.substr()` | 提取字符串|参数1：起始位置；参数2：长度（可选） \n`str.size()`| 获取字符串长度|返回字符数量（size_t）\n`str.empty()` | 判断是否为空|返回值bool类型\n`str.front()` | 获取首字符|返回char引用\n`str.back()`| 获取末尾字符|返回char引用\n\n- s + 'a'：在原字符串 s 的**末尾添加**字符 'a'；\n- 'a' + s：在原字符串 s 的**开头添加**字符 'a'。\n\n[Leetcode 67.二进制求和](https://leetcode.cn/problems/add-binary?envType=problem-list-v2&envId=string)\n\n这里使用**模拟竖式**的方法进行计算，对于位数不相等的两个数，我们使用以上方法对其**在前面补零**，使得两个数的位数相等。\n ```cpp\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int al=a.size(),bl=b.size();\n        while(al<bl){\n            a='0'+a;\n            al++;\n        }\n        while(al>bl){\n            b='0'+b;\n            bl++;\n        }\n        int forward=0;\n        for(int i=al-1;i>=0;i--){\n            int temp=a[i]+b[i]-'0'-'0'+forward;\n            forward=temp/2;\n            a[i]=temp%2+'0';\n        }\n        if(forward>0){\n            a='1'+a;\n        }\n        return a;\n    }\n};\n```\n\n## F题：迷宫问题\n{%fold into @ F题：迷宫问题 %}\n### 题目描述\n小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。\n小明只能向上下左右四个方向移动。\n### 输入\n输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。\n每组输入的第一行是两个整数N和M（1<=N,M<=100）。\n接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。\n字符的含义如下：\n‘S’：起点\n‘E’：终点\n‘-’：空地，可以通过\n‘#’：障碍，无法通过\n输入数据保证有且仅有一个起点和终点。\n### 输出\n对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。\n### 样例输入\n```\n1\n5 5\nS-###\n-----\n##---\nE#---\n---##\n```\n### 样例输出\n```\n9\n```\n{%endfold%}\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 100;\nchar grid[MAX][MAX];\nint dist[MAX][MAX];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint n, m;\n\nint bfs(pair<int, int> start, pair<int, int> end) {\n    queue<pair<int, int>> q;\n    q.push(start);\n    dist[start.first][start.second] = 0;\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        if (x == end.first && y == end.second)\n            return dist[x][y];\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] != '#' && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        pair<int, int> start, end;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> grid[i][j];\n                if (grid[i][j] == 'S') start = {i, j};\n                if (grid[i][j] == 'E') end = {i, j};\n            }\n        }\n\n        memset(dist, -1, sizeof(dist));\n        cout << bfs(start, end) << '\\n';\n    }\n    return 0;\n}\n```\n","source":"_posts/Data structure/CUMT-Datastructure-Assignment-2.md","raw":"---\ntitle: CUMT-Datastructure-Assignment 2\ndate: 2025-06-18 13:02:54\ntags: [stack,binary tree,algorithm]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Assignment-2.png\ncategory: Data Structure\ncategory_bar: true\ndescription: Problems involving the construction of binary trees, pre-order, in-order, and post-order traversal, as well as stack-related issues\n---\n\n\n## A题：统计回文字符串\n{%fold into @ A题：统计回文字符串 %}\n### 题目描述\n现在给你一个字符串S，请你计算S中有多少连续子串是回文串。\n### 输入\n输入包含多组测试数据。每组输入是一个非空字符串，长度不超过5000。\n### 输出\n对于每组输入，输出回文子串的个数。\n### 样例输入\n```\naba\naa\n```\n### 样例输出\n```\n4\n3\n```\n{%endfold%}\n\n### 问题分析\n先读取字符串```s```，采取从中心向两边进行扩展的方法，若回文字符串为奇数个字符则起始时中心均为```i```；若回文字符串为偶数个字符则起始时中心```i```和```i+1```，直至字符不匹配或者数组越界。\n### 注意点\n```cpp\nwhile (left >= 0 && right < n && s[left] == s[right])\n```\n和\n```cpp\nwhile (s[left] == s[right]&&left >= 0 && right < n )\n```\n在编译器中并不等同：应该先检查是否越界，否则可能出现未定义行为而报错\n**短路求值规则**：逻辑运算符 && 会从左到右依次求值，如果前面的条件为 false，后面的条件不会被计算。第一种写法利用了短路规则，避免了非法内存访问；第二种写法则可能引发问题。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint countnumber(string s) {\n\tint n = s.size();\n\tint num=0;\n\tfor (int i = 0;i < n;i++) {\n\t\tint left = i;\n\t\tint right = i;\n\t\t\n\t\twhile (left >= 0 && right < n && s[left] == s[right]) {\n\t\t\tnum++;\n\t\t\t--left;\n\t\t\t++right;\n\t\t}\n\t\tleft = i, right = i + 1;\n\t\twhile (left >= 0 && right < n && s[left] == s[right]) {\n\t\t\tnum++;\n\t\t\t--left;\n\t\t\t++right;\n\t\t}\n\t}\n\treturn num;\n}\nint main() {\n\tstring s;\n\twhile (cin >> s) {\n\tcout << countnumber(s) << endl;\n}\n\treturn 0;\n}\n```\n## B题：构建矩阵\n{%fold into @ B题：构建矩阵 %}\n### 题目描述\n现请你构建一个N*N的矩阵，第i行j列的元素为i与j的乘积。（i，j均从1开始）\n### 输入\n输入的第一行为一个正整数C，表示测试样例的个数。\n然后是C行测试样例，每行为一个整数N（1<=N<=9），表示矩阵的行列数。\n### 输出\n对于每一组输入，输出构建的矩阵。\n### 样例输入\n```\n2\n1\n4\n```\n### 样例输出\n```\n1\n1 2 3 4\n2 4 6 8\n3 6 9 12\n4 8 12 16\n```\n{%endfold%}\n\n### 问题分析\n1. 构造```printmatrix```的函数，主函数中每读入一个数，调用一次函数\n2. 观察矩阵，相当于每行是一个等差数列，公差等于所在行行数，每换一次行其公差+1即可。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\nvoid matrix(int i) {\n\tint d = 1;\n\tfor (int n = 1;n <= i * i && d<=i;n += d) {\n\t\tcout << n << \" \";\n\t\t\tif (n == i * d) {\n\t\t\t\tcout << endl;\n\t\t\t\td++;\n\t\t\t\tn = 0;\n\t\t\t}\n\t}\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tint i;\n\tfor (int j = 0;j < n;j++) {\n\t\tcin >> i;\n\t\tmatrix(i);\n\t}\n\treturn 0;\n}\n```\n构造打印矩阵函数的另外一种做法，双层嵌套**for**循环，这个方法显然更加直观:\n```cpp\nvoid printMatrix(int N) {\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            cout << i * j;\n            if (j < N) {\n                cout << \" \";\n            }\n        }\n        cout << endl;\n    }\n}\n```\n## C题：找规律填数字\n{%fold into @ C题：找规律填数字 %}\n### 题目描述\n小宇正在读小学，今天老师布置了几道数学题目。小宇平时上课经常不专心，这些他可发愁了，怎么办呢？看看你能不能帮帮他。\n题目是给你一组有规律序列的前面5个整数，请你给出它后面跟着的5个整数，如：1,2,3,4,5,_, _, _, _, _, _。这是个等差数列，后面应该是6,7,8,9,10，就这么简单。而且现在小宇已经知道这串序列要么是等差数列，要么是等比数列或者是斐波那契数列。\n### 输入\n输入包含多组测试数据。每组输入5个整数，每个数字之间隔一个空格，当5个数字都为0时输入结束。\n### 输出\n对于每组输入，输出这串数列的后面5个数字，每个数字之间隔一个空格。\n### 样例输入\n```\n1 2 3 4 5\n1 2 4 8 16\n1 2 3 5 8\n0 0 0 0 0\n```\n### 样例输出\n```\n6 7 8 9 10\n32 64 128 256 512\n13 21 34 55 89\n```\n{%endfold%}\n### 注意点\n参数变量较多，在```if```条件判断语句中要尽可能的将每个参数都包含进去，减小数据巧合而错判数列类型发生的可能性，博主一开始只通过三个参数就判断了数列的类型，就被特殊情况爆破了。\n\n### 完整代码\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid predictNext(int a, int b, int c, int d, int e) {\n    if (a == 0 && b == 0 && c == 0 && d == 0 && e == 0) return;\n\n    int d = b - a;\n    if (b + d == c && c + d == d && d + d == e) {\n        cout << e + d << \" \" << e + 2 * d << \" \" << e + 3 * d\n            << \" \" << e + 4 * d << \" \" << e + 5 * d << endl;\n        return;\n    }\n\n    if (a != 0 && b != 0 && c != 0 && d != 0 && e != 0) {\n        int q = b / a;\n        if (a * q == b && b * q == c && c * q == d && d * q == e) {\n            int next = e;\n            for (int i = 0; i < 5; ++i) {\n                next *= q;\n                cout << next << \" \";\n            }\n            cout << endl;\n            return;\n        }\n    }\n\n    if (a + b == c && b + c == d && c + d == e) {\n        int x = d, y = e;\n        for (int i = 0; i < 5; ++i) {\n            int z = x + y;\n            cout << z << \" \";\n            x = y;\n            y = z;\n        }\n        cout << endl;\n        return;\n    }\n\n    int x = d, y = e;\n    for (int i = 0; i < 5; ++i) {\n        int z = x + y;\n        cout << z << \" \";\n        x = y;\n        y = z;\n    }\n    cout << endl;\n}\n\nint main() {\n    int a, b, c, d, e;\n    while (cin >> a >> b >> c >> d >> e) {\n        if (a == 0 && b == 0 && c == 0 && d == 0 && e == 0) break;\n        predictNext(a, b, c, d, e);\n    }\n    return 0;\n}\n```\n## D题：复原二叉树\n{%fold into @ D题：复原二叉树 %}\n### 题目描述\n小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。\n### 输入\n输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。\n### 输出\n对于每组输入，输出对应的二叉树的后续遍历结果。\n### 样例输入\n```\nDBACEGF ABCDEFG\nBCAD CBAD\n```\n### 样例输出\n```\nACBFGED\nCDAB\n```\n{%endfold%}\n\n### 问题分析\n题目给前序和中序求后序遍历结果，前序是根左右（NLR），中序是左根右（LNR），也就是说前序遍历的第一个字母是二叉树的根节点，在中序遍历根节点前面的是根的左子树，后面的是右子树，这样我们可以不断找到树的前序遍历和中序遍历结果，从而进行递归。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nvoid postOrder(string pre, string in) {\n\tif (pre.empty()) return;\n\tchar root;\n\troot = pre[0];\n\tint position;\n\tposition = in.find(root);\n\tpostOrder(pre.substr(1, position), in.substr(0, position));\n\tpostOrder(pre.substr(position + 1), in.substr(position + 1));\n\tcout << root;\n}\nint main() {\n\tstring pre, in;\n\twhile (cin >> pre >> in) {\n\t\tpostOrder(pre, in);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n```\n\n## E题：子树的后序遍历\n{%fold into @ E题：子树的后序遍历 %}\n### 题目描述\n给你一颗二叉树的中序和后序遍历序列，请编程输出该二叉树左子树或右子树的后序遍历序列。\n### 输入\n占三行，第一行表示二叉树的中序遍历序列，第二行表示后序遍历序列。用大写字母标识结点，二叉树的结点最多26个。\n第三行是单个字母，L表示要求输出该二叉树的左子树的后序遍历序列，R表示要求输出该二叉树的右子树的后序遍历序列。\n### 输出\n按要求输出该二叉树左子树或右子树的后序遍历序列。\n### 样例输入\n```\nBDCEAFHG\nDECBHGFA\nR\n```\n### 样例输出\n```\nHGF\n```\n{%endfold%}\n### 问题分析\n题目给中序和后序遍历，中序是左根右（LNR），后序是左右根（LRN），后序遍历的最后一个即为二叉树的根结点，从而在中序遍历中，根结点前面的是的左子树，后面的是右子树；由于本题输出后序遍历结果，而后序遍历结果题目已经给出，现只需计算左、右子树长度，从后序遍历中提取相应字符串长度即可。\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n\tstring in, post;\n\tcin >> in >> post;\n\tchar side, root;\n\tcin >> side;\n\troot=post.back();// 后序最后一个字符是根节点\n\tint position = in.find(root);\n\tint length;\n\tif (side == 'R') { \n\t\tlength = in.size() - position - 1;\n\t\tcout << post.substr(post.size() - length - 1,length) << endl; }\n\telse { \n\t\tlength = position;\n\t\tcout << post.substr(0,length); }\n\treturn 0;\n}\n```\n### 注意\n1. 提取字符串最后一个字符时用 ```post.back()```或```post[post.size() - 1]```\n 获取最后一个字符（而不是 ```post[-1]```，C++不支持负数索引）。\n2. 有关字符串```string```的函数：\n\n用法示例     | 作用 | 注意事项\n-------- | ------- | -------- | \n`str.find()` | 查找字符或子串|返回首次出现字符的位置（`size_t`）\n`str.substr()` | 提取字符串|参数1：起始位置；参数2：长度（可选） \n`str.size()`| 获取字符串长度|返回字符数量（size_t）\n`str.empty()` | 判断是否为空|返回值bool类型\n`str.front()` | 获取首字符|返回char引用\n`str.back()`| 获取末尾字符|返回char引用\n\n- s + 'a'：在原字符串 s 的**末尾添加**字符 'a'；\n- 'a' + s：在原字符串 s 的**开头添加**字符 'a'。\n\n[Leetcode 67.二进制求和](https://leetcode.cn/problems/add-binary?envType=problem-list-v2&envId=string)\n\n这里使用**模拟竖式**的方法进行计算，对于位数不相等的两个数，我们使用以上方法对其**在前面补零**，使得两个数的位数相等。\n ```cpp\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int al=a.size(),bl=b.size();\n        while(al<bl){\n            a='0'+a;\n            al++;\n        }\n        while(al>bl){\n            b='0'+b;\n            bl++;\n        }\n        int forward=0;\n        for(int i=al-1;i>=0;i--){\n            int temp=a[i]+b[i]-'0'-'0'+forward;\n            forward=temp/2;\n            a[i]=temp%2+'0';\n        }\n        if(forward>0){\n            a='1'+a;\n        }\n        return a;\n    }\n};\n```\n\n## F题：迷宫问题\n{%fold into @ F题：迷宫问题 %}\n### 题目描述\n小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。\n小明只能向上下左右四个方向移动。\n### 输入\n输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。\n每组输入的第一行是两个整数N和M（1<=N,M<=100）。\n接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。\n字符的含义如下：\n‘S’：起点\n‘E’：终点\n‘-’：空地，可以通过\n‘#’：障碍，无法通过\n输入数据保证有且仅有一个起点和终点。\n### 输出\n对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。\n### 样例输入\n```\n1\n5 5\nS-###\n-----\n##---\nE#---\n---##\n```\n### 样例输出\n```\n9\n```\n{%endfold%}\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nconst int MAX = 100;\nchar grid[MAX][MAX];\nint dist[MAX][MAX];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint n, m;\n\nint bfs(pair<int, int> start, pair<int, int> end) {\n    queue<pair<int, int>> q;\n    q.push(start);\n    dist[start.first][start.second] = 0;\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        if (x == end.first && y == end.second)\n            return dist[x][y];\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] != '#' && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[x][y] + 1;\n                q.push({nx, ny});\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m;\n        pair<int, int> start, end;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                cin >> grid[i][j];\n                if (grid[i][j] == 'S') start = {i, j};\n                if (grid[i][j] == 'E') end = {i, j};\n            }\n        }\n\n        memset(dist, -1, sizeof(dist));\n        cout << bfs(start, end) << '\\n';\n    }\n    return 0;\n}\n```\n","slug":"Data structure/CUMT-Datastructure-Assignment-2","published":1,"updated":"2025-09-03T08:46:12.959Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcm000i40w3caj101or","content":"<h2 id=\"A题：统计回文字符串\">A题：统计回文字符串</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-5516a047\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-5516a047\">\n        <div class=\"fold-arrow\">▶</div> A题：统计回文字符串\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-5516a047\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现在给你一个字符串S，请你计算S中有多少连续子串是回文串。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入是一个非空字符串，长度不超过5000。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出回文子串的个数。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight ebnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">aba</span><br><span class=\"hljs-attribute\">aa</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">4<br>3<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>先读取字符串<code>s</code>，采取从中心向两边进行扩展的方法，若回文字符串为奇数个字符则起始时中心均为<code>i</code>；若回文字符串为偶数个字符则起始时中心<code>i</code>和<code>i+1</code>，直至字符不匹配或者数组越界。</p>\n<h3 id=\"注意点\">注意点</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])<br></code></pre></td></tr></tbody></table></figure>\n<p>和</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span> (s[left] == s[right]&amp;&amp;left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n )<br></code></pre></td></tr></tbody></table></figure>\n<p>在编译器中并不等同：应该先检查是否越界，否则可能出现未定义行为而报错<br>\n<strong>短路求值规则</strong>：逻辑运算符 &amp;&amp; 会从左到右依次求值，如果前面的条件为 false，后面的条件不会被计算。第一种写法利用了短路规则，避免了非法内存访问；第二种写法则可能引发问题。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">countnumber</span><span class=\"hljs-params\">(string s)</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n = s.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-type\">int</span> left = i;<br>\t\t<span class=\"hljs-type\">int</span> right = i;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) {<br>\t\t\tnum++;<br>\t\t\t--left;<br>\t\t\t++right;<br>\t\t}<br>\t\tleft = i, right = i + <span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) {<br>\t\t\tnum++;<br>\t\t\t--left;<br>\t\t\t++right;<br>\t\t}<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> num;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tstring s;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; s) {<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">countnumber</span>(s) &lt;&lt; endl;<br>}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"B题：构建矩阵\">B题：构建矩阵</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e5e15715\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e5e15715\">\n        <div class=\"fold-arrow\">▶</div> B题：构建矩阵\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e5e15715\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现请你构建一个N*N的矩阵，第i行j列的元素为i与j的乘积。（i，j均从1开始）</p><h3 id=\"输入\">输入</h3><p>输入的第一行为一个正整数C，表示测试样例的个数。<br>然后是C行测试样例，每行为一个整数N（1&lt;=N&lt;=9），表示矩阵的行列数。</p><h3 id=\"输出\">输出</h3><p>对于每一组输入，输出构建的矩阵。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">2<br>1<br>4<br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">3 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">12</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">8</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">16</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<ol>\n<li>构造<code>printmatrix</code>的函数，主函数中每读入一个数，调用一次函数</li>\n<li>观察矩阵，相当于每行是一个等差数列，公差等于所在行行数，每换一次行其公差+1即可。</li>\n</ol>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>{<br>\t<span class=\"hljs-type\">int</span> d = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">1</span>;n &lt;= i * i &amp;&amp; d&lt;=i;n += d) {<br>\t\tcout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (n == i * d) {<br>\t\t\t\tcout &lt;&lt; endl;<br>\t\t\t\td++;<br>\t\t\t\tn = <span class=\"hljs-number\">0</span>;<br>\t\t\t}<br>\t}<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) {<br>\t\tcin &gt;&gt; i;<br>\t\t<span class=\"hljs-built_in\">matrix</span>(i);<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>构造打印矩阵函数的另外一种做法，双层嵌套<strong>for</strong>循环，这个方法显然更加直观:</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printMatrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> N)</span> </span>{<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= N; ++i) {<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= N; ++j) {<br>            cout &lt;&lt; i * j;<br>            <span class=\"hljs-keyword\">if</span> (j &lt; N) {<br>                cout &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>            }<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"C题：找规律填数字\">C题：找规律填数字</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-08e013ca\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-08e013ca\">\n        <div class=\"fold-arrow\">▶</div> C题：找规律填数字\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-08e013ca\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小宇正在读小学，今天老师布置了几道数学题目。小宇平时上课经常不专心，这些他可发愁了，怎么办呢？看看你能不能帮帮他。<br>题目是给你一组有规律序列的前面5个整数，请你给出它后面跟着的5个整数，如：1,2,3,4,5,_, _, _, _, _, _。这是个等差数列，后面应该是6,7,8,9,10，就这么简单。而且现在小宇已经知道这串序列要么是等差数列，要么是等比数列或者是斐波那契数列。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入5个整数，每个数字之间隔一个空格，当5个数字都为0时输入结束。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出这串数列的后面5个数字，每个数字之间隔一个空格。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">16</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-symbol\">32 </span><span class=\"hljs-number\">64</span> <span class=\"hljs-number\">128</span> <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">512</span><br><span class=\"hljs-symbol\">13 </span><span class=\"hljs-number\">21</span> <span class=\"hljs-number\">34</span> <span class=\"hljs-number\">55</span> <span class=\"hljs-number\">89</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"注意点-v2\">注意点</h3>\n<p>参数变量较多，在<code>if</code>条件判断语句中要尽可能的将每个参数都包含进去，减小数据巧合而错判数列类型发生的可能性，博主一开始只通过三个参数就判断了数列的类型，就被特殊情况爆破了。</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">predictNext</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c, <span class=\"hljs-type\">int</span> d, <span class=\"hljs-type\">int</span> e)</span> </span>{<br>    <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span> &amp;&amp; b == <span class=\"hljs-number\">0</span> &amp;&amp; c == <span class=\"hljs-number\">0</span> &amp;&amp; d == <span class=\"hljs-number\">0</span> &amp;&amp; e == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    <span class=\"hljs-type\">int</span> d = b - a;<br>    <span class=\"hljs-keyword\">if</span> (b + d == c &amp;&amp; c + d == d &amp;&amp; d + d == e) {<br>        cout &lt;&lt; e + d &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; e + <span class=\"hljs-number\">2</span> * d &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; e + <span class=\"hljs-number\">3</span> * d<br>            &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; e + <span class=\"hljs-number\">4</span> * d &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; e + <span class=\"hljs-number\">5</span> * d &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span>;<br>    }<br><br>    <span class=\"hljs-keyword\">if</span> (a != <span class=\"hljs-number\">0</span> &amp;&amp; b != <span class=\"hljs-number\">0</span> &amp;&amp; c != <span class=\"hljs-number\">0</span> &amp;&amp; d != <span class=\"hljs-number\">0</span> &amp;&amp; e != <span class=\"hljs-number\">0</span>) {<br>        <span class=\"hljs-type\">int</span> q = b / a;<br>        <span class=\"hljs-keyword\">if</span> (a * q == b &amp;&amp; b * q == c &amp;&amp; c * q == d &amp;&amp; d * q == e) {<br>            <span class=\"hljs-type\">int</span> next = e;<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) {<br>                next *= q;<br>                cout &lt;&lt; next &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>            }<br>            cout &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        }<br>    }<br><br>    <span class=\"hljs-keyword\">if</span> (a + b == c &amp;&amp; b + c == d &amp;&amp; c + d == e) {<br>        <span class=\"hljs-type\">int</span> x = d, y = e;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) {<br>            <span class=\"hljs-type\">int</span> z = x + y;<br>            cout &lt;&lt; z &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>            x = y;<br>            y = z;<br>        }<br>        cout &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span>;<br>    }<br><br>    <span class=\"hljs-type\">int</span> x = d, y = e;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) {<br>        <span class=\"hljs-type\">int</span> z = x + y;<br>        cout &lt;&lt; z &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>        x = y;<br>        y = z;<br>    }<br>    cout &lt;&lt; endl;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> a, b, c, d, e;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e) {<br>        <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span> &amp;&amp; b == <span class=\"hljs-number\">0</span> &amp;&amp; c == <span class=\"hljs-number\">0</span> &amp;&amp; d == <span class=\"hljs-number\">0</span> &amp;&amp; e == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-built_in\">predictNext</span>(a, b, c, d, e);<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"D题：复原二叉树\">D题：复原二叉树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-6292b2b8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-6292b2b8\">\n        <div class=\"fold-arrow\">▶</div> D题：复原二叉树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-6292b2b8\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出对应的二叉树的后续遍历结果。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight ebnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">DBACEGF ABCDEFG</span><br><span class=\"hljs-attribute\">BCAD CBAD</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">ACBFGED</span><br><span class=\"hljs-attribute\">CDAB</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>题目给前序和中序求后序遍历结果，前序是根左右（NLR），中序是左根右（LNR），也就是说前序遍历的第一个字母是二叉树的根节点，在中序遍历根节点前面的是根的左子树，后面的是右子树，这样我们可以不断找到树的前序遍历和中序遍历结果，从而进行递归。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(string pre, string in)</span> </span>{<br>\t<span class=\"hljs-keyword\">if</span> (pre.<span class=\"hljs-built_in\">empty</span>()) <span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-type\">char</span> root;<br>\troot = pre[<span class=\"hljs-number\">0</span>];<br>\t<span class=\"hljs-type\">int</span> position;<br>\tposition = in.<span class=\"hljs-built_in\">find</span>(root);<br>\t<span class=\"hljs-built_in\">postOrder</span>(pre.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">1</span>, position), in.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>, position));<br>\t<span class=\"hljs-built_in\">postOrder</span>(pre.<span class=\"hljs-built_in\">substr</span>(position + <span class=\"hljs-number\">1</span>), in.<span class=\"hljs-built_in\">substr</span>(position + <span class=\"hljs-number\">1</span>));<br>\tcout &lt;&lt; root;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tstring pre, in;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; pre &gt;&gt; in) {<br>\t\t<span class=\"hljs-built_in\">postOrder</span>(pre, in);<br>\t\tcout &lt;&lt; endl;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"E题：子树的后序遍历\">E题：子树的后序遍历</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-358d20c0\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-358d20c0\">\n        <div class=\"fold-arrow\">▶</div> E题：子树的后序遍历\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-358d20c0\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你一颗二叉树的中序和后序遍历序列，请编程输出该二叉树左子树或右子树的后序遍历序列。</p><h3 id=\"输入\">输入</h3><p>占三行，第一行表示二叉树的中序遍历序列，第二行表示后序遍历序列。用大写字母标识结点，二叉树的结点最多26个。<br>第三行是单个字母，L表示要求输出该二叉树的左子树的后序遍历序列，R表示要求输出该二叉树的右子树的后序遍历序列。</p><h3 id=\"输出\">输出</h3><p>按要求输出该二叉树左子树或右子树的后序遍历序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">BDCEAFHG<br>DECBHGFA<br><span class=\"hljs-attribute\">R</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">HGF</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>题目给中序和后序遍历，中序是左根右（LNR），后序是左右根（LRN），后序遍历的最后一个即为二叉树的根结点，从而在中序遍历中，根结点前面的是的左子树，后面的是右子树；由于本题输出后序遍历结果，而后序遍历结果题目已经给出，现只需计算左、右子树长度，从后序遍历中提取相应字符串长度即可。</p>\n<h3 id=\"完整代码-v5\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tstring in, post;<br>\tcin &gt;&gt; in &gt;&gt; post;<br>\t<span class=\"hljs-type\">char</span> side, root;<br>\tcin &gt;&gt; side;<br>\troot=post.<span class=\"hljs-built_in\">back</span>();<span class=\"hljs-comment\">// 后序最后一个字符是根节点</span><br>\t<span class=\"hljs-type\">int</span> position = in.<span class=\"hljs-built_in\">find</span>(root);<br>\t<span class=\"hljs-type\">int</span> length;<br>\t<span class=\"hljs-keyword\">if</span> (side == <span class=\"hljs-string\">'R'</span>) { <br>\t\tlength = in.<span class=\"hljs-built_in\">size</span>() - position - <span class=\"hljs-number\">1</span>;<br>\t\tcout &lt;&lt; post.<span class=\"hljs-built_in\">substr</span>(post.<span class=\"hljs-built_in\">size</span>() - length - <span class=\"hljs-number\">1</span>,length) &lt;&lt; endl; }<br>\t<span class=\"hljs-keyword\">else</span> { <br>\t\tlength = position;<br>\t\tcout &lt;&lt; post.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,length); }<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注意\">注意</h3>\n<ol>\n<li>提取字符串最后一个字符时用 <code>post.back()</code>或<code>post[post.size() - 1]</code><br>\n获取最后一个字符（而不是 <code>post[-1]</code>，C++不支持负数索引）。</li>\n<li>有关字符串<code>string</code>的函数：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>用法示例</th>\n<th>作用</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>str.find()</code></td>\n<td>查找字符或子串</td>\n<td>返回首次出现字符的位置（<code>size_t</code>）</td>\n</tr>\n<tr>\n<td><code>str.substr()</code></td>\n<td>提取字符串</td>\n<td>参数1：起始位置；参数2：长度（可选）</td>\n</tr>\n<tr>\n<td><code>str.size()</code></td>\n<td>获取字符串长度</td>\n<td>返回字符数量（size_t）</td>\n</tr>\n<tr>\n<td><code>str.empty()</code></td>\n<td>判断是否为空</td>\n<td>返回值bool类型</td>\n</tr>\n<tr>\n<td><code>str.front()</code></td>\n<td>获取首字符</td>\n<td>返回char引用</td>\n</tr>\n<tr>\n<td><code>str.back()</code></td>\n<td>获取末尾字符</td>\n<td>返回char引用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>s + ‘a’：在原字符串 s 的<strong>末尾添加</strong>字符 ‘a’；</li>\n<li>‘a’ + s：在原字符串 s 的<strong>开头添加</strong>字符 ‘a’。</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/add-binary?envType=problem-list-v2&amp;envId=string\">Leetcode 67.二进制求和</a></p>\n<p>这里使用<strong>模拟竖式</strong>的方法进行计算，对于位数不相等的两个数，我们使用以上方法对其<strong>在前面补零</strong>，使得两个数的位数相等。</p>\n <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">addBinary</span><span class=\"hljs-params\">(string a, string b)</span> </span>{<br>        <span class=\"hljs-type\">int</span> al=a.<span class=\"hljs-built_in\">size</span>(),bl=b.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(al&lt;bl){<br>            a=<span class=\"hljs-string\">'0'</span>+a;<br>            al++;<br>        }<br>        <span class=\"hljs-keyword\">while</span>(al&gt;bl){<br>            b=<span class=\"hljs-string\">'0'</span>+b;<br>            bl++;<br>        }<br>        <span class=\"hljs-type\">int</span> forward=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=al<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--){<br>            <span class=\"hljs-type\">int</span> temp=a[i]+b[i]-<span class=\"hljs-string\">'0'</span>-<span class=\"hljs-string\">'0'</span>+forward;<br>            forward=temp/<span class=\"hljs-number\">2</span>;<br>            a[i]=temp%<span class=\"hljs-number\">2</span>+<span class=\"hljs-string\">'0'</span>;<br>        }<br>        <span class=\"hljs-keyword\">if</span>(forward&gt;<span class=\"hljs-number\">0</span>){<br>            a=<span class=\"hljs-string\">'1'</span>+a;<br>        }<br>        <span class=\"hljs-keyword\">return</span> a;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"F题：迷宫问题\">F题：迷宫问题</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-84e43ba8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-84e43ba8\">\n        <div class=\"fold-arrow\">▶</div> F题：迷宫问题\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-84e43ba8\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。<br>小明只能向上下左右四个方向移动。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。<br>每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。<br>接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。<br>字符的含义如下：<br>‘S’：起点<br>‘E’：终点<br>‘-’：空地，可以通过<br>‘#’：障碍，无法通过<br>输入数据保证有且仅有一个起点和终点。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight asciidoc\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">1<br>5 5<br><span class=\"hljs-section\">S-###</span><br><span class=\"hljs-section\">-----</span><br>##---<br>E#---<br>---##<br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">9<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"完整代码-v6\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">char</span> grid[MAX][MAX];<br><span class=\"hljs-type\">int</span> dist[MAX][MAX];<br><span class=\"hljs-type\">int</span> dx[] = {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>};<br><span class=\"hljs-type\">int</span> dy[] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>};<br><span class=\"hljs-type\">int</span> n, m;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">(pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; start, pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; end)</span> </span>{<br>    queue&lt;pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(start);<br>    dist[start.first][start.second] = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>()) {<br>        <span class=\"hljs-keyword\">auto</span> [x, y] = q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br><br>        <span class=\"hljs-keyword\">if</span> (x == end.first &amp;&amp; y == end.second)<br>            <span class=\"hljs-keyword\">return</span> dist[x][y];<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) {<br>            <span class=\"hljs-type\">int</span> nx = x + dx[i], ny = y + dy[i];<br>            <span class=\"hljs-keyword\">if</span> (nx &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny] != <span class=\"hljs-string\">'#'</span> &amp;&amp; dist[nx][ny] == <span class=\"hljs-number\">-1</span>) {<br>                dist[nx][ny] = dist[x][y] + <span class=\"hljs-number\">1</span>;<br>                q.<span class=\"hljs-built_in\">push</span>({nx, ny});<br>            }<br>        }<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    ios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-literal\">false</span>);<br>    cin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-literal\">nullptr</span>);<br><br>    <span class=\"hljs-type\">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class=\"hljs-keyword\">while</span> (T--) {<br>        cin &gt;&gt; n &gt;&gt; m;<br>        pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; start, end;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; m; j++) {<br>                cin &gt;&gt; grid[i][j];<br>                <span class=\"hljs-keyword\">if</span> (grid[i][j] == <span class=\"hljs-string\">'S'</span>) start = {i, j};<br>                <span class=\"hljs-keyword\">if</span> (grid[i][j] == <span class=\"hljs-string\">'E'</span>) end = {i, j};<br>            }<br>        }<br><br>        <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-built_in\">sizeof</span>(dist));<br>        cout &lt;&lt; <span class=\"hljs-built_in\">bfs</span>(start, end) &lt;&lt; <span class=\"hljs-string\">'\\n'</span>;<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<h2 id=\"A题：统计回文字符串\">A题：统计回文字符串</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-5516a047\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-5516a047\">\n        <div class=\"fold-arrow\">▶</div> A题：统计回文字符串\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-5516a047\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现在给你一个字符串S，请你计算S中有多少连续子串是回文串。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入是一个非空字符串，长度不超过5000。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出回文子串的个数。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">aba</span><br><span class=\"hljs-attribute\">aa</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">4<br>3<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>先读取字符串<code>s</code>，采取从中心向两边进行扩展的方法，若回文字符串为奇数个字符则起始时中心均为<code>i</code>；若回文字符串为偶数个字符则起始时中心<code>i</code>和<code>i+1</code>，直至字符不匹配或者数组越界。</p>\n<h3 id=\"注意点\">注意点</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right])<br></code></pre></td></tr></table></figure>\n<p>和</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span> (s[left] == s[right]&amp;&amp;left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n )<br></code></pre></td></tr></table></figure>\n<p>在编译器中并不等同：应该先检查是否越界，否则可能出现未定义行为而报错<br>\n<strong>短路求值规则</strong>：逻辑运算符 &amp;&amp; 会从左到右依次求值，如果前面的条件为 false，后面的条件不会被计算。第一种写法利用了短路规则，避免了非法内存访问；第二种写法则可能引发问题。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">countnumber</span><span class=\"hljs-params\">(string s)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n = s.<span class=\"hljs-built_in\">size</span>();<br>\t<span class=\"hljs-type\">int</span> num=<span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> left = i;<br>\t\t<span class=\"hljs-type\">int</span> right = i;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;<br>\t\t\tnum++;<br>\t\t\t--left;<br>\t\t\t++right;<br>\t\t&#125;<br>\t\tleft = i, right = i + <span class=\"hljs-number\">1</span>;<br>\t\t<span class=\"hljs-keyword\">while</span> (left &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;<br>\t\t\tnum++;<br>\t\t\t--left;<br>\t\t\t++right;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> num;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstring s;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; s) &#123;<br>\tcout &lt;&lt; <span class=\"hljs-built_in\">countnumber</span>(s) &lt;&lt; endl;<br>&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"B题：构建矩阵\">B题：构建矩阵</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e5e15715\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e5e15715\">\n        <div class=\"fold-arrow\">▶</div> B题：构建矩阵\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e5e15715\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现请你构建一个N*N的矩阵，第i行j列的元素为i与j的乘积。（i，j均从1开始）</p><h3 id=\"输入\">输入</h3><p>输入的第一行为一个正整数C，表示测试样例的个数。<br>然后是C行测试样例，每行为一个整数N（1&lt;=N&lt;=9），表示矩阵的行列数。</p><h3 id=\"输出\">输出</h3><p>对于每一组输入，输出构建的矩阵。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">2<br>1<br>4<br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">3 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">12</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">8</span> <span class=\"hljs-number\">12</span> <span class=\"hljs-number\">16</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<ol>\n<li>构造<code>printmatrix</code>的函数，主函数中每读入一个数，调用一次函数</li>\n<li>观察矩阵，相当于每行是一个等差数列，公差等于所在行行数，每换一次行其公差+1即可。</li>\n</ol>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> d = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">1</span>;n &lt;= i * i &amp;&amp; d&lt;=i;n += d) &#123;<br>\t\tcout &lt;&lt; n &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (n == i * d) &#123;<br>\t\t\t\tcout &lt;&lt; endl;<br>\t\t\t\td++;<br>\t\t\t\tn = <span class=\"hljs-number\">0</span>;<br>\t\t\t&#125;<br>\t&#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-type\">int</span> i;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) &#123;<br>\t\tcin &gt;&gt; i;<br>\t\t<span class=\"hljs-built_in\">matrix</span>(i);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>构造打印矩阵函数的另外一种做法，双层嵌套<strong>for</strong>循环，这个方法显然更加直观:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printMatrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> N)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= N; ++i) &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= N; ++j) &#123;<br>            cout &lt;&lt; i * j;<br>            <span class=\"hljs-keyword\">if</span> (j &lt; N) &#123;<br>                cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"C题：找规律填数字\">C题：找规律填数字</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-08e013ca\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-08e013ca\">\n        <div class=\"fold-arrow\">▶</div> C题：找规律填数字\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-08e013ca\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小宇正在读小学，今天老师布置了几道数学题目。小宇平时上课经常不专心，这些他可发愁了，怎么办呢？看看你能不能帮帮他。<br>题目是给你一组有规律序列的前面5个整数，请你给出它后面跟着的5个整数，如：1,2,3,4,5,_, _, _, _, _, _。这是个等差数列，后面应该是6,7,8,9,10，就这么简单。而且现在小宇已经知道这串序列要么是等差数列，要么是等比数列或者是斐波那契数列。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入5个整数，每个数字之间隔一个空格，当5个数字都为0时输入结束。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出这串数列的后面5个数字，每个数字之间隔一个空格。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">16</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-symbol\">32 </span><span class=\"hljs-number\">64</span> <span class=\"hljs-number\">128</span> <span class=\"hljs-number\">256</span> <span class=\"hljs-number\">512</span><br><span class=\"hljs-symbol\">13 </span><span class=\"hljs-number\">21</span> <span class=\"hljs-number\">34</span> <span class=\"hljs-number\">55</span> <span class=\"hljs-number\">89</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"注意点-v2\">注意点</h3>\n<p>参数变量较多，在<code>if</code>条件判断语句中要尽可能的将每个参数都包含进去，减小数据巧合而错判数列类型发生的可能性，博主一开始只通过三个参数就判断了数列的类型，就被特殊情况爆破了。</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">predictNext</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c, <span class=\"hljs-type\">int</span> d, <span class=\"hljs-type\">int</span> e)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span> &amp;&amp; b == <span class=\"hljs-number\">0</span> &amp;&amp; c == <span class=\"hljs-number\">0</span> &amp;&amp; d == <span class=\"hljs-number\">0</span> &amp;&amp; e == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>;<br><br>    <span class=\"hljs-type\">int</span> d = b - a;<br>    <span class=\"hljs-keyword\">if</span> (b + d == c &amp;&amp; c + d == d &amp;&amp; d + d == e) &#123;<br>        cout &lt;&lt; e + d &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; e + <span class=\"hljs-number\">2</span> * d &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; e + <span class=\"hljs-number\">3</span> * d<br>            &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; e + <span class=\"hljs-number\">4</span> * d &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; e + <span class=\"hljs-number\">5</span> * d &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (a != <span class=\"hljs-number\">0</span> &amp;&amp; b != <span class=\"hljs-number\">0</span> &amp;&amp; c != <span class=\"hljs-number\">0</span> &amp;&amp; d != <span class=\"hljs-number\">0</span> &amp;&amp; e != <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-type\">int</span> q = b / a;<br>        <span class=\"hljs-keyword\">if</span> (a * q == b &amp;&amp; b * q == c &amp;&amp; c * q == d &amp;&amp; d * q == e) &#123;<br>            <span class=\"hljs-type\">int</span> next = e;<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) &#123;<br>                next *= q;<br>                cout &lt;&lt; next &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-keyword\">if</span> (a + b == c &amp;&amp; b + c == d &amp;&amp; c + d == e) &#123;<br>        <span class=\"hljs-type\">int</span> x = d, y = e;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) &#123;<br>            <span class=\"hljs-type\">int</span> z = x + y;<br>            cout &lt;&lt; z &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>            x = y;<br>            y = z;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-type\">int</span> x = d, y = e;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; ++i) &#123;<br>        <span class=\"hljs-type\">int</span> z = x + y;<br>        cout &lt;&lt; z &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>        x = y;<br>        y = z;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> a, b, c, d, e;<br>    <span class=\"hljs-keyword\">while</span> (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e) &#123;<br>        <span class=\"hljs-keyword\">if</span> (a == <span class=\"hljs-number\">0</span> &amp;&amp; b == <span class=\"hljs-number\">0</span> &amp;&amp; c == <span class=\"hljs-number\">0</span> &amp;&amp; d == <span class=\"hljs-number\">0</span> &amp;&amp; e == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>;<br>        <span class=\"hljs-built_in\">predictNext</span>(a, b, c, d, e);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"D题：复原二叉树\">D题：复原二叉树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-6292b2b8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-6292b2b8\">\n        <div class=\"fold-arrow\">▶</div> D题：复原二叉树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-6292b2b8\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小明在做数据结构的作业，其中一题是给你一棵二叉树的前序遍历和中序遍历结果，要求你写出这棵二叉树的后序遍历结果。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。每组输入包含两个字符串，分别表示二叉树的前序遍历和中序遍历结果。每个字符串由不重复的大写字母组成。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出对应的二叉树的后续遍历结果。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">DBACEGF ABCDEFG</span><br><span class=\"hljs-attribute\">BCAD CBAD</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">ACBFGED</span><br><span class=\"hljs-attribute\">CDAB</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>题目给前序和中序求后序遍历结果，前序是根左右（NLR），中序是左根右（LNR），也就是说前序遍历的第一个字母是二叉树的根节点，在中序遍历根节点前面的是根的左子树，后面的是右子树，这样我们可以不断找到树的前序遍历和中序遍历结果，从而进行递归。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">postOrder</span><span class=\"hljs-params\">(string pre, string in)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (pre.<span class=\"hljs-built_in\">empty</span>()) <span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-type\">char</span> root;<br>\troot = pre[<span class=\"hljs-number\">0</span>];<br>\t<span class=\"hljs-type\">int</span> position;<br>\tposition = in.<span class=\"hljs-built_in\">find</span>(root);<br>\t<span class=\"hljs-built_in\">postOrder</span>(pre.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">1</span>, position), in.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>, position));<br>\t<span class=\"hljs-built_in\">postOrder</span>(pre.<span class=\"hljs-built_in\">substr</span>(position + <span class=\"hljs-number\">1</span>), in.<span class=\"hljs-built_in\">substr</span>(position + <span class=\"hljs-number\">1</span>));<br>\tcout &lt;&lt; root;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstring pre, in;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; pre &gt;&gt; in) &#123;<br>\t\t<span class=\"hljs-built_in\">postOrder</span>(pre, in);<br>\t\tcout &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"E题：子树的后序遍历\">E题：子树的后序遍历</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-358d20c0\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-358d20c0\">\n        <div class=\"fold-arrow\">▶</div> E题：子树的后序遍历\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-358d20c0\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你一颗二叉树的中序和后序遍历序列，请编程输出该二叉树左子树或右子树的后序遍历序列。</p><h3 id=\"输入\">输入</h3><p>占三行，第一行表示二叉树的中序遍历序列，第二行表示后序遍历序列。用大写字母标识结点，二叉树的结点最多26个。<br>第三行是单个字母，L表示要求输出该二叉树的左子树的后序遍历序列，R表示要求输出该二叉树的右子树的后序遍历序列。</p><h3 id=\"输出\">输出</h3><p>按要求输出该二叉树左子树或右子树的后序遍历序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">BDCEAFHG<br>DECBHGFA<br><span class=\"hljs-attribute\">R</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ebnf\"><span class=\"hljs-attribute\">HGF</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>题目给中序和后序遍历，中序是左根右（LNR），后序是左右根（LRN），后序遍历的最后一个即为二叉树的根结点，从而在中序遍历中，根结点前面的是的左子树，后面的是右子树；由于本题输出后序遍历结果，而后序遍历结果题目已经给出，现只需计算左、右子树长度，从后序遍历中提取相应字符串长度即可。</p>\n<h3 id=\"完整代码-v5\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstring in, post;<br>\tcin &gt;&gt; in &gt;&gt; post;<br>\t<span class=\"hljs-type\">char</span> side, root;<br>\tcin &gt;&gt; side;<br>\troot=post.<span class=\"hljs-built_in\">back</span>();<span class=\"hljs-comment\">// 后序最后一个字符是根节点</span><br>\t<span class=\"hljs-type\">int</span> position = in.<span class=\"hljs-built_in\">find</span>(root);<br>\t<span class=\"hljs-type\">int</span> length;<br>\t<span class=\"hljs-keyword\">if</span> (side == <span class=\"hljs-string\">&#x27;R&#x27;</span>) &#123; <br>\t\tlength = in.<span class=\"hljs-built_in\">size</span>() - position - <span class=\"hljs-number\">1</span>;<br>\t\tcout &lt;&lt; post.<span class=\"hljs-built_in\">substr</span>(post.<span class=\"hljs-built_in\">size</span>() - length - <span class=\"hljs-number\">1</span>,length) &lt;&lt; endl; &#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123; <br>\t\tlength = position;<br>\t\tcout &lt;&lt; post.<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,length); &#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注意\">注意</h3>\n<ol>\n<li>提取字符串最后一个字符时用 <code>post.back()</code>或<code>post[post.size() - 1]</code><br>\n获取最后一个字符（而不是 <code>post[-1]</code>，C++不支持负数索引）。</li>\n<li>有关字符串<code>string</code>的函数：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>用法示例</th>\n<th>作用</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>str.find()</code></td>\n<td>查找字符或子串</td>\n<td>返回首次出现字符的位置（<code>size_t</code>）</td>\n</tr>\n<tr>\n<td><code>str.substr()</code></td>\n<td>提取字符串</td>\n<td>参数1：起始位置；参数2：长度（可选）</td>\n</tr>\n<tr>\n<td><code>str.size()</code></td>\n<td>获取字符串长度</td>\n<td>返回字符数量（size_t）</td>\n</tr>\n<tr>\n<td><code>str.empty()</code></td>\n<td>判断是否为空</td>\n<td>返回值bool类型</td>\n</tr>\n<tr>\n<td><code>str.front()</code></td>\n<td>获取首字符</td>\n<td>返回char引用</td>\n</tr>\n<tr>\n<td><code>str.back()</code></td>\n<td>获取末尾字符</td>\n<td>返回char引用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>s + ‘a’：在原字符串 s 的<strong>末尾添加</strong>字符 ‘a’；</li>\n<li>‘a’ + s：在原字符串 s 的<strong>开头添加</strong>字符 ‘a’。</li>\n</ul>\n<p><a href=\"https://leetcode.cn/problems/add-binary?envType=problem-list-v2&amp;envId=string\">Leetcode 67.二进制求和</a></p>\n<p>这里使用<strong>模拟竖式</strong>的方法进行计算，对于位数不相等的两个数，我们使用以上方法对其<strong>在前面补零</strong>，使得两个数的位数相等。</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">addBinary</span><span class=\"hljs-params\">(string a, string b)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> al=a.<span class=\"hljs-built_in\">size</span>(),bl=b.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(al&lt;bl)&#123;<br>            a=<span class=\"hljs-string\">&#x27;0&#x27;</span>+a;<br>            al++;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(al&gt;bl)&#123;<br>            b=<span class=\"hljs-string\">&#x27;0&#x27;</span>+b;<br>            bl++;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> forward=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=al<span class=\"hljs-number\">-1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)&#123;<br>            <span class=\"hljs-type\">int</span> temp=a[i]+b[i]-<span class=\"hljs-string\">&#x27;0&#x27;</span>-<span class=\"hljs-string\">&#x27;0&#x27;</span>+forward;<br>            forward=temp/<span class=\"hljs-number\">2</span>;<br>            a[i]=temp%<span class=\"hljs-number\">2</span>+<span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(forward&gt;<span class=\"hljs-number\">0</span>)&#123;<br>            a=<span class=\"hljs-string\">&#x27;1&#x27;</span>+a;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"F题：迷宫问题\">F题：迷宫问题</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-84e43ba8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-84e43ba8\">\n        <div class=\"fold-arrow\">▶</div> F题：迷宫问题\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-84e43ba8\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>小明置身于一个迷宫，请你帮小明找出从起点到终点的最短路程。<br>小明只能向上下左右四个方向移动。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。输入的第一行是一个整数T，表示有T组测试数据。<br>每组输入的第一行是两个整数N和M（1&lt;=N,M&lt;=100）。<br>接下来N行，每行输入M个字符，每个字符表示迷宫中的一个小方格。<br>字符的含义如下：<br>‘S’：起点<br>‘E’：终点<br>‘-’：空地，可以通过<br>‘#’：障碍，无法通过<br>输入数据保证有且仅有一个起点和终点。</p><h3 id=\"输出\">输出</h3><p>对于每组输入，输出从起点到终点的最短路程，如果不存在从起点到终点的路，则输出-1。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs asciidoc\">1<br>5 5<br><span class=\"hljs-section\">S-###</span><br><span class=\"hljs-section\">-----</span><br>##---<br>E#---<br>---##<br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">9<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"完整代码-v6\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">char</span> grid[MAX][MAX];<br><span class=\"hljs-type\">int</span> dist[MAX][MAX];<br><span class=\"hljs-type\">int</span> dx[] = &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>&#125;;<br><span class=\"hljs-type\">int</span> dy[] = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>&#125;;<br><span class=\"hljs-type\">int</span> n, m;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">(pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; start, pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; end)</span> </span>&#123;<br>    queue&lt;pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(start);<br>    dist[start.first][start.second] = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">while</span> (!q.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        <span class=\"hljs-keyword\">auto</span> [x, y] = q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br><br>        <span class=\"hljs-keyword\">if</span> (x == end.first &amp;&amp; y == end.second)<br>            <span class=\"hljs-keyword\">return</span> dist[x][y];<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>            <span class=\"hljs-type\">int</span> nx = x + dx[i], ny = y + dy[i];<br>            <span class=\"hljs-keyword\">if</span> (nx &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; ny &lt; m &amp;&amp; grid[nx][ny] != <span class=\"hljs-string\">&#x27;#&#x27;</span> &amp;&amp; dist[nx][ny] == <span class=\"hljs-number\">-1</span>) &#123;<br>                dist[nx][ny] = dist[x][y] + <span class=\"hljs-number\">1</span>;<br>                q.<span class=\"hljs-built_in\">push</span>(&#123;nx, ny&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    ios::<span class=\"hljs-built_in\">sync_with_stdio</span>(<span class=\"hljs-literal\">false</span>);<br>    cin.<span class=\"hljs-built_in\">tie</span>(<span class=\"hljs-literal\">nullptr</span>);<br><br>    <span class=\"hljs-type\">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class=\"hljs-keyword\">while</span> (T--) &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; start, end;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; m; j++) &#123;<br>                cin &gt;&gt; grid[i][j];<br>                <span class=\"hljs-keyword\">if</span> (grid[i][j] == <span class=\"hljs-string\">&#x27;S&#x27;</span>) start = &#123;i, j&#125;;<br>                <span class=\"hljs-keyword\">if</span> (grid[i][j] == <span class=\"hljs-string\">&#x27;E&#x27;</span>) end = &#123;i, j&#125;;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-built_in\">sizeof</span>(dist));<br>        cout &lt;&lt; <span class=\"hljs-built_in\">bfs</span>(start, end) &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"CUMT-Datastructure-Practice 2","date":"2025-06-18T04:52:43.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover//CUMT-Datastructure-Practice-2.png","category_bar":true,"description":"Problems involving depth-first search of undirected graphs, construction of binary trees, minimum heap problems, binary search, and simple sorting problems","_content":"\n\n## A题：无向图的深度优先搜索\n{%fold into @ A题：无向图的深度优先搜索 %}\n### 题目描述\n已知一个无向图G的顶点和边，顶点从0依次编号，现在需要深度优先搜索，访问任一邻接顶点时编号小的顶点优先，请编程输出图G的深度优先搜索序列。\n### 输入\n第一行是整数m和n（1<m,n<100），分别代表顶点数和边数。后边n行，每行2个数，分别表示一个边的两个顶点。\n### 输出\n该图从0号顶点开始的深度优先搜索序列。\n### 样例输入 \n```\n5 5\n0 1\n2 0\n1 3\n1 4\n4 2\n```\n### 样例输出 \n```\n0 1 3 4 2\n```\n{%endfold%}\n### 问题分析\n使用邻接表存储图结构，读取数据后，为了保证小编号顶点优先访问，使用```sort()```\t将每个邻接表中的数据升序排列，函数调用中使用栈实现非递归DFS：\n将```start```压入栈内，若有邻接的顶点未被访问，将其输出，使用```visited```数组记录访问过的顶点并将其压入栈内；若其邻接的顶点均被访问，则回溯，弹出栈顶元素。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>//sort()函数的调用\n#include <stack>\nusing namespace std;\n//深度优先搜索DFS函数\nvoid DFS(vector<vector<int>>& graph, vector<bool> visited, int start) {\n\tstack<int> s;\n\ts.push(start);//将起始点压入栈内\n\tvisited[start] = true;//标记起始点已访问\n\tcout << start << \" \";\n\n\twhile (!s.empty()) {\n\t\tint current = s.top();\n\t\tbool found = false;\n\n\t\tfor (int neighbor:graph[current]) {\n\t\t\tif (!visited[neighbor]) {//如果邻接顶点未被访问\n\t\t\t\tvisited[neighbor] = true;//标记为已访问\n\t\t\t\tcout << neighbor << \" \";\n\t\t\t\ts.push(neighbor);//将该顶点压入栈内\n\t\t\t\tfound = true;//标记已访问过的顶点\n\t\t\t\tbreak;//跳出循环，优先处理该顶点的邻接顶点\n\t\t\t}\n\t\t}\n\t\tif (!found) {//若果该顶点没有未被访问的邻接顶点\n\t\t\ts.pop();//弹出栈顶元素，回溯\n\t\t}\n\t}\n}\n\nint main() {\n\tint m, n;\n\tcin >> m >> n;//读入定点数和边数\n\tint a, b;\n\tvector<vector<int>> graph(m);\n\t//初始化邻接表，大小为m，每个元素是vector<int>\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t\t//用读入的数据构建邻接表，注意两边都要处理\n\t}\n\tfor (int i = 0;i < m;i++) {\n\t\tsort(graph[i].begin(), graph[i].end());\n\t\t//对每个邻接表进行排序，确保DFS优先访问编号小的元素\n\t}\n\tvector<bool> visited(m, false);\n\t//初始化访问标记数组，大小为m，初始值为false（未被访问状态）\n\tDFS(graph, visited, 0);\n\treturn 0;\n}\n```\n### 注释\n```cpp\nvector<vector<int>> graph\n```\n相当于一个```graph[][]```的二维数组，外层的```vector```存储所有的顶点，内层的```vector<int>```存储每个顶点的邻接顶点列表\n```cpp\nfor (int neighbor:graph[current])\n```\n这是C++11 引入了范围```for```循环语法，专门用于遍历容器（如 ```vector```、```list```等），每次循环时变量会自动依次选取容器中的下一个元素。（注意中间是```:```）\n\n## B题：最小堆的形成\n{%fold into @ B题：最小堆的形成 %}\n### 题目描述\n现在给你n个结点的完全二叉树数组存储序列，请编程调整为最小堆，并输出相应最小堆的存储序列。\n### 输入\n第一行是n，第二行是n个结点的完全二叉树数组存储序列。\n### 输出\n输出相应最小堆的存储序列。\n### 样例输入 \n```\n8\n53 17 78 23 45 65 87 9\n```\n### 样例输出 \n\n```\n9 17 65 23 45 78 87 53\n```\n{%endfold%}\n\n### 问题分析\n解决问题前首先要了解什么是完全二叉树、什么是最小堆以及完全二叉树有什么性质。**完全二叉树**就是除了最后一层外，其他层的节点都是满的，并且最后一层的节点都尽可能靠左排列的二叉树（从上到下、从左到右的顺序进行填充）。**最小堆**就是满足节点的值<=其子叶节点的值的完全二叉树（给定完全二叉树求最小堆时不可直接升序排列，其有特定的存储结构）。\n假设完全二叉树某节点编号为```i```,则其父节点为```i/2```，其左子叶节点为```2*i```，其右子叶节点为```2*i+1```。而对于最小堆，其根节点为其全局最小值。有了这些简单的前置知识我们就可以开始解决这道题目了。\n由于**下沉法**相对于**上浮法**具有更高的效率，因此本题先选择自底向上的下沉法递归求解。\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid down(vector<int>& tree, int n, int parent) {\n//完全二叉树的性质\n\tint left = 2 * parent;//左子叶节点\n\tint right = 2 * parent + 1;//右子叶节点\n\tint smallest = parent;//初始化最小值为顶点\n\tif (left <= n && tree[left] < tree[smallest]) {\n\t\tsmallest = left;\n\t}\n\tif (right <= n && tree[right] < tree[smallest]) {\n\t\tsmallest = right;\n\t}//找出三个节点中的最小值，将其交换至父节点\n    if(smallest!=parent){\n\t\tint temp = tree[smallest]; \n\t\ttree[smallest] = tree[parent];\n\t\ttree[parent] = temp;\n\t\t//交换 也可以使用swap()更简便\n\t\tdown(tree, n, smallest);\n\t\t//由于最小值上移，原位置需要递归重新确保其子树为最小堆\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> tree(n+1);\n\t//提前为tree分配空间为n+1\n    //（由于从1开始索引）\n\tfor (int i = 1;i <= n;i++) {\n\t\tcin >> tree[i];\n\t}\n\tfor (int i = n / 2;i >= 1;i--){\n\t\tdown(tree, n, i);\n\t}\n\t//从最小的非子叶结点开始递归\n\t//反向遍历，确保处理父节点是，其子树已是最小堆结构\n\tfor (int i = 1;i<=n;i++){\n\t\tcout << tree[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n\n## C题：折半查找次数\n{%fold into @ C题：折半查找次数 %}\n### 题目描述\n给你一个无重复数的有序序列，如果采用折半查找的方式，对于给定的数，需要比较几次找到，请编程实现。\n### 输入\n第一行是N，表示序列中数的个数，序列最长1000，第二行是一个有序序列，第三行是要找的数x。\n### 输出\n如果找到x，输出折半比较的次数，否则输出NO。\n### 样例输入\n```\n11\n5 13 19 21 37 56 64 75 80 88 92\n19\n```\n### 样例输出\n```\n2\n```\n{%endfold%}\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    int x;\n    cin >> x;\n    int low = 0, high = n - 1;\n    int cnt = 0;\n    bool found = false;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        cnt++; \n        if (arr[mid] == x) {\n            found = true;\n            break;\n        }\n        else if (arr[mid] < x) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    if (found)\n        cout << cnt << endl;\n    else\n        cout << \"NO\" << endl;\n    return 0;\n}\n```\n## D题：N个数的排序\n{%fold into @ D题：N个数的排序 %}\n### 题目描述\n给你N个自然数，编程输出排序后的这N个数。\n### 输入\n第一行是整数的个数N（N<=100）。第二行是用空格隔开的N个数。\n### 输出\n排序输出N个数，每个数间用一个空格间隔。\n### 样例输入 \n```\n5\n9 6 8 7 5\n```\n### 样例输出 \n```\n5 6 7 8 9\n```\n{%endfold%}\n### 问题分析\n本题是最基础的的排序问题，这里采用冒泡排序、选择排序、c++封装的```sort()```排序函数三种方法进行求解。\n### 完整代码\n冒泡排序算法求解：\n```cpp\n#include <iostream>\nusing namespace std;\nvoid bubblesort(int arr[], int n) {\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n - i - 1;j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < n;i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\nint main() {\n\tint arr[100], n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> arr[i];\n\t}\n\tbubblesort(arr, n);\n\treturn 0;\n}\n```\n选择排序算法求解：\n```cpp\n#include <iostream>\n#include <climits>\nusing namespace std;\nvoid selectsort(int arr[], int n) {\n    int begin = 0;\n    while (begin < n) {\n        int min = INT_MAX; \n        int tag = begin; \n\n        for (int i = begin; i < n; i++) {\n            if (arr[i] < min) {\n                tag = i;\n                min = arr[tag];\n            }\n        }\n        int temp = arr[begin];\n        arr[begin] = arr[tag];\n        arr[tag] = temp;\n        begin++; \n    }\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n}\nint main() {\n\tint arr[100], n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> arr[i];\n\t}\n\tselectsort(arr, n);\n\treturn 0;\n}\n```\n\nSTL封装的 ```sort()```排序函数求解：\n```cpp \n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tvector <int> arr;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tarr.push_back(a);\n\t}\n\tsort(arr.begin(), arr.end());\n\tfor (int i = 0;i < n;i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n封面来源：[Tree data structures in 2 minutes](https://www.youtube.com/watch?v=Etpc_-br5rI&t=21s)\n","source":"_posts/Data structure/CUMT-Datastructure-Practice-2.md","raw":"---\ntitle: CUMT-Datastructure-Practice 2\ndate: 2025-06-18 12:52:43\ntags: [DFS,binary tree,search，graph，sort]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover//CUMT-Datastructure-Practice-2.png\ncategory: Data Structure\ncategory_bar: true\ndescription: Problems involving depth-first search of undirected graphs, construction of binary trees, minimum heap problems, binary search, and simple sorting problems\n---\n\n\n## A题：无向图的深度优先搜索\n{%fold into @ A题：无向图的深度优先搜索 %}\n### 题目描述\n已知一个无向图G的顶点和边，顶点从0依次编号，现在需要深度优先搜索，访问任一邻接顶点时编号小的顶点优先，请编程输出图G的深度优先搜索序列。\n### 输入\n第一行是整数m和n（1<m,n<100），分别代表顶点数和边数。后边n行，每行2个数，分别表示一个边的两个顶点。\n### 输出\n该图从0号顶点开始的深度优先搜索序列。\n### 样例输入 \n```\n5 5\n0 1\n2 0\n1 3\n1 4\n4 2\n```\n### 样例输出 \n```\n0 1 3 4 2\n```\n{%endfold%}\n### 问题分析\n使用邻接表存储图结构，读取数据后，为了保证小编号顶点优先访问，使用```sort()```\t将每个邻接表中的数据升序排列，函数调用中使用栈实现非递归DFS：\n将```start```压入栈内，若有邻接的顶点未被访问，将其输出，使用```visited```数组记录访问过的顶点并将其压入栈内；若其邻接的顶点均被访问，则回溯，弹出栈顶元素。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>//sort()函数的调用\n#include <stack>\nusing namespace std;\n//深度优先搜索DFS函数\nvoid DFS(vector<vector<int>>& graph, vector<bool> visited, int start) {\n\tstack<int> s;\n\ts.push(start);//将起始点压入栈内\n\tvisited[start] = true;//标记起始点已访问\n\tcout << start << \" \";\n\n\twhile (!s.empty()) {\n\t\tint current = s.top();\n\t\tbool found = false;\n\n\t\tfor (int neighbor:graph[current]) {\n\t\t\tif (!visited[neighbor]) {//如果邻接顶点未被访问\n\t\t\t\tvisited[neighbor] = true;//标记为已访问\n\t\t\t\tcout << neighbor << \" \";\n\t\t\t\ts.push(neighbor);//将该顶点压入栈内\n\t\t\t\tfound = true;//标记已访问过的顶点\n\t\t\t\tbreak;//跳出循环，优先处理该顶点的邻接顶点\n\t\t\t}\n\t\t}\n\t\tif (!found) {//若果该顶点没有未被访问的邻接顶点\n\t\t\ts.pop();//弹出栈顶元素，回溯\n\t\t}\n\t}\n}\n\nint main() {\n\tint m, n;\n\tcin >> m >> n;//读入定点数和边数\n\tint a, b;\n\tvector<vector<int>> graph(m);\n\t//初始化邻接表，大小为m，每个元素是vector<int>\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> a >> b;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t\t//用读入的数据构建邻接表，注意两边都要处理\n\t}\n\tfor (int i = 0;i < m;i++) {\n\t\tsort(graph[i].begin(), graph[i].end());\n\t\t//对每个邻接表进行排序，确保DFS优先访问编号小的元素\n\t}\n\tvector<bool> visited(m, false);\n\t//初始化访问标记数组，大小为m，初始值为false（未被访问状态）\n\tDFS(graph, visited, 0);\n\treturn 0;\n}\n```\n### 注释\n```cpp\nvector<vector<int>> graph\n```\n相当于一个```graph[][]```的二维数组，外层的```vector```存储所有的顶点，内层的```vector<int>```存储每个顶点的邻接顶点列表\n```cpp\nfor (int neighbor:graph[current])\n```\n这是C++11 引入了范围```for```循环语法，专门用于遍历容器（如 ```vector```、```list```等），每次循环时变量会自动依次选取容器中的下一个元素。（注意中间是```:```）\n\n## B题：最小堆的形成\n{%fold into @ B题：最小堆的形成 %}\n### 题目描述\n现在给你n个结点的完全二叉树数组存储序列，请编程调整为最小堆，并输出相应最小堆的存储序列。\n### 输入\n第一行是n，第二行是n个结点的完全二叉树数组存储序列。\n### 输出\n输出相应最小堆的存储序列。\n### 样例输入 \n```\n8\n53 17 78 23 45 65 87 9\n```\n### 样例输出 \n\n```\n9 17 65 23 45 78 87 53\n```\n{%endfold%}\n\n### 问题分析\n解决问题前首先要了解什么是完全二叉树、什么是最小堆以及完全二叉树有什么性质。**完全二叉树**就是除了最后一层外，其他层的节点都是满的，并且最后一层的节点都尽可能靠左排列的二叉树（从上到下、从左到右的顺序进行填充）。**最小堆**就是满足节点的值<=其子叶节点的值的完全二叉树（给定完全二叉树求最小堆时不可直接升序排列，其有特定的存储结构）。\n假设完全二叉树某节点编号为```i```,则其父节点为```i/2```，其左子叶节点为```2*i```，其右子叶节点为```2*i+1```。而对于最小堆，其根节点为其全局最小值。有了这些简单的前置知识我们就可以开始解决这道题目了。\n由于**下沉法**相对于**上浮法**具有更高的效率，因此本题先选择自底向上的下沉法递归求解。\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nvoid down(vector<int>& tree, int n, int parent) {\n//完全二叉树的性质\n\tint left = 2 * parent;//左子叶节点\n\tint right = 2 * parent + 1;//右子叶节点\n\tint smallest = parent;//初始化最小值为顶点\n\tif (left <= n && tree[left] < tree[smallest]) {\n\t\tsmallest = left;\n\t}\n\tif (right <= n && tree[right] < tree[smallest]) {\n\t\tsmallest = right;\n\t}//找出三个节点中的最小值，将其交换至父节点\n    if(smallest!=parent){\n\t\tint temp = tree[smallest]; \n\t\ttree[smallest] = tree[parent];\n\t\ttree[parent] = temp;\n\t\t//交换 也可以使用swap()更简便\n\t\tdown(tree, n, smallest);\n\t\t//由于最小值上移，原位置需要递归重新确保其子树为最小堆\n\t}\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> tree(n+1);\n\t//提前为tree分配空间为n+1\n    //（由于从1开始索引）\n\tfor (int i = 1;i <= n;i++) {\n\t\tcin >> tree[i];\n\t}\n\tfor (int i = n / 2;i >= 1;i--){\n\t\tdown(tree, n, i);\n\t}\n\t//从最小的非子叶结点开始递归\n\t//反向遍历，确保处理父节点是，其子树已是最小堆结构\n\tfor (int i = 1;i<=n;i++){\n\t\tcout << tree[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n\n## C题：折半查找次数\n{%fold into @ C题：折半查找次数 %}\n### 题目描述\n给你一个无重复数的有序序列，如果采用折半查找的方式，对于给定的数，需要比较几次找到，请编程实现。\n### 输入\n第一行是N，表示序列中数的个数，序列最长1000，第二行是一个有序序列，第三行是要找的数x。\n### 输出\n如果找到x，输出折半比较的次数，否则输出NO。\n### 样例输入\n```\n11\n5 13 19 21 37 56 64 75 80 88 92\n19\n```\n### 样例输出\n```\n2\n```\n{%endfold%}\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> arr[i];\n    }\n    int x;\n    cin >> x;\n    int low = 0, high = n - 1;\n    int cnt = 0;\n    bool found = false;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        cnt++; \n        if (arr[mid] == x) {\n            found = true;\n            break;\n        }\n        else if (arr[mid] < x) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    if (found)\n        cout << cnt << endl;\n    else\n        cout << \"NO\" << endl;\n    return 0;\n}\n```\n## D题：N个数的排序\n{%fold into @ D题：N个数的排序 %}\n### 题目描述\n给你N个自然数，编程输出排序后的这N个数。\n### 输入\n第一行是整数的个数N（N<=100）。第二行是用空格隔开的N个数。\n### 输出\n排序输出N个数，每个数间用一个空格间隔。\n### 样例输入 \n```\n5\n9 6 8 7 5\n```\n### 样例输出 \n```\n5 6 7 8 9\n```\n{%endfold%}\n### 问题分析\n本题是最基础的的排序问题，这里采用冒泡排序、选择排序、c++封装的```sort()```排序函数三种方法进行求解。\n### 完整代码\n冒泡排序算法求解：\n```cpp\n#include <iostream>\nusing namespace std;\nvoid bubblesort(int arr[], int n) {\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n - i - 1;j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < n;i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n}\nint main() {\n\tint arr[100], n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> arr[i];\n\t}\n\tbubblesort(arr, n);\n\treturn 0;\n}\n```\n选择排序算法求解：\n```cpp\n#include <iostream>\n#include <climits>\nusing namespace std;\nvoid selectsort(int arr[], int n) {\n    int begin = 0;\n    while (begin < n) {\n        int min = INT_MAX; \n        int tag = begin; \n\n        for (int i = begin; i < n; i++) {\n            if (arr[i] < min) {\n                tag = i;\n                min = arr[tag];\n            }\n        }\n        int temp = arr[begin];\n        arr[begin] = arr[tag];\n        arr[tag] = temp;\n        begin++; \n    }\n    for (int i = 0; i < n; i++) {\n        cout << arr[i] << \" \";\n    }\n}\nint main() {\n\tint arr[100], n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> arr[i];\n\t}\n\tselectsort(arr, n);\n\treturn 0;\n}\n```\n\nSTL封装的 ```sort()```排序函数求解：\n```cpp \n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main() {\n\tvector <int> arr;\n\tint n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tarr.push_back(a);\n\t}\n\tsort(arr.begin(), arr.end());\n\tfor (int i = 0;i < n;i++) {\n\t\tcout << arr[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n封面来源：[Tree data structures in 2 minutes](https://www.youtube.com/watch?v=Etpc_-br5rI&t=21s)\n","slug":"Data structure/CUMT-Datastructure-Practice-2","published":1,"updated":"2025-08-27T03:31:43.546Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcm000m40w31qo4e6gs","content":"<h2 id=\"A题：无向图的深度优先搜索\">A题：无向图的深度优先搜索</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-54b8fa86\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-54b8fa86\">\n        <div class=\"fold-arrow\">▶</div> A题：无向图的深度优先搜索\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-54b8fa86\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>已知一个无向图G的顶点和边，顶点从0依次编号，现在需要深度优先搜索，访问任一邻接顶点时编号小的顶点优先，请编程输出图G的深度优先搜索序列。</p><h3 id=\"输入\">输入</h3><p>第一行是整数m和n（1&lt;m,n&lt;100），分别代表顶点数和边数。后边n行，每行2个数，分别表示一个边的两个顶点。</p><h3 id=\"输出\">输出</h3><p>该图从0号顶点开始的深度优先搜索序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">0</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">2</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>使用邻接表存储图结构，读取数据后，为了保证小编号顶点优先访问，使用<code>sort()</code>\t将每个邻接表中的数据升序排列，函数调用中使用栈实现非递归DFS：<br>\n将<code>start</code>压入栈内，若有邻接的顶点未被访问，将其输出，使用<code>visited</code>数组记录访问过的顶点并将其压入栈内；若其邻接的顶点均被访问，则回溯，弹出栈顶元素。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span><span class=\"hljs-comment\">//sort()函数的调用</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//深度优先搜索DFS函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DFS</span><span class=\"hljs-params\">(vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"hljs-type\">bool</span>&gt; visited, <span class=\"hljs-type\">int</span> start)</span> </span>{<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>\ts.<span class=\"hljs-built_in\">push</span>(start);<span class=\"hljs-comment\">//将起始点压入栈内</span><br>\tvisited[start] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记起始点已访问</span><br>\tcout &lt;&lt; start &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br><br>\t<span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>()) {<br>\t\t<span class=\"hljs-type\">int</span> current = s.<span class=\"hljs-built_in\">top</span>();<br>\t\t<span class=\"hljs-type\">bool</span> found = <span class=\"hljs-literal\">false</span>;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor:graph[current]) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[neighbor]) {<span class=\"hljs-comment\">//如果邻接顶点未被访问</span><br>\t\t\t\tvisited[neighbor] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记为已访问</span><br>\t\t\t\tcout &lt;&lt; neighbor &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t\t\t\ts.<span class=\"hljs-built_in\">push</span>(neighbor);<span class=\"hljs-comment\">//将该顶点压入栈内</span><br>\t\t\t\tfound = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记已访问过的顶点</span><br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//跳出循环，优先处理该顶点的邻接顶点</span><br>\t\t\t}<br>\t\t}<br>\t\t<span class=\"hljs-keyword\">if</span> (!found) {<span class=\"hljs-comment\">//若果该顶点没有未被访问的邻接顶点</span><br>\t\t\ts.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//弹出栈顶元素，回溯</span><br>\t\t}<br>\t}<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> m, n;<br>\tcin &gt;&gt; m &gt;&gt; n;<span class=\"hljs-comment\">//读入定点数和边数</span><br>\t<span class=\"hljs-type\">int</span> a, b;<br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">graph</span>(m);<br>\t<span class=\"hljs-comment\">//初始化邻接表，大小为m，每个元素是vector&lt;int&gt;</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcin &gt;&gt; a &gt;&gt; b;<br>\t\tgraph[a].<span class=\"hljs-built_in\">push_back</span>(b);<br>\t\tgraph[b].<span class=\"hljs-built_in\">push_back</span>(a);<br>\t\t<span class=\"hljs-comment\">//用读入的数据构建邻接表，注意两边都要处理</span><br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; m;i++) {<br>\t\t<span class=\"hljs-built_in\">sort</span>(graph[i].<span class=\"hljs-built_in\">begin</span>(), graph[i].<span class=\"hljs-built_in\">end</span>());<br>\t\t<span class=\"hljs-comment\">//对每个邻接表进行排序，确保DFS优先访问编号小的元素</span><br>\t}<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(m, <span class=\"hljs-literal\">false</span>)</span></span>;<br>\t<span class=\"hljs-comment\">//初始化访问标记数组，大小为m，初始值为false（未被访问状态）</span><br>\t<span class=\"hljs-built_in\">DFS</span>(graph, visited, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释\">注释</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; graph<br></code></pre></td></tr></tbody></table></figure>\n<p>相当于一个<code>graph[][]</code>的二维数组，外层的<code>vector</code>存储所有的顶点，内层的<code>vector&lt;int&gt;</code>存储每个顶点的邻接顶点列表</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor:graph[current])<br></code></pre></td></tr></tbody></table></figure>\n<p>这是C++11 引入了范围<code>for</code>循环语法，专门用于遍历容器（如 <code>vector</code>、<code>list</code>等），每次循环时变量会自动依次选取容器中的下一个元素。（注意中间是<code>:</code>）</p>\n<h2 id=\"B题：最小堆的形成\">B题：最小堆的形成</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-854a53f5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-854a53f5\">\n        <div class=\"fold-arrow\">▶</div> B题：最小堆的形成\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-854a53f5\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现在给你n个结点的完全二叉树数组存储序列，请编程调整为最小堆，并输出相应最小堆的存储序列。</p><h3 id=\"输入\">输入</h3><p>第一行是n，第二行是n个结点的完全二叉树数组存储序列。</p><h3 id=\"输出\">输出</h3><p>输出相应最小堆的存储序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">53 </span><span class=\"hljs-number\">17</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">65</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">17</span> <span class=\"hljs-number\">65</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">53</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>解决问题前首先要了解什么是完全二叉树、什么是最小堆以及完全二叉树有什么性质。<strong>完全二叉树</strong>就是除了最后一层外，其他层的节点都是满的，并且最后一层的节点都尽可能靠左排列的二叉树（从上到下、从左到右的顺序进行填充）。<strong>最小堆</strong>就是满足节点的值&lt;=其子叶节点的值的完全二叉树（给定完全二叉树求最小堆时不可直接升序排列，其有特定的存储结构）。<br>\n假设完全二叉树某节点编号为<code>i</code>,则其父节点为<code>i/2</code>，其左子叶节点为<code>2*i</code>，其右子叶节点为<code>2*i+1</code>。而对于最小堆，其根节点为其全局最小值。有了这些简单的前置知识我们就可以开始解决这道题目了。<br>\n由于<strong>下沉法</strong>相对于<strong>上浮法</strong>具有更高的效率，因此本题先选择自底向上的下沉法递归求解。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">down</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; tree, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> parent)</span> </span>{<br><span class=\"hljs-comment\">//完全二叉树的性质</span><br>\t<span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * parent;<span class=\"hljs-comment\">//左子叶节点</span><br>\t<span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * parent + <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//右子叶节点</span><br>\t<span class=\"hljs-type\">int</span> smallest = parent;<span class=\"hljs-comment\">//初始化最小值为顶点</span><br>\t<span class=\"hljs-keyword\">if</span> (left &lt;= n &amp;&amp; tree[left] &lt; tree[smallest]) {<br>\t\tsmallest = left;<br>\t}<br>\t<span class=\"hljs-keyword\">if</span> (right &lt;= n &amp;&amp; tree[right] &lt; tree[smallest]) {<br>\t\tsmallest = right;<br>\t}<span class=\"hljs-comment\">//找出三个节点中的最小值，将其交换至父节点</span><br>    <span class=\"hljs-keyword\">if</span>(smallest!=parent){<br>\t\t<span class=\"hljs-type\">int</span> temp = tree[smallest]; <br>\t\ttree[smallest] = tree[parent];<br>\t\ttree[parent] = temp;<br>\t\t<span class=\"hljs-comment\">//交换 也可以使用swap()更简便</span><br>\t\t<span class=\"hljs-built_in\">down</span>(tree, n, smallest);<br>\t\t<span class=\"hljs-comment\">//由于最小值上移，原位置需要递归重新确保其子树为最小堆</span><br>\t}<br>}<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">tree</span>(n<span class=\"hljs-number\">+1</span>);<br>\t<span class=\"hljs-comment\">//提前为tree分配空间为n+1</span><br>    <span class=\"hljs-comment\">//（由于从1开始索引）</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= n;i++) {<br>\t\tcin &gt;&gt; tree[i];<br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n / <span class=\"hljs-number\">2</span>;i &gt;= <span class=\"hljs-number\">1</span>;i--){<br>\t\t<span class=\"hljs-built_in\">down</span>(tree, n, i);<br>\t}<br>\t<span class=\"hljs-comment\">//从最小的非子叶结点开始递归</span><br>\t<span class=\"hljs-comment\">//反向遍历，确保处理父节点是，其子树已是最小堆结构</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=n;i++){<br>\t\tcout &lt;&lt; tree[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"C题：折半查找次数\">C题：折半查找次数</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-33671f20\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-33671f20\">\n        <div class=\"fold-arrow\">▶</div> C题：折半查找次数\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-33671f20\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你一个无重复数的有序序列，如果采用折半查找的方式，对于给定的数，需要比较几次找到，请编程实现。</p><h3 id=\"输入\">输入</h3><p>第一行是N，表示序列中数的个数，序列最长1000，第二行是一个有序序列，第三行是要找的数x。</p><h3 id=\"输出\">输出</h3><p>如果找到x，输出折半比较的次数，否则输出NO。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">11</span><br><span class=\"hljs-attribute\">5</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">37</span> <span class=\"hljs-number\">56</span> <span class=\"hljs-number\">64</span> <span class=\"hljs-number\">75</span> <span class=\"hljs-number\">80</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">92</span><br><span class=\"hljs-attribute\">19</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">2<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) {<br>        cin &gt;&gt; arr[i];<br>    }<br>    <span class=\"hljs-type\">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">0</span>, high = n - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">bool</span> found = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">while</span> (low &lt;= high) {<br>        <span class=\"hljs-type\">int</span> mid = (low + high) / <span class=\"hljs-number\">2</span>;<br>        cnt++; <br>        <span class=\"hljs-keyword\">if</span> (arr[mid] == x) {<br>            found = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        }<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[mid] &lt; x) {<br>            low = mid + <span class=\"hljs-number\">1</span>;<br>        }<br>        <span class=\"hljs-keyword\">else</span> {<br>            high = mid - <span class=\"hljs-number\">1</span>;<br>        }<br>    }<br>    <span class=\"hljs-keyword\">if</span> (found)<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">else</span><br>        cout &lt;&lt; <span class=\"hljs-string\">\"NO\"</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"D题：N个数的排序\">D题：N个数的排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-55dc16e1\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-55dc16e1\">\n        <div class=\"fold-arrow\">▶</div> D题：N个数的排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-55dc16e1\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你N个自然数，编程输出排序后的这N个数。</p><h3 id=\"输入\">输入</h3><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h3 id=\"输出\">输出</h3><p>排序输出N个数，每个数间用一个空格间隔。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>本题是最基础的的排序问题，这里采用冒泡排序、选择排序、c++封装的<code>sort()</code>排序函数三种方法进行求解。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<p>冒泡排序算法求解：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubblesort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> n)</span> </span>{<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n - i - <span class=\"hljs-number\">1</span>;j++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"hljs-number\">1</span>]) {<br>\t\t\t\t<span class=\"hljs-type\">int</span> temp = arr[j];<br>\t\t\t\tarr[j] = arr[j + <span class=\"hljs-number\">1</span>];<br>\t\t\t\tarr[j + <span class=\"hljs-number\">1</span>] = temp;<br>\t\t\t}<br>\t\t}<br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t}<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>], n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcin &gt;&gt; arr[i];<br>\t}<br>\t<span class=\"hljs-built_in\">bubblesort</span>(arr, n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>选择排序算法求解：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selectsort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> n)</span> </span>{<br>    <span class=\"hljs-type\">int</span> begin = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (begin &lt; n) {<br>        <span class=\"hljs-type\">int</span> min = INT_MAX; <br>        <span class=\"hljs-type\">int</span> tag = begin; <br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = begin; i &lt; n; i++) {<br>            <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min) {<br>                tag = i;<br>                min = arr[tag];<br>            }<br>        }<br>        <span class=\"hljs-type\">int</span> temp = arr[begin];<br>        arr[begin] = arr[tag];<br>        arr[tag] = temp;<br>        begin++; <br>    }<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) {<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>    }<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>], n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcin &gt;&gt; arr[i];<br>\t}<br>\t<span class=\"hljs-built_in\">selectsort</span>(arr, n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>STL封装的 <code>sort()</code>排序函数求解：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tarr.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t}<br>\t<span class=\"hljs-built_in\">sort</span>(arr.<span class=\"hljs-built_in\">begin</span>(), arr.<span class=\"hljs-built_in\">end</span>());<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=Etpc_-br5rI&amp;t=21s\">Tree data structures in 2 minutes</a></p>\n","excerpt":"","more":"<h2 id=\"A题：无向图的深度优先搜索\">A题：无向图的深度优先搜索</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-54b8fa86\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-54b8fa86\">\n        <div class=\"fold-arrow\">▶</div> A题：无向图的深度优先搜索\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-54b8fa86\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>已知一个无向图G的顶点和边，顶点从0依次编号，现在需要深度优先搜索，访问任一邻接顶点时编号小的顶点优先，请编程输出图G的深度优先搜索序列。</p><h3 id=\"输入\">输入</h3><p>第一行是整数m和n（1&lt;m,n&lt;100），分别代表顶点数和边数。后边n行，每行2个数，分别表示一个边的两个顶点。</p><h3 id=\"输出\">输出</h3><p>该图从0号顶点开始的深度优先搜索序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">0</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>使用邻接表存储图结构，读取数据后，为了保证小编号顶点优先访问，使用<code>sort()</code>\t将每个邻接表中的数据升序排列，函数调用中使用栈实现非递归DFS：<br>\n将<code>start</code>压入栈内，若有邻接的顶点未被访问，将其输出，使用<code>visited</code>数组记录访问过的顶点并将其压入栈内；若其邻接的顶点均被访问，则回溯，弹出栈顶元素。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span><span class=\"hljs-comment\">//sort()函数的调用</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-comment\">//深度优先搜索DFS函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">DFS</span><span class=\"hljs-params\">(vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt;&amp; graph, vector&lt;<span class=\"hljs-type\">bool</span>&gt; visited, <span class=\"hljs-type\">int</span> start)</span> </span>&#123;<br>\tstack&lt;<span class=\"hljs-type\">int</span>&gt; s;<br>\ts.<span class=\"hljs-built_in\">push</span>(start);<span class=\"hljs-comment\">//将起始点压入栈内</span><br>\tvisited[start] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记起始点已访问</span><br>\tcout &lt;&lt; start &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br><br>\t<span class=\"hljs-keyword\">while</span> (!s.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t<span class=\"hljs-type\">int</span> current = s.<span class=\"hljs-built_in\">top</span>();<br>\t\t<span class=\"hljs-type\">bool</span> found = <span class=\"hljs-literal\">false</span>;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor:graph[current]) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[neighbor]) &#123;<span class=\"hljs-comment\">//如果邻接顶点未被访问</span><br>\t\t\t\tvisited[neighbor] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记为已访问</span><br>\t\t\t\tcout &lt;&lt; neighbor &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\t\t\ts.<span class=\"hljs-built_in\">push</span>(neighbor);<span class=\"hljs-comment\">//将该顶点压入栈内</span><br>\t\t\t\tfound = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记已访问过的顶点</span><br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//跳出循环，优先处理该顶点的邻接顶点</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (!found) &#123;<span class=\"hljs-comment\">//若果该顶点没有未被访问的邻接顶点</span><br>\t\t\ts.<span class=\"hljs-built_in\">pop</span>();<span class=\"hljs-comment\">//弹出栈顶元素，回溯</span><br>\t\t&#125;<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> m, n;<br>\tcin &gt;&gt; m &gt;&gt; n;<span class=\"hljs-comment\">//读入定点数和边数</span><br>\t<span class=\"hljs-type\">int</span> a, b;<br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">graph</span>(m);<br>\t<span class=\"hljs-comment\">//初始化邻接表，大小为m，每个元素是vector&lt;int&gt;</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcin &gt;&gt; a &gt;&gt; b;<br>\t\tgraph[a].<span class=\"hljs-built_in\">push_back</span>(b);<br>\t\tgraph[b].<span class=\"hljs-built_in\">push_back</span>(a);<br>\t\t<span class=\"hljs-comment\">//用读入的数据构建邻接表，注意两边都要处理</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; m;i++) &#123;<br>\t\t<span class=\"hljs-built_in\">sort</span>(graph[i].<span class=\"hljs-built_in\">begin</span>(), graph[i].<span class=\"hljs-built_in\">end</span>());<br>\t\t<span class=\"hljs-comment\">//对每个邻接表进行排序，确保DFS优先访问编号小的元素</span><br>\t&#125;<br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(m, <span class=\"hljs-literal\">false</span>)</span></span>;<br>\t<span class=\"hljs-comment\">//初始化访问标记数组，大小为m，初始值为false（未被访问状态）</span><br>\t<span class=\"hljs-built_in\">DFS</span>(graph, visited, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释\">注释</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; graph<br></code></pre></td></tr></table></figure>\n<p>相当于一个<code>graph[][]</code>的二维数组，外层的<code>vector</code>存储所有的顶点，内层的<code>vector&lt;int&gt;</code>存储每个顶点的邻接顶点列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor:graph[current])<br></code></pre></td></tr></table></figure>\n<p>这是C++11 引入了范围<code>for</code>循环语法，专门用于遍历容器（如 <code>vector</code>、<code>list</code>等），每次循环时变量会自动依次选取容器中的下一个元素。（注意中间是<code>:</code>）</p>\n<h2 id=\"B题：最小堆的形成\">B题：最小堆的形成</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-854a53f5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-854a53f5\">\n        <div class=\"fold-arrow\">▶</div> B题：最小堆的形成\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-854a53f5\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>现在给你n个结点的完全二叉树数组存储序列，请编程调整为最小堆，并输出相应最小堆的存储序列。</p><h3 id=\"输入\">输入</h3><p>第一行是n，第二行是n个结点的完全二叉树数组存储序列。</p><h3 id=\"输出\">输出</h3><p>输出相应最小堆的存储序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">8</span><br><span class=\"hljs-symbol\">53 </span><span class=\"hljs-number\">17</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">65</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">17</span> <span class=\"hljs-number\">65</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">45</span> <span class=\"hljs-number\">78</span> <span class=\"hljs-number\">87</span> <span class=\"hljs-number\">53</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>解决问题前首先要了解什么是完全二叉树、什么是最小堆以及完全二叉树有什么性质。<strong>完全二叉树</strong>就是除了最后一层外，其他层的节点都是满的，并且最后一层的节点都尽可能靠左排列的二叉树（从上到下、从左到右的顺序进行填充）。<strong>最小堆</strong>就是满足节点的值&lt;=其子叶节点的值的完全二叉树（给定完全二叉树求最小堆时不可直接升序排列，其有特定的存储结构）。<br>\n假设完全二叉树某节点编号为<code>i</code>,则其父节点为<code>i/2</code>，其左子叶节点为<code>2*i</code>，其右子叶节点为<code>2*i+1</code>。而对于最小堆，其根节点为其全局最小值。有了这些简单的前置知识我们就可以开始解决这道题目了。<br>\n由于<strong>下沉法</strong>相对于<strong>上浮法</strong>具有更高的效率，因此本题先选择自底向上的下沉法递归求解。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">down</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; tree, <span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> parent)</span> </span>&#123;<br><span class=\"hljs-comment\">//完全二叉树的性质</span><br>\t<span class=\"hljs-type\">int</span> left = <span class=\"hljs-number\">2</span> * parent;<span class=\"hljs-comment\">//左子叶节点</span><br>\t<span class=\"hljs-type\">int</span> right = <span class=\"hljs-number\">2</span> * parent + <span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//右子叶节点</span><br>\t<span class=\"hljs-type\">int</span> smallest = parent;<span class=\"hljs-comment\">//初始化最小值为顶点</span><br>\t<span class=\"hljs-keyword\">if</span> (left &lt;= n &amp;&amp; tree[left] &lt; tree[smallest]) &#123;<br>\t\tsmallest = left;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (right &lt;= n &amp;&amp; tree[right] &lt; tree[smallest]) &#123;<br>\t\tsmallest = right;<br>\t&#125;<span class=\"hljs-comment\">//找出三个节点中的最小值，将其交换至父节点</span><br>    <span class=\"hljs-keyword\">if</span>(smallest!=parent)&#123;<br>\t\t<span class=\"hljs-type\">int</span> temp = tree[smallest]; <br>\t\ttree[smallest] = tree[parent];<br>\t\ttree[parent] = temp;<br>\t\t<span class=\"hljs-comment\">//交换 也可以使用swap()更简便</span><br>\t\t<span class=\"hljs-built_in\">down</span>(tree, n, smallest);<br>\t\t<span class=\"hljs-comment\">//由于最小值上移，原位置需要递归重新确保其子树为最小堆</span><br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">tree</span>(n<span class=\"hljs-number\">+1</span>);<br>\t<span class=\"hljs-comment\">//提前为tree分配空间为n+1</span><br>    <span class=\"hljs-comment\">//（由于从1开始索引）</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= n;i++) &#123;<br>\t\tcin &gt;&gt; tree[i];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = n / <span class=\"hljs-number\">2</span>;i &gt;= <span class=\"hljs-number\">1</span>;i--)&#123;<br>\t\t<span class=\"hljs-built_in\">down</span>(tree, n, i);<br>\t&#125;<br>\t<span class=\"hljs-comment\">//从最小的非子叶结点开始递归</span><br>\t<span class=\"hljs-comment\">//反向遍历，确保处理父节点是，其子树已是最小堆结构</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>\t\tcout &lt;&lt; tree[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"C题：折半查找次数\">C题：折半查找次数</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-33671f20\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-33671f20\">\n        <div class=\"fold-arrow\">▶</div> C题：折半查找次数\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-33671f20\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你一个无重复数的有序序列，如果采用折半查找的方式，对于给定的数，需要比较几次找到，请编程实现。</p><h3 id=\"输入\">输入</h3><p>第一行是N，表示序列中数的个数，序列最长1000，第二行是一个有序序列，第三行是要找的数x。</p><h3 id=\"输出\">输出</h3><p>如果找到x，输出折半比较的次数，否则输出NO。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">11</span><br><span class=\"hljs-attribute\">5</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">19</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">37</span> <span class=\"hljs-number\">56</span> <span class=\"hljs-number\">64</span> <span class=\"hljs-number\">75</span> <span class=\"hljs-number\">80</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">92</span><br><span class=\"hljs-attribute\">19</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">2<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(n)</span></span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; arr[i];<br>    &#125;<br>    <span class=\"hljs-type\">int</span> x;<br>    cin &gt;&gt; x;<br>    <span class=\"hljs-type\">int</span> low = <span class=\"hljs-number\">0</span>, high = n - <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">bool</span> found = <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">while</span> (low &lt;= high) &#123;<br>        <span class=\"hljs-type\">int</span> mid = (low + high) / <span class=\"hljs-number\">2</span>;<br>        cnt++; <br>        <span class=\"hljs-keyword\">if</span> (arr[mid] == x) &#123;<br>            found = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (arr[mid] &lt; x) &#123;<br>            low = mid + <span class=\"hljs-number\">1</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            high = mid - <span class=\"hljs-number\">1</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (found)<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">else</span><br>        cout &lt;&lt; <span class=\"hljs-string\">&quot;NO&quot;</span> &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"D题：N个数的排序\">D题：N个数的排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-55dc16e1\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-55dc16e1\">\n        <div class=\"fold-arrow\">▶</div> D题：N个数的排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-55dc16e1\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你N个自然数，编程输出排序后的这N个数。</p><h3 id=\"输入\">输入</h3><p>第一行是整数的个数N（N&lt;=100）。第二行是用空格隔开的N个数。</p><h3 id=\"输出\">输出</h3><p>排序输出N个数，每个数间用一个空格间隔。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>本题是最基础的的排序问题，这里采用冒泡排序、选择排序、c++封装的<code>sort()</code>排序函数三种方法进行求解。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<p>冒泡排序算法求解：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bubblesort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n - i - <span class=\"hljs-number\">1</span>;j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"hljs-number\">1</span>]) &#123;<br>\t\t\t\t<span class=\"hljs-type\">int</span> temp = arr[j];<br>\t\t\t\tarr[j] = arr[j + <span class=\"hljs-number\">1</span>];<br>\t\t\t\tarr[j + <span class=\"hljs-number\">1</span>] = temp;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>], n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcin &gt;&gt; arr[i];<br>\t&#125;<br>\t<span class=\"hljs-built_in\">bubblesort</span>(arr, n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>选择排序算法求解：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">selectsort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> arr[], <span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> begin = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span> (begin &lt; n) &#123;<br>        <span class=\"hljs-type\">int</span> min = INT_MAX; <br>        <span class=\"hljs-type\">int</span> tag = begin; <br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = begin; i &lt; n; i++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (arr[i] &lt; min) &#123;<br>                tag = i;<br>                min = arr[tag];<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-type\">int</span> temp = arr[begin];<br>        arr[begin] = arr[tag];<br>        arr[tag] = temp;<br>        begin++; <br>    &#125;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> arr[<span class=\"hljs-number\">100</span>], n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcin &gt;&gt; arr[i];<br>\t&#125;<br>\t<span class=\"hljs-built_in\">selectsort</span>(arr, n);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>STL封装的 <code>sort()</code>排序函数求解：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; arr;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tarr.<span class=\"hljs-built_in\">push_back</span>(a);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">sort</span>(arr.<span class=\"hljs-built_in\">begin</span>(), arr.<span class=\"hljs-built_in\">end</span>());<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcout &lt;&lt; arr[i] &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=Etpc_-br5rI&amp;t=21s\">Tree data structures in 2 minutes</a></p>\n"},{"title":"CUMT-Datastructure-Practice 3","date":"2025-06-24T04:57:21.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Practice-3.png","category_bar":true,"description":"Problems involving binary trees stored in linked lists, Huffman trees, priority queues, Dijkstra's algorithm, and Kruskal's algorithm","_content":"\n## 问题 A: 二叉链表存储的二叉树\n{%fold into @ 问题 A: 二叉链表存储的二叉树 %}\n### 题目描述\n树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构.在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。\n### 输入\n输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。\n### 输出\n共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。\n### 样例输入\n```\nABC  DE G  F \n```\n### 样例输出\n```\nA B C D E G F \nC B E G D F A \nC B E G D F A\n```\n{%endfold%}\n\n### 提示\n遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。\n\n### 问题分析\n本题依照题目使用二叉树链式存储结构进行二叉树的建立和遍历。\n1. 设计二叉树的```struct```的节点结构，包含数据元素和左子叶节点和右子叶节点（使用构造函数给结点赋初值和初始化节点指针）。\n2. 用递归的思想实现二叉树的构建，若索引值```index```非空，则构建节点，再依次递归构建左子树，递归构建右子树。\n3. 递归遍历注意访问和递归的调用顺序即可。\n\n遍历方式|访问顺序|递归调用顺序\n--------- | -----------|----------|\n先序遍历\t|根 → 左 → 右\t|访问 → 左递归 → 右递归\n中序遍历\t|左 → 根 → 右\t|左递归 → 访问 → 右递归\n后序遍历\t|左 → 右 → 根\t|左递归 → 右递归 → 访问\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct BinaryTreeNode {\n\tchar data;\n\tBinaryTreeNode* left;\n\tBinaryTreeNode* right;\n\tBinaryTreeNode(char x):data(x),left(nullptr),right(nullptr){}\n};\n//若不构造函数则创建节点时需要:\n//BinaryTreeNode* node = new BinaryTreeNode{'A', nullptr, nullptr};\nBinaryTreeNode* buildtree(string str, int& index) {\n\tif (index >= str.size() || str[index] == ' ') {\n\t//若索引值超出范围或者为空\n\t\tindex++;\n\t\treturn nullptr;\n\t}\n\tBinaryTreeNode* node = new BinaryTreeNode(str[index++]);\n\t//创建新节点，递归构建左右子树\n\tnode->left = buildtree(str, index);\n\tnode->right = buildtree(str, index);\n\treturn node;\n};\nvoid preOrder(BinaryTreeNode* root) {//前序遍历\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tcout << root->data << \" \";\n\tpreOrder(root->left);\n\tpreOrder(root->right);\n};\nvoid inOrder(BinaryTreeNode* root) {//中序遍历\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tinOrder(root->left);\n\tcout << root->data << \" \";\n\tinOrder(root->right);\n};\n//void postOrder(BinaryTreeNode* root) {后序遍历\n//\tif (root == nullptr) {\n//\t\treturn;\n//\t}\n//\tpostOrder(root->left);\n//\tpostOrder(root->right);\n//\tcout << root->data << \" \";\n//};\nint main() {\n\tstring str;\n\tgetline(cin,str);\n\t//注意用getline需要读取空格\n\tint index=0;\n\tBinaryTreeNode* root=buildtree(str, index);\n\tpreOrder(root);\n\tcout << endl;\n\tinOrder(root);\n\tcout << endl;\n\tinOrder(root);\n\tcout << endl;\n\t//postOrder(root);\n\t//cout << endl;\n\treturn 0;\n}\n```\n## B题：哈夫曼树\n{%fold into @ B题：哈夫曼树 %}\n### 题目描述\n哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。\n### 输入\n输入有多组数据。\n每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。\n### 输出\n输出权值。\n### 样例输入\n```\n2\n2 8 \n3\n5 11 30 \n```\n### 样例输出\n```\n10\n62\n```\n{%endfold%}\n### 问题分析\n1. 将所有权值作为单独的树（每个树只有一个节点）\n2. 每次选择权值最小的两棵树合并，形成新的子树，新树的权值为两子树权值之和\n3. 将新树根节点作为新的子树，重复上述过程，直到只剩下一棵树\n4. 计算合并过程中所有中间结果的累加和\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\nvoid huffman(int n) {\n\tpriority_queue <int, vector<int>, greater<int>> minqueue;\n\t//创建最小优先队列\n\tfor (int i = 0;i < n;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tminqueue.push(a);\n\t}   // 读取n个权值并存入最小堆\n\tint total = 0;//带权路径长度\n\t// 隐式构建哈夫曼树\n\twhile (!minqueue.empty()) {\n\t\tint parent = minqueue.top();\n\t\tminqueue.pop();\n\t\t//取出当前最小值\n\t\tif (minqueue.empty()) {\n\t\t\tbreak;//当队列中只有一个元素时退出循环\n\t\t}\n\t\tparent += minqueue.top();\n\t\tminqueue.pop();\n\t\t//取出次小值\n\t\ttotal +=  parent;\n\t\tminqueue.push(parent);\n\t}\n\tcout << total << endl;\n}\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\thuffman(n);\n\t}\n\treturn 0;\n}\n```\n### 注释\n**优先队列：** 这是一种特殊的队列，每次```push```进去一个数，它就会自动按照大小排好队，```top```就能得到队首元素（最大值），```pop```就会弹出队首元素（队列中最大值）。定义方法如下：\n```cpp\npriority_queue<int> pq;//int型优先队列\n```\n若我们不满足其降序排列我们还可以将其调整为升序排列：\n```cpp\npriority_queue <int, vector<int>, greater<int>> pq;//int型逆序优先队列\n```\n\n## C题：树的遍历\n{%fold into @ C题：树的遍历 %}\n### 题目描述\n&emsp;&emsp;假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。\n&emsp;&emsp;现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。\n### 输入\n每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数N（≤30），即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。\n\n### 输出\n对于每个测试用例，如果树是唯一的，则首先是行中的Yes，否则是No。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。\n### 样例输入\n```\n7\n1 2 3 4 6 7 5\n2 6 7 4 5 3 1\n```\n### 样例输出\n```\nYes\n2 1 6 4 7 3 5\n```\n{%endfold%}\n### 问题分析\n&emsp;&emsp;已知前序、中序二叉树唯一确定，已知中序、后序二叉树唯一确定，而一直前序和后序二叉树无法唯一确定。\n&emsp;&emsp;前序序列的第一个节点必于后续序列最后一个节点相同，为根节点；前序序列的第二个节点为左子树的根节点（如果有左子树的话），在后续序列中寻找该节点，则划分了左右子树，其左边的所有节点属于左子树，右边的节点（直到根节点之前）属于右子树。\n&emsp;&emsp;因而我们可以使用前序和后序序列递归地分割左右子树，并直接生成中序序列。\n而如果前序的第二个节点在后序中位于根节点前的位置，说明该节点可以是左子树或右子树的根，此时树不唯一，可以任意选择左右子树。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> in, pre, post;\n//定义全局变量，分别为前序、中序、后序序列\nbool unique = true;//标记二叉树是否唯一\nvoid build(int preL, int preR, int postL, int postR) {\n//分别标记了前序和后序序列的左右边界\n    if (preL == preR) {\n        in.push_back(pre[preL]);\n        return;\n    }\n    if (pre[preL] == post[postR]) {\n        int i = preL + 1;\n        while (i <= preR && pre[i] != post[postR - 1]) i++;\n        //在后序序列中寻找左子树的根节点\n        if (i - preL > 1)\n            build(preL + 1, i - 1, postL, postL + (i - preL - 1) - 1);\n        else\n            unique = false;\n        in.push_back(post[postR]);\n        build(i, preR, postL + (i - preL - 1), postR - 1);\n    }\n}\nint main() {\n    int n;\n    cin >> n;\n    pre.resize(n);\n    post.resize(n);\n    //为全局变量重新分配空间\n    for (int& val : pre) cin >> val;\n    for (int& val : post) cin >> val;\n    //读入数据（注意是&索引值）\n    build(0, n - 1, 0, n - 1);\n    cout << (unique ? \"Yes\" : \"No\") << endl;\n    if (!in.empty()) {\n        cout << in[0];\n        for (int i = 1; i < in.size(); ++i)\n            cout << \" \" << in[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n## D题：最短路径\n{%fold into @ D题：最短路径 %}\n### 题目描述\n一个迷宫地图中，多个房间由单向通道相连，房间号从1到N依次编号。你能编程求解任意房间间的最短路径长度吗？\n\n### 输入\n第一行是迷宫中的房间数N和单项通道数M（0<N,M<100），接下来M行，每行三个数x,y,z，表示一个通道是从x到y,且通道长度是z(z<1000）。\n最后一行是start和end，分别是起点房间号和终点房间号。\n\n### 输出\n输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出STOP。\n### 样例输入\n```\n7 9\n1 2 3\n1 3 2\n3 4 2\n6 3 1\n2 6 3\n6 7 6\n2 5 4\n5 4 2\n5 7 5\n1 7\n```\n### 样例输出\n```\n12\n```\n{%endfold%}\n### 问题分析\n最短路径路径问题，我们这里采用**Dijkstra算法**进行求解。\n1. 构造邻接矩阵```graph```存储带权有向图。\n1. 将起始顶点的距离设为0，其他所有顶点的距离```distance```设为无穷大（即从```start```到`i`的最短路径长度）。\n2. 将起始顶点加入已访问集合```visited```。\n3. 遍历未访问顶点，找出距离起始点最短的顶点，将其加入已访问集合。\n4. 更新```distance```的距离，如果新计算的距离小于当前距离，则更新距离。\n5. 重复步骤3和4，直到所有顶点都被访问过。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n\tint M, N;\n\tcin >> N >> M;\n\tvector<int>distance(N, INT_MAX);//存放start到i点的最短路径长度\n\tvector<bool> visited(N, false);//记录当前顶点是否已被访问过\n\tvector<vector<int>> graph(N, vector<int>(N, 0));\n\t//有向图的邻接矩阵（二维数组）\n\tint p, q, length;\n\tfor(int i = 0;i < M;i++){\n\t\tcin >> p >> q >> length;\n\t\tgraph[p-1][q-1] = length;\n\t\t//均采用 0-based索引\n\t}\n\tint start, end;\n\tcin >> start >> end;\n\tvisited[start - 1] = true;\n\tdistance[start - 1] = 0;\n\tfor (int i = 0;i < N;i++) {\n\t\tif (graph[start - 1][i] != 0) {\n\t\t\tdistance[i] = graph[start - 1][i];\n\t\t\t//用start的邻接矩阵对distance数组进行初始化\n\t\t}\n\t}\n    for(int j=0;j <N;j++){\n\t\tint small = INT_MAX;\n\t\tint tag = -1;//标记最小顶点的索引\n\t\tfor (int i = 1;i <= N;i++) {\n\t\t\tif (distance[i - 1] < small && !visited[i - 1]) {\n\t\t\t\tsmall = distance[i - 1];\n\t\t\t\ttag = i;\n\t\t\t}\n\t\t}\n\t\tif (tag == -1) {\n\t\t\tbreak;\n\t\t\t//若没有找到最小索引\n\t\t\t//邻接矩阵已经全部遍历完成\n\t\t\t//退出循环\n\t\t}\n\t\tvisited[tag - 1] = true;//标记已访问\n\t\tfor (int i = 1;i <= N;i++) {\n\t\t\tif (graph[tag - 1][i - 1]!=0 && \n\t\t\tdistance[tag - 1] + graph[tag - 1][i - 1] < distance[i - 1]) {\n\t\t\tdistance[i - 1] = distance[tag - 1] + graph[tag - 1][i - 1];\n\t\t\t//如果当前路径为最短路径则进行更新\n\t\t\t}\n\t\t}\n\t}\n\t\tif (distance[end - 1] != INT_MAX) {\n\t\t\tcout << distance[end-1] << endl;\n\t\t}\n\t\t//若distance==INT_MAX，则没有通路\n\t\telse cout << \"STOP\" << endl;\n     return 0;\n}\n```\n## E题：最小生成树\n{%fold into @ E题：最小生成树 %}\n### 题目描述\n最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。\n可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。\n而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。\n在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。\n### 输入\n输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。\n以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。\n输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。\n### 输出\n只有一个整数，即最小生成树的总代价。请注意行尾输出换行。\n### 样例输入\n```\n4\n0 2 4 0\n2 0 3 5\n4 3 0 1\n0 5 1 0\n```\n### 样例输出\n```\n6\n```\n{%endfold%}\n\n### 提示\n在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。\n\n### 问题分析\n完成本题首先要掌握要掌握两种计算最小生成树的方法：普利姆（Prim）算法、克鲁斯卡尔（Kruskal）算法。（当然本题只要求使用普利姆算法）\n+ 普利姆算法（+点）\n1. 选择任意一个顶点作为起始点，将其加入最小生成树中\n2. 从未选择的顶点中选择与现有生成树连线权重最小的顶点，将其加入到现有生成树中\n3. 重复上述步骤，直到最小生成树包含了图中的所有顶点。\n\n+ 克鲁斯卡尔算法（+边）\n 1. 从不属于最小生成树的边中找到权值最小的边，判断最小边及其连接的两个顶点加入到最小生成树是否会形成环路。\n 2. 若不形成环路，则将此最小边及其连接的顶点并入最小生成树。\n 3. 若形成环路，则永远不再看此边，然后从剩下的且不属于最小生成树的边中，寻找权值最小的边。\n 4. 重复上述步骤，直至所有顶点均连接在一起，并没有形成环路时，最小生成树就找到了。\n \n根据题意这里使用普利姆算法进行编程求解，用```key```记录当前生成树与各个顶点的最小值，```visited```记录当前顶点是否被访问，外循环```n```次，每次将一个顶点加入最小生成树中。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <climits>//用于INT_MAX的数组初始化\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> matrix(n, vector<int>(n));\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++) {\n\t\t\tcin >> matrix[i][j];//读入邻接矩阵\n\t\t}\n\t}\n\tvector <int> key(n,INT_MAX);\n\t//记录当前生成树与各顶点的最小值并不断更新\n\tvector <bool> visited(n, false);\n\t//记录当前顶点是否已经被访问过\n\tkey[0] = 0;\n\tint total = 0;//记录最小生成树的总权值\n\tfor (int i = 0;i < n;i++) {\n\t\tint u = -1;\n\t\tfor (int j = 0;j < n;j++) {\n\t\t\tif (!visited[j] && (u == -1 || key[j] < key[u])) {\n\t\t\t\tu = j;//找到当前与生成树的最小权值点顶点\n\t\t\t}\n\t\t}\n\t\tvisited[u] = true;\n\t\ttotal += key[u];\n\t\tfor (int v = 0;v < n;v++) {\n\t\t\tif (!visited[v] && matrix[u][v]!=0 && matrix[u][v] < key[v]) {\n\t\t\t\tkey[v] = matrix[u][v];\n\t\t\t\t//对key生成树到顶点的最小值进行更新\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << total << endl;\n\treturn 0;\n}\n```\n### 注释\n```<climits>```头文件，定义了与整数类型的大小和范围相关的宏常量，常用```INT_MAX```和```INT_MIN```对数组变量进行初始化。\n\n封面来源: [Shortest Path Algorithms Explained (Dijkstra's & Bellman-Ford)](https://www.youtube.com/watch?v=j0OUwduDOS0)\n","source":"_posts/Data structure/CUMT-Datastructure-Practice-3.md","raw":"---\ntitle: CUMT-Datastructure-Practice 3\ndate: 2025-06-24 12:57:21\ntags: [binary tree,huffman tree,queue,Dijkstra,Kruskal]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Practice-3.png\ncategory: Data Structure\ncategory_bar: true\ndescription: Problems involving binary trees stored in linked lists, Huffman trees, priority queues, Dijkstra's algorithm, and Kruskal's algorithm\n---\n\n## 问题 A: 二叉链表存储的二叉树\n{%fold into @ 问题 A: 二叉链表存储的二叉树 %}\n### 题目描述\n树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构.在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。\n### 输入\n输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。\n### 输出\n共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。\n### 样例输入\n```\nABC  DE G  F \n```\n### 样例输出\n```\nA B C D E G F \nC B E G D F A \nC B E G D F A\n```\n{%endfold%}\n\n### 提示\n遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。\n\n### 问题分析\n本题依照题目使用二叉树链式存储结构进行二叉树的建立和遍历。\n1. 设计二叉树的```struct```的节点结构，包含数据元素和左子叶节点和右子叶节点（使用构造函数给结点赋初值和初始化节点指针）。\n2. 用递归的思想实现二叉树的构建，若索引值```index```非空，则构建节点，再依次递归构建左子树，递归构建右子树。\n3. 递归遍历注意访问和递归的调用顺序即可。\n\n遍历方式|访问顺序|递归调用顺序\n--------- | -----------|----------|\n先序遍历\t|根 → 左 → 右\t|访问 → 左递归 → 右递归\n中序遍历\t|左 → 根 → 右\t|左递归 → 访问 → 右递归\n后序遍历\t|左 → 右 → 根\t|左递归 → 右递归 → 访问\n\n### 完整代码\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nstruct BinaryTreeNode {\n\tchar data;\n\tBinaryTreeNode* left;\n\tBinaryTreeNode* right;\n\tBinaryTreeNode(char x):data(x),left(nullptr),right(nullptr){}\n};\n//若不构造函数则创建节点时需要:\n//BinaryTreeNode* node = new BinaryTreeNode{'A', nullptr, nullptr};\nBinaryTreeNode* buildtree(string str, int& index) {\n\tif (index >= str.size() || str[index] == ' ') {\n\t//若索引值超出范围或者为空\n\t\tindex++;\n\t\treturn nullptr;\n\t}\n\tBinaryTreeNode* node = new BinaryTreeNode(str[index++]);\n\t//创建新节点，递归构建左右子树\n\tnode->left = buildtree(str, index);\n\tnode->right = buildtree(str, index);\n\treturn node;\n};\nvoid preOrder(BinaryTreeNode* root) {//前序遍历\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tcout << root->data << \" \";\n\tpreOrder(root->left);\n\tpreOrder(root->right);\n};\nvoid inOrder(BinaryTreeNode* root) {//中序遍历\n\tif (root == nullptr) {\n\t\treturn;\n\t}\n\tinOrder(root->left);\n\tcout << root->data << \" \";\n\tinOrder(root->right);\n};\n//void postOrder(BinaryTreeNode* root) {后序遍历\n//\tif (root == nullptr) {\n//\t\treturn;\n//\t}\n//\tpostOrder(root->left);\n//\tpostOrder(root->right);\n//\tcout << root->data << \" \";\n//};\nint main() {\n\tstring str;\n\tgetline(cin,str);\n\t//注意用getline需要读取空格\n\tint index=0;\n\tBinaryTreeNode* root=buildtree(str, index);\n\tpreOrder(root);\n\tcout << endl;\n\tinOrder(root);\n\tcout << endl;\n\tinOrder(root);\n\tcout << endl;\n\t//postOrder(root);\n\t//cout << endl;\n\treturn 0;\n}\n```\n## B题：哈夫曼树\n{%fold into @ B题：哈夫曼树 %}\n### 题目描述\n哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。\n### 输入\n输入有多组数据。\n每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。\n### 输出\n输出权值。\n### 样例输入\n```\n2\n2 8 \n3\n5 11 30 \n```\n### 样例输出\n```\n10\n62\n```\n{%endfold%}\n### 问题分析\n1. 将所有权值作为单独的树（每个树只有一个节点）\n2. 每次选择权值最小的两棵树合并，形成新的子树，新树的权值为两子树权值之和\n3. 将新树根节点作为新的子树，重复上述过程，直到只剩下一棵树\n4. 计算合并过程中所有中间结果的累加和\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\nvoid huffman(int n) {\n\tpriority_queue <int, vector<int>, greater<int>> minqueue;\n\t//创建最小优先队列\n\tfor (int i = 0;i < n;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tminqueue.push(a);\n\t}   // 读取n个权值并存入最小堆\n\tint total = 0;//带权路径长度\n\t// 隐式构建哈夫曼树\n\twhile (!minqueue.empty()) {\n\t\tint parent = minqueue.top();\n\t\tminqueue.pop();\n\t\t//取出当前最小值\n\t\tif (minqueue.empty()) {\n\t\t\tbreak;//当队列中只有一个元素时退出循环\n\t\t}\n\t\tparent += minqueue.top();\n\t\tminqueue.pop();\n\t\t//取出次小值\n\t\ttotal +=  parent;\n\t\tminqueue.push(parent);\n\t}\n\tcout << total << endl;\n}\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\thuffman(n);\n\t}\n\treturn 0;\n}\n```\n### 注释\n**优先队列：** 这是一种特殊的队列，每次```push```进去一个数，它就会自动按照大小排好队，```top```就能得到队首元素（最大值），```pop```就会弹出队首元素（队列中最大值）。定义方法如下：\n```cpp\npriority_queue<int> pq;//int型优先队列\n```\n若我们不满足其降序排列我们还可以将其调整为升序排列：\n```cpp\npriority_queue <int, vector<int>, greater<int>> pq;//int型逆序优先队列\n```\n\n## C题：树的遍历\n{%fold into @ C题：树的遍历 %}\n### 题目描述\n&emsp;&emsp;假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。\n&emsp;&emsp;现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。\n### 输入\n每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数N（≤30），即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。\n\n### 输出\n对于每个测试用例，如果树是唯一的，则首先是行中的Yes，否则是No。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。\n### 样例输入\n```\n7\n1 2 3 4 6 7 5\n2 6 7 4 5 3 1\n```\n### 样例输出\n```\nYes\n2 1 6 4 7 3 5\n```\n{%endfold%}\n### 问题分析\n&emsp;&emsp;已知前序、中序二叉树唯一确定，已知中序、后序二叉树唯一确定，而一直前序和后序二叉树无法唯一确定。\n&emsp;&emsp;前序序列的第一个节点必于后续序列最后一个节点相同，为根节点；前序序列的第二个节点为左子树的根节点（如果有左子树的话），在后续序列中寻找该节点，则划分了左右子树，其左边的所有节点属于左子树，右边的节点（直到根节点之前）属于右子树。\n&emsp;&emsp;因而我们可以使用前序和后序序列递归地分割左右子树，并直接生成中序序列。\n而如果前序的第二个节点在后序中位于根节点前的位置，说明该节点可以是左子树或右子树的根，此时树不唯一，可以任意选择左右子树。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> in, pre, post;\n//定义全局变量，分别为前序、中序、后序序列\nbool unique = true;//标记二叉树是否唯一\nvoid build(int preL, int preR, int postL, int postR) {\n//分别标记了前序和后序序列的左右边界\n    if (preL == preR) {\n        in.push_back(pre[preL]);\n        return;\n    }\n    if (pre[preL] == post[postR]) {\n        int i = preL + 1;\n        while (i <= preR && pre[i] != post[postR - 1]) i++;\n        //在后序序列中寻找左子树的根节点\n        if (i - preL > 1)\n            build(preL + 1, i - 1, postL, postL + (i - preL - 1) - 1);\n        else\n            unique = false;\n        in.push_back(post[postR]);\n        build(i, preR, postL + (i - preL - 1), postR - 1);\n    }\n}\nint main() {\n    int n;\n    cin >> n;\n    pre.resize(n);\n    post.resize(n);\n    //为全局变量重新分配空间\n    for (int& val : pre) cin >> val;\n    for (int& val : post) cin >> val;\n    //读入数据（注意是&索引值）\n    build(0, n - 1, 0, n - 1);\n    cout << (unique ? \"Yes\" : \"No\") << endl;\n    if (!in.empty()) {\n        cout << in[0];\n        for (int i = 1; i < in.size(); ++i)\n            cout << \" \" << in[i];\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n## D题：最短路径\n{%fold into @ D题：最短路径 %}\n### 题目描述\n一个迷宫地图中，多个房间由单向通道相连，房间号从1到N依次编号。你能编程求解任意房间间的最短路径长度吗？\n\n### 输入\n第一行是迷宫中的房间数N和单项通道数M（0<N,M<100），接下来M行，每行三个数x,y,z，表示一个通道是从x到y,且通道长度是z(z<1000）。\n最后一行是start和end，分别是起点房间号和终点房间号。\n\n### 输出\n输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出STOP。\n### 样例输入\n```\n7 9\n1 2 3\n1 3 2\n3 4 2\n6 3 1\n2 6 3\n6 7 6\n2 5 4\n5 4 2\n5 7 5\n1 7\n```\n### 样例输出\n```\n12\n```\n{%endfold%}\n### 问题分析\n最短路径路径问题，我们这里采用**Dijkstra算法**进行求解。\n1. 构造邻接矩阵```graph```存储带权有向图。\n1. 将起始顶点的距离设为0，其他所有顶点的距离```distance```设为无穷大（即从```start```到`i`的最短路径长度）。\n2. 将起始顶点加入已访问集合```visited```。\n3. 遍历未访问顶点，找出距离起始点最短的顶点，将其加入已访问集合。\n4. 更新```distance```的距离，如果新计算的距离小于当前距离，则更新距离。\n5. 重复步骤3和4，直到所有顶点都被访问过。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\nint main() {\n\tint M, N;\n\tcin >> N >> M;\n\tvector<int>distance(N, INT_MAX);//存放start到i点的最短路径长度\n\tvector<bool> visited(N, false);//记录当前顶点是否已被访问过\n\tvector<vector<int>> graph(N, vector<int>(N, 0));\n\t//有向图的邻接矩阵（二维数组）\n\tint p, q, length;\n\tfor(int i = 0;i < M;i++){\n\t\tcin >> p >> q >> length;\n\t\tgraph[p-1][q-1] = length;\n\t\t//均采用 0-based索引\n\t}\n\tint start, end;\n\tcin >> start >> end;\n\tvisited[start - 1] = true;\n\tdistance[start - 1] = 0;\n\tfor (int i = 0;i < N;i++) {\n\t\tif (graph[start - 1][i] != 0) {\n\t\t\tdistance[i] = graph[start - 1][i];\n\t\t\t//用start的邻接矩阵对distance数组进行初始化\n\t\t}\n\t}\n    for(int j=0;j <N;j++){\n\t\tint small = INT_MAX;\n\t\tint tag = -1;//标记最小顶点的索引\n\t\tfor (int i = 1;i <= N;i++) {\n\t\t\tif (distance[i - 1] < small && !visited[i - 1]) {\n\t\t\t\tsmall = distance[i - 1];\n\t\t\t\ttag = i;\n\t\t\t}\n\t\t}\n\t\tif (tag == -1) {\n\t\t\tbreak;\n\t\t\t//若没有找到最小索引\n\t\t\t//邻接矩阵已经全部遍历完成\n\t\t\t//退出循环\n\t\t}\n\t\tvisited[tag - 1] = true;//标记已访问\n\t\tfor (int i = 1;i <= N;i++) {\n\t\t\tif (graph[tag - 1][i - 1]!=0 && \n\t\t\tdistance[tag - 1] + graph[tag - 1][i - 1] < distance[i - 1]) {\n\t\t\tdistance[i - 1] = distance[tag - 1] + graph[tag - 1][i - 1];\n\t\t\t//如果当前路径为最短路径则进行更新\n\t\t\t}\n\t\t}\n\t}\n\t\tif (distance[end - 1] != INT_MAX) {\n\t\t\tcout << distance[end-1] << endl;\n\t\t}\n\t\t//若distance==INT_MAX，则没有通路\n\t\telse cout << \"STOP\" << endl;\n     return 0;\n}\n```\n## E题：最小生成树\n{%fold into @ E题：最小生成树 %}\n### 题目描述\n最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。\n可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。\n而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。\n在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。\n### 输入\n输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。\n以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。\n输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。\n### 输出\n只有一个整数，即最小生成树的总代价。请注意行尾输出换行。\n### 样例输入\n```\n4\n0 2 4 0\n2 0 3 5\n4 3 0 1\n0 5 1 0\n```\n### 样例输出\n```\n6\n```\n{%endfold%}\n\n### 提示\n在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。\n\n### 问题分析\n完成本题首先要掌握要掌握两种计算最小生成树的方法：普利姆（Prim）算法、克鲁斯卡尔（Kruskal）算法。（当然本题只要求使用普利姆算法）\n+ 普利姆算法（+点）\n1. 选择任意一个顶点作为起始点，将其加入最小生成树中\n2. 从未选择的顶点中选择与现有生成树连线权重最小的顶点，将其加入到现有生成树中\n3. 重复上述步骤，直到最小生成树包含了图中的所有顶点。\n\n+ 克鲁斯卡尔算法（+边）\n 1. 从不属于最小生成树的边中找到权值最小的边，判断最小边及其连接的两个顶点加入到最小生成树是否会形成环路。\n 2. 若不形成环路，则将此最小边及其连接的顶点并入最小生成树。\n 3. 若形成环路，则永远不再看此边，然后从剩下的且不属于最小生成树的边中，寻找权值最小的边。\n 4. 重复上述步骤，直至所有顶点均连接在一起，并没有形成环路时，最小生成树就找到了。\n \n根据题意这里使用普利姆算法进行编程求解，用```key```记录当前生成树与各个顶点的最小值，```visited```记录当前顶点是否被访问，外循环```n```次，每次将一个顶点加入最小生成树中。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\n#include <climits>//用于INT_MAX的数组初始化\nusing namespace std;\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<vector<int>> matrix(n, vector<int>(n));\n\tfor (int i = 0;i < n;i++) {\n\t\tfor (int j = 0;j < n;j++) {\n\t\t\tcin >> matrix[i][j];//读入邻接矩阵\n\t\t}\n\t}\n\tvector <int> key(n,INT_MAX);\n\t//记录当前生成树与各顶点的最小值并不断更新\n\tvector <bool> visited(n, false);\n\t//记录当前顶点是否已经被访问过\n\tkey[0] = 0;\n\tint total = 0;//记录最小生成树的总权值\n\tfor (int i = 0;i < n;i++) {\n\t\tint u = -1;\n\t\tfor (int j = 0;j < n;j++) {\n\t\t\tif (!visited[j] && (u == -1 || key[j] < key[u])) {\n\t\t\t\tu = j;//找到当前与生成树的最小权值点顶点\n\t\t\t}\n\t\t}\n\t\tvisited[u] = true;\n\t\ttotal += key[u];\n\t\tfor (int v = 0;v < n;v++) {\n\t\t\tif (!visited[v] && matrix[u][v]!=0 && matrix[u][v] < key[v]) {\n\t\t\t\tkey[v] = matrix[u][v];\n\t\t\t\t//对key生成树到顶点的最小值进行更新\n\t\t\t}\n\t\t}\n\n\t}\n\tcout << total << endl;\n\treturn 0;\n}\n```\n### 注释\n```<climits>```头文件，定义了与整数类型的大小和范围相关的宏常量，常用```INT_MAX```和```INT_MIN```对数组变量进行初始化。\n\n封面来源: [Shortest Path Algorithms Explained (Dijkstra's & Bellman-Ford)](https://www.youtube.com/watch?v=j0OUwduDOS0)\n","slug":"Data structure/CUMT-Datastructure-Practice-3","published":1,"updated":"2025-08-27T03:32:38.441Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcn000n40w3gcf86mg2","content":"<h2 id=\"问题-A-二叉链表存储的二叉树\">问题 A: 二叉链表存储的二叉树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-f55dd9e6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-f55dd9e6\">\n        <div class=\"fold-arrow\">▶</div> 问题 A: 二叉链表存储的二叉树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-f55dd9e6\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构.在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p><h3 id=\"输入\">输入</h3><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p><h3 id=\"输出\">输出</h3><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">ABC  DE <span class=\"hljs-selector-tag\">G</span>  F <br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span> <span class=\"hljs-selector-tag\">B</span> C D E <span class=\"hljs-selector-tag\">G</span> F <br>C <span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-selector-tag\">G</span> D F <span class=\"hljs-selector-tag\">A</span> <br>C <span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-selector-tag\">G</span> D F <span class=\"hljs-selector-tag\">A</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"提示\">提示</h3>\n<p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>本题依照题目使用二叉树链式存储结构进行二叉树的建立和遍历。</p>\n<ol>\n<li>设计二叉树的<code>struct</code>的节点结构，包含数据元素和左子叶节点和右子叶节点（使用构造函数给结点赋初值和初始化节点指针）。</li>\n<li>用递归的思想实现二叉树的构建，若索引值<code>index</code>非空，则构建节点，再依次递归构建左子树，递归构建右子树。</li>\n<li>递归遍历注意访问和递归的调用顺序即可。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>遍历方式</th>\n<th>访问顺序</th>\n<th>递归调用顺序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先序遍历</td>\n<td>根 → 左 → 右</td>\n<td>访问 → 左递归 → 右递归</td>\n</tr>\n<tr>\n<td>中序遍历</td>\n<td>左 → 根 → 右</td>\n<td>左递归 → 访问 → 右递归</td>\n</tr>\n<tr>\n<td>后序遍历</td>\n<td>左 → 右 → 根</td>\n<td>左递归 → 右递归 → 访问</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BinaryTreeNode</span> {<br>\t<span class=\"hljs-type\">char</span> data;<br>\tBinaryTreeNode* left;<br>\tBinaryTreeNode* right;<br>\t<span class=\"hljs-built_in\">BinaryTreeNode</span>(<span class=\"hljs-type\">char</span> x):<span class=\"hljs-built_in\">data</span>(x),<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>){}<br>};<br><span class=\"hljs-comment\">//若不构造函数则创建节点时需要:</span><br><span class=\"hljs-comment\">//BinaryTreeNode* node = new BinaryTreeNode{'A', nullptr, nullptr};</span><br><span class=\"hljs-function\">BinaryTreeNode* <span class=\"hljs-title\">buildtree</span><span class=\"hljs-params\">(string str, <span class=\"hljs-type\">int</span>&amp; index)</span> </span>{<br>\t<span class=\"hljs-keyword\">if</span> (index &gt;= str.<span class=\"hljs-built_in\">size</span>() || str[index] == <span class=\"hljs-string\">' '</span>) {<br>\t<span class=\"hljs-comment\">//若索引值超出范围或者为空</span><br>\t\tindex++;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>\t}<br>\tBinaryTreeNode* node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BinaryTreeNode</span>(str[index++]);<br>\t<span class=\"hljs-comment\">//创建新节点，递归构建左右子树</span><br>\tnode-&gt;left = <span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\tnode-&gt;right = <span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\t<span class=\"hljs-keyword\">return</span> node;<br>};<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(BinaryTreeNode* root)</span> </span>{<span class=\"hljs-comment\">//前序遍历</span><br>\t<span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t}<br>\tcout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t<span class=\"hljs-built_in\">preOrder</span>(root-&gt;left);<br>\t<span class=\"hljs-built_in\">preOrder</span>(root-&gt;right);<br>};<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">inOrder</span><span class=\"hljs-params\">(BinaryTreeNode* root)</span> </span>{<span class=\"hljs-comment\">//中序遍历</span><br>\t<span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t}<br>\t<span class=\"hljs-built_in\">inOrder</span>(root-&gt;left);<br>\tcout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">\" \"</span>;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root-&gt;right);<br>};<br><span class=\"hljs-comment\">//void postOrder(BinaryTreeNode* root) {后序遍历</span><br><span class=\"hljs-comment\">//\tif (root == nullptr) {</span><br><span class=\"hljs-comment\">//\t\treturn;</span><br><span class=\"hljs-comment\">//\t}</span><br><span class=\"hljs-comment\">//\tpostOrder(root-&gt;left);</span><br><span class=\"hljs-comment\">//\tpostOrder(root-&gt;right);</span><br><span class=\"hljs-comment\">//\tcout &lt;&lt; root-&gt;data &lt;&lt; \" \";</span><br><span class=\"hljs-comment\">//};</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tstring str;<br>\t<span class=\"hljs-built_in\">getline</span>(cin,str);<br>\t<span class=\"hljs-comment\">//注意用getline需要读取空格</span><br>\t<span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>\tBinaryTreeNode* root=<span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\t<span class=\"hljs-built_in\">preOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">//postOrder(root);</span><br>\t<span class=\"hljs-comment\">//cout &lt;&lt; endl;</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"B题：哈夫曼树\">B题：哈夫曼树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-f47957e7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-f47957e7\">\n        <div class=\"fold-arrow\">▶</div> B题：哈夫曼树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-f47957e7\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。</p><h3 id=\"输入\">输入</h3><p>输入有多组数据。<br>每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</p><h3 id=\"输出\">输出</h3><p>输出权值。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">8</span> <br><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">30</span> <br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">10<br>62<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<ol>\n<li>将所有权值作为单独的树（每个树只有一个节点）</li>\n<li>每次选择权值最小的两棵树合并，形成新的子树，新树的权值为两子树权值之和</li>\n<li>将新树根节点作为新的子树，重复上述过程，直到只剩下一棵树</li>\n<li>计算合并过程中所有中间结果的累加和</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">huffman</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> </span>{<br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; minqueue;<br>\t<span class=\"hljs-comment\">//创建最小优先队列</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tminqueue.<span class=\"hljs-built_in\">push</span>(a);<br>\t}   <span class=\"hljs-comment\">// 读取n个权值并存入最小堆</span><br>\t<span class=\"hljs-type\">int</span> total = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//带权路径长度</span><br>\t<span class=\"hljs-comment\">// 隐式构建哈夫曼树</span><br>\t<span class=\"hljs-keyword\">while</span> (!minqueue.<span class=\"hljs-built_in\">empty</span>()) {<br>\t\t<span class=\"hljs-type\">int</span> parent = minqueue.<span class=\"hljs-built_in\">top</span>();<br>\t\tminqueue.<span class=\"hljs-built_in\">pop</span>();<br>\t\t<span class=\"hljs-comment\">//取出当前最小值</span><br>\t\t<span class=\"hljs-keyword\">if</span> (minqueue.<span class=\"hljs-built_in\">empty</span>()) {<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//当队列中只有一个元素时退出循环</span><br>\t\t}<br>\t\tparent += minqueue.<span class=\"hljs-built_in\">top</span>();<br>\t\tminqueue.<span class=\"hljs-built_in\">pop</span>();<br>\t\t<span class=\"hljs-comment\">//取出次小值</span><br>\t\ttotal +=  parent;<br>\t\tminqueue.<span class=\"hljs-built_in\">push</span>(parent);<br>\t}<br>\tcout &lt;&lt; total &lt;&lt; endl;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; n) {<br>\t\t<span class=\"hljs-built_in\">huffman</span>(n);<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><strong>优先队列：</strong> 这是一种特殊的队列，每次<code>push</code>进去一个数，它就会自动按照大小排好队，<code>top</code>就能得到队首元素（最大值），<code>pop</code>就会弹出队首元素（队列中最大值）。定义方法如下：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">priority_queue&lt;<span class=\"hljs-type\">int</span>&gt; pq;<span class=\"hljs-comment\">//int型优先队列</span><br></code></pre></td></tr></tbody></table></figure>\n<p>若我们不满足其降序排列我们还可以将其调整为升序排列：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">priority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; pq;<span class=\"hljs-comment\">//int型逆序优先队列</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"C题：树的遍历\">C题：树的遍历</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a926a9e9\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a926a9e9\">\n        <div class=\"fold-arrow\">▶</div> C题：树的遍历\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a926a9e9\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>  假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。<br>  现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。</p><h3 id=\"输入\">输入</h3><p>每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数N（≤30），即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。</p><h3 id=\"输出\">输出</h3><p>对于每个测试用例，如果树是唯一的，则首先是行中的Yes，否则是No。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">7</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Yes</span><br><span class=\"hljs-attribute\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>  已知前序、中序二叉树唯一确定，已知中序、后序二叉树唯一确定，而一直前序和后序二叉树无法唯一确定。<br>\n  前序序列的第一个节点必于后续序列最后一个节点相同，为根节点；前序序列的第二个节点为左子树的根节点（如果有左子树的话），在后续序列中寻找该节点，则划分了左右子树，其左边的所有节点属于左子树，右边的节点（直到根节点之前）属于右子树。<br>\n  因而我们可以使用前序和后序序列递归地分割左右子树，并直接生成中序序列。<br>\n而如果前序的第二个节点在后序中位于根节点前的位置，说明该节点可以是左子树或右子树的根，此时树不唯一，可以任意选择左右子树。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; in, pre, post;<br><span class=\"hljs-comment\">//定义全局变量，分别为前序、中序、后序序列</span><br><span class=\"hljs-type\">bool</span> unique = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记二叉树是否唯一</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">build</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> preL, <span class=\"hljs-type\">int</span> preR, <span class=\"hljs-type\">int</span> postL, <span class=\"hljs-type\">int</span> postR)</span> </span>{<br><span class=\"hljs-comment\">//分别标记了前序和后序序列的左右边界</span><br>    <span class=\"hljs-keyword\">if</span> (preL == preR) {<br>        in.<span class=\"hljs-built_in\">push_back</span>(pre[preL]);<br>        <span class=\"hljs-keyword\">return</span>;<br>    }<br>    <span class=\"hljs-keyword\">if</span> (pre[preL] == post[postR]) {<br>        <span class=\"hljs-type\">int</span> i = preL + <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (i &lt;= preR &amp;&amp; pre[i] != post[postR - <span class=\"hljs-number\">1</span>]) i++;<br>        <span class=\"hljs-comment\">//在后序序列中寻找左子树的根节点</span><br>        <span class=\"hljs-keyword\">if</span> (i - preL &gt; <span class=\"hljs-number\">1</span>)<br>            <span class=\"hljs-built_in\">build</span>(preL + <span class=\"hljs-number\">1</span>, i - <span class=\"hljs-number\">1</span>, postL, postL + (i - preL - <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">else</span><br>            unique = <span class=\"hljs-literal\">false</span>;<br>        in.<span class=\"hljs-built_in\">push_back</span>(post[postR]);<br>        <span class=\"hljs-built_in\">build</span>(i, preR, postL + (i - preL - <span class=\"hljs-number\">1</span>), postR - <span class=\"hljs-number\">1</span>);<br>    }<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    pre.<span class=\"hljs-built_in\">resize</span>(n);<br>    post.<span class=\"hljs-built_in\">resize</span>(n);<br>    <span class=\"hljs-comment\">//为全局变量重新分配空间</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span>&amp; val : pre) cin &gt;&gt; val;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span>&amp; val : post) cin &gt;&gt; val;<br>    <span class=\"hljs-comment\">//读入数据（注意是&amp;索引值）</span><br>    <span class=\"hljs-built_in\">build</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>);<br>    cout &lt;&lt; (unique ? <span class=\"hljs-string\">\"Yes\"</span> : <span class=\"hljs-string\">\"No\"</span>) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">if</span> (!in.<span class=\"hljs-built_in\">empty</span>()) {<br>        cout &lt;&lt; in[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; in.<span class=\"hljs-built_in\">size</span>(); ++i)<br>            cout &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt; in[i];<br>    }<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"D题：最短路径\">D题：最短路径</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-aa984d44\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-aa984d44\">\n        <div class=\"fold-arrow\">▶</div> D题：最短路径\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-aa984d44\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>一个迷宫地图中，多个房间由单向通道相连，房间号从1到N依次编号。你能编程求解任意房间间的最短路径长度吗？</p><h3 id=\"输入\">输入</h3><p>第一行是迷宫中的房间数N和单项通道数M（0&lt;N,M&lt;100），接下来M行，每行三个数x,y,z，表示一个通道是从x到y,且通道长度是z(z&lt;1000）。<br>最后一行是start和end，分别是起点房间号和终点房间号。</p><h3 id=\"输出\">输出</h3><p>输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出STOP。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">7 </span><span class=\"hljs-number\">9</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">3 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">6</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">7</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">12<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>最短路径路径问题，我们这里采用<strong>Dijkstra算法</strong>进行求解。</p>\n<ol>\n<li>构造邻接矩阵<code>graph</code>存储带权有向图。</li>\n<li>将起始顶点的距离设为0，其他所有顶点的距离<code>distance</code>设为无穷大（即从<code>start</code>到<code>i</code>的最短路径长度）。</li>\n<li>将起始顶点加入已访问集合<code>visited</code>。</li>\n<li>遍历未访问顶点，找出距离起始点最短的顶点，将其加入已访问集合。</li>\n<li>更新<code>distance</code>的距离，如果新计算的距离小于当前距离，则更新距离。</li>\n<li>重复步骤3和4，直到所有顶点都被访问过。</li>\n</ol>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> M, N;<br>\tcin &gt;&gt; N &gt;&gt; M;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;<span class=\"hljs-built_in\">distance</span>(N, INT_MAX);<span class=\"hljs-comment\">//存放start到i点的最短路径长度</span><br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(N, <span class=\"hljs-literal\">false</span>)</span></span>;<span class=\"hljs-comment\">//记录当前顶点是否已被访问过</span><br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">graph</span>(N, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(N, <span class=\"hljs-number\">0</span>));<br>\t<span class=\"hljs-comment\">//有向图的邻接矩阵（二维数组）</span><br>\t<span class=\"hljs-type\">int</span> p, q, length;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; M;i++){<br>\t\tcin &gt;&gt; p &gt;&gt; q &gt;&gt; length;<br>\t\tgraph[p<span class=\"hljs-number\">-1</span>][q<span class=\"hljs-number\">-1</span>] = length;<br>\t\t<span class=\"hljs-comment\">//均采用 0-based索引</span><br>\t}<br>\t<span class=\"hljs-type\">int</span> start, end;<br>\tcin &gt;&gt; start &gt;&gt; end;<br>\tvisited[start - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;<br>\tdistance[start - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) {<br>\t\t<span class=\"hljs-keyword\">if</span> (graph[start - <span class=\"hljs-number\">1</span>][i] != <span class=\"hljs-number\">0</span>) {<br>\t\t\tdistance[i] = graph[start - <span class=\"hljs-number\">1</span>][i];<br>\t\t\t<span class=\"hljs-comment\">//用start的邻接矩阵对distance数组进行初始化</span><br>\t\t}<br>\t}<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j &lt;N;j++){<br>\t\t<span class=\"hljs-type\">int</span> small = INT_MAX;<br>\t\t<span class=\"hljs-type\">int</span> tag = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//标记最小顶点的索引</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= N;i++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (distance[i - <span class=\"hljs-number\">1</span>] &lt; small &amp;&amp; !visited[i - <span class=\"hljs-number\">1</span>]) {<br>\t\t\t\tsmall = distance[i - <span class=\"hljs-number\">1</span>];<br>\t\t\t\ttag = i;<br>\t\t\t}<br>\t\t}<br>\t\t<span class=\"hljs-keyword\">if</span> (tag == <span class=\"hljs-number\">-1</span>) {<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-comment\">//若没有找到最小索引</span><br>\t\t\t<span class=\"hljs-comment\">//邻接矩阵已经全部遍历完成</span><br>\t\t\t<span class=\"hljs-comment\">//退出循环</span><br>\t\t}<br>\t\tvisited[tag - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记已访问</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= N;i++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>]!=<span class=\"hljs-number\">0</span> &amp;&amp; <br>\t\t\tdistance[tag - <span class=\"hljs-number\">1</span>] + graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>] &lt; distance[i - <span class=\"hljs-number\">1</span>]) {<br>\t\t\tdistance[i - <span class=\"hljs-number\">1</span>] = distance[tag - <span class=\"hljs-number\">1</span>] + graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>];<br>\t\t\t<span class=\"hljs-comment\">//如果当前路径为最短路径则进行更新</span><br>\t\t\t}<br>\t\t}<br>\t}<br>\t\t<span class=\"hljs-keyword\">if</span> (distance[end - <span class=\"hljs-number\">1</span>] != INT_MAX) {<br>\t\t\tcout &lt;&lt; distance[end<span class=\"hljs-number\">-1</span>] &lt;&lt; endl;<br>\t\t}<br>\t\t<span class=\"hljs-comment\">//若distance==INT_MAX，则没有通路</span><br>\t\t<span class=\"hljs-keyword\">else</span> cout &lt;&lt; <span class=\"hljs-string\">\"STOP\"</span> &lt;&lt; endl;<br>     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"E题：最小生成树\">E题：最小生成树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-3f175be7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-3f175be7\">\n        <div class=\"fold-arrow\">▶</div> E题：最小生成树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-3f175be7\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。<br>可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。<br>而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。<br>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。</p><h3 id=\"输入\">输入</h3><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。</p><h3 id=\"输出\">输出</h3><p>只有一个整数，即最小生成树的总代价。请注意行尾输出换行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">6<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"提示-v2\">提示</h3>\n<p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>\n<h3 id=\"问题分析-v5\">问题分析</h3>\n<p>完成本题首先要掌握要掌握两种计算最小生成树的方法：普利姆（Prim）算法、克鲁斯卡尔（Kruskal）算法。（当然本题只要求使用普利姆算法）</p>\n<ul>\n<li>普利姆算法（+点）</li>\n</ul>\n<ol>\n<li>选择任意一个顶点作为起始点，将其加入最小生成树中</li>\n<li>从未选择的顶点中选择与现有生成树连线权重最小的顶点，将其加入到现有生成树中</li>\n<li>重复上述步骤，直到最小生成树包含了图中的所有顶点。</li>\n</ol>\n<ul>\n<li>克鲁斯卡尔算法（+边）</li>\n</ul>\n<ol>\n<li>从不属于最小生成树的边中找到权值最小的边，判断最小边及其连接的两个顶点加入到最小生成树是否会形成环路。</li>\n<li>若不形成环路，则将此最小边及其连接的顶点并入最小生成树。</li>\n<li>若形成环路，则永远不再看此边，然后从剩下的且不属于最小生成树的边中，寻找权值最小的边。</li>\n<li>重复上述步骤，直至所有顶点均连接在一起，并没有形成环路时，最小生成树就找到了。</li>\n</ol>\n<p>根据题意这里使用普利姆算法进行编程求解，用<code>key</code>记录当前生成树与各个顶点的最小值，<code>visited</code>记录当前顶点是否被访问，外循环<code>n</code>次，每次将一个顶点加入最小生成树中。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span><span class=\"hljs-comment\">//用于INT_MAX的数组初始化</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">matrix</span>(n, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n));<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) {<br>\t\t\tcin &gt;&gt; matrix[i][j];<span class=\"hljs-comment\">//读入邻接矩阵</span><br>\t\t}<br>\t}<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">key</span>(n,INT_MAX);<br>\t<span class=\"hljs-comment\">//记录当前生成树与各顶点的最小值并不断更新</span><br>\tvector &lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-built_in\">visited</span>(n, <span class=\"hljs-literal\">false</span>);<br>\t<span class=\"hljs-comment\">//记录当前顶点是否已经被访问过</span><br>\tkey[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> total = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//记录最小生成树的总权值</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">-1</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[j] &amp;&amp; (u == <span class=\"hljs-number\">-1</span> || key[j] &lt; key[u])) {<br>\t\t\t\tu = j;<span class=\"hljs-comment\">//找到当前与生成树的最小权值点顶点</span><br>\t\t\t}<br>\t\t}<br>\t\tvisited[u] = <span class=\"hljs-literal\">true</span>;<br>\t\ttotal += key[u];<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>;v &lt; n;v++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[v] &amp;&amp; matrix[u][v]!=<span class=\"hljs-number\">0</span> &amp;&amp; matrix[u][v] &lt; key[v]) {<br>\t\t\t\tkey[v] = matrix[u][v];<br>\t\t\t\t<span class=\"hljs-comment\">//对key生成树到顶点的最小值进行更新</span><br>\t\t\t}<br>\t\t}<br><br>\t}<br>\tcout &lt;&lt; total &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释-v2\">注释</h3>\n<p><code>&lt;climits&gt;</code>头文件，定义了与整数类型的大小和范围相关的宏常量，常用<code>INT_MAX</code>和<code>INT_MIN</code>对数组变量进行初始化。</p>\n<p>封面来源: <a href=\"https://www.youtube.com/watch?v=j0OUwduDOS0\">Shortest Path Algorithms Explained (Dijkstra’s &amp; Bellman-Ford)</a></p>\n","excerpt":"","more":"<h2 id=\"问题-A-二叉链表存储的二叉树\">问题 A: 二叉链表存储的二叉树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-f55dd9e6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-f55dd9e6\">\n        <div class=\"fold-arrow\">▶</div> 问题 A: 二叉链表存储的二叉树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-f55dd9e6\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构.在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。</p><h3 id=\"输入\">输入</h3><p>输入只有一行，包含一个字符串S，用来建立二叉树。保证S为合法的二叉树先序遍历字符串，节点内容只有大写字母，且S的长度不超过100。</p><h3 id=\"输出\">输出</h3><p>共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">ABC  DE <span class=\"hljs-selector-tag\">G</span>  F <br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">A</span> <span class=\"hljs-selector-tag\">B</span> C D E <span class=\"hljs-selector-tag\">G</span> F <br>C <span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-selector-tag\">G</span> D F <span class=\"hljs-selector-tag\">A</span> <br>C <span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-selector-tag\">G</span> D F <span class=\"hljs-selector-tag\">A</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"提示\">提示</h3>\n<p>遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。</p>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>本题依照题目使用二叉树链式存储结构进行二叉树的建立和遍历。</p>\n<ol>\n<li>设计二叉树的<code>struct</code>的节点结构，包含数据元素和左子叶节点和右子叶节点（使用构造函数给结点赋初值和初始化节点指针）。</li>\n<li>用递归的思想实现二叉树的构建，若索引值<code>index</code>非空，则构建节点，再依次递归构建左子树，递归构建右子树。</li>\n<li>递归遍历注意访问和递归的调用顺序即可。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>遍历方式</th>\n<th>访问顺序</th>\n<th>递归调用顺序</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>先序遍历</td>\n<td>根 → 左 → 右</td>\n<td>访问 → 左递归 → 右递归</td>\n</tr>\n<tr>\n<td>中序遍历</td>\n<td>左 → 根 → 右</td>\n<td>左递归 → 访问 → 右递归</td>\n</tr>\n<tr>\n<td>后序遍历</td>\n<td>左 → 右 → 根</td>\n<td>左递归 → 右递归 → 访问</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">BinaryTreeNode</span> &#123;<br>\t<span class=\"hljs-type\">char</span> data;<br>\tBinaryTreeNode* left;<br>\tBinaryTreeNode* right;<br>\t<span class=\"hljs-built_in\">BinaryTreeNode</span>(<span class=\"hljs-type\">char</span> x):<span class=\"hljs-built_in\">data</span>(x),<span class=\"hljs-built_in\">left</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">right</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>&#125;;<br><span class=\"hljs-comment\">//若不构造函数则创建节点时需要:</span><br><span class=\"hljs-comment\">//BinaryTreeNode* node = new BinaryTreeNode&#123;&#x27;A&#x27;, nullptr, nullptr&#125;;</span><br><span class=\"hljs-function\">BinaryTreeNode* <span class=\"hljs-title\">buildtree</span><span class=\"hljs-params\">(string str, <span class=\"hljs-type\">int</span>&amp; index)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">if</span> (index &gt;= str.<span class=\"hljs-built_in\">size</span>() || str[index] == <span class=\"hljs-string\">&#x27; &#x27;</span>) &#123;<br>\t<span class=\"hljs-comment\">//若索引值超出范围或者为空</span><br>\t\tindex++;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>\t&#125;<br>\tBinaryTreeNode* node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">BinaryTreeNode</span>(str[index++]);<br>\t<span class=\"hljs-comment\">//创建新节点，递归构建左右子树</span><br>\tnode-&gt;left = <span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\tnode-&gt;right = <span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\t<span class=\"hljs-keyword\">return</span> node;<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">preOrder</span><span class=\"hljs-params\">(BinaryTreeNode* root)</span> </span>&#123;<span class=\"hljs-comment\">//前序遍历</span><br>\t<span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\tcout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t<span class=\"hljs-built_in\">preOrder</span>(root-&gt;left);<br>\t<span class=\"hljs-built_in\">preOrder</span>(root-&gt;right);<br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">inOrder</span><span class=\"hljs-params\">(BinaryTreeNode* root)</span> </span>&#123;<span class=\"hljs-comment\">//中序遍历</span><br>\t<span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root-&gt;left);<br>\tcout &lt;&lt; root-&gt;data &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root-&gt;right);<br>&#125;;<br><span class=\"hljs-comment\">//void postOrder(BinaryTreeNode* root) &#123;后序遍历</span><br><span class=\"hljs-comment\">//\tif (root == nullptr) &#123;</span><br><span class=\"hljs-comment\">//\t\treturn;</span><br><span class=\"hljs-comment\">//\t&#125;</span><br><span class=\"hljs-comment\">//\tpostOrder(root-&gt;left);</span><br><span class=\"hljs-comment\">//\tpostOrder(root-&gt;right);</span><br><span class=\"hljs-comment\">//\tcout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class=\"hljs-comment\">//&#125;;</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tstring str;<br>\t<span class=\"hljs-built_in\">getline</span>(cin,str);<br>\t<span class=\"hljs-comment\">//注意用getline需要读取空格</span><br>\t<span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>\tBinaryTreeNode* root=<span class=\"hljs-built_in\">buildtree</span>(str, index);<br>\t<span class=\"hljs-built_in\">preOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-built_in\">inOrder</span>(root);<br>\tcout &lt;&lt; endl;<br>\t<span class=\"hljs-comment\">//postOrder(root);</span><br>\t<span class=\"hljs-comment\">//cout &lt;&lt; endl;</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"B题：哈夫曼树\">B题：哈夫曼树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-f47957e7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-f47957e7\">\n        <div class=\"fold-arrow\">▶</div> B题：哈夫曼树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-f47957e7\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有叶子结点的路径长度与权值的乘积之和。</p><h3 id=\"输入\">输入</h3><p>输入有多组数据。<br>每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。</p><h3 id=\"输出\">输出</h3><p>输出权值。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">8</span> <br><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">30</span> <br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">10<br>62<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<ol>\n<li>将所有权值作为单独的树（每个树只有一个节点）</li>\n<li>每次选择权值最小的两棵树合并，形成新的子树，新树的权值为两子树权值之和</li>\n<li>将新树根节点作为新的子树，重复上述过程，直到只剩下一棵树</li>\n<li>计算合并过程中所有中间结果的累加和</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">huffman</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; minqueue;<br>\t<span class=\"hljs-comment\">//创建最小优先队列</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tminqueue.<span class=\"hljs-built_in\">push</span>(a);<br>\t&#125;   <span class=\"hljs-comment\">// 读取n个权值并存入最小堆</span><br>\t<span class=\"hljs-type\">int</span> total = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//带权路径长度</span><br>\t<span class=\"hljs-comment\">// 隐式构建哈夫曼树</span><br>\t<span class=\"hljs-keyword\">while</span> (!minqueue.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t<span class=\"hljs-type\">int</span> parent = minqueue.<span class=\"hljs-built_in\">top</span>();<br>\t\tminqueue.<span class=\"hljs-built_in\">pop</span>();<br>\t\t<span class=\"hljs-comment\">//取出当前最小值</span><br>\t\t<span class=\"hljs-keyword\">if</span> (minqueue.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<span class=\"hljs-comment\">//当队列中只有一个元素时退出循环</span><br>\t\t&#125;<br>\t\tparent += minqueue.<span class=\"hljs-built_in\">top</span>();<br>\t\tminqueue.<span class=\"hljs-built_in\">pop</span>();<br>\t\t<span class=\"hljs-comment\">//取出次小值</span><br>\t\ttotal +=  parent;<br>\t\tminqueue.<span class=\"hljs-built_in\">push</span>(parent);<br>\t&#125;<br>\tcout &lt;&lt; total &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\t<span class=\"hljs-keyword\">while</span> (cin &gt;&gt; n) &#123;<br>\t\t<span class=\"hljs-built_in\">huffman</span>(n);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><strong>优先队列：</strong> 这是一种特殊的队列，每次<code>push</code>进去一个数，它就会自动按照大小排好队，<code>top</code>就能得到队首元素（最大值），<code>pop</code>就会弹出队首元素（队列中最大值）。定义方法如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">priority_queue&lt;<span class=\"hljs-type\">int</span>&gt; pq;<span class=\"hljs-comment\">//int型优先队列</span><br></code></pre></td></tr></table></figure>\n<p>若我们不满足其降序排列我们还可以将其调整为升序排列：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">priority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; pq;<span class=\"hljs-comment\">//int型逆序优先队列</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"C题：树的遍历\">C题：树的遍历</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a926a9e9\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a926a9e9\">\n        <div class=\"fold-arrow\">▶</div> C题：树的遍历\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a926a9e9\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>  假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。<br>  现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。</p><h3 id=\"输入\">输入</h3><p>每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数N（≤30），即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。</p><h3 id=\"输出\">输出</h3><p>对于每个测试用例，如果树是唯一的，则首先是行中的Yes，否则是No。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">7</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">Yes</span><br><span class=\"hljs-attribute\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>  已知前序、中序二叉树唯一确定，已知中序、后序二叉树唯一确定，而一直前序和后序二叉树无法唯一确定。<br>\n  前序序列的第一个节点必于后续序列最后一个节点相同，为根节点；前序序列的第二个节点为左子树的根节点（如果有左子树的话），在后续序列中寻找该节点，则划分了左右子树，其左边的所有节点属于左子树，右边的节点（直到根节点之前）属于右子树。<br>\n  因而我们可以使用前序和后序序列递归地分割左右子树，并直接生成中序序列。<br>\n而如果前序的第二个节点在后序中位于根节点前的位置，说明该节点可以是左子树或右子树的根，此时树不唯一，可以任意选择左右子树。</p>\n<h3 id=\"完整代码-v2\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; in, pre, post;<br><span class=\"hljs-comment\">//定义全局变量，分别为前序、中序、后序序列</span><br><span class=\"hljs-type\">bool</span> unique = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记二叉树是否唯一</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">build</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> preL, <span class=\"hljs-type\">int</span> preR, <span class=\"hljs-type\">int</span> postL, <span class=\"hljs-type\">int</span> postR)</span> </span>&#123;<br><span class=\"hljs-comment\">//分别标记了前序和后序序列的左右边界</span><br>    <span class=\"hljs-keyword\">if</span> (preL == preR) &#123;<br>        in.<span class=\"hljs-built_in\">push_back</span>(pre[preL]);<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (pre[preL] == post[postR]) &#123;<br>        <span class=\"hljs-type\">int</span> i = preL + <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">while</span> (i &lt;= preR &amp;&amp; pre[i] != post[postR - <span class=\"hljs-number\">1</span>]) i++;<br>        <span class=\"hljs-comment\">//在后序序列中寻找左子树的根节点</span><br>        <span class=\"hljs-keyword\">if</span> (i - preL &gt; <span class=\"hljs-number\">1</span>)<br>            <span class=\"hljs-built_in\">build</span>(preL + <span class=\"hljs-number\">1</span>, i - <span class=\"hljs-number\">1</span>, postL, postL + (i - preL - <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">else</span><br>            unique = <span class=\"hljs-literal\">false</span>;<br>        in.<span class=\"hljs-built_in\">push_back</span>(post[postR]);<br>        <span class=\"hljs-built_in\">build</span>(i, preR, postL + (i - preL - <span class=\"hljs-number\">1</span>), postR - <span class=\"hljs-number\">1</span>);<br>    &#125;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n;<br>    cin &gt;&gt; n;<br>    pre.<span class=\"hljs-built_in\">resize</span>(n);<br>    post.<span class=\"hljs-built_in\">resize</span>(n);<br>    <span class=\"hljs-comment\">//为全局变量重新分配空间</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span>&amp; val : pre) cin &gt;&gt; val;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span>&amp; val : post) cin &gt;&gt; val;<br>    <span class=\"hljs-comment\">//读入数据（注意是&amp;索引值）</span><br>    <span class=\"hljs-built_in\">build</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>);<br>    cout &lt;&lt; (unique ? <span class=\"hljs-string\">&quot;Yes&quot;</span> : <span class=\"hljs-string\">&quot;No&quot;</span>) &lt;&lt; endl;<br>    <span class=\"hljs-keyword\">if</span> (!in.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>        cout &lt;&lt; in[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; in.<span class=\"hljs-built_in\">size</span>(); ++i)<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; in[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"D题：最短路径\">D题：最短路径</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-aa984d44\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-aa984d44\">\n        <div class=\"fold-arrow\">▶</div> D题：最短路径\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-aa984d44\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>一个迷宫地图中，多个房间由单向通道相连，房间号从1到N依次编号。你能编程求解任意房间间的最短路径长度吗？</p><h3 id=\"输入\">输入</h3><p>第一行是迷宫中的房间数N和单项通道数M（0&lt;N,M&lt;100），接下来M行，每行三个数x,y,z，表示一个通道是从x到y,且通道长度是z(z&lt;1000）。<br>最后一行是start和end，分别是起点房间号和终点房间号。</p><h3 id=\"输出\">输出</h3><p>输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出STOP。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">7 </span><span class=\"hljs-number\">9</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">3 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">6 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">6</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">4</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">5 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">7</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">12<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>最短路径路径问题，我们这里采用<strong>Dijkstra算法</strong>进行求解。</p>\n<ol>\n<li>构造邻接矩阵<code>graph</code>存储带权有向图。</li>\n<li>将起始顶点的距离设为0，其他所有顶点的距离<code>distance</code>设为无穷大（即从<code>start</code>到<code>i</code>的最短路径长度）。</li>\n<li>将起始顶点加入已访问集合<code>visited</code>。</li>\n<li>遍历未访问顶点，找出距离起始点最短的顶点，将其加入已访问集合。</li>\n<li>更新<code>distance</code>的距离，如果新计算的距离小于当前距离，则更新距离。</li>\n<li>重复步骤3和4，直到所有顶点都被访问过。</li>\n</ol>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> M, N;<br>\tcin &gt;&gt; N &gt;&gt; M;<br>\tvector&lt;<span class=\"hljs-type\">int</span>&gt;<span class=\"hljs-built_in\">distance</span>(N, INT_MAX);<span class=\"hljs-comment\">//存放start到i点的最短路径长度</span><br>\t<span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">visited</span><span class=\"hljs-params\">(N, <span class=\"hljs-literal\">false</span>)</span></span>;<span class=\"hljs-comment\">//记录当前顶点是否已被访问过</span><br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">graph</span>(N, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(N, <span class=\"hljs-number\">0</span>));<br>\t<span class=\"hljs-comment\">//有向图的邻接矩阵（二维数组）</span><br>\t<span class=\"hljs-type\">int</span> p, q, length;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; M;i++)&#123;<br>\t\tcin &gt;&gt; p &gt;&gt; q &gt;&gt; length;<br>\t\tgraph[p<span class=\"hljs-number\">-1</span>][q<span class=\"hljs-number\">-1</span>] = length;<br>\t\t<span class=\"hljs-comment\">//均采用 0-based索引</span><br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> start, end;<br>\tcin &gt;&gt; start &gt;&gt; end;<br>\tvisited[start - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;<br>\tdistance[start - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; N;i++) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (graph[start - <span class=\"hljs-number\">1</span>][i] != <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tdistance[i] = graph[start - <span class=\"hljs-number\">1</span>][i];<br>\t\t\t<span class=\"hljs-comment\">//用start的邻接矩阵对distance数组进行初始化</span><br>\t\t&#125;<br>\t&#125;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">0</span>;j &lt;N;j++)&#123;<br>\t\t<span class=\"hljs-type\">int</span> small = INT_MAX;<br>\t\t<span class=\"hljs-type\">int</span> tag = <span class=\"hljs-number\">-1</span>;<span class=\"hljs-comment\">//标记最小顶点的索引</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= N;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (distance[i - <span class=\"hljs-number\">1</span>] &lt; small &amp;&amp; !visited[i - <span class=\"hljs-number\">1</span>]) &#123;<br>\t\t\t\tsmall = distance[i - <span class=\"hljs-number\">1</span>];<br>\t\t\t\ttag = i;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (tag == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-comment\">//若没有找到最小索引</span><br>\t\t\t<span class=\"hljs-comment\">//邻接矩阵已经全部遍历完成</span><br>\t\t\t<span class=\"hljs-comment\">//退出循环</span><br>\t\t&#125;<br>\t\tvisited[tag - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;<span class=\"hljs-comment\">//标记已访问</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>;i &lt;= N;i++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>]!=<span class=\"hljs-number\">0</span> &amp;&amp; <br>\t\t\tdistance[tag - <span class=\"hljs-number\">1</span>] + graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>] &lt; distance[i - <span class=\"hljs-number\">1</span>]) &#123;<br>\t\t\tdistance[i - <span class=\"hljs-number\">1</span>] = distance[tag - <span class=\"hljs-number\">1</span>] + graph[tag - <span class=\"hljs-number\">1</span>][i - <span class=\"hljs-number\">1</span>];<br>\t\t\t<span class=\"hljs-comment\">//如果当前路径为最短路径则进行更新</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (distance[end - <span class=\"hljs-number\">1</span>] != INT_MAX) &#123;<br>\t\t\tcout &lt;&lt; distance[end<span class=\"hljs-number\">-1</span>] &lt;&lt; endl;<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">//若distance==INT_MAX，则没有通路</span><br>\t\t<span class=\"hljs-keyword\">else</span> cout &lt;&lt; <span class=\"hljs-string\">&quot;STOP&quot;</span> &lt;&lt; endl;<br>     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"E题：最小生成树\">E题：最小生成树</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-3f175be7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-3f175be7\">\n        <div class=\"fold-arrow\">▶</div> E题：最小生成树\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-3f175be7\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。<br>可以用连通网来表示n个城市以及n个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于n个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。<br>而在常用的最小生成树构造算法中，普里姆（Prim）算法是一种非常常用的算法。<br>在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。</p><h3 id=\"输入\">输入</h3><p>输入的第一行包含一个正整数n，表示图中共有n个顶点。其中n不超过50。<br>以后的n行中每行有n个用空格隔开的整数，对于第i行的第j个整数，如果不为0，则表示第i个顶点和第j个顶点有直接连接且代价为相应的值，0表示没有直接连接。当i和j相等的时候，保证对应的整数为0。<br>输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。</p><h3 id=\"输出\">输出</h3><p>只有一个整数，即最小生成树的总代价。请注意行尾输出换行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-symbol\">2 </span><span class=\"hljs-number\">0</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">0 </span><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">6<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"提示-v2\">提示</h3>\n<p>在本题中，需要掌握图的深度优先遍历的方法，并需要掌握无向图的连通性问题的本质。通过求出无向图的连通分量和对应的生成树，应该能够对图的连通性建立更加直观和清晰的概念。</p>\n<h3 id=\"问题分析-v5\">问题分析</h3>\n<p>完成本题首先要掌握要掌握两种计算最小生成树的方法：普利姆（Prim）算法、克鲁斯卡尔（Kruskal）算法。（当然本题只要求使用普利姆算法）</p>\n<ul>\n<li>普利姆算法（+点）</li>\n</ul>\n<ol>\n<li>选择任意一个顶点作为起始点，将其加入最小生成树中</li>\n<li>从未选择的顶点中选择与现有生成树连线权重最小的顶点，将其加入到现有生成树中</li>\n<li>重复上述步骤，直到最小生成树包含了图中的所有顶点。</li>\n</ol>\n<ul>\n<li>克鲁斯卡尔算法（+边）</li>\n</ul>\n<ol>\n<li>从不属于最小生成树的边中找到权值最小的边，判断最小边及其连接的两个顶点加入到最小生成树是否会形成环路。</li>\n<li>若不形成环路，则将此最小边及其连接的顶点并入最小生成树。</li>\n<li>若形成环路，则永远不再看此边，然后从剩下的且不属于最小生成树的边中，寻找权值最小的边。</li>\n<li>重复上述步骤，直至所有顶点均连接在一起，并没有形成环路时，最小生成树就找到了。</li>\n</ol>\n<p>根据题意这里使用普利姆算法进行编程求解，用<code>key</code>记录当前生成树与各个顶点的最小值，<code>visited</code>记录当前顶点是否被访问，外循环<code>n</code>次，每次将一个顶点加入最小生成树中。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;climits&gt;</span><span class=\"hljs-comment\">//用于INT_MAX的数组初始化</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">matrix</span>(n, <span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(n));<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) &#123;<br>\t\t\tcin &gt;&gt; matrix[i][j];<span class=\"hljs-comment\">//读入邻接矩阵</span><br>\t\t&#125;<br>\t&#125;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">key</span>(n,INT_MAX);<br>\t<span class=\"hljs-comment\">//记录当前生成树与各顶点的最小值并不断更新</span><br>\tvector &lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-built_in\">visited</span>(n, <span class=\"hljs-literal\">false</span>);<br>\t<span class=\"hljs-comment\">//记录当前顶点是否已经被访问过</span><br>\tkey[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">int</span> total = <span class=\"hljs-number\">0</span>;<span class=\"hljs-comment\">//记录最小生成树的总权值</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">-1</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>;j &lt; n;j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[j] &amp;&amp; (u == <span class=\"hljs-number\">-1</span> || key[j] &lt; key[u])) &#123;<br>\t\t\t\tu = j;<span class=\"hljs-comment\">//找到当前与生成树的最小权值点顶点</span><br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tvisited[u] = <span class=\"hljs-literal\">true</span>;<br>\t\ttotal += key[u];<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>;v &lt; n;v++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (!visited[v] &amp;&amp; matrix[u][v]!=<span class=\"hljs-number\">0</span> &amp;&amp; matrix[u][v] &lt; key[v]) &#123;<br>\t\t\t\tkey[v] = matrix[u][v];<br>\t\t\t\t<span class=\"hljs-comment\">//对key生成树到顶点的最小值进行更新</span><br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t&#125;<br>\tcout &lt;&lt; total &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释-v2\">注释</h3>\n<p><code>&lt;climits&gt;</code>头文件，定义了与整数类型的大小和范围相关的宏常量，常用<code>INT_MAX</code>和<code>INT_MIN</code>对数组变量进行初始化。</p>\n<p>封面来源: <a href=\"https://www.youtube.com/watch?v=j0OUwduDOS0\">Shortest Path Algorithms Explained (Dijkstra’s &amp; Bellman-Ford)</a></p>\n"},{"title":"Array and Linkedlist","date":"2025-08-22T08:16:33.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/Blog-image/refs/heads/main/cover/linkedlist.webp","category_bar":true,"description":"Reviewing the chapter about arrays and linked lists in Data Structure","_content":"\n# Introduction\n&emsp;&emsp;博主上学期结束了数据结构的学习，但是由于高数、线代、离散等课程积压，课程进度过快，数据结构学的粗枝大叶，很多地方蜻蜓点水般一笔带过，甚至是理论课学思想，实践课STL直接上，很多地方没有仔细钻研，考虑到下学期**程序综合实践有“CCF-CSP认证”**，以及数据结构 && 算法的重要性，遂打算再次进行学习相关内容，但相对的会有详略取舍！\n\n\n参考教材：[Hello,算法！](https://github.com/krahets/hello-algo)\n\n## Physical Structure\n\n&emsp;&emsp;内存是**所有程序的共享资源**，当某块内存被某个程序占用时，则无法被其他程序同时使用。就正如我们平时买电子产品时，讨论的8G、16G、32G的内存，当你同时打开开多个程序时就可能发生卡顿的现象。因此在数据结构和算法设计中，**内存资源**是一个很重要的考虑因素。\n\n{%note info%}\n比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果**缺少连续大块的内存空间**，那么所选用的数据结构必须能够**存储在分散的内存空间**里！\n{%endnote%}\n\n所有的数据结构都是基于**数组**（**连续空间存储**）、**链表**（**分散空间存储**）或二者的组合实现的！\n\n- 基于**数组**可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等\n- 基于**链表**可实现：栈、队列、哈希表、树、堆、图、等\n\n\n## Array\n\n![数组地址计算](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Address-Caculate.png?raw=true)\n\n- 数组的索引本质上是**内存地址的偏移量**\n\n### Array in STL\n```cpp\n#include <vector>\n/*动态数组的初始化*/\n\n/*初始化int数组*/\nvector<int> vec;\t\t\t\t\t//定义一个int型向量\nvector<int> vec(10);\t\t\t\t//vec有10个值为0的元素\nvector<int> vec(10, 1);\t\t\t\t//vec初始有10个值为1的元素\nvector<vector<int>> vec;\t\t\t//定义一个int型二维向量\nvector<int>::iterator it;\t\t\t//定义一个int型迭代器\n\n/*初始化string数组*/\nvector<string> vec(10, \"string\")    //vec初始有10个值为\"string\"的元素\nvector<string> vec(a.begin(), a.end());\t//vec是a的复制\n\n/*vector基本用法*/\nvec.push_back();\t\t\t\t\t\t//在数组的尾部添加一个元素\nvec.pop_back();\t\t\t\t\t\t\t//去掉数组的最后一个元素\nvec.begin();\t\t\t\t\t\t\t//得到数组头的指针，用迭代器接受\nvec.end();\t\t\t\t\t\t\t\t//得到数组的最后一个元素+1的指针\nvec.clear();\t\t\t\t\t\t\t//清空容器中所有元素\nvec.empty();\t\t\t\t\t\t\t//判断容器是否为空\nvec.erase(vec.begin() + i, vec.end() + j);\t//删除[i,j)区间的元素\nvec.erase(vec.begin() + i);\t\t\t\t//删除第i+1个元素\nvec.insert(vec.begin() + i, a);\t\t\t//在第i+1个元素前面插入a\nvec.insert(vec.end(), 10, a);\t\t\t//尾部插入10个值为a的元素\nvec.insert(pos, data);\t\t\t\t\t//在pos处插入数据\nvec.size();\t\t\t\t\t\t\t\t//返回容器中实际元素的个数\nvec.back();\t\t\t\t\t\t\t\t//返回尾部元素\nvec.front();\t\t\t\t\t\t\t//返回头部元素\nvec.resize(n);\t\t\t\t\t\t\t//数组大小变为n\nreverse(vec.begin(), vec.end())\t\t\t//用函数reverse()翻转数组\nsort(vec.begin(), vec.end())\t\t\t//用函数排序，默认从小排到大\n```\n\n### Pros and Cons\n\n{%note info%}\n- 空间效率高：为数据分配连续内存块，无需额外结构开销\n- 支持随机访问：循序在O(1) 时间内访问任意元素\n- 缓存局部性：当访问数组元素时，计算机还会缓存器周围的其他数据，从而借助高速缓存来提升后续操作的执行速度\n{%endnote%}\n\n{%note info%}\n- 插入与删除效率低：元素较多时，需要移动大量元素\n- 长度不可变：在初始化后长度就固定了。扩容数组需要将所有数据复制到新数组，开销很大\n- 空间浪费：如果分配的大小超过实际所需，那么多余的空间就被浪费了\n{%endnote%}\n\n## Linkedlist\n由前面的内存空间可知，在一个复杂的系统运行环境下，空闲的内存空间可能**散落在内存各处**，而存储数组的内存空间必须是**连续的**，当数组非常大时，内存可能无法提供如此大的连续空间，那么此时**链表的灵活性**就体现出来了！\n\n![链表定义与存储方式](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Physical-Storage-Address.png?raw=true)\n\n链表的组成单位是**节点**（node）对象。每个节点都包含两项数据：\n\n- **节点值**\n- **指向下一节点的指针**\n\n链表的首个节点被称为“**头节点**”，最后一个节点被称为“**尾节点**”。\n```c++\nstruct Node {\n    int val;         // 节点值\n    Node* next;  // 指向下一节点的指针\n    Node(int x) : val(x), next(nullptr) {}  // 构造函数\n};\n```\n链表节点 `Node` 除了包含值，还需额外保存**一个指针**。因此在相同数据量下，**链表比数组占用更多的内存空间**。\n\n### 链表操作\n#### 初始化链表\n\n```cpp\n// 实现1->3->2->5->4的链表\nNode* n0=new Node(1);\nNode* n1=new Node(3);\nNode* n2=new Node(2);\nNode* n3=new Node(5);\nNode* n4=new Node(4);\n```\n\n先创建各节点，并赋值\n\n```c++\nn0->next=n1;\nn1->next=n2;\nn2->next=n3;\nn3->next=n4;\n```\n再将各节点按顺序连接起来，即可初始化链表！\n\n#### 插入节点\n在链表中插入节点非常容易。假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需**改变两个节点指针**即可，时间复杂度为 O(1)。\n```cpp\nvoid insert(Node* n0,Node* p){\n    Node* n1=n0->next;\n    p->next=n1;\n    n0->next=p;\n}\n```\n\n```cpp\nvoid insert(Node* n0,Node* p){\n   p->next=n0->next;\n   n0->next=p;\n}\n```\n\n#### 删除节点\n\n```cpp\n/* 删除链表的节点 n0 之后的首个节点 */\nvoid remove(Node* n0){\n    if(n0->next==nullptr){\n        return ;\n    }\n    Node* p=n0->next;\n    Node* n1=p->next;\n    n0->next=n1;\n    //释放内存\n    delete p;\n}\n```\n{%note danger%}\n尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\n{%endnote%}\n\n\n\n#### 访问节点\n在链表中**访问节点的效率较低**。我们可以在 O(1)时间下访问数组中的任意元素。链表则不然，程序需要**从头节点出发**，逐个向后遍历，直至找到目标节点，时间复杂度为 O(n)。\n```cpp\n/* 访问链表中索引为 index 的节点 */\nvoid access(Node* head,int index){\n    for(int i=0;i<index;i++){\n        if(head==nullptr){\n            return nullptr;\n        }\n        head=head->next;\n        //通过索引值i进行遍历计数\n        //head指针不断后移，进行迭代，直至索引值\n    }\n    return head;\n}\n```\n\n#### 查找节点\n{% fold into @ Wrong Version %}\n:x::x::x:\n```cpp\n//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引\nint find(Node* head,int target){\n    int i=0;\n    while(head!=nullptr&&head->val!=target){\n        head=head->next;\n        i++;\n    }\n    return i;\n}\n```\n:x::x::x:\n未检验是否找到目标节点\n\n{% endfold %}\n```cpp\n//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引\nint find (Node* head,int target){\n    int index=0;\n    while(head!=nullptr){\n        if(head->val==target){\n            return index;\n        }\n        head=head->next;\n        index++;\n    }\n    return -1;\n}\n```\n\n## Array  VS.  Linkedlist\n\n||数组|链表|\n|:---:|:---:|:---:|\n|存储方式|连续内存空间|分散内存空间|\n|容量扩展|长度不可变|可灵活扩展|\n|内存效率|元素占用内存少、但可能浪费空间|元素占用内存多|\n|访问元素| O(1) | O(n) |\n|添加元素| O(n) | O(1) |\n|删除元素| O(n) | O(1) |\n\n\n## 常见链表类型\n![常见链表种类](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/kindoflinkedlist.png?raw=true)\n\n- **单向链表**：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\n\n- **环形链表**：如果我们令**单向链表的尾节点指向头节点**（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\n```cpp\nstruct Node{\n    int val;\n    Node* next;\n    Node(x):val(x),next(nullptr){}\n};\nNode* head=new Node(1);\n\n   ...\n   ...\n   ...\n\n   Node* tail=new Node(5);\n   tail->next=head;\n```\n\n- **双向链表**：与单向链表相比，双向链表**记录了两个方向的引用**。双向链表的节点定义同时包含指向**后继节点**和**前驱节点**指针。相较于单向链表，双向链表更具**灵活性**，可以**朝两个方向遍历链表**，但相应地也需要占用更多的内存空间。\n\n\n```cpp\nstruct Node{\n    int val;\n    Node* next;\n    Node* prev;\n    Node(x): val(x),next(nullptr),prev(nullptr){}\n};\n```\n\n## 计算机存储设备\n\n||硬盘|内存|缓存|\n|:---:|:---:|:---:|:---:|\n|用途|长期存储数据，包括操作系统、程序、文件等|临时存储当前运行的程序和正在处理的数据|存储经常访问的数据和指令，减少 CPU 访问内存的次数|\n|易失性|断电后数据不会丢失|断电后数据会丢失|断电后数据会丢失|\n|容量|较大，TB 级别|较小，GB 级别|非常小，MB 级别|\n|速度|较慢，几百到几千 MB/s|较快，几十 GB/s|非常快，几十到几百 GB/s|\n|价格（人民币）|较便宜，几毛到几元 / GB|较贵，几十到几百元 / GB|非常贵，随 CPU 打包计价|\n\n- **硬盘**用于**长期存储大量数据**\n- **内存**用于**临时存储程序运行中正在处理的数据**\n- **缓存**用于**存储经常访问的数据和指令**\n\n\n## Conclusion\n1. **数组要求相同类型的元素，而在链表中不强调相同类型！**\n- 链表由节点组成，节点之间通过指针连接，各个节点可以**存储不同类型的数据**，例如 int、double、string、object 等。\n- 相对地，数组元素则必须是相同类型的，这样才能**通过计算偏移量来获取对应元素位置**。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 。","source":"_posts/Data structure/Linkedlist.md","raw":"---\ntitle: Array and Linkedlist\ndate: 2025-08-22 16:16:33\ntags: [datastructure,linkedlist]\nindex_img: https://raw.githubusercontent.com/Richard110206/Blog-image/refs/heads/main/cover/linkedlist.webp\ncategory: Data Structure\ncategory_bar: true\ndescription: Reviewing the chapter about arrays and linked lists in Data Structure\n---\n\n# Introduction\n&emsp;&emsp;博主上学期结束了数据结构的学习，但是由于高数、线代、离散等课程积压，课程进度过快，数据结构学的粗枝大叶，很多地方蜻蜓点水般一笔带过，甚至是理论课学思想，实践课STL直接上，很多地方没有仔细钻研，考虑到下学期**程序综合实践有“CCF-CSP认证”**，以及数据结构 && 算法的重要性，遂打算再次进行学习相关内容，但相对的会有详略取舍！\n\n\n参考教材：[Hello,算法！](https://github.com/krahets/hello-algo)\n\n## Physical Structure\n\n&emsp;&emsp;内存是**所有程序的共享资源**，当某块内存被某个程序占用时，则无法被其他程序同时使用。就正如我们平时买电子产品时，讨论的8G、16G、32G的内存，当你同时打开开多个程序时就可能发生卡顿的现象。因此在数据结构和算法设计中，**内存资源**是一个很重要的考虑因素。\n\n{%note info%}\n比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果**缺少连续大块的内存空间**，那么所选用的数据结构必须能够**存储在分散的内存空间**里！\n{%endnote%}\n\n所有的数据结构都是基于**数组**（**连续空间存储**）、**链表**（**分散空间存储**）或二者的组合实现的！\n\n- 基于**数组**可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等\n- 基于**链表**可实现：栈、队列、哈希表、树、堆、图、等\n\n\n## Array\n\n![数组地址计算](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Address-Caculate.png?raw=true)\n\n- 数组的索引本质上是**内存地址的偏移量**\n\n### Array in STL\n```cpp\n#include <vector>\n/*动态数组的初始化*/\n\n/*初始化int数组*/\nvector<int> vec;\t\t\t\t\t//定义一个int型向量\nvector<int> vec(10);\t\t\t\t//vec有10个值为0的元素\nvector<int> vec(10, 1);\t\t\t\t//vec初始有10个值为1的元素\nvector<vector<int>> vec;\t\t\t//定义一个int型二维向量\nvector<int>::iterator it;\t\t\t//定义一个int型迭代器\n\n/*初始化string数组*/\nvector<string> vec(10, \"string\")    //vec初始有10个值为\"string\"的元素\nvector<string> vec(a.begin(), a.end());\t//vec是a的复制\n\n/*vector基本用法*/\nvec.push_back();\t\t\t\t\t\t//在数组的尾部添加一个元素\nvec.pop_back();\t\t\t\t\t\t\t//去掉数组的最后一个元素\nvec.begin();\t\t\t\t\t\t\t//得到数组头的指针，用迭代器接受\nvec.end();\t\t\t\t\t\t\t\t//得到数组的最后一个元素+1的指针\nvec.clear();\t\t\t\t\t\t\t//清空容器中所有元素\nvec.empty();\t\t\t\t\t\t\t//判断容器是否为空\nvec.erase(vec.begin() + i, vec.end() + j);\t//删除[i,j)区间的元素\nvec.erase(vec.begin() + i);\t\t\t\t//删除第i+1个元素\nvec.insert(vec.begin() + i, a);\t\t\t//在第i+1个元素前面插入a\nvec.insert(vec.end(), 10, a);\t\t\t//尾部插入10个值为a的元素\nvec.insert(pos, data);\t\t\t\t\t//在pos处插入数据\nvec.size();\t\t\t\t\t\t\t\t//返回容器中实际元素的个数\nvec.back();\t\t\t\t\t\t\t\t//返回尾部元素\nvec.front();\t\t\t\t\t\t\t//返回头部元素\nvec.resize(n);\t\t\t\t\t\t\t//数组大小变为n\nreverse(vec.begin(), vec.end())\t\t\t//用函数reverse()翻转数组\nsort(vec.begin(), vec.end())\t\t\t//用函数排序，默认从小排到大\n```\n\n### Pros and Cons\n\n{%note info%}\n- 空间效率高：为数据分配连续内存块，无需额外结构开销\n- 支持随机访问：循序在O(1) 时间内访问任意元素\n- 缓存局部性：当访问数组元素时，计算机还会缓存器周围的其他数据，从而借助高速缓存来提升后续操作的执行速度\n{%endnote%}\n\n{%note info%}\n- 插入与删除效率低：元素较多时，需要移动大量元素\n- 长度不可变：在初始化后长度就固定了。扩容数组需要将所有数据复制到新数组，开销很大\n- 空间浪费：如果分配的大小超过实际所需，那么多余的空间就被浪费了\n{%endnote%}\n\n## Linkedlist\n由前面的内存空间可知，在一个复杂的系统运行环境下，空闲的内存空间可能**散落在内存各处**，而存储数组的内存空间必须是**连续的**，当数组非常大时，内存可能无法提供如此大的连续空间，那么此时**链表的灵活性**就体现出来了！\n\n![链表定义与存储方式](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Physical-Storage-Address.png?raw=true)\n\n链表的组成单位是**节点**（node）对象。每个节点都包含两项数据：\n\n- **节点值**\n- **指向下一节点的指针**\n\n链表的首个节点被称为“**头节点**”，最后一个节点被称为“**尾节点**”。\n```c++\nstruct Node {\n    int val;         // 节点值\n    Node* next;  // 指向下一节点的指针\n    Node(int x) : val(x), next(nullptr) {}  // 构造函数\n};\n```\n链表节点 `Node` 除了包含值，还需额外保存**一个指针**。因此在相同数据量下，**链表比数组占用更多的内存空间**。\n\n### 链表操作\n#### 初始化链表\n\n```cpp\n// 实现1->3->2->5->4的链表\nNode* n0=new Node(1);\nNode* n1=new Node(3);\nNode* n2=new Node(2);\nNode* n3=new Node(5);\nNode* n4=new Node(4);\n```\n\n先创建各节点，并赋值\n\n```c++\nn0->next=n1;\nn1->next=n2;\nn2->next=n3;\nn3->next=n4;\n```\n再将各节点按顺序连接起来，即可初始化链表！\n\n#### 插入节点\n在链表中插入节点非常容易。假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需**改变两个节点指针**即可，时间复杂度为 O(1)。\n```cpp\nvoid insert(Node* n0,Node* p){\n    Node* n1=n0->next;\n    p->next=n1;\n    n0->next=p;\n}\n```\n\n```cpp\nvoid insert(Node* n0,Node* p){\n   p->next=n0->next;\n   n0->next=p;\n}\n```\n\n#### 删除节点\n\n```cpp\n/* 删除链表的节点 n0 之后的首个节点 */\nvoid remove(Node* n0){\n    if(n0->next==nullptr){\n        return ;\n    }\n    Node* p=n0->next;\n    Node* n1=p->next;\n    n0->next=n1;\n    //释放内存\n    delete p;\n}\n```\n{%note danger%}\n尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。\n{%endnote%}\n\n\n\n#### 访问节点\n在链表中**访问节点的效率较低**。我们可以在 O(1)时间下访问数组中的任意元素。链表则不然，程序需要**从头节点出发**，逐个向后遍历，直至找到目标节点，时间复杂度为 O(n)。\n```cpp\n/* 访问链表中索引为 index 的节点 */\nvoid access(Node* head,int index){\n    for(int i=0;i<index;i++){\n        if(head==nullptr){\n            return nullptr;\n        }\n        head=head->next;\n        //通过索引值i进行遍历计数\n        //head指针不断后移，进行迭代，直至索引值\n    }\n    return head;\n}\n```\n\n#### 查找节点\n{% fold into @ Wrong Version %}\n:x::x::x:\n```cpp\n//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引\nint find(Node* head,int target){\n    int i=0;\n    while(head!=nullptr&&head->val!=target){\n        head=head->next;\n        i++;\n    }\n    return i;\n}\n```\n:x::x::x:\n未检验是否找到目标节点\n\n{% endfold %}\n```cpp\n//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引\nint find (Node* head,int target){\n    int index=0;\n    while(head!=nullptr){\n        if(head->val==target){\n            return index;\n        }\n        head=head->next;\n        index++;\n    }\n    return -1;\n}\n```\n\n## Array  VS.  Linkedlist\n\n||数组|链表|\n|:---:|:---:|:---:|\n|存储方式|连续内存空间|分散内存空间|\n|容量扩展|长度不可变|可灵活扩展|\n|内存效率|元素占用内存少、但可能浪费空间|元素占用内存多|\n|访问元素| O(1) | O(n) |\n|添加元素| O(n) | O(1) |\n|删除元素| O(n) | O(1) |\n\n\n## 常见链表类型\n![常见链表种类](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/kindoflinkedlist.png?raw=true)\n\n- **单向链表**：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。\n\n- **环形链表**：如果我们令**单向链表的尾节点指向头节点**（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。\n```cpp\nstruct Node{\n    int val;\n    Node* next;\n    Node(x):val(x),next(nullptr){}\n};\nNode* head=new Node(1);\n\n   ...\n   ...\n   ...\n\n   Node* tail=new Node(5);\n   tail->next=head;\n```\n\n- **双向链表**：与单向链表相比，双向链表**记录了两个方向的引用**。双向链表的节点定义同时包含指向**后继节点**和**前驱节点**指针。相较于单向链表，双向链表更具**灵活性**，可以**朝两个方向遍历链表**，但相应地也需要占用更多的内存空间。\n\n\n```cpp\nstruct Node{\n    int val;\n    Node* next;\n    Node* prev;\n    Node(x): val(x),next(nullptr),prev(nullptr){}\n};\n```\n\n## 计算机存储设备\n\n||硬盘|内存|缓存|\n|:---:|:---:|:---:|:---:|\n|用途|长期存储数据，包括操作系统、程序、文件等|临时存储当前运行的程序和正在处理的数据|存储经常访问的数据和指令，减少 CPU 访问内存的次数|\n|易失性|断电后数据不会丢失|断电后数据会丢失|断电后数据会丢失|\n|容量|较大，TB 级别|较小，GB 级别|非常小，MB 级别|\n|速度|较慢，几百到几千 MB/s|较快，几十 GB/s|非常快，几十到几百 GB/s|\n|价格（人民币）|较便宜，几毛到几元 / GB|较贵，几十到几百元 / GB|非常贵，随 CPU 打包计价|\n\n- **硬盘**用于**长期存储大量数据**\n- **内存**用于**临时存储程序运行中正在处理的数据**\n- **缓存**用于**存储经常访问的数据和指令**\n\n\n## Conclusion\n1. **数组要求相同类型的元素，而在链表中不强调相同类型！**\n- 链表由节点组成，节点之间通过指针连接，各个节点可以**存储不同类型的数据**，例如 int、double、string、object 等。\n- 相对地，数组元素则必须是相同类型的，这样才能**通过计算偏移量来获取对应元素位置**。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 。","slug":"Data structure/Linkedlist","published":1,"updated":"2025-08-26T07:25:07.363Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcn000r40w3de4cbrmb","content":"<h1>Introduction</h1>\n<p>  博主上学期结束了数据结构的学习，但是由于高数、线代、离散等课程积压，课程进度过快，数据结构学的粗枝大叶，很多地方蜻蜓点水般一笔带过，甚至是理论课学思想，实践课STL直接上，很多地方没有仔细钻研，考虑到下学期<strong>程序综合实践有“CCF-CSP认证”</strong>，以及数据结构 &amp;&amp; 算法的重要性，遂打算再次进行学习相关内容，但相对的会有详略取舍！</p>\n<p>参考教材：<a href=\"https://github.com/krahets/hello-algo\">Hello,算法！</a></p>\n<h2 id=\"Physical-Structure\">Physical Structure</h2>\n<p>  内存是<strong>所有程序的共享资源</strong>，当某块内存被某个程序占用时，则无法被其他程序同时使用。就正如我们平时买电子产品时，讨论的8G、16G、32G的内存，当你同时打开开多个程序时就可能发生卡顿的现象。因此在数据结构和算法设计中，<strong>内存资源</strong>是一个很重要的考虑因素。</p>\n<div class=\"note note-info\">\n            <p>比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果<strong>缺少连续大块的内存空间</strong>，那么所选用的数据结构必须能够<strong>存储在分散的内存空间</strong>里！</p>\n          </div>\n<p>所有的数据结构都是基于<strong>数组</strong>（<strong>连续空间存储</strong>）、<strong>链表</strong>（<strong>分散空间存储</strong>）或二者的组合实现的！</p>\n<ul>\n<li>基于<strong>数组</strong>可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等</li>\n<li>基于<strong>链表</strong>可实现：栈、队列、哈希表、树、堆、图、等</li>\n</ul>\n<h2 id=\"Array\">Array</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Address-Caculate.png?raw=true\" alt=\"数组地址计算\"></p>\n<ul>\n<li>数组的索引本质上是<strong>内存地址的偏移量</strong></li>\n</ul>\n<h3 id=\"Array-in-STL\">Array in STL</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-comment\">/*动态数组的初始化*/</span><br><br><span class=\"hljs-comment\">/*初始化int数组*/</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;\t\t\t\t\t<span class=\"hljs-comment\">//定义一个int型向量</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;\t\t\t\t<span class=\"hljs-comment\">//vec有10个值为0的元素</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>)</span></span>;\t\t\t\t<span class=\"hljs-comment\">//vec初始有10个值为1的元素</span><br>vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; vec;\t\t\t<span class=\"hljs-comment\">//定义一个int型二维向量</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\t\t\t<span class=\"hljs-comment\">//定义一个int型迭代器</span><br><br><span class=\"hljs-comment\">/*初始化string数组*/</span><br><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">\"string\"</span>)</span>    <span class=\"hljs-comment\">//vec初始有10个值为\"string\"的元素</span></span><br><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(a.begin(), a.end())</span></span>;\t<span class=\"hljs-comment\">//vec是a的复制</span><br><br><span class=\"hljs-comment\">/*vector基本用法*/</span><br>vec.<span class=\"hljs-built_in\">push_back</span>();\t\t\t\t\t\t<span class=\"hljs-comment\">//在数组的尾部添加一个元素</span><br>vec.<span class=\"hljs-built_in\">pop_back</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//去掉数组的最后一个元素</span><br>vec.<span class=\"hljs-built_in\">begin</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//得到数组头的指针，用迭代器接受</span><br>vec.<span class=\"hljs-built_in\">end</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//得到数组的最后一个元素+1的指针</span><br>vec.<span class=\"hljs-built_in\">clear</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//清空容器中所有元素</span><br>vec.<span class=\"hljs-built_in\">empty</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//判断容器是否为空</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i, vec.<span class=\"hljs-built_in\">end</span>() + j);\t<span class=\"hljs-comment\">//删除[i,j)区间的元素</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i);\t\t\t\t<span class=\"hljs-comment\">//删除第i+1个元素</span><br>vec.<span class=\"hljs-built_in\">insert</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i, a);\t\t\t<span class=\"hljs-comment\">//在第i+1个元素前面插入a</span><br>vec.<span class=\"hljs-built_in\">insert</span>(vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">10</span>, a);\t\t\t<span class=\"hljs-comment\">//尾部插入10个值为a的元素</span><br>vec.<span class=\"hljs-built_in\">insert</span>(pos, data);\t\t\t\t\t<span class=\"hljs-comment\">//在pos处插入数据</span><br>vec.<span class=\"hljs-built_in\">size</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回容器中实际元素的个数</span><br>vec.<span class=\"hljs-built_in\">back</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回尾部元素</span><br>vec.<span class=\"hljs-built_in\">front</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回头部元素</span><br>vec.<span class=\"hljs-built_in\">resize</span>(n);\t\t\t\t\t\t\t<span class=\"hljs-comment\">//数组大小变为n</span><br><span class=\"hljs-built_in\">reverse</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>())\t\t\t<span class=\"hljs-comment\">//用函数reverse()翻转数组</span><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>())\t\t\t<span class=\"hljs-comment\">//用函数排序，默认从小排到大</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"Pros-and-Cons\">Pros and Cons</h3>\n<div class=\"note note-info\">\n            <ul><li>空间效率高：为数据分配连续内存块，无需额外结构开销</li><li>支持随机访问：循序在O(1) 时间内访问任意元素</li><li>缓存局部性：当访问数组元素时，计算机还会缓存器周围的其他数据，从而借助高速缓存来提升后续操作的执行速度</li></ul>\n          </div>\n<div class=\"note note-info\">\n            <ul><li>插入与删除效率低：元素较多时，需要移动大量元素</li><li>长度不可变：在初始化后长度就固定了。扩容数组需要将所有数据复制到新数组，开销很大</li><li>空间浪费：如果分配的大小超过实际所需，那么多余的空间就被浪费了</li></ul>\n          </div>\n<h2 id=\"Linkedlist\">Linkedlist</h2>\n<p>由前面的内存空间可知，在一个复杂的系统运行环境下，空闲的内存空间可能<strong>散落在内存各处</strong>，而存储数组的内存空间必须是<strong>连续的</strong>，当数组非常大时，内存可能无法提供如此大的连续空间，那么此时<strong>链表的灵活性</strong>就体现出来了！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Physical-Storage-Address.png?raw=true\" alt=\"链表定义与存储方式\"></p>\n<p>链表的组成单位是<strong>节点</strong>（node）对象。每个节点都包含两项数据：</p>\n<ul>\n<li><strong>节点值</strong></li>\n<li><strong>指向下一节点的指针</strong></li>\n</ul>\n<p>链表的首个节点被称为“<strong>头节点</strong>”，最后一个节点被称为“<strong>尾节点</strong>”。</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {<br>    <span class=\"hljs-type\">int</span> val;         <span class=\"hljs-comment\">// 节点值</span><br>    Node* next;  <span class=\"hljs-comment\">// 指向下一节点的指针</span><br>    <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-type\">int</span> x) : <span class=\"hljs-built_in\">val</span>(x), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) {}  <span class=\"hljs-comment\">// 构造函数</span><br>};<br></code></pre></td></tr></tbody></table></figure>\n<p>链表节点 <code>Node</code> 除了包含值，还需额外保存<strong>一个指针</strong>。因此在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p>\n<h3 id=\"链表操作\">链表操作</h3>\n<h4 id=\"初始化链表\">初始化链表</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 实现1-&gt;3-&gt;2-&gt;5-&gt;4的链表</span><br>Node* n0=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">1</span>);<br>Node* n1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">3</span>);<br>Node* n2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">2</span>);<br>Node* n3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">5</span>);<br>Node* n4=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></tbody></table></figure>\n<p>先创建各节点，并赋值</p>\n<figure class=\"highlight c++\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">n0-&gt;next=n1;<br>n1-&gt;next=n2;<br>n2-&gt;next=n3;<br>n3-&gt;next=n4;<br></code></pre></td></tr></tbody></table></figure>\n<p>再将各节点按顺序连接起来，即可初始化链表！</p>\n<h4 id=\"插入节点\">插入节点</h4>\n<p>在链表中插入节点非常容易。假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需<strong>改变两个节点指针</strong>即可，时间复杂度为 O(1)。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(Node* n0,Node* p)</span></span>{<br>    Node* n1=n0-&gt;next;<br>    p-&gt;next=n1;<br>    n0-&gt;next=p;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(Node* n0,Node* p)</span></span>{<br>   p-&gt;next=n0-&gt;next;<br>   n0-&gt;next=p;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"删除节点\">删除节点</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(Node* n0)</span></span>{<br>    <span class=\"hljs-keyword\">if</span>(n0-&gt;next==<span class=\"hljs-literal\">nullptr</span>){<br>        <span class=\"hljs-keyword\">return</span> ;<br>    }<br>    Node* p=n0-&gt;next;<br>    Node* n1=p-&gt;next;<br>    n0-&gt;next=n1;<br>    <span class=\"hljs-comment\">//释放内存</span><br>    <span class=\"hljs-keyword\">delete</span> p;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-danger\">\n            <p>尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。</p>\n          </div>\n<h4 id=\"访问节点\">访问节点</h4>\n<p>在链表中<strong>访问节点的效率较低</strong>。我们可以在 O(1)时间下访问数组中的任意元素。链表则不然，程序需要<strong>从头节点出发</strong>，逐个向后遍历，直至找到目标节点，时间复杂度为 O(n)。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 访问链表中索引为 index 的节点 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">access</span><span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> index)</span></span>{<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;index;i++){<br>        <span class=\"hljs-keyword\">if</span>(head==<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>        }<br>        head=head-&gt;next;<br>        <span class=\"hljs-comment\">//通过索引值i进行遍历计数</span><br>        <span class=\"hljs-comment\">//head指针不断后移，进行迭代，直至索引值</span><br>    }<br>    <span class=\"hljs-keyword\">return</span> head;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"查找节点\">查找节点</h4>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-bc5bc4b6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-bc5bc4b6\">\n        <div class=\"fold-arrow\">▶</div> Wrong Version\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-bc5bc4b6\">\n        <div class=\"fold-content\">\n          <p>❌❌❌</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> target)</span></span>{<br>    <span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(head!=<span class=\"hljs-literal\">nullptr</span>&amp;&amp;head-&gt;val!=target){<br>        head=head-&gt;next;<br>        i++;<br>    }<br>    <span class=\"hljs-keyword\">return</span> i;<br>}<br></code></pre></td></tr></tbody></table></figure><p>❌❌❌<br>未检验是否找到目标节点</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span> <span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> target)</span></span>{<br>    <span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(head!=<span class=\"hljs-literal\">nullptr</span>){<br>        <span class=\"hljs-keyword\">if</span>(head-&gt;val==target){<br>            <span class=\"hljs-keyword\">return</span> index;<br>        }<br>        head=head-&gt;next;<br>        index++;<br>    }<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Array-VS-Linkedlist\">Array  VS.  Linkedlist</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储方式</td>\n<td style=\"text-align:center\">连续内存空间</td>\n<td style=\"text-align:center\">分散内存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容量扩展</td>\n<td style=\"text-align:center\">长度不可变</td>\n<td style=\"text-align:center\">可灵活扩展</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存效率</td>\n<td style=\"text-align:center\">元素占用内存少、但可能浪费空间</td>\n<td style=\"text-align:center\">元素占用内存多</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">访问元素</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"常见链表类型\">常见链表类型</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/kindoflinkedlist.png?raw=true\" alt=\"常见链表种类\"></p>\n<ul>\n<li>\n<p><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</p>\n</li>\n<li>\n<p><strong>环形链表</strong>：如果我们令<strong>单向链表的尾节点指向头节点</strong>（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>{<br>    <span class=\"hljs-type\">int</span> val;<br>    Node* next;<br>    <span class=\"hljs-built_in\">Node</span>(x):<span class=\"hljs-built_in\">val</span>(x),<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>){}<br>};<br>Node* head=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">1</span>);<br><br>   ...<br>   ...<br>   ...<br><br>   Node* tail=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">5</span>);<br>   tail-&gt;next=head;<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><strong>双向链表</strong>：与单向链表相比，双向链表<strong>记录了两个方向的引用</strong>。双向链表的节点定义同时包含指向<strong>后继节点</strong>和<strong>前驱节点</strong>指针。相较于单向链表，双向链表更具<strong>灵活性</strong>，可以<strong>朝两个方向遍历链表</strong>，但相应地也需要占用更多的内存空间。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>{<br>    <span class=\"hljs-type\">int</span> val;<br>    Node* next;<br>    Node* prev;<br>    <span class=\"hljs-built_in\">Node</span>(x): <span class=\"hljs-built_in\">val</span>(x),<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>){}<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"计算机存储设备\">计算机存储设备</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">硬盘</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">缓存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">用途</td>\n<td style=\"text-align:center\">长期存储数据，包括操作系统、程序、文件等</td>\n<td style=\"text-align:center\">临时存储当前运行的程序和正在处理的数据</td>\n<td style=\"text-align:center\">存储经常访问的数据和指令，减少 CPU 访问内存的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">易失性</td>\n<td style=\"text-align:center\">断电后数据不会丢失</td>\n<td style=\"text-align:center\">断电后数据会丢失</td>\n<td style=\"text-align:center\">断电后数据会丢失</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容量</td>\n<td style=\"text-align:center\">较大，TB 级别</td>\n<td style=\"text-align:center\">较小，GB 级别</td>\n<td style=\"text-align:center\">非常小，MB 级别</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">速度</td>\n<td style=\"text-align:center\">较慢，几百到几千 MB/s</td>\n<td style=\"text-align:center\">较快，几十 GB/s</td>\n<td style=\"text-align:center\">非常快，几十到几百 GB/s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">价格（人民币）</td>\n<td style=\"text-align:center\">较便宜，几毛到几元 / GB</td>\n<td style=\"text-align:center\">较贵，几十到几百元 / GB</td>\n<td style=\"text-align:center\">非常贵，随 CPU 打包计价</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>硬盘</strong>用于<strong>长期存储大量数据</strong></li>\n<li><strong>内存</strong>用于<strong>临时存储程序运行中正在处理的数据</strong></li>\n<li><strong>缓存</strong>用于<strong>存储经常访问的数据和指令</strong></li>\n</ul>\n<h2 id=\"Conclusion\">Conclusion</h2>\n<ol>\n<li><strong>数组要求相同类型的元素，而在链表中不强调相同类型！</strong></li>\n</ol>\n<ul>\n<li>链表由节点组成，节点之间通过指针连接，各个节点可以<strong>存储不同类型的数据</strong>，例如 int、double、string、object 等。</li>\n<li>相对地，数组元素则必须是相同类型的，这样才能<strong>通过计算偏移量来获取对应元素位置</strong>。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 。</li>\n</ul>\n","excerpt":"","more":"<h1>Introduction</h1>\n<p>  博主上学期结束了数据结构的学习，但是由于高数、线代、离散等课程积压，课程进度过快，数据结构学的粗枝大叶，很多地方蜻蜓点水般一笔带过，甚至是理论课学思想，实践课STL直接上，很多地方没有仔细钻研，考虑到下学期<strong>程序综合实践有“CCF-CSP认证”</strong>，以及数据结构 &amp;&amp; 算法的重要性，遂打算再次进行学习相关内容，但相对的会有详略取舍！</p>\n<p>参考教材：<a href=\"https://github.com/krahets/hello-algo\">Hello,算法！</a></p>\n<h2 id=\"Physical-Structure\">Physical Structure</h2>\n<p>  内存是<strong>所有程序的共享资源</strong>，当某块内存被某个程序占用时，则无法被其他程序同时使用。就正如我们平时买电子产品时，讨论的8G、16G、32G的内存，当你同时打开开多个程序时就可能发生卡顿的现象。因此在数据结构和算法设计中，<strong>内存资源</strong>是一个很重要的考虑因素。</p>\n<div class=\"note note-info\">\n            <p>比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果<strong>缺少连续大块的内存空间</strong>，那么所选用的数据结构必须能够<strong>存储在分散的内存空间</strong>里！</p>\n          </div>\n<p>所有的数据结构都是基于<strong>数组</strong>（<strong>连续空间存储</strong>）、<strong>链表</strong>（<strong>分散空间存储</strong>）或二者的组合实现的！</p>\n<ul>\n<li>基于<strong>数组</strong>可实现：栈、队列、哈希表、树、堆、图、矩阵、张量等</li>\n<li>基于<strong>链表</strong>可实现：栈、队列、哈希表、树、堆、图、等</li>\n</ul>\n<h2 id=\"Array\">Array</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Address-Caculate.png?raw=true\" alt=\"数组地址计算\"></p>\n<ul>\n<li>数组的索引本质上是<strong>内存地址的偏移量</strong></li>\n</ul>\n<h3 id=\"Array-in-STL\">Array in STL</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-comment\">/*动态数组的初始化*/</span><br><br><span class=\"hljs-comment\">/*初始化int数组*/</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt; vec;\t\t\t\t\t<span class=\"hljs-comment\">//定义一个int型向量</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>)</span></span>;\t\t\t\t<span class=\"hljs-comment\">//vec有10个值为0的元素</span><br><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>)</span></span>;\t\t\t\t<span class=\"hljs-comment\">//vec初始有10个值为1的元素</span><br>vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; vec;\t\t\t<span class=\"hljs-comment\">//定义一个int型二维向量</span><br>vector&lt;<span class=\"hljs-type\">int</span>&gt;::iterator it;\t\t\t<span class=\"hljs-comment\">//定义一个int型迭代器</span><br><br><span class=\"hljs-comment\">/*初始化string数组*/</span><br><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">&quot;string&quot;</span>)</span>    <span class=\"hljs-comment\">//vec初始有10个值为&quot;string&quot;的元素</span></span><br><span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">vec</span><span class=\"hljs-params\">(a.begin(), a.end())</span></span>;\t<span class=\"hljs-comment\">//vec是a的复制</span><br><br><span class=\"hljs-comment\">/*vector基本用法*/</span><br>vec.<span class=\"hljs-built_in\">push_back</span>();\t\t\t\t\t\t<span class=\"hljs-comment\">//在数组的尾部添加一个元素</span><br>vec.<span class=\"hljs-built_in\">pop_back</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//去掉数组的最后一个元素</span><br>vec.<span class=\"hljs-built_in\">begin</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//得到数组头的指针，用迭代器接受</span><br>vec.<span class=\"hljs-built_in\">end</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//得到数组的最后一个元素+1的指针</span><br>vec.<span class=\"hljs-built_in\">clear</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//清空容器中所有元素</span><br>vec.<span class=\"hljs-built_in\">empty</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//判断容器是否为空</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i, vec.<span class=\"hljs-built_in\">end</span>() + j);\t<span class=\"hljs-comment\">//删除[i,j)区间的元素</span><br>vec.<span class=\"hljs-built_in\">erase</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i);\t\t\t\t<span class=\"hljs-comment\">//删除第i+1个元素</span><br>vec.<span class=\"hljs-built_in\">insert</span>(vec.<span class=\"hljs-built_in\">begin</span>() + i, a);\t\t\t<span class=\"hljs-comment\">//在第i+1个元素前面插入a</span><br>vec.<span class=\"hljs-built_in\">insert</span>(vec.<span class=\"hljs-built_in\">end</span>(), <span class=\"hljs-number\">10</span>, a);\t\t\t<span class=\"hljs-comment\">//尾部插入10个值为a的元素</span><br>vec.<span class=\"hljs-built_in\">insert</span>(pos, data);\t\t\t\t\t<span class=\"hljs-comment\">//在pos处插入数据</span><br>vec.<span class=\"hljs-built_in\">size</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回容器中实际元素的个数</span><br>vec.<span class=\"hljs-built_in\">back</span>();\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回尾部元素</span><br>vec.<span class=\"hljs-built_in\">front</span>();\t\t\t\t\t\t\t<span class=\"hljs-comment\">//返回头部元素</span><br>vec.<span class=\"hljs-built_in\">resize</span>(n);\t\t\t\t\t\t\t<span class=\"hljs-comment\">//数组大小变为n</span><br><span class=\"hljs-built_in\">reverse</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>())\t\t\t<span class=\"hljs-comment\">//用函数reverse()翻转数组</span><br><span class=\"hljs-built_in\">sort</span>(vec.<span class=\"hljs-built_in\">begin</span>(), vec.<span class=\"hljs-built_in\">end</span>())\t\t\t<span class=\"hljs-comment\">//用函数排序，默认从小排到大</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"Pros-and-Cons\">Pros and Cons</h3>\n<div class=\"note note-info\">\n            <ul><li>空间效率高：为数据分配连续内存块，无需额外结构开销</li><li>支持随机访问：循序在O(1) 时间内访问任意元素</li><li>缓存局部性：当访问数组元素时，计算机还会缓存器周围的其他数据，从而借助高速缓存来提升后续操作的执行速度</li></ul>\n          </div>\n<div class=\"note note-info\">\n            <ul><li>插入与删除效率低：元素较多时，需要移动大量元素</li><li>长度不可变：在初始化后长度就固定了。扩容数组需要将所有数据复制到新数组，开销很大</li><li>空间浪费：如果分配的大小超过实际所需，那么多余的空间就被浪费了</li></ul>\n          </div>\n<h2 id=\"Linkedlist\">Linkedlist</h2>\n<p>由前面的内存空间可知，在一个复杂的系统运行环境下，空闲的内存空间可能<strong>散落在内存各处</strong>，而存储数组的内存空间必须是<strong>连续的</strong>，当数组非常大时，内存可能无法提供如此大的连续空间，那么此时<strong>链表的灵活性</strong>就体现出来了！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/Physical-Storage-Address.png?raw=true\" alt=\"链表定义与存储方式\"></p>\n<p>链表的组成单位是<strong>节点</strong>（node）对象。每个节点都包含两项数据：</p>\n<ul>\n<li><strong>节点值</strong></li>\n<li><strong>指向下一节点的指针</strong></li>\n</ul>\n<p>链表的首个节点被称为“<strong>头节点</strong>”，最后一个节点被称为“<strong>尾节点</strong>”。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> &#123;<br>    <span class=\"hljs-type\">int</span> val;         <span class=\"hljs-comment\">// 节点值</span><br>    Node* next;  <span class=\"hljs-comment\">// 指向下一节点的指针</span><br>    <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-type\">int</span> x) : <span class=\"hljs-built_in\">val</span>(x), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;&#125;  <span class=\"hljs-comment\">// 构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>链表节点 <code>Node</code> 除了包含值，还需额外保存<strong>一个指针</strong>。因此在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p>\n<h3 id=\"链表操作\">链表操作</h3>\n<h4 id=\"初始化链表\">初始化链表</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 实现1-&gt;3-&gt;2-&gt;5-&gt;4的链表</span><br>Node* n0=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">1</span>);<br>Node* n1=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">3</span>);<br>Node* n2=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">2</span>);<br>Node* n3=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">5</span>);<br>Node* n4=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></table></figure>\n<p>先创建各节点，并赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">n0-&gt;next=n1;<br>n1-&gt;next=n2;<br>n2-&gt;next=n3;<br>n3-&gt;next=n4;<br></code></pre></td></tr></table></figure>\n<p>再将各节点按顺序连接起来，即可初始化链表！</p>\n<h4 id=\"插入节点\">插入节点</h4>\n<p>在链表中插入节点非常容易。假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需<strong>改变两个节点指针</strong>即可，时间复杂度为 O(1)。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(Node* n0,Node* p)</span></span>&#123;<br>    Node* n1=n0-&gt;next;<br>    p-&gt;next=n1;<br>    n0-&gt;next=p;<br>&#125;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(Node* n0,Node* p)</span></span>&#123;<br>   p-&gt;next=n0-&gt;next;<br>   n0-&gt;next=p;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"删除节点\">删除节点</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 删除链表的节点 n0 之后的首个节点 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(Node* n0)</span></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(n0-&gt;next==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>        <span class=\"hljs-keyword\">return</span> ;<br>    &#125;<br>    Node* p=n0-&gt;next;<br>    Node* n1=p-&gt;next;<br>    n0-&gt;next=n1;<br>    <span class=\"hljs-comment\">//释放内存</span><br>    <span class=\"hljs-keyword\">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-danger\">\n            <p>尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。</p>\n          </div>\n<h4 id=\"访问节点\">访问节点</h4>\n<p>在链表中<strong>访问节点的效率较低</strong>。我们可以在 O(1)时间下访问数组中的任意元素。链表则不然，程序需要<strong>从头节点出发</strong>，逐个向后遍历，直至找到目标节点，时间复杂度为 O(n)。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 访问链表中索引为 index 的节点 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">access</span><span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> index)</span></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;index;i++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(head==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>        &#125;<br>        head=head-&gt;next;<br>        <span class=\"hljs-comment\">//通过索引值i进行遍历计数</span><br>        <span class=\"hljs-comment\">//head指针不断后移，进行迭代，直至索引值</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"查找节点\">查找节点</h4>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-bc5bc4b6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-bc5bc4b6\">\n        <div class=\"fold-arrow\">▶</div> Wrong Version\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-bc5bc4b6\">\n        <div class=\"fold-content\">\n          <p>❌❌❌</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(head!=<span class=\"hljs-literal\">nullptr</span>&amp;&amp;head-&gt;val!=target)&#123;<br>        head=head-&gt;next;<br>        i++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>❌❌❌<br>未检验是否找到目标节点</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span> <span class=\"hljs-params\">(Node* head,<span class=\"hljs-type\">int</span> target)</span></span>&#123;<br>    <span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">while</span>(head!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>        <span class=\"hljs-keyword\">if</span>(head-&gt;val==target)&#123;<br>            <span class=\"hljs-keyword\">return</span> index;<br>        &#125;<br>        head=head-&gt;next;<br>        index++;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Array-VS-Linkedlist\">Array  VS.  Linkedlist</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">存储方式</td>\n<td style=\"text-align:center\">连续内存空间</td>\n<td style=\"text-align:center\">分散内存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容量扩展</td>\n<td style=\"text-align:center\">长度不可变</td>\n<td style=\"text-align:center\">可灵活扩展</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存效率</td>\n<td style=\"text-align:center\">元素占用内存少、但可能浪费空间</td>\n<td style=\"text-align:center\">元素占用内存多</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">访问元素</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"常见链表类型\">常见链表类型</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/kindoflinkedlist.png?raw=true\" alt=\"常见链表种类\"></p>\n<ul>\n<li>\n<p><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</p>\n</li>\n<li>\n<p><strong>环形链表</strong>：如果我们令<strong>单向链表的尾节点指向头节点</strong>（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>    <span class=\"hljs-type\">int</span> val;<br>    Node* next;<br>    <span class=\"hljs-built_in\">Node</span>(x):<span class=\"hljs-built_in\">val</span>(x),<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>&#125;;<br>Node* head=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">1</span>);<br><br>   ...<br>   ...<br>   ...<br><br>   Node* tail=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(<span class=\"hljs-number\">5</span>);<br>   tail-&gt;next=head;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>双向链表</strong>：与单向链表相比，双向链表<strong>记录了两个方向的引用</strong>。双向链表的节点定义同时包含指向<strong>后继节点</strong>和<strong>前驱节点</strong>指针。相较于单向链表，双向链表更具<strong>灵活性</strong>，可以<strong>朝两个方向遍历链表</strong>，但相应地也需要占用更多的内存空间。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>&#123;<br>    <span class=\"hljs-type\">int</span> val;<br>    Node* next;<br>    Node* prev;<br>    <span class=\"hljs-built_in\">Node</span>(x): <span class=\"hljs-built_in\">val</span>(x),<span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>),<span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"计算机存储设备\">计算机存储设备</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">硬盘</th>\n<th style=\"text-align:center\">内存</th>\n<th style=\"text-align:center\">缓存</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">用途</td>\n<td style=\"text-align:center\">长期存储数据，包括操作系统、程序、文件等</td>\n<td style=\"text-align:center\">临时存储当前运行的程序和正在处理的数据</td>\n<td style=\"text-align:center\">存储经常访问的数据和指令，减少 CPU 访问内存的次数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">易失性</td>\n<td style=\"text-align:center\">断电后数据不会丢失</td>\n<td style=\"text-align:center\">断电后数据会丢失</td>\n<td style=\"text-align:center\">断电后数据会丢失</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容量</td>\n<td style=\"text-align:center\">较大，TB 级别</td>\n<td style=\"text-align:center\">较小，GB 级别</td>\n<td style=\"text-align:center\">非常小，MB 级别</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">速度</td>\n<td style=\"text-align:center\">较慢，几百到几千 MB/s</td>\n<td style=\"text-align:center\">较快，几十 GB/s</td>\n<td style=\"text-align:center\">非常快，几十到几百 GB/s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">价格（人民币）</td>\n<td style=\"text-align:center\">较便宜，几毛到几元 / GB</td>\n<td style=\"text-align:center\">较贵，几十到几百元 / GB</td>\n<td style=\"text-align:center\">非常贵，随 CPU 打包计价</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>硬盘</strong>用于<strong>长期存储大量数据</strong></li>\n<li><strong>内存</strong>用于<strong>临时存储程序运行中正在处理的数据</strong></li>\n<li><strong>缓存</strong>用于<strong>存储经常访问的数据和指令</strong></li>\n</ul>\n<h2 id=\"Conclusion\">Conclusion</h2>\n<ol>\n<li><strong>数组要求相同类型的元素，而在链表中不强调相同类型！</strong></li>\n</ol>\n<ul>\n<li>链表由节点组成，节点之间通过指针连接，各个节点可以<strong>存储不同类型的数据</strong>，例如 int、double、string、object 等。</li>\n<li>相对地，数组元素则必须是相同类型的，这样才能<strong>通过计算偏移量来获取对应元素位置</strong>。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 。</li>\n</ul>\n"},{"title":"Hashtable","date":"2025-08-26T04:07:53.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/Hashtable.png?raw=true","category_bar":true,"description":"This article explores some of the most essential sorting algorithms in Datastructure!","math":true,"_content":"\n## Hashtable\n\n&emsp;&emsp;**哈希表**（hash table），又称**散列表**，它通过建立**键key**与**值value**之间的**映射**，实现高效的**元素查询**。具体而言，我们向哈希表中输入一个键 key,则可以在 $O(1)$ 时间内获取对应的值value 。\n\n同时数组和链表也可以实现查询功能，元素查询效率对比如图表所示：\n\n| 操作     | 数组    | 链表    | 哈希表 |\n| :-------: | :------: | :------: | :-----: |\n| 查找元素 | O(n) | O(n) | O(1) |\n| 添加元素 | O(1) | O(1) | O(1) |\n| 删除元素 | O(n) | O(n) | O(1) |\n\n可以发现，在哈希表中进行**增删查改**的时间复杂度都是 $O(1)$ ，非常高效。\n\n### Hashtable in STL\n[详情请看这篇博客Problem A的注释](https://richard110206.github.io/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/)\n\n### 哈希表的实现\n&emsp;&emsp;我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将**数组中的每个空位**称为**桶**（bucket），每个桶可**存储一个键值对**。因此，查询操作就是找到key对应的桶，并在桶中获取value。\n\n&emsp;&emsp;这是通过**哈希函数**（hash function）实现的，它能将一个较大的输入空间**映射**到一个较小的输出空间。在哈希表中，输入空间是所有key，输出空间是所有桶（**数组索引**）。换句话说，输入一个key，我们可以通过哈希函数得到该key对应的键值对**在数组中的存储位置**。\n\n输入一个key，哈希函数的计算过程分为以下两步。\n1. 通过某种**哈希算法**hash()计算得到**哈希值**。\n2. 将**哈希值对桶数量（数组长度）capacity 取模**，从而获取该key对应的数组索引index。\n\n```\nindex = hash(key) % capacity\n```\n\n随后，我们就可以利用index在哈希表中访问对应的桶，从而获取value。\n\n```cpp\n/* 键值对 */\nstruct Pair {\n  public:\n    int key;\n    string val;\n    Pair(int key, string val) {\n        this->key = key;\n        this->val = val;\n    }\n};\n\n/* 基于数组实现的哈希表 */\nclass ArrayHashMap {\n  private:\n    vector<Pair *> buckets;\n\n  public:\n    ArrayHashMap() {\n        // 初始化数组，包含 100 个桶\n        buckets = vector<Pair *>(100);\n    }\n\n    ~ArrayHashMap() {\n        // 释放内存\n        for (const auto &bucket : buckets) {\n            delete bucket;\n        }\n        buckets.clear();\n    }\n\n    /* 哈希函数 */\n    int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* 查询操作 */\n    string get(int key) {\n        int index = hashFunc(key);\n        Pair *pair = buckets[index];\n        if (pair == nullptr)\n            return \"\";\n        return pair->val;\n    }\n\n    /* 添加操作 */\n    void put(int key, string val) {\n        Pair *pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* 删除操作 */\n    void remove(int key) {\n        int index = hashFunc(key);\n        // 释放内存并置为 nullptr\n        delete buckets[index];\n        buckets[index] = nullptr;\n    }\n\n    /* 获取所有键值对 */\n    vector<Pair *> pairSet() {\n        vector<Pair *> pairSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                pairSet.push_back(pair);\n            }\n        }\n        return pairSet;\n    }\n\n    /* 获取所有键 */\n    vector<int> keySet() {\n        vector<int> keySet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                keySet.push_back(pair->key);\n            }\n        }\n        return keySet;\n    }\n\n    /* 获取所有值 */\n    vector<string> valueSet() {\n        vector<string> valueSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                valueSet.push_back(pair->val);\n            }\n        }\n        return valueSet;\n    }\n\n    /* 打印哈希表 */\n    void print() {\n        for (Pair *kv : pairSet()) {\n            cout << kv->key << \" -> \" << kv->val << endl;\n        }\n    }\n};\n```\n\n\n### 哈希冲突\n&emsp;&emsp;从本质上看，哈希函数的作用是将所有 key 构成的**输入空间映射到数组所有索引构成的输出空间**，而输入空间往往远大于输出空间。因此，理论上一定存在“**多个输入对应相同输出**”的情况,我们将这种多个输入对应同一输出的情况称为**哈希冲突**（hash collision）。\n&emsp;&emsp;哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低。为了提升效率，我们可以采用以下策略：\n\n1. **改良哈希表数据结构**，使得哈希表可以在出现哈希冲突时正常工作。\n- **“链式地址”**\n- **“开放寻址”**\n2. 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n#### 链式地址\n&emsp;&emsp;在原始哈希表中，每个桶仅能存储一个键值对。**链式地址**（separate chaining）将**单个元素转换为链表**，将键值对作为链表节点，将所有**发生冲突的键值对都存储在同一链表中**。\n\n![链式地址哈希表](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/linkedlisthash.png?raw=true)\n\n&emsp;&emsp;基于链式地址实现的哈希表，需要通过哈希函数**访问链表头节点**，**遍历链表到目标节点**在进行增删改查的操作。\n\n{%note info%}\n**Limitations**\n\n- **占用空间增大**：链表包含节点指针，它相比数组更加**耗费内存空间**。\n- **查询效率降低**：因为需要**线性遍历链表**来查找对应元素。\n{%endnote%}\n\n\n```cpp\n/* 链式地址哈希表 */\nclass HashMapChaining {\n  private:\n    int size;                       // 键值对数量\n    int capacity;                   // 哈希表容量\n    double loadThres;               // 触发扩容的负载因子阈值\n    int extendRatio;                // 扩容倍数\n    vector<vector<Pair *>> buckets; // 桶数组\n\n  public:\n    /* 构造方法 */\n    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) {\n        buckets.resize(capacity);\n    }\n\n    /* 析构方法 */\n    ~HashMapChaining() {\n        for (auto &bucket : buckets) {\n            for (Pair *pair : bucket) {\n                // 释放内存\n                delete pair;\n            }\n        }\n    }\n\n    /* 哈希函数 */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* 负载因子 */\n    double loadFactor() {\n        return (double)size / (double)capacity;\n    }\n\n    /* 查询操作 */\n    string get(int key) {\n        int index = hashFunc(key);\n        // 遍历桶，若找到 key ，则返回对应 val\n        for (Pair *pair : buckets[index]) {\n            if (pair->key == key) {\n                return pair->val;\n            }\n        }\n        // 若未找到 key ，则返回空字符串\n        return \"\";\n    }\n\n    /* 添加操作 */\n    void put(int key, string val) {\n        // 当负载因子超过阈值时，执行扩容\n        if (loadFactor() > loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        // 遍历桶，若遇到指定 key ，则更新对应 val 并返回\n        for (Pair *pair : buckets[index]) {\n            if (pair->key == key) {\n                pair->val = val;\n                return;\n            }\n        }\n        // 若无该 key ，则将键值对添加至尾部\n        buckets[index].push_back(new Pair(key, val));\n        size++;\n    }\n\n    /* 删除操作 */\n    void remove(int key) {\n        int index = hashFunc(key);\n        auto &bucket = buckets[index];\n        // 遍历桶，从中删除键值对\n        for (int i = 0; i < bucket.size(); i++) {\n            if (bucket[i]->key == key) {\n                Pair *tmp = bucket[i];\n                bucket.erase(bucket.begin() + i); // 从中删除键值对\n                delete tmp;                       // 释放内存\n                size--;\n                return;\n            }\n        }\n    }\n\n    /* 扩容哈希表 */\n    void extend() {\n        // 暂存原哈希表\n        vector<vector<Pair *>> bucketsTmp = buckets;\n        // 初始化扩容后的新哈希表\n        capacity *= extendRatio;\n        buckets.clear();\n        buckets.resize(capacity);\n        size = 0;\n        // 将键值对从原哈希表搬运至新哈希表\n        for (auto &bucket : bucketsTmp) {\n            for (Pair *pair : bucket) {\n                put(pair->key, pair->val);\n                // 释放内存\n                delete pair;\n            }\n        }\n    }\n\n    /* 打印哈希表 */\n    void print() {\n        for (auto &bucket : buckets) {\n            cout << \"[\";\n            for (Pair *pair : bucket) {\n                cout << pair->key << \" -> \" << pair->val << \", \";\n            }\n            cout << \"]\\n\";\n        }\n    }\n};\n```\n\n\n#### 开放寻址\n开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括**线性探测**、**平方探测**和**多次哈希**等。\n\n1. **线性探测**\n\n&emsp;&emsp;通过哈希函数计算桶索引，若发现桶内已有元素，则**从冲突位置向后线性遍历**（步长通常为1，**固定步长索引**），直至找到空桶（none）/目标元素。\n\n&emsp;&emsp;然而，线性探测容易产生“**聚集现象**”。具体来说，**数组中连续被占用的位置越长**，这些连续位置**发生哈希冲突的可能性越大**，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作**效率劣化**。\n\n***\n\n2. **平方探测**\n&emsp;&emsp;平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测**不是简单地跳过一个固定的步数**，而是跳过“**探测次数的平方**”的步数，即1、4、9......步。\n\n{%note info%}\n**Advantages**\n- 平方探测通过跳过探测次数平方的距离，试图**缓解线性探测的聚集效应**。\n- 平方探测会跳过更大的距离来寻找空位置，有助于**数据分布得更加均匀**。\n{%endnote%}\n{%note info%}\n**Limitations**\n- **仍然存在聚集现象**，即某些位置比其他位置更容易被占用。\n- 由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能**无法访问**到它。\n{%endnote%}\n\n***\n\n3. **多次哈希**\n顾名思义，多次哈希方法**使用多个哈希函数** $f(x),g(x),k(x)$ 进行探测。\n\n***\n\n{%note danger%}\n:warning:注意：**开放寻址**哈希表都存在“**不能直接删除元素**”的问题。\n\n&emsp;&emsp;这是因为删除元素会在数组内产生一个空桶`None`，而当查询元素时，线性探测到该空桶就会返回，因此在**该空桶之下的元素都无法再被访问到**，程序可能**误判这些元素不存在**。\n\n&emsp;&emsp;为了解决该问题，我们可以采用**懒删除机制**：它不直接从哈希表中移除元素，而是利用一个常量`TOMBSTONE`来标记这个桶。在该机制下，`None`和`TOMBSTONE`都代表空桶，都可以放置键值对。但不同的是，线性探测到`TOMBSTONE`时应该**继续遍历**，因为其之下可能还存在键值对。\n\n&emsp;&emsp;然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着`TOMBSTONE`的增加，搜索时间也会增加，因为线性探测可能需要跳过多个`TOMBSTONE`才能找到目标元素。\n\n&emsp;&emsp;为此，考虑在线性探测中记录遇到的首个`TOMBSTONE`的索引，并将搜索到的目标元素与该`TOMBSTONE`交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而**优化查询效率**。\n{%endnote%}\n***\n\n### 哈希扩容\n&emsp;&emsp;哈希表容量越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。\n\n- **类似于数组扩容**，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时\n- 哈希表容量 capacity 改变，我们需要通过哈希函数来**重新计算所有键值对的存储位置**，这进一步增加了扩容过程的计算开销\n  \n为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\n\n&emsp;&emsp;**负载因子**（load factor）是哈希表的一个重要概念，其定义为**哈希表的元素数量除以桶数量**，用于**衡量哈希冲突的严重程度**，也常作为哈希表扩容的触发条件。例如，当负载因子超过 0.75 时，我们可以考虑扩容哈希表。\n\n### 哈希算法\n\n&emsp;&emsp;前面的方法只能处理哈希冲突，并不能从**本质上**减少哈希冲突。如果哈希冲突**过于频繁**，哈希表的性能则会急剧劣化。对于链式地址哈希表，理想情况下**键值对均匀分布**在各个桶中，达到最佳查询效率；最差情况下所有键值对**都存储到同一个桶中**，时间复杂度退化至$O(n)$。\n\n![链式存储最好最坏情况](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/condition.png?raw=true)\n\n我们制定出的哈希算法应达到以下目标：\n- **确定性**：对于相同的输入，哈希算法应**始终产生相同的输出**。这样才能确保哈希表是可靠的。\n- **效率高**：计算哈希值的过程应该**足够快**。**计算开销越小**，哈希表的**实用性越高**。\n- **均匀分布**：哈希算法应使得**键值对均匀分布在哈希表**中。分布越均匀，哈希冲突的概率就越低。\n\n{%fold into @为什么不使用哈希函数$f(x)=x$呢？这样就不会有冲突了！%}\n在 $f(x)=x$ 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而给定的数据空间是未知的，如果数据范围较为稀疏如学号12592、16754，那么数组的绝大部分空间都将被闲置，导致空间复杂度急剧上升。并且我们的目标是在有限的数组范围内存储较大数量的键值，也就是将一个较大的状态空间映射到一个较小的空间。\n{%endfold%}","source":"_posts/Data structure/Hashtable.md","raw":"---\ntitle: Hashtable\ndate: 2025-08-26 12:07:53\ntags: [algorithm]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/Hashtable.png?raw=true\ncategory: Data Structure\ncategory_bar: true\ndescription: This article explores some of the most essential sorting algorithms in Datastructure!\nmath: true\n---\n\n## Hashtable\n\n&emsp;&emsp;**哈希表**（hash table），又称**散列表**，它通过建立**键key**与**值value**之间的**映射**，实现高效的**元素查询**。具体而言，我们向哈希表中输入一个键 key,则可以在 $O(1)$ 时间内获取对应的值value 。\n\n同时数组和链表也可以实现查询功能，元素查询效率对比如图表所示：\n\n| 操作     | 数组    | 链表    | 哈希表 |\n| :-------: | :------: | :------: | :-----: |\n| 查找元素 | O(n) | O(n) | O(1) |\n| 添加元素 | O(1) | O(1) | O(1) |\n| 删除元素 | O(n) | O(n) | O(1) |\n\n可以发现，在哈希表中进行**增删查改**的时间复杂度都是 $O(1)$ ，非常高效。\n\n### Hashtable in STL\n[详情请看这篇博客Problem A的注释](https://richard110206.github.io/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/)\n\n### 哈希表的实现\n&emsp;&emsp;我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将**数组中的每个空位**称为**桶**（bucket），每个桶可**存储一个键值对**。因此，查询操作就是找到key对应的桶，并在桶中获取value。\n\n&emsp;&emsp;这是通过**哈希函数**（hash function）实现的，它能将一个较大的输入空间**映射**到一个较小的输出空间。在哈希表中，输入空间是所有key，输出空间是所有桶（**数组索引**）。换句话说，输入一个key，我们可以通过哈希函数得到该key对应的键值对**在数组中的存储位置**。\n\n输入一个key，哈希函数的计算过程分为以下两步。\n1. 通过某种**哈希算法**hash()计算得到**哈希值**。\n2. 将**哈希值对桶数量（数组长度）capacity 取模**，从而获取该key对应的数组索引index。\n\n```\nindex = hash(key) % capacity\n```\n\n随后，我们就可以利用index在哈希表中访问对应的桶，从而获取value。\n\n```cpp\n/* 键值对 */\nstruct Pair {\n  public:\n    int key;\n    string val;\n    Pair(int key, string val) {\n        this->key = key;\n        this->val = val;\n    }\n};\n\n/* 基于数组实现的哈希表 */\nclass ArrayHashMap {\n  private:\n    vector<Pair *> buckets;\n\n  public:\n    ArrayHashMap() {\n        // 初始化数组，包含 100 个桶\n        buckets = vector<Pair *>(100);\n    }\n\n    ~ArrayHashMap() {\n        // 释放内存\n        for (const auto &bucket : buckets) {\n            delete bucket;\n        }\n        buckets.clear();\n    }\n\n    /* 哈希函数 */\n    int hashFunc(int key) {\n        int index = key % 100;\n        return index;\n    }\n\n    /* 查询操作 */\n    string get(int key) {\n        int index = hashFunc(key);\n        Pair *pair = buckets[index];\n        if (pair == nullptr)\n            return \"\";\n        return pair->val;\n    }\n\n    /* 添加操作 */\n    void put(int key, string val) {\n        Pair *pair = new Pair(key, val);\n        int index = hashFunc(key);\n        buckets[index] = pair;\n    }\n\n    /* 删除操作 */\n    void remove(int key) {\n        int index = hashFunc(key);\n        // 释放内存并置为 nullptr\n        delete buckets[index];\n        buckets[index] = nullptr;\n    }\n\n    /* 获取所有键值对 */\n    vector<Pair *> pairSet() {\n        vector<Pair *> pairSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                pairSet.push_back(pair);\n            }\n        }\n        return pairSet;\n    }\n\n    /* 获取所有键 */\n    vector<int> keySet() {\n        vector<int> keySet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                keySet.push_back(pair->key);\n            }\n        }\n        return keySet;\n    }\n\n    /* 获取所有值 */\n    vector<string> valueSet() {\n        vector<string> valueSet;\n        for (Pair *pair : buckets) {\n            if (pair != nullptr) {\n                valueSet.push_back(pair->val);\n            }\n        }\n        return valueSet;\n    }\n\n    /* 打印哈希表 */\n    void print() {\n        for (Pair *kv : pairSet()) {\n            cout << kv->key << \" -> \" << kv->val << endl;\n        }\n    }\n};\n```\n\n\n### 哈希冲突\n&emsp;&emsp;从本质上看，哈希函数的作用是将所有 key 构成的**输入空间映射到数组所有索引构成的输出空间**，而输入空间往往远大于输出空间。因此，理论上一定存在“**多个输入对应相同输出**”的情况,我们将这种多个输入对应同一输出的情况称为**哈希冲突**（hash collision）。\n&emsp;&emsp;哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低。为了提升效率，我们可以采用以下策略：\n\n1. **改良哈希表数据结构**，使得哈希表可以在出现哈希冲突时正常工作。\n- **“链式地址”**\n- **“开放寻址”**\n2. 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。\n\n#### 链式地址\n&emsp;&emsp;在原始哈希表中，每个桶仅能存储一个键值对。**链式地址**（separate chaining）将**单个元素转换为链表**，将键值对作为链表节点，将所有**发生冲突的键值对都存储在同一链表中**。\n\n![链式地址哈希表](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/linkedlisthash.png?raw=true)\n\n&emsp;&emsp;基于链式地址实现的哈希表，需要通过哈希函数**访问链表头节点**，**遍历链表到目标节点**在进行增删改查的操作。\n\n{%note info%}\n**Limitations**\n\n- **占用空间增大**：链表包含节点指针，它相比数组更加**耗费内存空间**。\n- **查询效率降低**：因为需要**线性遍历链表**来查找对应元素。\n{%endnote%}\n\n\n```cpp\n/* 链式地址哈希表 */\nclass HashMapChaining {\n  private:\n    int size;                       // 键值对数量\n    int capacity;                   // 哈希表容量\n    double loadThres;               // 触发扩容的负载因子阈值\n    int extendRatio;                // 扩容倍数\n    vector<vector<Pair *>> buckets; // 桶数组\n\n  public:\n    /* 构造方法 */\n    HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3.0), extendRatio(2) {\n        buckets.resize(capacity);\n    }\n\n    /* 析构方法 */\n    ~HashMapChaining() {\n        for (auto &bucket : buckets) {\n            for (Pair *pair : bucket) {\n                // 释放内存\n                delete pair;\n            }\n        }\n    }\n\n    /* 哈希函数 */\n    int hashFunc(int key) {\n        return key % capacity;\n    }\n\n    /* 负载因子 */\n    double loadFactor() {\n        return (double)size / (double)capacity;\n    }\n\n    /* 查询操作 */\n    string get(int key) {\n        int index = hashFunc(key);\n        // 遍历桶，若找到 key ，则返回对应 val\n        for (Pair *pair : buckets[index]) {\n            if (pair->key == key) {\n                return pair->val;\n            }\n        }\n        // 若未找到 key ，则返回空字符串\n        return \"\";\n    }\n\n    /* 添加操作 */\n    void put(int key, string val) {\n        // 当负载因子超过阈值时，执行扩容\n        if (loadFactor() > loadThres) {\n            extend();\n        }\n        int index = hashFunc(key);\n        // 遍历桶，若遇到指定 key ，则更新对应 val 并返回\n        for (Pair *pair : buckets[index]) {\n            if (pair->key == key) {\n                pair->val = val;\n                return;\n            }\n        }\n        // 若无该 key ，则将键值对添加至尾部\n        buckets[index].push_back(new Pair(key, val));\n        size++;\n    }\n\n    /* 删除操作 */\n    void remove(int key) {\n        int index = hashFunc(key);\n        auto &bucket = buckets[index];\n        // 遍历桶，从中删除键值对\n        for (int i = 0; i < bucket.size(); i++) {\n            if (bucket[i]->key == key) {\n                Pair *tmp = bucket[i];\n                bucket.erase(bucket.begin() + i); // 从中删除键值对\n                delete tmp;                       // 释放内存\n                size--;\n                return;\n            }\n        }\n    }\n\n    /* 扩容哈希表 */\n    void extend() {\n        // 暂存原哈希表\n        vector<vector<Pair *>> bucketsTmp = buckets;\n        // 初始化扩容后的新哈希表\n        capacity *= extendRatio;\n        buckets.clear();\n        buckets.resize(capacity);\n        size = 0;\n        // 将键值对从原哈希表搬运至新哈希表\n        for (auto &bucket : bucketsTmp) {\n            for (Pair *pair : bucket) {\n                put(pair->key, pair->val);\n                // 释放内存\n                delete pair;\n            }\n        }\n    }\n\n    /* 打印哈希表 */\n    void print() {\n        for (auto &bucket : buckets) {\n            cout << \"[\";\n            for (Pair *pair : bucket) {\n                cout << pair->key << \" -> \" << pair->val << \", \";\n            }\n            cout << \"]\\n\";\n        }\n    }\n};\n```\n\n\n#### 开放寻址\n开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括**线性探测**、**平方探测**和**多次哈希**等。\n\n1. **线性探测**\n\n&emsp;&emsp;通过哈希函数计算桶索引，若发现桶内已有元素，则**从冲突位置向后线性遍历**（步长通常为1，**固定步长索引**），直至找到空桶（none）/目标元素。\n\n&emsp;&emsp;然而，线性探测容易产生“**聚集现象**”。具体来说，**数组中连续被占用的位置越长**，这些连续位置**发生哈希冲突的可能性越大**，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作**效率劣化**。\n\n***\n\n2. **平方探测**\n&emsp;&emsp;平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测**不是简单地跳过一个固定的步数**，而是跳过“**探测次数的平方**”的步数，即1、4、9......步。\n\n{%note info%}\n**Advantages**\n- 平方探测通过跳过探测次数平方的距离，试图**缓解线性探测的聚集效应**。\n- 平方探测会跳过更大的距离来寻找空位置，有助于**数据分布得更加均匀**。\n{%endnote%}\n{%note info%}\n**Limitations**\n- **仍然存在聚集现象**，即某些位置比其他位置更容易被占用。\n- 由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能**无法访问**到它。\n{%endnote%}\n\n***\n\n3. **多次哈希**\n顾名思义，多次哈希方法**使用多个哈希函数** $f(x),g(x),k(x)$ 进行探测。\n\n***\n\n{%note danger%}\n:warning:注意：**开放寻址**哈希表都存在“**不能直接删除元素**”的问题。\n\n&emsp;&emsp;这是因为删除元素会在数组内产生一个空桶`None`，而当查询元素时，线性探测到该空桶就会返回，因此在**该空桶之下的元素都无法再被访问到**，程序可能**误判这些元素不存在**。\n\n&emsp;&emsp;为了解决该问题，我们可以采用**懒删除机制**：它不直接从哈希表中移除元素，而是利用一个常量`TOMBSTONE`来标记这个桶。在该机制下，`None`和`TOMBSTONE`都代表空桶，都可以放置键值对。但不同的是，线性探测到`TOMBSTONE`时应该**继续遍历**，因为其之下可能还存在键值对。\n\n&emsp;&emsp;然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着`TOMBSTONE`的增加，搜索时间也会增加，因为线性探测可能需要跳过多个`TOMBSTONE`才能找到目标元素。\n\n&emsp;&emsp;为此，考虑在线性探测中记录遇到的首个`TOMBSTONE`的索引，并将搜索到的目标元素与该`TOMBSTONE`交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而**优化查询效率**。\n{%endnote%}\n***\n\n### 哈希扩容\n&emsp;&emsp;哈希表容量越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。\n\n- **类似于数组扩容**，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时\n- 哈希表容量 capacity 改变，我们需要通过哈希函数来**重新计算所有键值对的存储位置**，这进一步增加了扩容过程的计算开销\n  \n为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。\n\n&emsp;&emsp;**负载因子**（load factor）是哈希表的一个重要概念，其定义为**哈希表的元素数量除以桶数量**，用于**衡量哈希冲突的严重程度**，也常作为哈希表扩容的触发条件。例如，当负载因子超过 0.75 时，我们可以考虑扩容哈希表。\n\n### 哈希算法\n\n&emsp;&emsp;前面的方法只能处理哈希冲突，并不能从**本质上**减少哈希冲突。如果哈希冲突**过于频繁**，哈希表的性能则会急剧劣化。对于链式地址哈希表，理想情况下**键值对均匀分布**在各个桶中，达到最佳查询效率；最差情况下所有键值对**都存储到同一个桶中**，时间复杂度退化至$O(n)$。\n\n![链式存储最好最坏情况](https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/condition.png?raw=true)\n\n我们制定出的哈希算法应达到以下目标：\n- **确定性**：对于相同的输入，哈希算法应**始终产生相同的输出**。这样才能确保哈希表是可靠的。\n- **效率高**：计算哈希值的过程应该**足够快**。**计算开销越小**，哈希表的**实用性越高**。\n- **均匀分布**：哈希算法应使得**键值对均匀分布在哈希表**中。分布越均匀，哈希冲突的概率就越低。\n\n{%fold into @为什么不使用哈希函数$f(x)=x$呢？这样就不会有冲突了！%}\n在 $f(x)=x$ 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而给定的数据空间是未知的，如果数据范围较为稀疏如学号12592、16754，那么数组的绝大部分空间都将被闲置，导致空间复杂度急剧上升。并且我们的目标是在有限的数组范围内存储较大数量的键值，也就是将一个较大的状态空间映射到一个较小的空间。\n{%endfold%}","slug":"Data structure/Hashtable","published":1,"updated":"2025-08-26T16:33:56.821Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcn000t40w3gvscgf9j","content":"<h2 id=\"Hashtable\">Hashtable</h2>\n<p>  <strong>哈希表</strong>（hash table），又称<strong>散列表</strong>，它通过建立<strong>键key</strong>与<strong>值value</strong>之间的<strong>映射</strong>，实现高效的<strong>元素查询</strong>。具体而言，我们向哈希表中输入一个键 key,则可以在 $O(1)$ 时间内获取对应的值value 。</p>\n<p>同时数组和链表也可以实现查询功能，元素查询效率对比如图表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n<th style=\"text-align:center\">哈希表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查找元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加元素</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现，在哈希表中进行<strong>增删查改</strong>的时间复杂度都是 $O(1)$ ，非常高效。</p>\n<h3 id=\"Hashtable-in-STL\">Hashtable in STL</h3>\n<p><a href=\"https://richard110206.github.io/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/\">详情请看这篇博客Problem A的注释</a></p>\n<h3 id=\"哈希表的实现\">哈希表的实现</h3>\n<p>  我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将<strong>数组中的每个空位</strong>称为<strong>桶</strong>（bucket），每个桶可<strong>存储一个键值对</strong>。因此，查询操作就是找到key对应的桶，并在桶中获取value。</p>\n<p>  这是通过<strong>哈希函数</strong>（hash function）实现的，它能将一个较大的输入空间<strong>映射</strong>到一个较小的输出空间。在哈希表中，输入空间是所有key，输出空间是所有桶（<strong>数组索引</strong>）。换句话说，输入一个key，我们可以通过哈希函数得到该key对应的键值对<strong>在数组中的存储位置</strong>。</p>\n<p>输入一个key，哈希函数的计算过程分为以下两步。</p>\n<ol>\n<li>通过某种<strong>哈希算法</strong>hash()计算得到<strong>哈希值</strong>。</li>\n<li>将<strong>哈希值对桶数量（数组长度）capacity 取模</strong>，从而获取该key对应的数组索引index。</li>\n</ol>\n<figure class=\"highlight abnf\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">index</span> <span class=\"hljs-operator\">=</span> hash(key) % capacity<br></code></pre></td></tr></tbody></table></figure>\n<p>随后，我们就可以利用index在哈希表中访问对应的桶，从而获取value。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 键值对 */</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pair</span> {<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> key;<br>    string val;<br>    <span class=\"hljs-built_in\">Pair</span>(<span class=\"hljs-type\">int</span> key, string val) {<br>        <span class=\"hljs-keyword\">this</span>-&gt;key = key;<br>        <span class=\"hljs-keyword\">this</span>-&gt;val = val;<br>    }<br>};<br><br><span class=\"hljs-comment\">/* 基于数组实现的哈希表 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayHashMap</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    vector&lt;Pair *&gt; buckets;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayHashMap</span>() {<br>        <span class=\"hljs-comment\">// 初始化数组，包含 100 个桶</span><br>        buckets = <span class=\"hljs-built_in\">vector</span>&lt;Pair *&gt;(<span class=\"hljs-number\">100</span>);<br>    }<br><br>    ~<span class=\"hljs-built_in\">ArrayHashMap</span>() {<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) {<br>            <span class=\"hljs-keyword\">delete</span> bucket;<br>        }<br>        buckets.<span class=\"hljs-built_in\">clear</span>();<br>    }<br><br>    <span class=\"hljs-comment\">/* 哈希函数 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hashFunc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-type\">int</span> index = key % <span class=\"hljs-number\">100</span>;<br>        <span class=\"hljs-keyword\">return</span> index;<br>    }<br><br>    <span class=\"hljs-comment\">/* 查询操作 */</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        Pair *pair = buckets[index];<br>        <span class=\"hljs-keyword\">if</span> (pair == <span class=\"hljs-literal\">nullptr</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>;<br>        <span class=\"hljs-keyword\">return</span> pair-&gt;val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 添加操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, string val)</span> </span>{<br>        Pair *pair = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Pair</span>(key, val);<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        buckets[index] = pair;<br>    }<br><br>    <span class=\"hljs-comment\">/* 删除操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 释放内存并置为 nullptr</span><br>        <span class=\"hljs-keyword\">delete</span> buckets[index];<br>        buckets[index] = <span class=\"hljs-literal\">nullptr</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取所有键值对 */</span><br>    <span class=\"hljs-function\">vector&lt;Pair *&gt; <span class=\"hljs-title\">pairSet</span><span class=\"hljs-params\">()</span> </span>{<br>        vector&lt;Pair *&gt; pairSet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) {<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) {<br>                pairSet.<span class=\"hljs-built_in\">push_back</span>(pair);<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> pairSet;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取所有键 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">keySet</span><span class=\"hljs-params\">()</span> </span>{<br>        vector&lt;<span class=\"hljs-type\">int</span>&gt; keySet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) {<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) {<br>                keySet.<span class=\"hljs-built_in\">push_back</span>(pair-&gt;key);<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> keySet;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取所有值 */</span><br>    <span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">valueSet</span><span class=\"hljs-params\">()</span> </span>{<br>        vector&lt;string&gt; valueSet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) {<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) {<br>                valueSet.<span class=\"hljs-built_in\">push_back</span>(pair-&gt;val);<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> valueSet;<br>    }<br><br>    <span class=\"hljs-comment\">/* 打印哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">for</span> (Pair *kv : <span class=\"hljs-built_in\">pairSet</span>()) {<br>            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class=\"hljs-string\">\" -&gt; \"</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"哈希冲突\">哈希冲突</h3>\n<p>  从本质上看，哈希函数的作用是将所有 key 构成的<strong>输入空间映射到数组所有索引构成的输出空间</strong>，而输入空间往往远大于输出空间。因此，理论上一定存在“<strong>多个输入对应相同输出</strong>”的情况,我们将这种多个输入对应同一输出的情况称为<strong>哈希冲突</strong>（hash collision）。<br>\n  哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低。为了提升效率，我们可以采用以下策略：</p>\n<ol>\n<li><strong>改良哈希表数据结构</strong>，使得哈希表可以在出现哈希冲突时正常工作。</li>\n</ol>\n<ul>\n<li><strong>“链式地址”</strong></li>\n<li><strong>“开放寻址”</strong></li>\n</ul>\n<ol start=\"2\">\n<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>\n</ol>\n<h4 id=\"链式地址\">链式地址</h4>\n<p>  在原始哈希表中，每个桶仅能存储一个键值对。<strong>链式地址</strong>（separate chaining）将<strong>单个元素转换为链表</strong>，将键值对作为链表节点，将所有<strong>发生冲突的键值对都存储在同一链表中</strong>。</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/linkedlisthash.png?raw=true\" alt=\"链式地址哈希表\"></p>\n<p>  基于链式地址实现的哈希表，需要通过哈希函数<strong>访问链表头节点</strong>，<strong>遍历链表到目标节点</strong>在进行增删改查的操作。</p>\n<div class=\"note note-info\">\n            <p><strong>Limitations</strong></p><ul><li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加<strong>耗费内存空间</strong>。</li><li><strong>查询效率降低</strong>：因为需要<strong>线性遍历链表</strong>来查找对应元素。</li></ul>\n          </div>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 链式地址哈希表 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HashMapChaining</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> size;                       <span class=\"hljs-comment\">// 键值对数量</span><br>    <span class=\"hljs-type\">int</span> capacity;                   <span class=\"hljs-comment\">// 哈希表容量</span><br>    <span class=\"hljs-type\">double</span> loadThres;               <span class=\"hljs-comment\">// 触发扩容的负载因子阈值</span><br>    <span class=\"hljs-type\">int</span> extendRatio;                <span class=\"hljs-comment\">// 扩容倍数</span><br>    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class=\"hljs-comment\">// 桶数组</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">HashMapChaining</span>() : <span class=\"hljs-built_in\">size</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">capacity</span>(<span class=\"hljs-number\">4</span>), <span class=\"hljs-built_in\">loadThres</span>(<span class=\"hljs-number\">2.0</span> / <span class=\"hljs-number\">3.0</span>), <span class=\"hljs-built_in\">extendRatio</span>(<span class=\"hljs-number\">2</span>) {<br>        buckets.<span class=\"hljs-built_in\">resize</span>(capacity);<br>    }<br><br>    <span class=\"hljs-comment\">/* 析构方法 */</span><br>    ~<span class=\"hljs-built_in\">HashMapChaining</span>() {<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) {<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) {<br>                <span class=\"hljs-comment\">// 释放内存</span><br>                <span class=\"hljs-keyword\">delete</span> pair;<br>            }<br>        }<br>    }<br><br>    <span class=\"hljs-comment\">/* 哈希函数 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hashFunc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> key % capacity;<br>    }<br><br>    <span class=\"hljs-comment\">/* 负载因子 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">loadFactor</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)size / (<span class=\"hljs-type\">double</span>)capacity;<br>    }<br><br>    <span class=\"hljs-comment\">/* 查询操作 */</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 遍历桶，若找到 key ，则返回对应 val</span><br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets[index]) {<br>            <span class=\"hljs-keyword\">if</span> (pair-&gt;key == key) {<br>                <span class=\"hljs-keyword\">return</span> pair-&gt;val;<br>            }<br>        }<br>        <span class=\"hljs-comment\">// 若未找到 key ，则返回空字符串</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 添加操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, string val)</span> </span>{<br>        <span class=\"hljs-comment\">// 当负载因子超过阈值时，执行扩容</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">loadFactor</span>() &gt; loadThres) {<br>            <span class=\"hljs-built_in\">extend</span>();<br>        }<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span><br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets[index]) {<br>            <span class=\"hljs-keyword\">if</span> (pair-&gt;key == key) {<br>                pair-&gt;val = val;<br>                <span class=\"hljs-keyword\">return</span>;<br>            }<br>        }<br>        <span class=\"hljs-comment\">// 若无该 key ，则将键值对添加至尾部</span><br>        buckets[index].<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Pair</span>(key, val));<br>        size++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 删除操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>{<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-keyword\">auto</span> &amp;bucket = buckets[index];<br>        <span class=\"hljs-comment\">// 遍历桶，从中删除键值对</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; bucket.<span class=\"hljs-built_in\">size</span>(); i++) {<br>            <span class=\"hljs-keyword\">if</span> (bucket[i]-&gt;key == key) {<br>                Pair *tmp = bucket[i];<br>                bucket.<span class=\"hljs-built_in\">erase</span>(bucket.<span class=\"hljs-built_in\">begin</span>() + i); <span class=\"hljs-comment\">// 从中删除键值对</span><br>                <span class=\"hljs-keyword\">delete</span> tmp;                       <span class=\"hljs-comment\">// 释放内存</span><br>                size--;<br>                <span class=\"hljs-keyword\">return</span>;<br>            }<br>        }<br>    }<br><br>    <span class=\"hljs-comment\">/* 扩容哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extend</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-comment\">// 暂存原哈希表</span><br>        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;<br>        <span class=\"hljs-comment\">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets.<span class=\"hljs-built_in\">clear</span>();<br>        buckets.<span class=\"hljs-built_in\">resize</span>(capacity);<br>        size = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-comment\">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : bucketsTmp) {<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) {<br>                <span class=\"hljs-built_in\">put</span>(pair-&gt;key, pair-&gt;val);<br>                <span class=\"hljs-comment\">// 释放内存</span><br>                <span class=\"hljs-keyword\">delete</span> pair;<br>            }<br>        }<br>    }<br><br>    <span class=\"hljs-comment\">/* 打印哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) {<br>            cout &lt;&lt; <span class=\"hljs-string\">\"[\"</span>;<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) {<br>                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class=\"hljs-string\">\" -&gt; \"</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class=\"hljs-string\">\", \"</span>;<br>            }<br>            cout &lt;&lt; <span class=\"hljs-string\">\"]\\n\"</span>;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"开放寻址\">开放寻址</h4>\n<p>开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括<strong>线性探测</strong>、<strong>平方探测</strong>和<strong>多次哈希</strong>等。</p>\n<ol>\n<li><strong>线性探测</strong></li>\n</ol>\n<p>  通过哈希函数计算桶索引，若发现桶内已有元素，则<strong>从冲突位置向后线性遍历</strong>（步长通常为1，<strong>固定步长索引</strong>），直至找到空桶（none）/目标元素。</p>\n<p>  然而，线性探测容易产生“<strong>聚集现象</strong>”。具体来说，<strong>数组中连续被占用的位置越长</strong>，这些连续位置<strong>发生哈希冲突的可能性越大</strong>，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作<strong>效率劣化</strong>。</p>\n<hr>\n<ol start=\"2\">\n<li><strong>平方探测</strong><br>\n  平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测<strong>不是简单地跳过一个固定的步数</strong>，而是跳过“<strong>探测次数的平方</strong>”的步数，即1、4、9…步。</li>\n</ol>\n<div class=\"note note-info\">\n            <p><strong>Advantages</strong></p><ul><li>平方探测通过跳过探测次数平方的距离，试图<strong>缓解线性探测的聚集效应</strong>。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于<strong>数据分布得更加均匀</strong>。</li></ul>\n          </div>\n<div class=\"note note-info\">\n            <p><strong>Limitations</strong></p><ul><li><strong>仍然存在聚集现象</strong>，即某些位置比其他位置更容易被占用。</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能<strong>无法访问</strong>到它。</li></ul>\n          </div>\n<hr>\n<ol start=\"3\">\n<li><strong>多次哈希</strong><br>\n顾名思义，多次哈希方法<strong>使用多个哈希函数</strong> $f(x),g(x),k(x)$ 进行探测。</li>\n</ol>\n<hr>\n<div class=\"note note-danger\">\n            <p>⚠️注意：<strong>开放寻址</strong>哈希表都存在“<strong>不能直接删除元素</strong>”的问题。</p><p>  这是因为删除元素会在数组内产生一个空桶<code>None</code>，而当查询元素时，线性探测到该空桶就会返回，因此在<strong>该空桶之下的元素都无法再被访问到</strong>，程序可能<strong>误判这些元素不存在</strong>。</p><p>  为了解决该问题，我们可以采用<strong>懒删除机制</strong>：它不直接从哈希表中移除元素，而是利用一个常量<code>TOMBSTONE</code>来标记这个桶。在该机制下，<code>None</code>和<code>TOMBSTONE</code>都代表空桶，都可以放置键值对。但不同的是，线性探测到<code>TOMBSTONE</code>时应该<strong>继续遍历</strong>，因为其之下可能还存在键值对。</p><p>  然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着<code>TOMBSTONE</code>的增加，搜索时间也会增加，因为线性探测可能需要跳过多个<code>TOMBSTONE</code>才能找到目标元素。</p><p>  为此，考虑在线性探测中记录遇到的首个<code>TOMBSTONE</code>的索引，并将搜索到的目标元素与该<code>TOMBSTONE</code>交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而<strong>优化查询效率</strong>。</p>\n          </div>\n<hr>\n<h3 id=\"哈希扩容\">哈希扩容</h3>\n<p>  哈希表容量越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。</p>\n<ul>\n<li><strong>类似于数组扩容</strong>，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时</li>\n<li>哈希表容量 capacity 改变，我们需要通过哈希函数来<strong>重新计算所有键值对的存储位置</strong>，这进一步增加了扩容过程的计算开销</li>\n</ul>\n<p>为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p>\n<p>  <strong>负载因子</strong>（load factor）是哈希表的一个重要概念，其定义为<strong>哈希表的元素数量除以桶数量</strong>，用于<strong>衡量哈希冲突的严重程度</strong>，也常作为哈希表扩容的触发条件。例如，当负载因子超过 0.75 时，我们可以考虑扩容哈希表。</p>\n<h3 id=\"哈希算法\">哈希算法</h3>\n<p>  前面的方法只能处理哈希冲突，并不能从<strong>本质上</strong>减少哈希冲突。如果哈希冲突<strong>过于频繁</strong>，哈希表的性能则会急剧劣化。对于链式地址哈希表，理想情况下<strong>键值对均匀分布</strong>在各个桶中，达到最佳查询效率；最差情况下所有键值对<strong>都存储到同一个桶中</strong>，时间复杂度退化至$O(n)$。</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/condition.png?raw=true\" alt=\"链式存储最好最坏情况\"></p>\n<p>我们制定出的哈希算法应达到以下目标：</p>\n<ul>\n<li><strong>确定性</strong>：对于相同的输入，哈希算法应<strong>始终产生相同的输出</strong>。这样才能确保哈希表是可靠的。</li>\n<li><strong>效率高</strong>：计算哈希值的过程应该<strong>足够快</strong>。<strong>计算开销越小</strong>，哈希表的<strong>实用性越高</strong>。</li>\n<li><strong>均匀分布</strong>：哈希算法应使得<strong>键值对均匀分布在哈希表</strong>中。分布越均匀，哈希冲突的概率就越低。</li>\n</ul>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-dfa96ec5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-dfa96ec5\">\n        <div class=\"fold-arrow\">▶</div>为什么不使用哈希函数$f(x)=x$呢？这样就不会有冲突了！\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-dfa96ec5\">\n        <div class=\"fold-content\">\n          <p>在 $f(x)=x$ 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而给定的数据空间是未知的，如果数据范围较为稀疏如学号12592、16754，那么数组的绝大部分空间都将被闲置，导致空间复杂度急剧上升。并且我们的目标是在有限的数组范围内存储较大数量的键值，也就是将一个较大的状态空间映射到一个较小的空间。</p>\n        </div>\n      </div>\n    </div>","excerpt":"","more":"<h2 id=\"Hashtable\">Hashtable</h2>\n<p>  <strong>哈希表</strong>（hash table），又称<strong>散列表</strong>，它通过建立<strong>键key</strong>与<strong>值value</strong>之间的<strong>映射</strong>，实现高效的<strong>元素查询</strong>。具体而言，我们向哈希表中输入一个键 key,则可以在 $O(1)$ 时间内获取对应的值value 。</p>\n<p>同时数组和链表也可以实现查询功能，元素查询效率对比如图表所示：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">操作</th>\n<th style=\"text-align:center\">数组</th>\n<th style=\"text-align:center\">链表</th>\n<th style=\"text-align:center\">哈希表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">查找元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">添加元素</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">删除元素</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现，在哈希表中进行<strong>增删查改</strong>的时间复杂度都是 $O(1)$ ，非常高效。</p>\n<h3 id=\"Hashtable-in-STL\">Hashtable in STL</h3>\n<p><a href=\"https://richard110206.github.io/2025/06/27/Data%20structure/CUMT-Datastructure-Practice-4/\">详情请看这篇博客Problem A的注释</a></p>\n<h3 id=\"哈希表的实现\">哈希表的实现</h3>\n<p>  我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将<strong>数组中的每个空位</strong>称为<strong>桶</strong>（bucket），每个桶可<strong>存储一个键值对</strong>。因此，查询操作就是找到key对应的桶，并在桶中获取value。</p>\n<p>  这是通过<strong>哈希函数</strong>（hash function）实现的，它能将一个较大的输入空间<strong>映射</strong>到一个较小的输出空间。在哈希表中，输入空间是所有key，输出空间是所有桶（<strong>数组索引</strong>）。换句话说，输入一个key，我们可以通过哈希函数得到该key对应的键值对<strong>在数组中的存储位置</strong>。</p>\n<p>输入一个key，哈希函数的计算过程分为以下两步。</p>\n<ol>\n<li>通过某种<strong>哈希算法</strong>hash()计算得到<strong>哈希值</strong>。</li>\n<li>将<strong>哈希值对桶数量（数组长度）capacity 取模</strong>，从而获取该key对应的数组索引index。</li>\n</ol>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\"><span class=\"hljs-attribute\">index</span> <span class=\"hljs-operator\">=</span> hash(key) % capacity<br></code></pre></td></tr></table></figure>\n<p>随后，我们就可以利用index在哈希表中访问对应的桶，从而获取value。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 键值对 */</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Pair</span> &#123;<br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-type\">int</span> key;<br>    string val;<br>    <span class=\"hljs-built_in\">Pair</span>(<span class=\"hljs-type\">int</span> key, string val) &#123;<br>        <span class=\"hljs-keyword\">this</span>-&gt;key = key;<br>        <span class=\"hljs-keyword\">this</span>-&gt;val = val;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/* 基于数组实现的哈希表 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayHashMap</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    vector&lt;Pair *&gt; buckets;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayHashMap</span>() &#123;<br>        <span class=\"hljs-comment\">// 初始化数组，包含 100 个桶</span><br>        buckets = <span class=\"hljs-built_in\">vector</span>&lt;Pair *&gt;(<span class=\"hljs-number\">100</span>);<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">ArrayHashMap</span>() &#123;<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) &#123;<br>            <span class=\"hljs-keyword\">delete</span> bucket;<br>        &#125;<br>        buckets.<span class=\"hljs-built_in\">clear</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 哈希函数 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hashFunc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> index = key % <span class=\"hljs-number\">100</span>;<br>        <span class=\"hljs-keyword\">return</span> index;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 查询操作 */</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        Pair *pair = buckets[index];<br>        <span class=\"hljs-keyword\">if</span> (pair == <span class=\"hljs-literal\">nullptr</span>)<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>        <span class=\"hljs-keyword\">return</span> pair-&gt;val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 添加操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, string val)</span> </span>&#123;<br>        Pair *pair = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Pair</span>(key, val);<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        buckets[index] = pair;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 删除操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 释放内存并置为 nullptr</span><br>        <span class=\"hljs-keyword\">delete</span> buckets[index];<br>        buckets[index] = <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取所有键值对 */</span><br>    <span class=\"hljs-function\">vector&lt;Pair *&gt; <span class=\"hljs-title\">pairSet</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        vector&lt;Pair *&gt; pairSet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) &#123;<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>                pairSet.<span class=\"hljs-built_in\">push_back</span>(pair);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> pairSet;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取所有键 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">keySet</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        vector&lt;<span class=\"hljs-type\">int</span>&gt; keySet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) &#123;<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>                keySet.<span class=\"hljs-built_in\">push_back</span>(pair-&gt;key);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> keySet;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取所有值 */</span><br>    <span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">valueSet</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        vector&lt;string&gt; valueSet;<br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets) &#123;<br>            <span class=\"hljs-keyword\">if</span> (pair != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>                valueSet.<span class=\"hljs-built_in\">push_back</span>(pair-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> valueSet;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 打印哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (Pair *kv : <span class=\"hljs-built_in\">pairSet</span>()) &#123;<br>            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class=\"hljs-string\">&quot; -&gt; &quot;</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"哈希冲突\">哈希冲突</h3>\n<p>  从本质上看，哈希函数的作用是将所有 key 构成的<strong>输入空间映射到数组所有索引构成的输出空间</strong>，而输入空间往往远大于输出空间。因此，理论上一定存在“<strong>多个输入对应相同输出</strong>”的情况,我们将这种多个输入对应同一输出的情况称为<strong>哈希冲突</strong>（hash collision）。<br>\n  哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低。为了提升效率，我们可以采用以下策略：</p>\n<ol>\n<li><strong>改良哈希表数据结构</strong>，使得哈希表可以在出现哈希冲突时正常工作。</li>\n</ol>\n<ul>\n<li><strong>“链式地址”</strong></li>\n<li><strong>“开放寻址”</strong></li>\n</ul>\n<ol start=\"2\">\n<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>\n</ol>\n<h4 id=\"链式地址\">链式地址</h4>\n<p>  在原始哈希表中，每个桶仅能存储一个键值对。<strong>链式地址</strong>（separate chaining）将<strong>单个元素转换为链表</strong>，将键值对作为链表节点，将所有<strong>发生冲突的键值对都存储在同一链表中</strong>。</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/linkedlisthash.png?raw=true\" alt=\"链式地址哈希表\"></p>\n<p>  基于链式地址实现的哈希表，需要通过哈希函数<strong>访问链表头节点</strong>，<strong>遍历链表到目标节点</strong>在进行增删改查的操作。</p>\n<div class=\"note note-info\">\n            <p><strong>Limitations</strong></p><ul><li><strong>占用空间增大</strong>：链表包含节点指针，它相比数组更加<strong>耗费内存空间</strong>。</li><li><strong>查询效率降低</strong>：因为需要<strong>线性遍历链表</strong>来查找对应元素。</li></ul>\n          </div>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 链式地址哈希表 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HashMapChaining</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> size;                       <span class=\"hljs-comment\">// 键值对数量</span><br>    <span class=\"hljs-type\">int</span> capacity;                   <span class=\"hljs-comment\">// 哈希表容量</span><br>    <span class=\"hljs-type\">double</span> loadThres;               <span class=\"hljs-comment\">// 触发扩容的负载因子阈值</span><br>    <span class=\"hljs-type\">int</span> extendRatio;                <span class=\"hljs-comment\">// 扩容倍数</span><br>    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class=\"hljs-comment\">// 桶数组</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">HashMapChaining</span>() : <span class=\"hljs-built_in\">size</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">capacity</span>(<span class=\"hljs-number\">4</span>), <span class=\"hljs-built_in\">loadThres</span>(<span class=\"hljs-number\">2.0</span> / <span class=\"hljs-number\">3.0</span>), <span class=\"hljs-built_in\">extendRatio</span>(<span class=\"hljs-number\">2</span>) &#123;<br>        buckets.<span class=\"hljs-built_in\">resize</span>(capacity);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 析构方法 */</span><br>    ~<span class=\"hljs-built_in\">HashMapChaining</span>() &#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) &#123;<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) &#123;<br>                <span class=\"hljs-comment\">// 释放内存</span><br>                <span class=\"hljs-keyword\">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 哈希函数 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hashFunc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> key % capacity;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 负载因子 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">loadFactor</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)size / (<span class=\"hljs-type\">double</span>)capacity;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 查询操作 */</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 遍历桶，若找到 key ，则返回对应 val</span><br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets[index]) &#123;<br>            <span class=\"hljs-keyword\">if</span> (pair-&gt;key == key) &#123;<br>                <span class=\"hljs-keyword\">return</span> pair-&gt;val;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 若未找到 key ，则返回空字符串</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;&quot;</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 添加操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key, string val)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 当负载因子超过阈值时，执行扩容</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">loadFactor</span>() &gt; loadThres) &#123;<br>            <span class=\"hljs-built_in\">extend</span>();<br>        &#125;<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-comment\">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span><br>        <span class=\"hljs-keyword\">for</span> (Pair *pair : buckets[index]) &#123;<br>            <span class=\"hljs-keyword\">if</span> (pair-&gt;key == key) &#123;<br>                pair-&gt;val = val;<br>                <span class=\"hljs-keyword\">return</span>;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 若无该 key ，则将键值对添加至尾部</span><br>        buckets[index].<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Pair</span>(key, val));<br>        size++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 删除操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> index = <span class=\"hljs-built_in\">hashFunc</span>(key);<br>        <span class=\"hljs-keyword\">auto</span> &amp;bucket = buckets[index];<br>        <span class=\"hljs-comment\">// 遍历桶，从中删除键值对</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; bucket.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>            <span class=\"hljs-keyword\">if</span> (bucket[i]-&gt;key == key) &#123;<br>                Pair *tmp = bucket[i];<br>                bucket.<span class=\"hljs-built_in\">erase</span>(bucket.<span class=\"hljs-built_in\">begin</span>() + i); <span class=\"hljs-comment\">// 从中删除键值对</span><br>                <span class=\"hljs-keyword\">delete</span> tmp;                       <span class=\"hljs-comment\">// 释放内存</span><br>                size--;<br>                <span class=\"hljs-keyword\">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 扩容哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">extend</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 暂存原哈希表</span><br>        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;<br>        <span class=\"hljs-comment\">// 初始化扩容后的新哈希表</span><br>        capacity *= extendRatio;<br>        buckets.<span class=\"hljs-built_in\">clear</span>();<br>        buckets.<span class=\"hljs-built_in\">resize</span>(capacity);<br>        size = <span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-comment\">// 将键值对从原哈希表搬运至新哈希表</span><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : bucketsTmp) &#123;<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) &#123;<br>                <span class=\"hljs-built_in\">put</span>(pair-&gt;key, pair-&gt;val);<br>                <span class=\"hljs-comment\">// 释放内存</span><br>                <span class=\"hljs-keyword\">delete</span> pair;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 打印哈希表 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;bucket : buckets) &#123;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;[&quot;</span>;<br>            <span class=\"hljs-keyword\">for</span> (Pair *pair : bucket) &#123;<br>                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class=\"hljs-string\">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class=\"hljs-string\">&quot;, &quot;</span>;<br>            &#125;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;]\\n&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h4 id=\"开放寻址\">开放寻址</h4>\n<p>开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括<strong>线性探测</strong>、<strong>平方探测</strong>和<strong>多次哈希</strong>等。</p>\n<ol>\n<li><strong>线性探测</strong></li>\n</ol>\n<p>  通过哈希函数计算桶索引，若发现桶内已有元素，则<strong>从冲突位置向后线性遍历</strong>（步长通常为1，<strong>固定步长索引</strong>），直至找到空桶（none）/目标元素。</p>\n<p>  然而，线性探测容易产生“<strong>聚集现象</strong>”。具体来说，<strong>数组中连续被占用的位置越长</strong>，这些连续位置<strong>发生哈希冲突的可能性越大</strong>，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作<strong>效率劣化</strong>。</p>\n<hr>\n<ol start=\"2\">\n<li><strong>平方探测</strong><br>\n  平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测<strong>不是简单地跳过一个固定的步数</strong>，而是跳过“<strong>探测次数的平方</strong>”的步数，即1、4、9…步。</li>\n</ol>\n<div class=\"note note-info\">\n            <p><strong>Advantages</strong></p><ul><li>平方探测通过跳过探测次数平方的距离，试图<strong>缓解线性探测的聚集效应</strong>。</li><li>平方探测会跳过更大的距离来寻找空位置，有助于<strong>数据分布得更加均匀</strong>。</li></ul>\n          </div>\n<div class=\"note note-info\">\n            <p><strong>Limitations</strong></p><ul><li><strong>仍然存在聚集现象</strong>，即某些位置比其他位置更容易被占用。</li><li>由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能<strong>无法访问</strong>到它。</li></ul>\n          </div>\n<hr>\n<ol start=\"3\">\n<li><strong>多次哈希</strong><br>\n顾名思义，多次哈希方法<strong>使用多个哈希函数</strong> $f(x),g(x),k(x)$ 进行探测。</li>\n</ol>\n<hr>\n<div class=\"note note-danger\">\n            <p>⚠️注意：<strong>开放寻址</strong>哈希表都存在“<strong>不能直接删除元素</strong>”的问题。</p><p>  这是因为删除元素会在数组内产生一个空桶<code>None</code>，而当查询元素时，线性探测到该空桶就会返回，因此在<strong>该空桶之下的元素都无法再被访问到</strong>，程序可能<strong>误判这些元素不存在</strong>。</p><p>  为了解决该问题，我们可以采用<strong>懒删除机制</strong>：它不直接从哈希表中移除元素，而是利用一个常量<code>TOMBSTONE</code>来标记这个桶。在该机制下，<code>None</code>和<code>TOMBSTONE</code>都代表空桶，都可以放置键值对。但不同的是，线性探测到<code>TOMBSTONE</code>时应该<strong>继续遍历</strong>，因为其之下可能还存在键值对。</p><p>  然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着<code>TOMBSTONE</code>的增加，搜索时间也会增加，因为线性探测可能需要跳过多个<code>TOMBSTONE</code>才能找到目标元素。</p><p>  为此，考虑在线性探测中记录遇到的首个<code>TOMBSTONE</code>的索引，并将搜索到的目标元素与该<code>TOMBSTONE</code>交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而<strong>优化查询效率</strong>。</p>\n          </div>\n<hr>\n<h3 id=\"哈希扩容\">哈希扩容</h3>\n<p>  哈希表容量越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。</p>\n<ul>\n<li><strong>类似于数组扩容</strong>，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时</li>\n<li>哈希表容量 capacity 改变，我们需要通过哈希函数来<strong>重新计算所有键值对的存储位置</strong>，这进一步增加了扩容过程的计算开销</li>\n</ul>\n<p>为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p>\n<p>  <strong>负载因子</strong>（load factor）是哈希表的一个重要概念，其定义为<strong>哈希表的元素数量除以桶数量</strong>，用于<strong>衡量哈希冲突的严重程度</strong>，也常作为哈希表扩容的触发条件。例如，当负载因子超过 0.75 时，我们可以考虑扩容哈希表。</p>\n<h3 id=\"哈希算法\">哈希算法</h3>\n<p>  前面的方法只能处理哈希冲突，并不能从<strong>本质上</strong>减少哈希冲突。如果哈希冲突<strong>过于频繁</strong>，哈希表的性能则会急剧劣化。对于链式地址哈希表，理想情况下<strong>键值对均匀分布</strong>在各个桶中，达到最佳查询效率；最差情况下所有键值对<strong>都存储到同一个桶中</strong>，时间复杂度退化至$O(n)$。</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/DataStructure/condition.png?raw=true\" alt=\"链式存储最好最坏情况\"></p>\n<p>我们制定出的哈希算法应达到以下目标：</p>\n<ul>\n<li><strong>确定性</strong>：对于相同的输入，哈希算法应<strong>始终产生相同的输出</strong>。这样才能确保哈希表是可靠的。</li>\n<li><strong>效率高</strong>：计算哈希值的过程应该<strong>足够快</strong>。<strong>计算开销越小</strong>，哈希表的<strong>实用性越高</strong>。</li>\n<li><strong>均匀分布</strong>：哈希算法应使得<strong>键值对均匀分布在哈希表</strong>中。分布越均匀，哈希冲突的概率就越低。</li>\n</ul>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-dfa96ec5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-dfa96ec5\">\n        <div class=\"fold-arrow\">▶</div>为什么不使用哈希函数$f(x)=x$呢？这样就不会有冲突了！\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-dfa96ec5\">\n        <div class=\"fold-content\">\n          <p>在 $f(x)=x$ 哈希函数下，每个元素对应唯一的桶索引，这与数组等价。然而给定的数据空间是未知的，如果数据范围较为稀疏如学号12592、16754，那么数组的绝大部分空间都将被闲置，导致空间复杂度急剧上升。并且我们的目标是在有限的数组范围内存储较大数量的键值，也就是将一个较大的状态空间映射到一个较小的空间。</p>\n        </div>\n      </div>\n    </div>"},{"title":"CUMT-Datastructure-Practice 4","date":"2025-06-27T04:57:31.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Practice-4.png","category_bar":true,"descriptiom":"Problems involving hash tables, sorting, and priority queues","_content":"\n\n\n## 问题 A: 机器人王国里的路径长度\n{%fold into @ 问题 A: 机器人王国里的路径长度 %}\n### 题目描述\n在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？\n### 输入\n第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1-2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。\n### 输出\n根据最后一行的卫星城代号，求该卫星城到首都的路程。\n### 样例输入\n```\n2\nA F 20\nB D 100\nG A 5\nG B 10\nA C 6\nB E 30\nD\n```\n### 样例输出\n```\n110\n```\n{%endfold%}\n### 问题分析\n本题需要根据当前```target```不断向上**回溯寻找其父节点**，将```distance```值返回加入到总路程```sum```中即可，这里使用哈希表存储每个城市的父城市和到父城市的距离。\n### 完整代码\n```cpp\n#include <iostream>\n#include <unordered_map>//哈希表容器\n#include <string>//处理字符串\n#include <cmath>//这里用于幂运算\nusing namespace std;\nstruct city {\n\tstring parent;//父城市名称\n\tint distance;//到父城市的距离\n};\nint main() {\n\tunordered_map<string, city> path;//存储城市路径关系的哈希表\n\tint N;\n\tcin >> N;\n\tint number = pow(2, N + 1) - 2;//计算读取的城市个数\n\tfor (int i = 0;i < number;i ++) {\n\t\tstring start, end;\n\t\tint distance;\n\t\tcin >> start >> end >> distance;\n\t\tpath[end] = { start,distance };//进行存储\n\t}\n\tstring target;\n\tcin >> target;\n\tint sum = 0;\n\twhile (path.find(target)!=path.end()){\n\t//直至当前的目标城市无法查找到父城市是停止\n\t\tsum += path[target].distance;\n\t\ttarget = path[target].parent;//将当前目标城市向上移动\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n```\n### 注释\n`<unordered_map>`是C++标准库中提供**无序关联容器**的头文件，它实现了基于哈希表的**键值对存储结构**，它具有以下特性：\n+ 元素**无序存储**，不会根据关键字值或映射值按**任何特定顺序排序**\n+ 键必须**唯一**（不允许重复键）\n+ 根据关键字来引用，而**不是根据索引来引用**\n+ 使用**链表处理哈希冲突**（**链地址法**）\n\n构造哈希表：\n\n``` cpp\nunordered_map<KeyType, ValueType> map_name;\n```\n```cpp\nunordered_map(int,int) position;\nunordered_map<string,string> name;\nunordered_map<string,int> age;\n```\n\n1. **元素添加**\n\n- 声明时**使用初始化列表**进行初始化：\n```cpp\nunordered_map<int,int> position = {{1,10},{2,20},{3,30}};\nunordered_map<string, string> capital_city = {\n    {\"UK\", \"London\"},\n    {\"France\", \"Paris\"},\n    {\"Germany\", \"Berlin\"}\n};\n```\n\n- 使用`[]`运算符添加：\n\n  - 如果键**不存在**，会**插入一个新的键值对**\n  - 如果键**已存在**，则会**覆盖**原有的值\n```cpp\nunordered_map<string, int> age_map;\nage_map[\"Alice\"] = 25; // 插入 {\"Alice\", 25}\nage_map[\"Bob\"] = 30;   // 插入 {\"Bob\", 30}\nage_map[\"Alice\"] = 26; // 更新，现在 {\"Alice\", 26}\n```\n\n- 使用`insert()`：插入一个键值对 `pair<Key, Value>`:\n\n   - 返回值是一个 `pair<iterator, bool>`\n   - `name.first`是**指向插入元素的迭代器**\n   - `name.second`是 bool 类型，表示**插入是否成功**（true 表示成功，false 表示键已存在）\n\n```cpp\nauto result = age_map.insert({\"Charlie\", 28}); \n// result 是一个 pair<iterator, bool>\n// result.first 是指向插入元素的迭代器\n// result.second 是 bool 类型，表示插入是否成功（true 表示成功，false 表示键已存在）\nif (result.second) {\n    std::cout << \"Insertion successful!\\n\";\n}\n```\n\n2. **元素访问**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`[]`运算符|**访问**元素（键不存在时会插入默认值）|\n|`map.at(key)`| 安全**访问**元素（不存在时**抛出out_of_range异常**）|\n|`map.find(key)`| 返回指向元素的**迭代器**（不存在时**返回end()**）|\n\n```cpp\nint alice_age = age_map[\"Alice\"]; // 存在，返回 26\nint dave_age = age_map[\"Dave\"];   // 不存在！会自动插入 {\"Dave\", 0}，然后返回 0\n```\n```cpp\nint alice_age = age_map.at(\"Alice\"); // 存在，返回 26\nint dave_age = age_map.at(\"Dave\");   // 不存在！抛出异常\n```\n```cpp\nauto it = age_map.find(\"Bob\");\nif (it != age_map.end()) {\n    // it->first 是键 (”Bob“)\n    // it->second 是值 (30)\n    cout << \"Found Bob, age: \" << it->second << endl;\n} else {\n    cout << \"Bob not found.\\n\";\n}\n```\n3. **容量查询**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.empty()`| 判断容器是否为空|\n|`map.size()`| 返回元素个数|\n\n4. **修改操作**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.insert({key, value})`| 插入键值对（返回pair<iterator, bool>）|\n|`map.emplace(key, value)`| **直接构造元素**（避免临时对象）|\n|`map.erase(key)`| **删除指定键的元素**|\n\n- 通过**迭代器**删除：\n```cpp\nauto it = age_map.find(\"Bob\");\nif (it != age_map.end()) {\n    age_map.erase(it); // 删除迭代器指向的元素\n}\n```\n- 通过**键**删除：\n```cpp\nsize_t num_removed = age_map.erase(\"Charlie\"); // 返回被删除的元素个数（0 或 1）\n```\n\n`insert()` && `emplace()`的区别：\n\n```cpp\nmap.insert({\"apple\", 2});\n```\n\n```cpp\nmap.emplace(\"apple\", 3);\n ```\n\n5. **查找与统计**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.count(key)`| 判断**键是否存在**（返回bool）|\n|`map.contains(key)`| 返回**关键字出现的次数**|\n\n6. **遍历元素**\n- 使用范围 for 循环 \n```cpp\nfor (const auto& pair : age_map) {\n    cout << pair.first << \": \" << pair.second << endl;\n}\n```\n- 使用迭代器\n```cpp\nfor (auto it = age_map.begin(); it != age_map.end(); ++it) {\n    cout << it->first << \": \" << it->second << endl;\n}\n```\n\n## 问题 D: 寻找第二小的数\n{%fold into @ 问题 D: 寻找第二小的数 %}\n### 题目描述\n求n个整数中第二小的数。\n相同的整数看成一个数。比如，有5个数分别是1,1,3,4,5，那么第二小的数就是3。\n### 输入\n输入包含多组测试数据。输入的第一行是一个整数C，表示有C组测试数据；\n每组测试数据的第一行是一个整数n，表示本组测试数据有n个整数（2<=n<=10），接着一行是n个整数（每个数均小于100）。\n### 输出\n为每组测试数据输出第二小的整数，如果不存在第二小的整数则输出“NO”，每组输出占一行。\n### 样例输入\n```\n3\n2\n1 2\n5\n1 1 3 4 5\n3\n1 1 1\n```\n### 样例输出\n```\n2\n3\nNO\n```\n{%endfold%}\n### 问题分析\n用逆序的优先队列即可完成！\n#### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\nvoid find() {\n\tpriority_queue <int, vector<int>, greater<int>> pq;\n\tint m;\n\tcin >> m;\n\tfor (int i = 0;i < m;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tpq.push(a);\n\t}\n\tint min = pq.top();\n\tpq.pop();\n\twhile (!pq.empty() && min == pq.top()) {\n\t\tpq.pop();\n\t}\n\tif (pq.empty()) {\n\t\tcout << \"NO\" << endl;\n\t}\n\telse cout << pq.top() << endl;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tfind();\n\t}\n\treturn 0;\n}\n```\n## 问题 E: 按十进制各位和排序\n{%fold into @ 问题 E: 按十进制各位和排序 %}\n### 题目描述\n对于给定的正整数序列，按照每个数的十进制形式各个位上的数之和从大到小排序，各个位上的数和相同的按照本身大小排序，大的在前，小的在后。\n### 输入\n第一行 1 个整数 n,表示序列的大小。( 0 < n ≤ 1000) 第二行 n 个正整数，表示序列的每个数，每个数不大于 100000000。\n### 输出\n输出按照题目要求排序后的序列。\n### 样例输入\n```\n6 \n17 26 9 13 88 22\n```\n### 样例输出\n```\n88 9 26 17 22 13\n```\n{%endfold%}\n### 问题分析\n要将其十进制排序后的结果与原本大小匹配，这里使用了冒泡排序完成。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint Sum(int a) {//十进制各个位数求和函数\n\tint sum = 0;\n\twhile (a != 0) {\n\t\tsum += a % 10;\n\t\ta = a / 10;\n\t}\n\treturn sum;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> order(n);\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> order[i];\n\t}\n\tfor (int i = 0;i < n ; i++) {//进行冒泡排序\n\t\tfor (int j = 0 ;j < n-i-1;j++) {\n\t\t\tif (Sum(order[j]) < Sum(order[j + 1]) ||\n\t\t\t\t(Sum(order[j]) == Sum(order[j + 1]) && order[j] < order[j + 1])) {\n\t\t\t\tint temp=order[j];\n\t\t\t\torder[j]=order[j+1];\n\t\t\t\torder[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < n; i++) {\n\t\tcout<<order[i]<<\" \";\n\t}\n\treturn 0;\n}\n```\n## 问题 F: 奇偶数的排序\n{%fold into @ 问题 F: 奇偶数的排序 %}\n### 题目描述\n给你10个正整数，其中5个奇数、5个偶数，先递减排奇数，然后再递增排偶数。请编程实现。\n### 输入\n一行10个正整数（int类型范围）。\n### 输出\n先递减排5个奇数，然后再递增排5个偶数，各个数之间有一个空格间隔。\n### 样例输入\n```\n1 2 3 4 5 6 7 8 10 9\n```\n### 样例输出\n```\n9 7 5 3 1 2 4 6 8 10\n```\n{%endfold%}\n### 问题分析\n分别使用优先队列和逆序优先队列对奇数偶数进行排序，再依次输出队首元素。\n### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint main() {\n\tpriority_queue<int> odd;//奇数的优先队列\n\tpriority_queue <int, vector<int>, greater<int>>  even;//偶数逆序优先队列\n\tfor (int i = 0;i < 10;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tif (a % 2 == 0) {\n\t\t\teven.push(a);\n\t\t}\n\t\telse odd.push(a);\n\t}\n\twhile(!odd.empty()) {\n\t\tcout << odd.top()<<\" \";\n\t\todd.pop();\n\t}\n\twhile (!even.empty() ){\n\t\tcout << even.top()<<\" \";\n\t\teven.pop();\n\t}\n\treturn 0;\n}\n```\n封面来源：: [Learn Hash Tables in 13 minutes](https://www.youtube.com/watch?v=FsfRsGFHuv4)\n\n","source":"_posts/Data structure/CUMT-Datastructure-Practice-4.md","raw":"---\ntitle: CUMT-Datastructure-Practice 4\ndate: 2025-06-27 12:57:31\ntags: [hashtable,sort,queue]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/CUMT-Datastructure-Practice-4.png\ncategory: Data Structure\ncategory_bar: true\ndescriptiom: Problems involving hash tables, sorting, and priority queues\n---\n\n\n\n## 问题 A: 机器人王国里的路径长度\n{%fold into @ 问题 A: 机器人王国里的路径长度 %}\n### 题目描述\n在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？\n### 输入\n第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1-2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。\n### 输出\n根据最后一行的卫星城代号，求该卫星城到首都的路程。\n### 样例输入\n```\n2\nA F 20\nB D 100\nG A 5\nG B 10\nA C 6\nB E 30\nD\n```\n### 样例输出\n```\n110\n```\n{%endfold%}\n### 问题分析\n本题需要根据当前```target```不断向上**回溯寻找其父节点**，将```distance```值返回加入到总路程```sum```中即可，这里使用哈希表存储每个城市的父城市和到父城市的距离。\n### 完整代码\n```cpp\n#include <iostream>\n#include <unordered_map>//哈希表容器\n#include <string>//处理字符串\n#include <cmath>//这里用于幂运算\nusing namespace std;\nstruct city {\n\tstring parent;//父城市名称\n\tint distance;//到父城市的距离\n};\nint main() {\n\tunordered_map<string, city> path;//存储城市路径关系的哈希表\n\tint N;\n\tcin >> N;\n\tint number = pow(2, N + 1) - 2;//计算读取的城市个数\n\tfor (int i = 0;i < number;i ++) {\n\t\tstring start, end;\n\t\tint distance;\n\t\tcin >> start >> end >> distance;\n\t\tpath[end] = { start,distance };//进行存储\n\t}\n\tstring target;\n\tcin >> target;\n\tint sum = 0;\n\twhile (path.find(target)!=path.end()){\n\t//直至当前的目标城市无法查找到父城市是停止\n\t\tsum += path[target].distance;\n\t\ttarget = path[target].parent;//将当前目标城市向上移动\n\t}\n\tcout << sum << endl;\n\treturn 0;\n}\n```\n### 注释\n`<unordered_map>`是C++标准库中提供**无序关联容器**的头文件，它实现了基于哈希表的**键值对存储结构**，它具有以下特性：\n+ 元素**无序存储**，不会根据关键字值或映射值按**任何特定顺序排序**\n+ 键必须**唯一**（不允许重复键）\n+ 根据关键字来引用，而**不是根据索引来引用**\n+ 使用**链表处理哈希冲突**（**链地址法**）\n\n构造哈希表：\n\n``` cpp\nunordered_map<KeyType, ValueType> map_name;\n```\n```cpp\nunordered_map(int,int) position;\nunordered_map<string,string> name;\nunordered_map<string,int> age;\n```\n\n1. **元素添加**\n\n- 声明时**使用初始化列表**进行初始化：\n```cpp\nunordered_map<int,int> position = {{1,10},{2,20},{3,30}};\nunordered_map<string, string> capital_city = {\n    {\"UK\", \"London\"},\n    {\"France\", \"Paris\"},\n    {\"Germany\", \"Berlin\"}\n};\n```\n\n- 使用`[]`运算符添加：\n\n  - 如果键**不存在**，会**插入一个新的键值对**\n  - 如果键**已存在**，则会**覆盖**原有的值\n```cpp\nunordered_map<string, int> age_map;\nage_map[\"Alice\"] = 25; // 插入 {\"Alice\", 25}\nage_map[\"Bob\"] = 30;   // 插入 {\"Bob\", 30}\nage_map[\"Alice\"] = 26; // 更新，现在 {\"Alice\", 26}\n```\n\n- 使用`insert()`：插入一个键值对 `pair<Key, Value>`:\n\n   - 返回值是一个 `pair<iterator, bool>`\n   - `name.first`是**指向插入元素的迭代器**\n   - `name.second`是 bool 类型，表示**插入是否成功**（true 表示成功，false 表示键已存在）\n\n```cpp\nauto result = age_map.insert({\"Charlie\", 28}); \n// result 是一个 pair<iterator, bool>\n// result.first 是指向插入元素的迭代器\n// result.second 是 bool 类型，表示插入是否成功（true 表示成功，false 表示键已存在）\nif (result.second) {\n    std::cout << \"Insertion successful!\\n\";\n}\n```\n\n2. **元素访问**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`[]`运算符|**访问**元素（键不存在时会插入默认值）|\n|`map.at(key)`| 安全**访问**元素（不存在时**抛出out_of_range异常**）|\n|`map.find(key)`| 返回指向元素的**迭代器**（不存在时**返回end()**）|\n\n```cpp\nint alice_age = age_map[\"Alice\"]; // 存在，返回 26\nint dave_age = age_map[\"Dave\"];   // 不存在！会自动插入 {\"Dave\", 0}，然后返回 0\n```\n```cpp\nint alice_age = age_map.at(\"Alice\"); // 存在，返回 26\nint dave_age = age_map.at(\"Dave\");   // 不存在！抛出异常\n```\n```cpp\nauto it = age_map.find(\"Bob\");\nif (it != age_map.end()) {\n    // it->first 是键 (”Bob“)\n    // it->second 是值 (30)\n    cout << \"Found Bob, age: \" << it->second << endl;\n} else {\n    cout << \"Bob not found.\\n\";\n}\n```\n3. **容量查询**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.empty()`| 判断容器是否为空|\n|`map.size()`| 返回元素个数|\n\n4. **修改操作**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.insert({key, value})`| 插入键值对（返回pair<iterator, bool>）|\n|`map.emplace(key, value)`| **直接构造元素**（避免临时对象）|\n|`map.erase(key)`| **删除指定键的元素**|\n\n- 通过**迭代器**删除：\n```cpp\nauto it = age_map.find(\"Bob\");\nif (it != age_map.end()) {\n    age_map.erase(it); // 删除迭代器指向的元素\n}\n```\n- 通过**键**删除：\n```cpp\nsize_t num_removed = age_map.erase(\"Charlie\"); // 返回被删除的元素个数（0 或 1）\n```\n\n`insert()` && `emplace()`的区别：\n\n```cpp\nmap.insert({\"apple\", 2});\n```\n\n```cpp\nmap.emplace(\"apple\", 3);\n ```\n\n5. **查找与统计**\n\n|成员函数     | 说明|\n|-------- | -----|\n|`map.count(key)`| 判断**键是否存在**（返回bool）|\n|`map.contains(key)`| 返回**关键字出现的次数**|\n\n6. **遍历元素**\n- 使用范围 for 循环 \n```cpp\nfor (const auto& pair : age_map) {\n    cout << pair.first << \": \" << pair.second << endl;\n}\n```\n- 使用迭代器\n```cpp\nfor (auto it = age_map.begin(); it != age_map.end(); ++it) {\n    cout << it->first << \": \" << it->second << endl;\n}\n```\n\n## 问题 D: 寻找第二小的数\n{%fold into @ 问题 D: 寻找第二小的数 %}\n### 题目描述\n求n个整数中第二小的数。\n相同的整数看成一个数。比如，有5个数分别是1,1,3,4,5，那么第二小的数就是3。\n### 输入\n输入包含多组测试数据。输入的第一行是一个整数C，表示有C组测试数据；\n每组测试数据的第一行是一个整数n，表示本组测试数据有n个整数（2<=n<=10），接着一行是n个整数（每个数均小于100）。\n### 输出\n为每组测试数据输出第二小的整数，如果不存在第二小的整数则输出“NO”，每组输出占一行。\n### 样例输入\n```\n3\n2\n1 2\n5\n1 1 3 4 5\n3\n1 1 1\n```\n### 样例输出\n```\n2\n3\nNO\n```\n{%endfold%}\n### 问题分析\n用逆序的优先队列即可完成！\n#### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\nvoid find() {\n\tpriority_queue <int, vector<int>, greater<int>> pq;\n\tint m;\n\tcin >> m;\n\tfor (int i = 0;i < m;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tpq.push(a);\n\t}\n\tint min = pq.top();\n\tpq.pop();\n\twhile (!pq.empty() && min == pq.top()) {\n\t\tpq.pop();\n\t}\n\tif (pq.empty()) {\n\t\tcout << \"NO\" << endl;\n\t}\n\telse cout << pq.top() << endl;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0;i < n;i++) {\n\t\tfind();\n\t}\n\treturn 0;\n}\n```\n## 问题 E: 按十进制各位和排序\n{%fold into @ 问题 E: 按十进制各位和排序 %}\n### 题目描述\n对于给定的正整数序列，按照每个数的十进制形式各个位上的数之和从大到小排序，各个位上的数和相同的按照本身大小排序，大的在前，小的在后。\n### 输入\n第一行 1 个整数 n,表示序列的大小。( 0 < n ≤ 1000) 第二行 n 个正整数，表示序列的每个数，每个数不大于 100000000。\n### 输出\n输出按照题目要求排序后的序列。\n### 样例输入\n```\n6 \n17 26 9 13 88 22\n```\n### 样例输出\n```\n88 9 26 17 22 13\n```\n{%endfold%}\n### 问题分析\n要将其十进制排序后的结果与原本大小匹配，这里使用了冒泡排序完成。\n### 完整代码\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint Sum(int a) {//十进制各个位数求和函数\n\tint sum = 0;\n\twhile (a != 0) {\n\t\tsum += a % 10;\n\t\ta = a / 10;\n\t}\n\treturn sum;\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tvector <int> order(n);\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> order[i];\n\t}\n\tfor (int i = 0;i < n ; i++) {//进行冒泡排序\n\t\tfor (int j = 0 ;j < n-i-1;j++) {\n\t\t\tif (Sum(order[j]) < Sum(order[j + 1]) ||\n\t\t\t\t(Sum(order[j]) == Sum(order[j + 1]) && order[j] < order[j + 1])) {\n\t\t\t\tint temp=order[j];\n\t\t\t\torder[j]=order[j+1];\n\t\t\t\torder[j+1]=temp;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < n; i++) {\n\t\tcout<<order[i]<<\" \";\n\t}\n\treturn 0;\n}\n```\n## 问题 F: 奇偶数的排序\n{%fold into @ 问题 F: 奇偶数的排序 %}\n### 题目描述\n给你10个正整数，其中5个奇数、5个偶数，先递减排奇数，然后再递增排偶数。请编程实现。\n### 输入\n一行10个正整数（int类型范围）。\n### 输出\n先递减排5个奇数，然后再递增排5个偶数，各个数之间有一个空格间隔。\n### 样例输入\n```\n1 2 3 4 5 6 7 8 10 9\n```\n### 样例输出\n```\n9 7 5 3 1 2 4 6 8 10\n```\n{%endfold%}\n### 问题分析\n分别使用优先队列和逆序优先队列对奇数偶数进行排序，再依次输出队首元素。\n### 完整代码\n```cpp\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nint main() {\n\tpriority_queue<int> odd;//奇数的优先队列\n\tpriority_queue <int, vector<int>, greater<int>>  even;//偶数逆序优先队列\n\tfor (int i = 0;i < 10;i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tif (a % 2 == 0) {\n\t\t\teven.push(a);\n\t\t}\n\t\telse odd.push(a);\n\t}\n\twhile(!odd.empty()) {\n\t\tcout << odd.top()<<\" \";\n\t\todd.pop();\n\t}\n\twhile (!even.empty() ){\n\t\tcout << even.top()<<\" \";\n\t\teven.pop();\n\t}\n\treturn 0;\n}\n```\n封面来源：: [Learn Hash Tables in 13 minutes](https://www.youtube.com/watch?v=FsfRsGFHuv4)\n\n","slug":"Data structure/CUMT-Datastructure-Practice-4","published":1,"updated":"2025-08-27T03:33:17.124Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hco000x40w39fp82cne","content":"<h2 id=\"问题-A-机器人王国里的路径长度\">问题 A: 机器人王国里的路径长度</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a5ff173a\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a5ff173a\">\n        <div class=\"fold-arrow\">▶</div> 问题 A: 机器人王国里的路径长度\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a5ff173a\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？</p><h3 id=\"输入\">输入</h3><p>第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1-2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。</p><h3 id=\"输出\">输出</h3><p>根据最后一行的卫星城代号，求该卫星城到首都的路程。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-selector-tag\">A</span> F <span class=\"hljs-number\">20</span><br><span class=\"hljs-selector-tag\">B</span> D <span class=\"hljs-number\">100</span><br><span class=\"hljs-selector-tag\">G</span> <span class=\"hljs-selector-tag\">A</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-selector-tag\">G</span> <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-selector-tag\">A</span> C <span class=\"hljs-number\">6</span><br><span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-number\">30</span><br>D<br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">110<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>本题需要根据当前<code>target</code>不断向上<strong>回溯寻找其父节点</strong>，将<code>distance</code>值返回加入到总路程<code>sum</code>中即可，这里使用哈希表存储每个城市的父城市和到父城市的距离。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span><span class=\"hljs-comment\">//哈希表容器</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span><span class=\"hljs-comment\">//处理字符串</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span><span class=\"hljs-comment\">//这里用于幂运算</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">city</span> {<br>\tstring parent;<span class=\"hljs-comment\">//父城市名称</span><br>\t<span class=\"hljs-type\">int</span> distance;<span class=\"hljs-comment\">//到父城市的距离</span><br>};<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tunordered_map&lt;string, city&gt; path;<span class=\"hljs-comment\">//存储城市路径关系的哈希表</span><br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-type\">int</span> number = <span class=\"hljs-built_in\">pow</span>(<span class=\"hljs-number\">2</span>, N + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//计算读取的城市个数</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; number;i ++) {<br>\t\tstring start, end;<br>\t\t<span class=\"hljs-type\">int</span> distance;<br>\t\tcin &gt;&gt; start &gt;&gt; end &gt;&gt; distance;<br>\t\tpath[end] = { start,distance };<span class=\"hljs-comment\">//进行存储</span><br>\t}<br>\tstring target;<br>\tcin &gt;&gt; target;<br>\t<span class=\"hljs-type\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (path.<span class=\"hljs-built_in\">find</span>(target)!=path.<span class=\"hljs-built_in\">end</span>()){<br>\t<span class=\"hljs-comment\">//直至当前的目标城市无法查找到父城市是停止</span><br>\t\tsum += path[target].distance;<br>\t\ttarget = path[target].parent;<span class=\"hljs-comment\">//将当前目标城市向上移动</span><br>\t}<br>\tcout &lt;&lt; sum &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><code>&lt;unordered_map&gt;</code>是C++标准库中提供<strong>无序关联容器</strong>的头文件，它实现了基于哈希表的<strong>键值对存储结构</strong>，它具有以下特性：</p>\n<ul>\n<li>元素<strong>无序存储</strong>，不会根据关键字值或映射值按<strong>任何特定顺序排序</strong></li>\n<li>键必须<strong>唯一</strong>（不允许重复键）</li>\n<li>根据关键字来引用，而<strong>不是根据索引来引用</strong></li>\n<li>使用<strong>链表处理哈希冲突</strong>（<strong>链地址法</strong>）</li>\n</ul>\n<p>构造哈希表：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;KeyType, ValueType&gt; map_name;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">unordered_map</span>(<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>) position;<br>unordered_map&lt;string,string&gt; name;<br>unordered_map&lt;string,<span class=\"hljs-type\">int</span>&gt; age;<br></code></pre></td></tr></tbody></table></figure>\n<ol>\n<li><strong>元素添加</strong></li>\n</ol>\n<ul>\n<li>声明时<strong>使用初始化列表</strong>进行初始化：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; position = {{<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>},{<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">20</span>},{<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">30</span>}};<br>unordered_map&lt;string, string&gt; capital_city = {<br>    {<span class=\"hljs-string\">\"UK\"</span>, <span class=\"hljs-string\">\"London\"</span>},<br>    {<span class=\"hljs-string\">\"France\"</span>, <span class=\"hljs-string\">\"Paris\"</span>},<br>    {<span class=\"hljs-string\">\"Germany\"</span>, <span class=\"hljs-string\">\"Berlin\"</span>}<br>};<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>\n<p>使用<code>[]</code>运算符添加：</p>\n<ul>\n<li>如果键<strong>不存在</strong>，会<strong>插入一个新的键值对</strong></li>\n<li>如果键<strong>已存在</strong>，则会<strong>覆盖</strong>原有的值</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;string, <span class=\"hljs-type\">int</span>&gt; age_map;<br>age_map[<span class=\"hljs-string\">\"Alice\"</span>] = <span class=\"hljs-number\">25</span>; <span class=\"hljs-comment\">// 插入 {\"Alice\", 25}</span><br>age_map[<span class=\"hljs-string\">\"Bob\"</span>] = <span class=\"hljs-number\">30</span>;   <span class=\"hljs-comment\">// 插入 {\"Bob\", 30}</span><br>age_map[<span class=\"hljs-string\">\"Alice\"</span>] = <span class=\"hljs-number\">26</span>; <span class=\"hljs-comment\">// 更新，现在 {\"Alice\", 26}</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>\n<p>使用<code>insert()</code>：插入一个键值对 <code>pair&lt;Key, Value&gt;</code>:</p>\n<ul>\n<li>返回值是一个 <code>pair&lt;iterator, bool&gt;</code></li>\n<li><code>name.first</code>是<strong>指向插入元素的迭代器</strong></li>\n<li><code>name.second</code>是 bool 类型，表示<strong>插入是否成功</strong>（true 表示成功，false 表示键已存在）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> result = age_map.<span class=\"hljs-built_in\">insert</span>({<span class=\"hljs-string\">\"Charlie\"</span>, <span class=\"hljs-number\">28</span>}); <br><span class=\"hljs-comment\">// result 是一个 pair&lt;iterator, bool&gt;</span><br><span class=\"hljs-comment\">// result.first 是指向插入元素的迭代器</span><br><span class=\"hljs-comment\">// result.second 是 bool 类型，表示插入是否成功（true 表示成功，false 表示键已存在）</span><br><span class=\"hljs-keyword\">if</span> (result.second) {<br>    std::cout &lt;&lt; <span class=\"hljs-string\">\"Insertion successful!\\n\"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"2\">\n<li><strong>元素访问</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[]</code>运算符</td>\n<td><strong>访问</strong>元素（键不存在时会插入默认值）</td>\n</tr>\n<tr>\n<td><code>map.at(key)</code></td>\n<td>安全<strong>访问</strong>元素（不存在时<strong>抛出out_of_range异常</strong>）</td>\n</tr>\n<tr>\n<td><code>map.find(key)</code></td>\n<td>返回指向元素的<strong>迭代器</strong>（不存在时<strong>返回end()</strong>）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> alice_age = age_map[<span class=\"hljs-string\">\"Alice\"</span>]; <span class=\"hljs-comment\">// 存在，返回 26</span><br><span class=\"hljs-type\">int</span> dave_age = age_map[<span class=\"hljs-string\">\"Dave\"</span>];   <span class=\"hljs-comment\">// 不存在！会自动插入 {\"Dave\", 0}，然后返回 0</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> alice_age = age_map.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-string\">\"Alice\"</span>); <span class=\"hljs-comment\">// 存在，返回 26</span><br><span class=\"hljs-type\">int</span> dave_age = age_map.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-string\">\"Dave\"</span>);   <span class=\"hljs-comment\">// 不存在！抛出异常</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">\"Bob\"</span>);<br><span class=\"hljs-keyword\">if</span> (it != age_map.<span class=\"hljs-built_in\">end</span>()) {<br>    <span class=\"hljs-comment\">// it-&gt;first 是键 (”Bob“)</span><br>    <span class=\"hljs-comment\">// it-&gt;second 是值 (30)</span><br>    cout &lt;&lt; <span class=\"hljs-string\">\"Found Bob, age: \"</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>} <span class=\"hljs-keyword\">else</span> {<br>    cout &lt;&lt; <span class=\"hljs-string\">\"Bob not found.\\n\"</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"3\">\n<li><strong>容量查询</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.empty()</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>map.size()</code></td>\n<td>返回元素个数</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li><strong>修改操作</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.insert({key, value})</code></td>\n<td>插入键值对（返回pair&lt;iterator, bool&gt;）</td>\n</tr>\n<tr>\n<td><code>map.emplace(key, value)</code></td>\n<td><strong>直接构造元素</strong>（避免临时对象）</td>\n</tr>\n<tr>\n<td><code>map.erase(key)</code></td>\n<td><strong>删除指定键的元素</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>通过<strong>迭代器</strong>删除：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">\"Bob\"</span>);<br><span class=\"hljs-keyword\">if</span> (it != age_map.<span class=\"hljs-built_in\">end</span>()) {<br>    age_map.<span class=\"hljs-built_in\">erase</span>(it); <span class=\"hljs-comment\">// 删除迭代器指向的元素</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>通过<strong>键</strong>删除：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">size_t</span> num_removed = age_map.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-string\">\"Charlie\"</span>); <span class=\"hljs-comment\">// 返回被删除的元素个数（0 或 1）</span><br></code></pre></td></tr></tbody></table></figure>\n<p><code>insert()</code> &amp;&amp; <code>emplace()</code>的区别：</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">map.<span class=\"hljs-built_in\">insert</span>({<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-number\">2</span>});<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">map.<span class=\"hljs-built_in\">emplace</span>(<span class=\"hljs-string\">\"apple\"</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"5\">\n<li><strong>查找与统计</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.count(key)</code></td>\n<td>判断<strong>键是否存在</strong>（返回bool）</td>\n</tr>\n<tr>\n<td><code>map.contains(key)</code></td>\n<td>返回<strong>关键字出现的次数</strong></td>\n</tr>\n</tbody>\n</table>\n<ol start=\"6\">\n<li><strong>遍历元素</strong></li>\n</ol>\n<ul>\n<li>使用范围 for 循环</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; pair : age_map) {<br>    cout &lt;&lt; pair.first &lt;&lt; <span class=\"hljs-string\">\": \"</span> &lt;&lt; pair.second &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>使用迭代器</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">begin</span>(); it != age_map.<span class=\"hljs-built_in\">end</span>(); ++it) {<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">\": \"</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"问题-D-寻找第二小的数\">问题 D: 寻找第二小的数</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b7bb3a6d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b7bb3a6d\">\n        <div class=\"fold-arrow\">▶</div> 问题 D: 寻找第二小的数\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b7bb3a6d\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>求n个整数中第二小的数。<br>相同的整数看成一个数。比如，有5个数分别是1,1,3,4,5，那么第二小的数就是3。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。输入的第一行是一个整数C，表示有C组测试数据；<br>每组测试数据的第一行是一个整数n，表示本组测试数据有n个整数（2&lt;=n&lt;=10），接着一行是n个整数（每个数均小于100）。</p><h3 id=\"输出\">输出</h3><p>为每组测试数据输出第二小的整数，如果不存在第二小的整数则输出“NO”，每组输出占一行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight gams\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-keyword\">NO</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>用逆序的优先队列即可完成！</p>\n<h4 id=\"完整代码-v2\">完整代码</h4>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">()</span> </span>{<br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; pq;<br>\t<span class=\"hljs-type\">int</span> m;<br>\tcin &gt;&gt; m;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; m;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tpq.<span class=\"hljs-built_in\">push</span>(a);<br>\t}<br>\t<span class=\"hljs-type\">int</span> min = pq.<span class=\"hljs-built_in\">top</span>();<br>\tpq.<span class=\"hljs-built_in\">pop</span>();<br>\t<span class=\"hljs-keyword\">while</span> (!pq.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; min == pq.<span class=\"hljs-built_in\">top</span>()) {<br>\t\tpq.<span class=\"hljs-built_in\">pop</span>();<br>\t}<br>\t<span class=\"hljs-keyword\">if</span> (pq.<span class=\"hljs-built_in\">empty</span>()) {<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">\"NO\"</span> &lt;&lt; endl;<br>\t}<br>\t<span class=\"hljs-keyword\">else</span> cout &lt;&lt; pq.<span class=\"hljs-built_in\">top</span>() &lt;&lt; endl;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\t<span class=\"hljs-built_in\">find</span>();<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"问题-E-按十进制各位和排序\">问题 E: 按十进制各位和排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-78f48315\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-78f48315\">\n        <div class=\"fold-arrow\">▶</div> 问题 E: 按十进制各位和排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-78f48315\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>对于给定的正整数序列，按照每个数的十进制形式各个位上的数之和从大到小排序，各个位上的数和相同的按照本身大小排序，大的在前，小的在后。</p><h3 id=\"输入\">输入</h3><p>第一行 1 个整数 n,表示序列的大小。( 0 &lt; n ≤ 1000) 第二行 n 个正整数，表示序列的每个数，每个数不大于 100000000。</p><h3 id=\"输出\">输出</h3><p>输出按照题目要求排序后的序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><br><span class=\"hljs-symbol\">17 </span><span class=\"hljs-number\">26</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">22</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">88 </span><span class=\"hljs-number\">9</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">17</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">13</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>要将其十进制排序后的结果与原本大小匹配，这里使用了冒泡排序完成。</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>{<span class=\"hljs-comment\">//十进制各个位数求和函数</span><br>\t<span class=\"hljs-type\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (a != <span class=\"hljs-number\">0</span>) {<br>\t\tsum += a % <span class=\"hljs-number\">10</span>;<br>\t\ta = a / <span class=\"hljs-number\">10</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> sum;<br>}<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">order</span>(n);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) {<br>\t\tcin &gt;&gt; order[i];<br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n ; i++) {<span class=\"hljs-comment\">//进行冒泡排序</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span> ;j &lt; n-i<span class=\"hljs-number\">-1</span>;j++) {<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Sum</span>(order[j]) &lt; <span class=\"hljs-built_in\">Sum</span>(order[j + <span class=\"hljs-number\">1</span>]) ||<br>\t\t\t\t(<span class=\"hljs-built_in\">Sum</span>(order[j]) == <span class=\"hljs-built_in\">Sum</span>(order[j + <span class=\"hljs-number\">1</span>]) &amp;&amp; order[j] &lt; order[j + <span class=\"hljs-number\">1</span>])) {<br>\t\t\t\t<span class=\"hljs-type\">int</span> temp=order[j];<br>\t\t\t\torder[j]=order[j<span class=\"hljs-number\">+1</span>];<br>\t\t\t\torder[j<span class=\"hljs-number\">+1</span>]=temp;<br>\t\t\t}<br>\t\t}<br>\t}<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n; i++) {<br>\t\tcout&lt;&lt;order[i]&lt;&lt;<span class=\"hljs-string\">\" \"</span>;<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"问题-F-奇偶数的排序\">问题 F: 奇偶数的排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b019705e\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b019705e\">\n        <div class=\"fold-arrow\">▶</div> 问题 F: 奇偶数的排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b019705e\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你10个正整数，其中5个奇数、5个偶数，先递减排奇数，然后再递增排偶数。请编程实现。</p><h3 id=\"输入\">输入</h3><p>一行10个正整数（int类型范围）。</p><h3 id=\"输出\">输出</h3><p>先递减排5个奇数，然后再递增排5个偶数，各个数之间有一个空格间隔。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></tbody></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">10</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>分别使用优先队列和逆序优先队列对奇数偶数进行排序，再依次输出队首元素。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{<br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; odd;<span class=\"hljs-comment\">//奇数的优先队列</span><br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;  even;<span class=\"hljs-comment\">//偶数逆序优先队列</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++) {<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) {<br>\t\t\teven.<span class=\"hljs-built_in\">push</span>(a);<br>\t\t}<br>\t\t<span class=\"hljs-keyword\">else</span> odd.<span class=\"hljs-built_in\">push</span>(a);<br>\t}<br>\t<span class=\"hljs-keyword\">while</span>(!odd.<span class=\"hljs-built_in\">empty</span>()) {<br>\t\tcout &lt;&lt; odd.<span class=\"hljs-built_in\">top</span>()&lt;&lt;<span class=\"hljs-string\">\" \"</span>;<br>\t\todd.<span class=\"hljs-built_in\">pop</span>();<br>\t}<br>\t<span class=\"hljs-keyword\">while</span> (!even.<span class=\"hljs-built_in\">empty</span>() ){<br>\t\tcout &lt;&lt; even.<span class=\"hljs-built_in\">top</span>()&lt;&lt;<span class=\"hljs-string\">\" \"</span>;<br>\t\teven.<span class=\"hljs-built_in\">pop</span>();<br>\t}<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：: <a href=\"https://www.youtube.com/watch?v=FsfRsGFHuv4\">Learn Hash Tables in 13 minutes</a></p>\n","excerpt":"","more":"<h2 id=\"问题-A-机器人王国里的路径长度\">问题 A: 机器人王国里的路径长度</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-a5ff173a\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-a5ff173a\">\n        <div class=\"fold-arrow\">▶</div> 问题 A: 机器人王国里的路径长度\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-a5ff173a\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>在一个机器人王国里，围绕首都分N层构建卫星城市。以首都为圆心，以路相连分出两个卫星城在第一个层，然后每个卫星城又有路相连分出两个卫星城在下一层，但每条路的长度不同。第N层的卫星城不再分出新的卫星城。现在人类只探知到所有直接相连的城市间的路程，你能计算某个卫星城到达首都的路程吗？</p><h3 id=\"输入\">输入</h3><p>第一行为N，表示机器人王国里有N层卫星城，N最大为10。从第二行开始，共2N+1-2行，每行分别是城市的代号到其分出的卫星城的代号和它们间的路程。 代号用若干个字母表示，直连路程最大为100。最后一行是某卫星城的代号。</p><h3 id=\"输出\">输出</h3><p>根据最后一行的卫星城代号，求该卫星城到首都的路程。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-selector-tag\">A</span> F <span class=\"hljs-number\">20</span><br><span class=\"hljs-selector-tag\">B</span> D <span class=\"hljs-number\">100</span><br><span class=\"hljs-selector-tag\">G</span> <span class=\"hljs-selector-tag\">A</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-selector-tag\">G</span> <span class=\"hljs-selector-tag\">B</span> <span class=\"hljs-number\">10</span><br><span class=\"hljs-selector-tag\">A</span> C <span class=\"hljs-number\">6</span><br><span class=\"hljs-selector-tag\">B</span> E <span class=\"hljs-number\">30</span><br>D<br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">110<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析\">问题分析</h3>\n<p>本题需要根据当前<code>target</code>不断向上<strong>回溯寻找其父节点</strong>，将<code>distance</code>值返回加入到总路程<code>sum</code>中即可，这里使用哈希表存储每个城市的父城市和到父城市的距离。</p>\n<h3 id=\"完整代码\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unordered_map&gt;</span><span class=\"hljs-comment\">//哈希表容器</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span><span class=\"hljs-comment\">//处理字符串</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span><span class=\"hljs-comment\">//这里用于幂运算</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">city</span> &#123;<br>\tstring parent;<span class=\"hljs-comment\">//父城市名称</span><br>\t<span class=\"hljs-type\">int</span> distance;<span class=\"hljs-comment\">//到父城市的距离</span><br>&#125;;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tunordered_map&lt;string, city&gt; path;<span class=\"hljs-comment\">//存储城市路径关系的哈希表</span><br>\t<span class=\"hljs-type\">int</span> N;<br>\tcin &gt;&gt; N;<br>\t<span class=\"hljs-type\">int</span> number = <span class=\"hljs-built_in\">pow</span>(<span class=\"hljs-number\">2</span>, N + <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//计算读取的城市个数</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; number;i ++) &#123;<br>\t\tstring start, end;<br>\t\t<span class=\"hljs-type\">int</span> distance;<br>\t\tcin &gt;&gt; start &gt;&gt; end &gt;&gt; distance;<br>\t\tpath[end] = &#123; start,distance &#125;;<span class=\"hljs-comment\">//进行存储</span><br>\t&#125;<br>\tstring target;<br>\tcin &gt;&gt; target;<br>\t<span class=\"hljs-type\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (path.<span class=\"hljs-built_in\">find</span>(target)!=path.<span class=\"hljs-built_in\">end</span>())&#123;<br>\t<span class=\"hljs-comment\">//直至当前的目标城市无法查找到父城市是停止</span><br>\t\tsum += path[target].distance;<br>\t\ttarget = path[target].parent;<span class=\"hljs-comment\">//将当前目标城市向上移动</span><br>\t&#125;<br>\tcout &lt;&lt; sum &lt;&lt; endl;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"注释\">注释</h3>\n<p><code>&lt;unordered_map&gt;</code>是C++标准库中提供<strong>无序关联容器</strong>的头文件，它实现了基于哈希表的<strong>键值对存储结构</strong>，它具有以下特性：</p>\n<ul>\n<li>元素<strong>无序存储</strong>，不会根据关键字值或映射值按<strong>任何特定顺序排序</strong></li>\n<li>键必须<strong>唯一</strong>（不允许重复键）</li>\n<li>根据关键字来引用，而<strong>不是根据索引来引用</strong></li>\n<li>使用<strong>链表处理哈希冲突</strong>（<strong>链地址法</strong>）</li>\n</ul>\n<p>构造哈希表：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;KeyType, ValueType&gt; map_name;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-built_in\">unordered_map</span>(<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>) position;<br>unordered_map&lt;string,string&gt; name;<br>unordered_map&lt;string,<span class=\"hljs-type\">int</span>&gt; age;<br></code></pre></td></tr></table></figure>\n<ol>\n<li><strong>元素添加</strong></li>\n</ol>\n<ul>\n<li>声明时<strong>使用初始化列表</strong>进行初始化：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; position = &#123;&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">10</span>&#125;,&#123;<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">20</span>&#125;,&#123;<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">30</span>&#125;&#125;;<br>unordered_map&lt;string, string&gt; capital_city = &#123;<br>    &#123;<span class=\"hljs-string\">&quot;UK&quot;</span>, <span class=\"hljs-string\">&quot;London&quot;</span>&#125;,<br>    &#123;<span class=\"hljs-string\">&quot;France&quot;</span>, <span class=\"hljs-string\">&quot;Paris&quot;</span>&#125;,<br>    &#123;<span class=\"hljs-string\">&quot;Germany&quot;</span>, <span class=\"hljs-string\">&quot;Berlin&quot;</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>使用<code>[]</code>运算符添加：</p>\n<ul>\n<li>如果键<strong>不存在</strong>，会<strong>插入一个新的键值对</strong></li>\n<li>如果键<strong>已存在</strong>，则会<strong>覆盖</strong>原有的值</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">unordered_map&lt;string, <span class=\"hljs-type\">int</span>&gt; age_map;<br>age_map[<span class=\"hljs-string\">&quot;Alice&quot;</span>] = <span class=\"hljs-number\">25</span>; <span class=\"hljs-comment\">// 插入 &#123;&quot;Alice&quot;, 25&#125;</span><br>age_map[<span class=\"hljs-string\">&quot;Bob&quot;</span>] = <span class=\"hljs-number\">30</span>;   <span class=\"hljs-comment\">// 插入 &#123;&quot;Bob&quot;, 30&#125;</span><br>age_map[<span class=\"hljs-string\">&quot;Alice&quot;</span>] = <span class=\"hljs-number\">26</span>; <span class=\"hljs-comment\">// 更新，现在 &#123;&quot;Alice&quot;, 26&#125;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p>使用<code>insert()</code>：插入一个键值对 <code>pair&lt;Key, Value&gt;</code>:</p>\n<ul>\n<li>返回值是一个 <code>pair&lt;iterator, bool&gt;</code></li>\n<li><code>name.first</code>是<strong>指向插入元素的迭代器</strong></li>\n<li><code>name.second</code>是 bool 类型，表示<strong>插入是否成功</strong>（true 表示成功，false 表示键已存在）</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> result = age_map.<span class=\"hljs-built_in\">insert</span>(&#123;<span class=\"hljs-string\">&quot;Charlie&quot;</span>, <span class=\"hljs-number\">28</span>&#125;); <br><span class=\"hljs-comment\">// result 是一个 pair&lt;iterator, bool&gt;</span><br><span class=\"hljs-comment\">// result.first 是指向插入元素的迭代器</span><br><span class=\"hljs-comment\">// result.second 是 bool 类型，表示插入是否成功（true 表示成功，false 表示键已存在）</span><br><span class=\"hljs-keyword\">if</span> (result.second) &#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Insertion successful!\\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>元素访问</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[]</code>运算符</td>\n<td><strong>访问</strong>元素（键不存在时会插入默认值）</td>\n</tr>\n<tr>\n<td><code>map.at(key)</code></td>\n<td>安全<strong>访问</strong>元素（不存在时<strong>抛出out_of_range异常</strong>）</td>\n</tr>\n<tr>\n<td><code>map.find(key)</code></td>\n<td>返回指向元素的<strong>迭代器</strong>（不存在时<strong>返回end()</strong>）</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> alice_age = age_map[<span class=\"hljs-string\">&quot;Alice&quot;</span>]; <span class=\"hljs-comment\">// 存在，返回 26</span><br><span class=\"hljs-type\">int</span> dave_age = age_map[<span class=\"hljs-string\">&quot;Dave&quot;</span>];   <span class=\"hljs-comment\">// 不存在！会自动插入 &#123;&quot;Dave&quot;, 0&#125;，然后返回 0</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> alice_age = age_map.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>); <span class=\"hljs-comment\">// 存在，返回 26</span><br><span class=\"hljs-type\">int</span> dave_age = age_map.<span class=\"hljs-built_in\">at</span>(<span class=\"hljs-string\">&quot;Dave&quot;</span>);   <span class=\"hljs-comment\">// 不存在！抛出异常</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (it != age_map.<span class=\"hljs-built_in\">end</span>()) &#123;<br>    <span class=\"hljs-comment\">// it-&gt;first 是键 (”Bob“)</span><br>    <span class=\"hljs-comment\">// it-&gt;second 是值 (30)</span><br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Found Bob, age: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    cout &lt;&lt; <span class=\"hljs-string\">&quot;Bob not found.\\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><strong>容量查询</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.empty()</code></td>\n<td>判断容器是否为空</td>\n</tr>\n<tr>\n<td><code>map.size()</code></td>\n<td>返回元素个数</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li><strong>修改操作</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.insert(&#123;key, value&#125;)</code></td>\n<td>插入键值对（返回pair&lt;iterator, bool&gt;）</td>\n</tr>\n<tr>\n<td><code>map.emplace(key, value)</code></td>\n<td><strong>直接构造元素</strong>（避免临时对象）</td>\n</tr>\n<tr>\n<td><code>map.erase(key)</code></td>\n<td><strong>删除指定键的元素</strong></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>通过<strong>迭代器</strong>删除：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">find</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);<br><span class=\"hljs-keyword\">if</span> (it != age_map.<span class=\"hljs-built_in\">end</span>()) &#123;<br>    age_map.<span class=\"hljs-built_in\">erase</span>(it); <span class=\"hljs-comment\">// 删除迭代器指向的元素</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>通过<strong>键</strong>删除：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">size_t</span> num_removed = age_map.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-string\">&quot;Charlie&quot;</span>); <span class=\"hljs-comment\">// 返回被删除的元素个数（0 或 1）</span><br></code></pre></td></tr></table></figure>\n<p><code>insert()</code> &amp;&amp; <code>emplace()</code>的区别：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">map.<span class=\"hljs-built_in\">insert</span>(&#123;<span class=\"hljs-string\">&quot;apple&quot;</span>, <span class=\"hljs-number\">2</span>&#125;);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">map.<span class=\"hljs-built_in\">emplace</span>(<span class=\"hljs-string\">&quot;apple&quot;</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li><strong>查找与统计</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>成员函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>map.count(key)</code></td>\n<td>判断<strong>键是否存在</strong>（返回bool）</td>\n</tr>\n<tr>\n<td><code>map.contains(key)</code></td>\n<td>返回<strong>关键字出现的次数</strong></td>\n</tr>\n</tbody>\n</table>\n<ol start=\"6\">\n<li><strong>遍历元素</strong></li>\n</ol>\n<ul>\n<li>使用范围 for 循环</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; pair : age_map) &#123;<br>    cout &lt;&lt; pair.first &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li>使用迭代器</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it = age_map.<span class=\"hljs-built_in\">begin</span>(); it != age_map.<span class=\"hljs-built_in\">end</span>(); ++it) &#123;<br>    cout &lt;&lt; it-&gt;first &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"问题-D-寻找第二小的数\">问题 D: 寻找第二小的数</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b7bb3a6d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b7bb3a6d\">\n        <div class=\"fold-arrow\">▶</div> 问题 D: 寻找第二小的数\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b7bb3a6d\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>求n个整数中第二小的数。<br>相同的整数看成一个数。比如，有5个数分别是1,1,3,4,5，那么第二小的数就是3。</p><h3 id=\"输入\">输入</h3><p>输入包含多组测试数据。输入的第一行是一个整数C，表示有C组测试数据；<br>每组测试数据的第一行是一个整数n，表示本组测试数据有n个整数（2&lt;=n&lt;=10），接着一行是n个整数（每个数均小于100）。</p><h3 id=\"输出\">输出</h3><p>为每组测试数据输出第二小的整数，如果不存在第二小的整数则输出“NO”，每组输出占一行。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">5</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">3</span><br><span class=\"hljs-keyword\">NO</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v2\">问题分析</h3>\n<p>用逆序的优先队列即可完成！</p>\n<h4 id=\"完整代码-v2\">完整代码</h4>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt; pq;<br>\t<span class=\"hljs-type\">int</span> m;<br>\tcin &gt;&gt; m;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; m;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\tpq.<span class=\"hljs-built_in\">push</span>(a);<br>\t&#125;<br>\t<span class=\"hljs-type\">int</span> min = pq.<span class=\"hljs-built_in\">top</span>();<br>\tpq.<span class=\"hljs-built_in\">pop</span>();<br>\t<span class=\"hljs-keyword\">while</span> (!pq.<span class=\"hljs-built_in\">empty</span>() &amp;&amp; min == pq.<span class=\"hljs-built_in\">top</span>()) &#123;<br>\t\tpq.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span> (pq.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\tcout &lt;&lt; <span class=\"hljs-string\">&quot;NO&quot;</span> &lt;&lt; endl;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> cout &lt;&lt; pq.<span class=\"hljs-built_in\">top</span>() &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\t<span class=\"hljs-built_in\">find</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"问题-E-按十进制各位和排序\">问题 E: 按十进制各位和排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-78f48315\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-78f48315\">\n        <div class=\"fold-arrow\">▶</div> 问题 E: 按十进制各位和排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-78f48315\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>对于给定的正整数序列，按照每个数的十进制形式各个位上的数之和从大到小排序，各个位上的数和相同的按照本身大小排序，大的在前，小的在后。</p><h3 id=\"输入\">输入</h3><p>第一行 1 个整数 n,表示序列的大小。( 0 &lt; n ≤ 1000) 第二行 n 个正整数，表示序列的每个数，每个数不大于 100000000。</p><h3 id=\"输出\">输出</h3><p>输出按照题目要求排序后的序列。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">6 </span><br><span class=\"hljs-symbol\">17 </span><span class=\"hljs-number\">26</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">88</span> <span class=\"hljs-number\">22</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">88 </span><span class=\"hljs-number\">9</span> <span class=\"hljs-number\">26</span> <span class=\"hljs-number\">17</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">13</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v3\">问题分析</h3>\n<p>要将其十进制排序后的结果与原本大小匹配，这里使用了冒泡排序完成。</p>\n<h3 id=\"完整代码-v3\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Sum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span> </span>&#123;<span class=\"hljs-comment\">//十进制各个位数求和函数</span><br>\t<span class=\"hljs-type\">int</span> sum = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (a != <span class=\"hljs-number\">0</span>) &#123;<br>\t\tsum += a % <span class=\"hljs-number\">10</span>;<br>\t\ta = a / <span class=\"hljs-number\">10</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> sum;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-type\">int</span> n;<br>\tcin &gt;&gt; n;<br>\tvector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">order</span>(n);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n;i++) &#123;<br>\t\tcin &gt;&gt; order[i];<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n ; i++) &#123;<span class=\"hljs-comment\">//进行冒泡排序</span><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span> ;j &lt; n-i<span class=\"hljs-number\">-1</span>;j++) &#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Sum</span>(order[j]) &lt; <span class=\"hljs-built_in\">Sum</span>(order[j + <span class=\"hljs-number\">1</span>]) ||<br>\t\t\t\t(<span class=\"hljs-built_in\">Sum</span>(order[j]) == <span class=\"hljs-built_in\">Sum</span>(order[j + <span class=\"hljs-number\">1</span>]) &amp;&amp; order[j] &lt; order[j + <span class=\"hljs-number\">1</span>])) &#123;<br>\t\t\t\t<span class=\"hljs-type\">int</span> temp=order[j];<br>\t\t\t\torder[j]=order[j<span class=\"hljs-number\">+1</span>];<br>\t\t\t\torder[j<span class=\"hljs-number\">+1</span>]=temp;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; n; i++) &#123;<br>\t\tcout&lt;&lt;order[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"问题-F-奇偶数的排序\">问题 F: 奇偶数的排序</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b019705e\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b019705e\">\n        <div class=\"fold-arrow\">▶</div> 问题 F: 奇偶数的排序\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b019705e\">\n        <div class=\"fold-content\">\n          <h3 id=\"题目描述\">题目描述</h3><p>给你10个正整数，其中5个奇数、5个偶数，先递减排奇数，然后再递增排偶数。请编程实现。</p><h3 id=\"输入\">输入</h3><p>一行10个正整数（int类型范围）。</p><h3 id=\"输出\">输出</h3><p>先递减排5个奇数，然后再递增排5个偶数，各个数之间有一个空格间隔。</p><h3 id=\"样例输入\">样例输入</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">9</span><br></code></pre></td></tr></table></figure><h3 id=\"样例输出\">样例输出</h3><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">9 </span><span class=\"hljs-number\">7</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"问题分析-v4\">问题分析</h3>\n<p>分别使用优先队列和逆序优先队列对奇数偶数进行排序，再依次输出队首元素。</p>\n<h3 id=\"完整代码-v4\">完整代码</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\tpriority_queue&lt;<span class=\"hljs-type\">int</span>&gt; odd;<span class=\"hljs-comment\">//奇数的优先队列</span><br>\tpriority_queue &lt;<span class=\"hljs-type\">int</span>, vector&lt;<span class=\"hljs-type\">int</span>&gt;, greater&lt;<span class=\"hljs-type\">int</span>&gt;&gt;  even;<span class=\"hljs-comment\">//偶数逆序优先队列</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;i &lt; <span class=\"hljs-number\">10</span>;i++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> a;<br>\t\tcin &gt;&gt; a;<br>\t\t<span class=\"hljs-keyword\">if</span> (a % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\teven.<span class=\"hljs-built_in\">push</span>(a);<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> odd.<span class=\"hljs-built_in\">push</span>(a);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">while</span>(!odd.<span class=\"hljs-built_in\">empty</span>()) &#123;<br>\t\tcout &lt;&lt; odd.<span class=\"hljs-built_in\">top</span>()&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\todd.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">while</span> (!even.<span class=\"hljs-built_in\">empty</span>() )&#123;<br>\t\tcout &lt;&lt; even.<span class=\"hljs-built_in\">top</span>()&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>\t\teven.<span class=\"hljs-built_in\">pop</span>();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>封面来源：: <a href=\"https://www.youtube.com/watch?v=FsfRsGFHuv4\">Learn Hash Tables in 13 minutes</a></p>\n"},{"title":"CSS Basic Tutorial","date":"2025-08-18T07:15:38.000Z","index_img":"https://github.com/Richard110206/blog-image/blob/main/cover/CSS.png?raw=true","category_bar":true,"description":"A brief tutorial on CSS, including the basic grammar, detailed example and demonstration!","_content":"\n## What is CSS？\n\nCSS(Cascading Style Sheet)是用于**控制页面样式与布局**并允许**样式信息与网页内容相分离**的一种标记性语言。如果HTML是人，那么CSS就是我们身上的衣服和化妆品！\n\nCSS由**选择器**，**属性**和**属性值**组成：\n```css\nselector{prosperties:value;}\n```\n{%note info %}\n- 选择器：用于定义CSS样式名称\n- 属性：例如网页中的字体样式、字体颜色等\n- 属性值：例如字体的大小、颜色等\n{%endnote%}\n\n{%note danger%}\n- 属性和属性值必须写在{}内，且用“:”隔开\n- 每写完一个完整的属性和属性值，必须用“;”隔开\n- 如果一个属性有多个属性值，每个属性值用`space`隔开\n{%endnote%}\n\n### 引入CSS\n#### 1.内联引入\n每个HTML元素都拥有一个`<style>`属性，我们的CSS代码都是作为HTML中`<style>`属性的属性值出现的：\n\n```html\n<p style=\"color: red;\">这是段落</p>\n```\n\n<p style=\"color: red;\">这是段落</p>\n\n\n#### 2.内部引入\n当我们页面有很多元素时，这样内联引入CSS样式代码显然是不合适的，比如当**同一个元素需要复用同一种样式**，我们需要在每一个**元素内部手动添加**，这样产生很多**重复性**的操作和劳动。所以我们可以将有相同需求的元素整理好**分成许多类别**，让相同类别元素使用同一种样式。\n\n我们使用`<style>`标签进行对CSS的引入，在页面的`<head>`区域引入`<style>`标签，在其中写入需要的CSS样式：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n    p{\n        color:red;\n        font-size:20px;\n    }\n    span{\n        color:green;\n        font-size:10px;\n    }\n    </style>\n</head>\n<body>\n    <p> It's been a long day without you, my friend.</p>\n    <span>And I'll tell you all about it when I see you again.</span>\n</body>\n</html>\n```\n\n#### 3.外部引入\n在我们实际开发过程中，项目的页面不会少，如果我们希望**所有的页面都使用同一个CSS样式**，那么我们就需要将CSS样式单独放在一个文件中（**新建一个以`.css`为后缀名的样式表**）然后通过`<link>`标签引入到我们的页面中，这是你还会发现，当我们需要对所有页面进行样式修改时，就只需要修改一个CSS文件，不用对所有页面逐个修改！\n\n### CSS选择器\n\n#### 1.元素选择器\n\n对HTML元素进行选取，如`<p>`、`<ul>`等\n\n```css\n<sytle>\np{\n    color:red;\n    font-size:20px;\n}\nul{\n    list-style-type:none;\n}\na{\n    text-decoration:none;\n}\n</style>\n```\n\n#### 2.类选择器\n\n通过`class`属性确定类名进行选取，**相同类名的元素**含有相同的CSS样式\n\n```css\n<body>\n<p class=\"title\">我是一个段落</p>\n<div class=\"container\">这是一个容器</div>\n</body>\n<sytle type=\"text/css\">\n.title{\n    color:red;\n    font-size:20px;\n    text-align:center;\n}\n</sytle>\n```\n{%note info%}\n- 类选择器前需要加`.`\n- 在`vscode`中，属性名+`.`+`类名`，`Tab`自动补全<元素  class=\"类名\">的形式\n{%endnote%}\n\n#### 3.ID选择器 \n\n以上两种都是对同一类元素进行选取和操作，当我们需要**单独为一个元素**进行操作时，通过`id`属性确定ID名进行选取，如`<p id=\"title\">`、`<ul id=\"list\">`，相同ID名的含有相同的CSS样式\n\n```css\n<body>\n<p id=\"title\">我是一个段落</p>\n<div id=\"container\">这是一个容器</div>\n</body>\n<sytle type=\"text/css\">\n#title{\n    color:red;\n    font-size:20px;\n    text-align:center;\n}\n#container{\n    background-color:yellow;\n}\n</sytle>\n```\n{%note info%}\n- ID选择器前需要加`#`\n{%endnote%}\n\n## 网页常用样式\n\n### 字体\n\n#### `font-family`字体\n\n#### `font-size`字号\n{%note info%}\n- 像素（px）\n- 点数（pt）\n- 英寸（in）、厘米（cm）、毫米（mm）\n- 倍数（em）\n- 百分比（%）\n{%endnote%}\n\n#### `font-weight`字重\n{%note info%}\n- 正常（normal）：400\n- 加粗（bold）：700\n- 更粗（bolder）\n- 更细（lighter）\n- 数字（100~900）：只能写成整百的数字\n{%endnote%}\n\n#### `color`颜色\n相关内容前文有相应介绍，不再赘述\n{%note info%}\n- color_name\n- hex_number\n- rgb_number\n- rgba_number\n{%endnote%}\n\n#### `text-decoration`文本修饰\n{%note info%}\n- none：无修饰\n- underline：下划线\n- overline：上划线\n- line-through：中划线\n- blink：闪烁\n{%endnote%}\n\n### 段落\n\n#### `letter-spacing`字间距\n{%note info%}\n- normal：正常\n- length：长度\n{%endnote%}\n\n#### `word-spacing`词间距\n{%note info%}\n- normal：正常\n- length：长度\n{%endnote%}\n\n#### `text-indent`缩进\n{%note info%}\n- length：长度\n- %：百分比\n{%endnote%}\n\n#### `text-align`水平对齐\n{%note info%}\n- left：左对齐\n- right：右对齐\n- center：居中对齐\n- justify：两端对齐\n{%endnote%}\n\n#### `vertical-align`垂直对齐\n{%note info%}\n- top：顶部对齐\n- middle：垂直居中对齐\n- bottom：底部对齐\n{%endnote%}\n#### `line-height`行间距\n{%note info%}\n- normal：正常\n- number：与当前字体尺寸相乘来设置行间距\n- length：固定行间距\n{%endnote%}\n\n### 边框\n#### `border-style`边框线型\n{%note info%}\n- none：无边框\n- hidden：隐藏边框\n- dotted：点状边框\n- dashed：虚线边框\n- solid：实线边框\n- double：双线边框\n{%endnote%}\n\n```css\nborder-style:dotted solid double dashed;\n```\n\n```\n上边框是点状\n右边框是实线\n下边框是双线\n左边框是虚线\n```\n***\n```css\nborder-style:dotted solid double;\n```\n\n```\n上边框是点状\n右边框和左边框是实线\n下边框是双线\n```\n***\n```css\nborder-style:dotted solid;\n```\n```\n上边框和下边框是点状\n右边框和左边框是实线\n```\n***\n```css\nborder-style:dotted;\n```\n\n```\n四个边框均为点状\n```\n***\n#### `border-color`边框颜色\n#### `border-width`边框宽度\n\n\n\n\n## 盒子模型\n![盒子模型图解](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/div.png?raw=true)\n\n&emsp;&emsp;根据上图，**俯视**这个盒子，内边距（padding）可以理解为**盒子里装的东西和边框的距离**；而边框（border）就是**盒子本身**；内容（content）就是**盒子中装的东西**；外边距就是边框外面自动留出的一段空白；而填充（padding）就是怕盒子里装的东西损坏而添加的泡沫或者其他抗震**材料**；至于边界（margin）则说明盒子摆放时不能全部堆在一起，要**留有一定空隙**保持通风，同时方便取出！\n\n### 外边距设置\n使用`margin`属性设置**外边距**，`margin`边界环绕在该元素的`content`区域四周，如果`margin`为0，则`margin`边界与`border`边界重合。\n|属性|描述|\n|----|----|\n|`margin-top`|上外边距|\n|`margin-right`|右外边距|\n|`margin-bottom`|下外边距|\n|`margin-left`|左外边距|\n\n{%note info%}\n`margin`属性值仍然有**四个参数**，对应上、右、下、左即**顺时针方向旋转**\n{%endnote%}\n\n![margin效果图](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/div_example_1.png?raw=true)\n```html\n <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        div{\n            width:200px;\n            height:100px;\n            border:2px green solid;\n            background-color:crimson\n        }\n        .d2{\n            margin-top: 20px;\n            margin-right:auto;\n            margin-bottom: 40px;\n            margin-left:10px;\n            // margin:20px auto 40px 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"d1\"></div>\n    <div class=\"d2\"></div>\n    <div class=\"d3\"></div>\n</body>\n</html>\n```\n{%note danger%}\n当两个垂直外边距相遇时，他们将会**形成一个外边距**，合并后的外边距的高度等于两个**外边距的最大高度**（注意不是外边距相加）\n{%endnote%}\n\n![margin外边距合并](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/margin.png?raw=true)\n\n\n### 内边距设置\n使用`padding`属性设置**内边距**，内边距在边框和内容区之间，`padding`属性接受长度值和百分比，但不允许使用负值。\n|属性|描述|\n|----|----|\n|`padding-top`|上内边距|\n|`padding-right`|右内边距|\n|`padding-bottom`|下内边距|\n|`padding-left`|左内边距|\n\n### 弹性盒子\n{%note info%}\n默认流式布局中，块级元素（如`div`）会独占一行，多个`div`会垂直堆叠，无法横向排列；而当我们使用`float`和`inline-box`进行横向排列时，会带来间距、对齐、父元素高度塌陷等问题。\n{%endnote%}\n\n&emsp;&emsp;当一种页面需要**适应不同的屏幕大小以及设备类型**时，弹性盒子可以确保元素拥有恰当行为的布局方式，这样的布局模型能提供一种**更有效的方式来对一个容器中的子元素进行排列、对齐、分配空白空间**！\n\n{%note danger%}\n- 只要给容器设置`display: flex;`**任何一个容器**我们都可以设置为弹性盒子\n- 设为`flex`布局以后，子元素的`float`、`clear`、`vertical-align`**属性将失效**\n{%endnote%}\n\n- `flex-direction`：设置**排列方向**（沿纵轴还是横轴）（正序还是倒序）\n\n|值|描述|动画演示|\n|----|----|----|\n|`row`|默认值，水平显示，起点在左端|:one::two::three::four:_ _ _ _|\n|`row-reverse`|盒子方向相反，且起点在右端|_ _ _ _:four::three::two::one:|\n|`column`|垂直显示，起点在上端|无|\n|`column-reverse`|盒子方向相反，且起点在下端|无|\n\n\n- `justify-content`：在**主轴（横轴）上的对齐方式**\n\n|值|描述|动画演示|\n|----|----|----|\n|`flex-start`|起点在左端|:one::two::three::four:_ _ _ _|\n|`flex-end`|终点在右端|_ _ _ _:one::two::three::four:|\n|`center`|居中对齐|_ _:one::two::three::four: _ _|\n|`space-between`|项目之间的间隔相等，紧贴左右两端|:one: _ :two: _ :three: _ :four:|\n|`space-around`|每个项目两侧的间隔相等|_ :one: _ :two: _ :three: _ :four: _|\n|`space-evenly`|项目之间的间隔相等，且项目两侧的间隔相等|_ :one: _ :two: _ :three: _ :four: _|\n\n\n- `align-items`：在**侧轴（纵轴）上的对齐方式**\n\n\n|值|描述|\n|----|----|\n|`flex-start`|起点在上端|\n|`flex-end`|终点在下端|\n|`center`|居中对齐|\n|`baseline`|基线对齐|\n|`stretch`|`auto`尽可能接近所在行的尺寸|\n\n\n- `flex-wrap`：弹性盒子的**换行方式**\n\n|值|描述|\n|----|----|\n|`nowrap`|默认值，不换行，盒子会被压缩|\n|`wrap`|换行，第一行在上方|\n|`wrap-reverse`|反向换行，第一行在下方|\n\n- `align-content`：**多行情况下侧轴（纵轴）的对齐方式**\n\n|值|描述|\n|----|----|\n|`stretch`|默认值`auto`，将占满整个容器的高度|\n|`flex-start`|起点在上端|\n|`flex-end`|起点在下端|\n|`center`|上下居中对齐|\n|`space-between`|项目之间的间隔相等|\n|`space-around`|每个项目两侧的间隔相等|\n\n{%note danger%}\n该属性只在多行（`flex-wrap: wrap`或`flex-wrap: wrap-reverse`）的情况下生效！\n{%endnote%}\n\n\n下面是使用CSS和HTML创建的“待办事项”demo！\n\n![“待办事项”样例展示](https://raw.githubusercontent.com/Richard110206/blog-image/main/article/Html%26%26CSS/%E6%A0%B7%E4%BE%8B%E5%B1%95%E7%A4%BA.png)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>hello</title>\n</head>\n\n<body>\n    <div class=\"todolist\">\n        <div class=\"title\">\n            Richard的todolist\n        </div>\n        <div class=\"todo-form\">\n            <input class=\"todo-input\" type=\"text\" placeholder=\"请输入待办事项\">\n            <div class=\"todo-button\">添加</div>\n        </div>\n\n        <div class=\"item completed\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">吃饭</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n        <div class=\"item\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">睡觉</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n        <div class=\"item\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">学习</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n    </div>\n\n    <style>\n        .completed{\n            text-decoration: line-through;\n            opacity: 0.4;\n        }\n        .del{\n            color: red;\n        }\n        .item{\n            display: flex;\n            align-items: center; /* 垂直居中对齐 */\n            box-sizing: border-box;\n            width: 80%;\n            height: 50px;\n            margin: 8px auto;\n            padding: 16px;\n            border-radius: 0 20px 20px 0; \n            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* 修复阴影语法 */\n            background-color: #f9f9f9;\n        }\n        \n        .todo-form{ \n            display: flex;\n            width: 80%;\n            margin: 20px auto; /* 居中表单 */\n            height: 50px; /* 固定表单高度 */\n        }\n        \n        .todo-input{ \n            padding-left: 15px;\n            border: 1px solid #dfe1e5; \n            outline: none;\n            width: calc(100% - 100px); /* 自动计算宽度 */\n            height: 100%; /* 与按钮同高 */\n            border-radius: 20px 0 0 20px; /* 修复语法错误 */\n            box-sizing: border-box; /* 确保padding不增加总宽度 */\n            font-size: 16px;\n        }\n        \n        .todo-button{\n            width: 100px;\n            height: 100%; /* 与输入框同高 */\n            border-radius: 0 20px 20px 0;\n            text-align: center;\n            background: linear-gradient(\n                to right,\n                rgb(113,65,168),\n                rgba(44, 144, 251,1)\n            );\n            color: white;\n            padding: 0 10px; /* 垂直居中文字 */\n            line-height: 50px; /* 与高度一致实现垂直居中 */\n            cursor: pointer;\n            user-select: none;\n        }\n        \n        body{\n            background: linear-gradient(\n                to right,\n                rgb(113,65,168),\n                rgba(44, 144, 251,1)\n            );\n            margin: 0;\n            padding: 20px;\n        }\n        \n        .todolist{\n            max-width: 600px; /* 限制最大宽度 */\n            width: 100%;\n            padding: 20px;\n            background-color: white;\n            border-radius: 10px;\n            margin: 40px auto; /* 水平居中 */\n            box-shadow: 0 5px 15px rgba(0,0,0,0.1);\n        }\n        \n        .title{\n            text-align: center;\n            font-size: 30px;\n            font-weight: 700;\n            color: rgb(113,65,168);\n            margin-top: 20px;\n            margin-bottom: 30px;\n        }\n        \n        .del {\n            margin-left: auto;\n            color: #ff4444;\n            cursor: pointer;\n            padding: 5px 10px;\n            border-radius: 12px;\n            background-color: #fef0f0;\n        }\n        \n        .name {\n            margin-left: 10px;\n            flex: 1;\n        }\n    </style>\n</body>\n</html> \n```\n\n封面来源：[Learn CSS Flexbox in 20 Minutes (Course)](https://www.youtube.com/watch?v=wsTv9y931o8)","source":"_posts/Full-Stack/CSS.md","raw":"---\ntitle: CSS Basic Tutorial\ndate: 2025-08-18 15:15:38\ntags: [CSS]\nindex_img: https://github.com/Richard110206/blog-image/blob/main/cover/CSS.png?raw=true\ncategory: Full Stack\ncategory_bar: true\ndescription: A brief tutorial on CSS, including the basic grammar, detailed example and demonstration!\n---\n\n## What is CSS？\n\nCSS(Cascading Style Sheet)是用于**控制页面样式与布局**并允许**样式信息与网页内容相分离**的一种标记性语言。如果HTML是人，那么CSS就是我们身上的衣服和化妆品！\n\nCSS由**选择器**，**属性**和**属性值**组成：\n```css\nselector{prosperties:value;}\n```\n{%note info %}\n- 选择器：用于定义CSS样式名称\n- 属性：例如网页中的字体样式、字体颜色等\n- 属性值：例如字体的大小、颜色等\n{%endnote%}\n\n{%note danger%}\n- 属性和属性值必须写在{}内，且用“:”隔开\n- 每写完一个完整的属性和属性值，必须用“;”隔开\n- 如果一个属性有多个属性值，每个属性值用`space`隔开\n{%endnote%}\n\n### 引入CSS\n#### 1.内联引入\n每个HTML元素都拥有一个`<style>`属性，我们的CSS代码都是作为HTML中`<style>`属性的属性值出现的：\n\n```html\n<p style=\"color: red;\">这是段落</p>\n```\n\n<p style=\"color: red;\">这是段落</p>\n\n\n#### 2.内部引入\n当我们页面有很多元素时，这样内联引入CSS样式代码显然是不合适的，比如当**同一个元素需要复用同一种样式**，我们需要在每一个**元素内部手动添加**，这样产生很多**重复性**的操作和劳动。所以我们可以将有相同需求的元素整理好**分成许多类别**，让相同类别元素使用同一种样式。\n\n我们使用`<style>`标签进行对CSS的引入，在页面的`<head>`区域引入`<style>`标签，在其中写入需要的CSS样式：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n    p{\n        color:red;\n        font-size:20px;\n    }\n    span{\n        color:green;\n        font-size:10px;\n    }\n    </style>\n</head>\n<body>\n    <p> It's been a long day without you, my friend.</p>\n    <span>And I'll tell you all about it when I see you again.</span>\n</body>\n</html>\n```\n\n#### 3.外部引入\n在我们实际开发过程中，项目的页面不会少，如果我们希望**所有的页面都使用同一个CSS样式**，那么我们就需要将CSS样式单独放在一个文件中（**新建一个以`.css`为后缀名的样式表**）然后通过`<link>`标签引入到我们的页面中，这是你还会发现，当我们需要对所有页面进行样式修改时，就只需要修改一个CSS文件，不用对所有页面逐个修改！\n\n### CSS选择器\n\n#### 1.元素选择器\n\n对HTML元素进行选取，如`<p>`、`<ul>`等\n\n```css\n<sytle>\np{\n    color:red;\n    font-size:20px;\n}\nul{\n    list-style-type:none;\n}\na{\n    text-decoration:none;\n}\n</style>\n```\n\n#### 2.类选择器\n\n通过`class`属性确定类名进行选取，**相同类名的元素**含有相同的CSS样式\n\n```css\n<body>\n<p class=\"title\">我是一个段落</p>\n<div class=\"container\">这是一个容器</div>\n</body>\n<sytle type=\"text/css\">\n.title{\n    color:red;\n    font-size:20px;\n    text-align:center;\n}\n</sytle>\n```\n{%note info%}\n- 类选择器前需要加`.`\n- 在`vscode`中，属性名+`.`+`类名`，`Tab`自动补全<元素  class=\"类名\">的形式\n{%endnote%}\n\n#### 3.ID选择器 \n\n以上两种都是对同一类元素进行选取和操作，当我们需要**单独为一个元素**进行操作时，通过`id`属性确定ID名进行选取，如`<p id=\"title\">`、`<ul id=\"list\">`，相同ID名的含有相同的CSS样式\n\n```css\n<body>\n<p id=\"title\">我是一个段落</p>\n<div id=\"container\">这是一个容器</div>\n</body>\n<sytle type=\"text/css\">\n#title{\n    color:red;\n    font-size:20px;\n    text-align:center;\n}\n#container{\n    background-color:yellow;\n}\n</sytle>\n```\n{%note info%}\n- ID选择器前需要加`#`\n{%endnote%}\n\n## 网页常用样式\n\n### 字体\n\n#### `font-family`字体\n\n#### `font-size`字号\n{%note info%}\n- 像素（px）\n- 点数（pt）\n- 英寸（in）、厘米（cm）、毫米（mm）\n- 倍数（em）\n- 百分比（%）\n{%endnote%}\n\n#### `font-weight`字重\n{%note info%}\n- 正常（normal）：400\n- 加粗（bold）：700\n- 更粗（bolder）\n- 更细（lighter）\n- 数字（100~900）：只能写成整百的数字\n{%endnote%}\n\n#### `color`颜色\n相关内容前文有相应介绍，不再赘述\n{%note info%}\n- color_name\n- hex_number\n- rgb_number\n- rgba_number\n{%endnote%}\n\n#### `text-decoration`文本修饰\n{%note info%}\n- none：无修饰\n- underline：下划线\n- overline：上划线\n- line-through：中划线\n- blink：闪烁\n{%endnote%}\n\n### 段落\n\n#### `letter-spacing`字间距\n{%note info%}\n- normal：正常\n- length：长度\n{%endnote%}\n\n#### `word-spacing`词间距\n{%note info%}\n- normal：正常\n- length：长度\n{%endnote%}\n\n#### `text-indent`缩进\n{%note info%}\n- length：长度\n- %：百分比\n{%endnote%}\n\n#### `text-align`水平对齐\n{%note info%}\n- left：左对齐\n- right：右对齐\n- center：居中对齐\n- justify：两端对齐\n{%endnote%}\n\n#### `vertical-align`垂直对齐\n{%note info%}\n- top：顶部对齐\n- middle：垂直居中对齐\n- bottom：底部对齐\n{%endnote%}\n#### `line-height`行间距\n{%note info%}\n- normal：正常\n- number：与当前字体尺寸相乘来设置行间距\n- length：固定行间距\n{%endnote%}\n\n### 边框\n#### `border-style`边框线型\n{%note info%}\n- none：无边框\n- hidden：隐藏边框\n- dotted：点状边框\n- dashed：虚线边框\n- solid：实线边框\n- double：双线边框\n{%endnote%}\n\n```css\nborder-style:dotted solid double dashed;\n```\n\n```\n上边框是点状\n右边框是实线\n下边框是双线\n左边框是虚线\n```\n***\n```css\nborder-style:dotted solid double;\n```\n\n```\n上边框是点状\n右边框和左边框是实线\n下边框是双线\n```\n***\n```css\nborder-style:dotted solid;\n```\n```\n上边框和下边框是点状\n右边框和左边框是实线\n```\n***\n```css\nborder-style:dotted;\n```\n\n```\n四个边框均为点状\n```\n***\n#### `border-color`边框颜色\n#### `border-width`边框宽度\n\n\n\n\n## 盒子模型\n![盒子模型图解](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/div.png?raw=true)\n\n&emsp;&emsp;根据上图，**俯视**这个盒子，内边距（padding）可以理解为**盒子里装的东西和边框的距离**；而边框（border）就是**盒子本身**；内容（content）就是**盒子中装的东西**；外边距就是边框外面自动留出的一段空白；而填充（padding）就是怕盒子里装的东西损坏而添加的泡沫或者其他抗震**材料**；至于边界（margin）则说明盒子摆放时不能全部堆在一起，要**留有一定空隙**保持通风，同时方便取出！\n\n### 外边距设置\n使用`margin`属性设置**外边距**，`margin`边界环绕在该元素的`content`区域四周，如果`margin`为0，则`margin`边界与`border`边界重合。\n|属性|描述|\n|----|----|\n|`margin-top`|上外边距|\n|`margin-right`|右外边距|\n|`margin-bottom`|下外边距|\n|`margin-left`|左外边距|\n\n{%note info%}\n`margin`属性值仍然有**四个参数**，对应上、右、下、左即**顺时针方向旋转**\n{%endnote%}\n\n![margin效果图](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/div_example_1.png?raw=true)\n```html\n <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        div{\n            width:200px;\n            height:100px;\n            border:2px green solid;\n            background-color:crimson\n        }\n        .d2{\n            margin-top: 20px;\n            margin-right:auto;\n            margin-bottom: 40px;\n            margin-left:10px;\n            // margin:20px auto 40px 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"d1\"></div>\n    <div class=\"d2\"></div>\n    <div class=\"d3\"></div>\n</body>\n</html>\n```\n{%note danger%}\n当两个垂直外边距相遇时，他们将会**形成一个外边距**，合并后的外边距的高度等于两个**外边距的最大高度**（注意不是外边距相加）\n{%endnote%}\n\n![margin外边距合并](https://github.com/Richard110206/Blog-image/blob/main/article/Html&&CSS/margin.png?raw=true)\n\n\n### 内边距设置\n使用`padding`属性设置**内边距**，内边距在边框和内容区之间，`padding`属性接受长度值和百分比，但不允许使用负值。\n|属性|描述|\n|----|----|\n|`padding-top`|上内边距|\n|`padding-right`|右内边距|\n|`padding-bottom`|下内边距|\n|`padding-left`|左内边距|\n\n### 弹性盒子\n{%note info%}\n默认流式布局中，块级元素（如`div`）会独占一行，多个`div`会垂直堆叠，无法横向排列；而当我们使用`float`和`inline-box`进行横向排列时，会带来间距、对齐、父元素高度塌陷等问题。\n{%endnote%}\n\n&emsp;&emsp;当一种页面需要**适应不同的屏幕大小以及设备类型**时，弹性盒子可以确保元素拥有恰当行为的布局方式，这样的布局模型能提供一种**更有效的方式来对一个容器中的子元素进行排列、对齐、分配空白空间**！\n\n{%note danger%}\n- 只要给容器设置`display: flex;`**任何一个容器**我们都可以设置为弹性盒子\n- 设为`flex`布局以后，子元素的`float`、`clear`、`vertical-align`**属性将失效**\n{%endnote%}\n\n- `flex-direction`：设置**排列方向**（沿纵轴还是横轴）（正序还是倒序）\n\n|值|描述|动画演示|\n|----|----|----|\n|`row`|默认值，水平显示，起点在左端|:one::two::three::four:_ _ _ _|\n|`row-reverse`|盒子方向相反，且起点在右端|_ _ _ _:four::three::two::one:|\n|`column`|垂直显示，起点在上端|无|\n|`column-reverse`|盒子方向相反，且起点在下端|无|\n\n\n- `justify-content`：在**主轴（横轴）上的对齐方式**\n\n|值|描述|动画演示|\n|----|----|----|\n|`flex-start`|起点在左端|:one::two::three::four:_ _ _ _|\n|`flex-end`|终点在右端|_ _ _ _:one::two::three::four:|\n|`center`|居中对齐|_ _:one::two::three::four: _ _|\n|`space-between`|项目之间的间隔相等，紧贴左右两端|:one: _ :two: _ :three: _ :four:|\n|`space-around`|每个项目两侧的间隔相等|_ :one: _ :two: _ :three: _ :four: _|\n|`space-evenly`|项目之间的间隔相等，且项目两侧的间隔相等|_ :one: _ :two: _ :three: _ :four: _|\n\n\n- `align-items`：在**侧轴（纵轴）上的对齐方式**\n\n\n|值|描述|\n|----|----|\n|`flex-start`|起点在上端|\n|`flex-end`|终点在下端|\n|`center`|居中对齐|\n|`baseline`|基线对齐|\n|`stretch`|`auto`尽可能接近所在行的尺寸|\n\n\n- `flex-wrap`：弹性盒子的**换行方式**\n\n|值|描述|\n|----|----|\n|`nowrap`|默认值，不换行，盒子会被压缩|\n|`wrap`|换行，第一行在上方|\n|`wrap-reverse`|反向换行，第一行在下方|\n\n- `align-content`：**多行情况下侧轴（纵轴）的对齐方式**\n\n|值|描述|\n|----|----|\n|`stretch`|默认值`auto`，将占满整个容器的高度|\n|`flex-start`|起点在上端|\n|`flex-end`|起点在下端|\n|`center`|上下居中对齐|\n|`space-between`|项目之间的间隔相等|\n|`space-around`|每个项目两侧的间隔相等|\n\n{%note danger%}\n该属性只在多行（`flex-wrap: wrap`或`flex-wrap: wrap-reverse`）的情况下生效！\n{%endnote%}\n\n\n下面是使用CSS和HTML创建的“待办事项”demo！\n\n![“待办事项”样例展示](https://raw.githubusercontent.com/Richard110206/blog-image/main/article/Html%26%26CSS/%E6%A0%B7%E4%BE%8B%E5%B1%95%E7%A4%BA.png)\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>hello</title>\n</head>\n\n<body>\n    <div class=\"todolist\">\n        <div class=\"title\">\n            Richard的todolist\n        </div>\n        <div class=\"todo-form\">\n            <input class=\"todo-input\" type=\"text\" placeholder=\"请输入待办事项\">\n            <div class=\"todo-button\">添加</div>\n        </div>\n\n        <div class=\"item completed\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">吃饭</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n        <div class=\"item\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">睡觉</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n        <div class=\"item\">\n            <div>\n            <input type=\"checkbox\">\n            <span class=\"name\">学习</span>\n            </div>\n\n            <div class=\"del\">删除</div>\n        </div>\n    </div>\n\n    <style>\n        .completed{\n            text-decoration: line-through;\n            opacity: 0.4;\n        }\n        .del{\n            color: red;\n        }\n        .item{\n            display: flex;\n            align-items: center; /* 垂直居中对齐 */\n            box-sizing: border-box;\n            width: 80%;\n            height: 50px;\n            margin: 8px auto;\n            padding: 16px;\n            border-radius: 0 20px 20px 0; \n            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* 修复阴影语法 */\n            background-color: #f9f9f9;\n        }\n        \n        .todo-form{ \n            display: flex;\n            width: 80%;\n            margin: 20px auto; /* 居中表单 */\n            height: 50px; /* 固定表单高度 */\n        }\n        \n        .todo-input{ \n            padding-left: 15px;\n            border: 1px solid #dfe1e5; \n            outline: none;\n            width: calc(100% - 100px); /* 自动计算宽度 */\n            height: 100%; /* 与按钮同高 */\n            border-radius: 20px 0 0 20px; /* 修复语法错误 */\n            box-sizing: border-box; /* 确保padding不增加总宽度 */\n            font-size: 16px;\n        }\n        \n        .todo-button{\n            width: 100px;\n            height: 100%; /* 与输入框同高 */\n            border-radius: 0 20px 20px 0;\n            text-align: center;\n            background: linear-gradient(\n                to right,\n                rgb(113,65,168),\n                rgba(44, 144, 251,1)\n            );\n            color: white;\n            padding: 0 10px; /* 垂直居中文字 */\n            line-height: 50px; /* 与高度一致实现垂直居中 */\n            cursor: pointer;\n            user-select: none;\n        }\n        \n        body{\n            background: linear-gradient(\n                to right,\n                rgb(113,65,168),\n                rgba(44, 144, 251,1)\n            );\n            margin: 0;\n            padding: 20px;\n        }\n        \n        .todolist{\n            max-width: 600px; /* 限制最大宽度 */\n            width: 100%;\n            padding: 20px;\n            background-color: white;\n            border-radius: 10px;\n            margin: 40px auto; /* 水平居中 */\n            box-shadow: 0 5px 15px rgba(0,0,0,0.1);\n        }\n        \n        .title{\n            text-align: center;\n            font-size: 30px;\n            font-weight: 700;\n            color: rgb(113,65,168);\n            margin-top: 20px;\n            margin-bottom: 30px;\n        }\n        \n        .del {\n            margin-left: auto;\n            color: #ff4444;\n            cursor: pointer;\n            padding: 5px 10px;\n            border-radius: 12px;\n            background-color: #fef0f0;\n        }\n        \n        .name {\n            margin-left: 10px;\n            flex: 1;\n        }\n    </style>\n</body>\n</html> \n```\n\n封面来源：[Learn CSS Flexbox in 20 Minutes (Course)](https://www.youtube.com/watch?v=wsTv9y931o8)","slug":"Full-Stack/CSS","published":1,"updated":"2025-08-21T10:01:12.595Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hco000z40w37fuvcrw7","content":"<h2 id=\"What-is-CSS？\">What is CSS？</h2>\n<p>CSS(Cascading Style Sheet)是用于<strong>控制页面样式与布局</strong>并允许<strong>样式信息与网页内容相分离</strong>的一种标记性语言。如果HTML是人，那么CSS就是我们身上的衣服和化妆品！</p>\n<p>CSS由<strong>选择器</strong>，<strong>属性</strong>和<strong>属性值</strong>组成：</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">selector{prosperties:value;}<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <ul><li>选择器：用于定义CSS样式名称</li><li>属性：例如网页中的字体样式、字体颜色等</li><li>属性值：例如字体的大小、颜色等</li></ul>\n          </div>\n<div class=\"note note-danger\">\n            <ul><li>属性和属性值必须写在{}内，且用“:”隔开</li><li>每写完一个完整的属性和属性值，必须用“;”隔开</li><li>如果一个属性有多个属性值，每个属性值用<code>space</code>隔开</li></ul>\n          </div>\n<h3 id=\"引入CSS\">引入CSS</h3>\n<h4 id=\"1-内联引入\">1.内联引入</h4>\n<p>每个HTML元素都拥有一个<code>&lt;style&gt;</code>属性，我们的CSS代码都是作为HTML中<code>&lt;style&gt;</code>属性的属性值出现的：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: red;\"</span>&gt;</span>这是段落<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p style=\"color: red;\">这是段落</p>\n<h4 id=\"2-内部引入\">2.内部引入</h4>\n<p>当我们页面有很多元素时，这样内联引入CSS样式代码显然是不合适的，比如当<strong>同一个元素需要复用同一种样式</strong>，我们需要在每一个<strong>元素内部手动添加</strong>，这样产生很多<strong>重复性</strong>的操作和劳动。所以我们可以将有相同需求的元素整理好<strong>分成许多类别</strong>，让相同类别元素使用同一种样式。</p>\n<p>我们使用<code>&lt;style&gt;</code>标签进行对CSS的引入，在页面的<code>&lt;head&gt;</code>区域引入<code>&lt;style&gt;</code>标签，在其中写入需要的CSS样式：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">    <span class=\"hljs-selector-tag\">p</span>{</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">color</span>:red;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">    }</span><br><span class=\"language-css\">    <span class=\"hljs-selector-tag\">span</span>{</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">color</span>:green;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">    }</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> It's been a long day without you, my friend.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>And I'll tell you all about it when I see you again.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"3-外部引入\">3.外部引入</h4>\n<p>在我们实际开发过程中，项目的页面不会少，如果我们希望<strong>所有的页面都使用同一个CSS样式</strong>，那么我们就需要将CSS样式单独放在一个文件中（<strong>新建一个以<code>.css</code>为后缀名的样式表</strong>）然后通过<code>&lt;link&gt;</code>标签引入到我们的页面中，这是你还会发现，当我们需要对所有页面进行样式修改时，就只需要修改一个CSS文件，不用对所有页面逐个修改！</p>\n<h3 id=\"CSS选择器\">CSS选择器</h3>\n<h4 id=\"1-元素选择器\">1.元素选择器</h4>\n<p>对HTML元素进行选取，如<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code>等</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;sytle&gt;<br><span class=\"hljs-selector-tag\">p</span>{<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>}<br><span class=\"hljs-selector-tag\">ul</span>{<br>    <span class=\"hljs-attribute\">list-style-type</span>:none;<br>}<br><span class=\"hljs-selector-tag\">a</span>{<br>    <span class=\"hljs-attribute\">text-decoration</span>:none;<br>}<br>&lt;/style&gt;<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"2-类选择器\">2.类选择器</h4>\n<p>通过<code>class</code>属性确定类名进行选取，<strong>相同类名的元素</strong>含有相同的CSS样式</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">p</span> class=\"title\"&gt;我是一个段落&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">div</span> class=\"<span class=\"hljs-attribute\">container</span>\"&gt;这是一个容器&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;<br>&lt;/<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;sytle type=\"<span class=\"hljs-selector-tag\">text</span>/css\"&gt;<br><span class=\"hljs-selector-class\">.title</span>{<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>:center;<br>}<br>&lt;/sytle&gt;<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <ul><li>类选择器前需要加<code>.</code></li><li>在<code>vscode</code>中，属性名+<code>.</code>+<code>类名</code>，<code>Tab</code>自动补全&lt;元素  class=“类名”&gt;的形式</li></ul>\n          </div>\n<h4 id=\"3-ID选择器\">3.ID选择器</h4>\n<p>以上两种都是对同一类元素进行选取和操作，当我们需要<strong>单独为一个元素</strong>进行操作时，通过<code>id</code>属性确定ID名进行选取，如<code>&lt;p id=\"title\"&gt;</code>、<code>&lt;ul id=\"list\"&gt;</code>，相同ID名的含有相同的CSS样式</p>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">p</span> id=\"title\"&gt;我是一个段落&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">div</span> id=\"<span class=\"hljs-attribute\">container</span>\"&gt;这是一个容器&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;<br>&lt;/<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;sytle type=\"<span class=\"hljs-selector-tag\">text</span>/css\"&gt;<br><span class=\"hljs-selector-id\">#title</span>{<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>:center;<br>}<br><span class=\"hljs-selector-id\">#container</span>{<br>    <span class=\"hljs-attribute\">background-color</span>:yellow;<br>}<br>&lt;/sytle&gt;<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <ul><li>ID选择器前需要加<code>#</code></li></ul>\n          </div>\n<h2 id=\"网页常用样式\">网页常用样式</h2>\n<h3 id=\"字体\">字体</h3>\n<h4 id=\"font-family字体\"><code>font-family</code>字体</h4>\n<h4 id=\"font-size字号\"><code>font-size</code>字号</h4>\n<div class=\"note note-info\">\n            <ul><li>像素（px）</li><li>点数（pt）</li><li>英寸（in）、厘米（cm）、毫米（mm）</li><li>倍数（em）</li><li>百分比（%）</li></ul>\n          </div>\n<h4 id=\"font-weight字重\"><code>font-weight</code>字重</h4>\n<div class=\"note note-info\">\n            <ul><li>正常（normal）：400</li><li>加粗（bold）：700</li><li>更粗（bolder）</li><li>更细（lighter）</li><li>数字（100~900）：只能写成整百的数字</li></ul>\n          </div>\n<h4 id=\"color颜色\"><code>color</code>颜色</h4>\n<p>相关内容前文有相应介绍，不再赘述</p>\n<div class=\"note note-info\">\n            <ul><li>color_name</li><li>hex_number</li><li>rgb_number</li><li>rgba_number</li></ul>\n          </div>\n<h4 id=\"text-decoration文本修饰\"><code>text-decoration</code>文本修饰</h4>\n<div class=\"note note-info\">\n            <ul><li>none：无修饰</li><li>underline：下划线</li><li>overline：上划线</li><li>line-through：中划线</li><li>blink：闪烁</li></ul>\n          </div>\n<h3 id=\"段落\">段落</h3>\n<h4 id=\"letter-spacing字间距\"><code>letter-spacing</code>字间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>length：长度</li></ul>\n          </div>\n<h4 id=\"word-spacing词间距\"><code>word-spacing</code>词间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>length：长度</li></ul>\n          </div>\n<h4 id=\"text-indent缩进\"><code>text-indent</code>缩进</h4>\n<div class=\"note note-info\">\n            <ul><li>length：长度</li><li>%：百分比</li></ul>\n          </div>\n<h4 id=\"text-align水平对齐\"><code>text-align</code>水平对齐</h4>\n<div class=\"note note-info\">\n            <ul><li>left：左对齐</li><li>right：右对齐</li><li>center：居中对齐</li><li>justify：两端对齐</li></ul>\n          </div>\n<h4 id=\"vertical-align垂直对齐\"><code>vertical-align</code>垂直对齐</h4>\n<div class=\"note note-info\">\n            <ul><li>top：顶部对齐</li><li>middle：垂直居中对齐</li><li>bottom：底部对齐</li></ul>\n          </div>\n<h4 id=\"line-height行间距\"><code>line-height</code>行间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>number：与当前字体尺寸相乘来设置行间距</li><li>length：固定行间距</li></ul>\n          </div>\n<h3 id=\"边框\">边框</h3>\n<h4 id=\"border-style边框线型\"><code>border-style</code>边框线型</h4>\n<div class=\"note note-info\">\n            <ul><li>none：无边框</li><li>hidden：隐藏边框</li><li>dotted：点状边框</li><li>dashed：虚线边框</li><li>solid：实线边框</li><li>double：双线边框</li></ul>\n          </div>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid double dashed;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框是点状<br>右边框是实线<br>下边框是双线<br>左边框是虚线<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid double;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框是点状<br>右边框和左边框是实线<br>下边框是双线<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框和下边框是点状<br>右边框和左边框是实线<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted;<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">四个边框均为点状<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h4 id=\"border-color边框颜色\"><code>border-color</code>边框颜色</h4>\n<h4 id=\"border-width边框宽度\"><code>border-width</code>边框宽度</h4>\n<h2 id=\"盒子模型\">盒子模型</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/div.png?raw=true\" alt=\"盒子模型图解\"></p>\n<p>  根据上图，<strong>俯视</strong>这个盒子，内边距（padding）可以理解为<strong>盒子里装的东西和边框的距离</strong>；而边框（border）就是<strong>盒子本身</strong>；内容（content）就是<strong>盒子中装的东西</strong>；外边距就是边框外面自动留出的一段空白；而填充（padding）就是怕盒子里装的东西损坏而添加的泡沫或者其他抗震<strong>材料</strong>；至于边界（margin）则说明盒子摆放时不能全部堆在一起，要<strong>留有一定空隙</strong>保持通风，同时方便取出！</p>\n<h3 id=\"外边距设置\">外边距设置</h3>\n<p>使用<code>margin</code>属性设置<strong>外边距</strong>，<code>margin</code>边界环绕在该元素的<code>content</code>区域四周，如果<code>margin</code>为0，则<code>margin</code>边界与<code>border</code>边界重合。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>margin-top</code></td>\n<td>上外边距</td>\n</tr>\n<tr>\n<td><code>margin-right</code></td>\n<td>右外边距</td>\n</tr>\n<tr>\n<td><code>margin-bottom</code></td>\n<td>下外边距</td>\n</tr>\n<tr>\n<td><code>margin-left</code></td>\n<td>左外边距</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-info\">\n            <p><code>margin</code>属性值仍然有<strong>四个参数</strong>，对应上、右、下、左即<strong>顺时针方向旋转</strong></p>\n          </div>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/div_example_1.png?raw=true\" alt=\"margin效果图\"></p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"> <span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-tag\">div</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>:<span class=\"hljs-number\">2px</span> green solid;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>:crimson</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.d2</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-right</span>:auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>:<span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            // <span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">20px</span> auto <span class=\"hljs-number\">40px</span> <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"d1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"d2\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"d3\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-danger\">\n            <p>当两个垂直外边距相遇时，他们将会<strong>形成一个外边距</strong>，合并后的外边距的高度等于两个<strong>外边距的最大高度</strong>（注意不是外边距相加）</p>\n          </div>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/margin.png?raw=true\" alt=\"margin外边距合并\"></p>\n<h3 id=\"内边距设置\">内边距设置</h3>\n<p>使用<code>padding</code>属性设置<strong>内边距</strong>，内边距在边框和内容区之间，<code>padding</code>属性接受长度值和百分比，但不允许使用负值。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>padding-top</code></td>\n<td>上内边距</td>\n</tr>\n<tr>\n<td><code>padding-right</code></td>\n<td>右内边距</td>\n</tr>\n<tr>\n<td><code>padding-bottom</code></td>\n<td>下内边距</td>\n</tr>\n<tr>\n<td><code>padding-left</code></td>\n<td>左内边距</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"弹性盒子\">弹性盒子</h3>\n<div class=\"note note-info\">\n            <p>默认流式布局中，块级元素（如<code>div</code>）会独占一行，多个<code>div</code>会垂直堆叠，无法横向排列；而当我们使用<code>float</code>和<code>inline-box</code>进行横向排列时，会带来间距、对齐、父元素高度塌陷等问题。</p>\n          </div>\n<p>  当一种页面需要<strong>适应不同的屏幕大小以及设备类型</strong>时，弹性盒子可以确保元素拥有恰当行为的布局方式，这样的布局模型能提供一种<strong>更有效的方式来对一个容器中的子元素进行排列、对齐、分配空白空间</strong>！</p>\n<div class=\"note note-danger\">\n            <ul><li>只要给容器设置<code>display: flex;</code><strong>任何一个容器</strong>我们都可以设置为弹性盒子</li><li>设为<code>flex</code>布局以后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code><strong>属性将失效</strong></li></ul>\n          </div>\n<ul>\n<li><code>flex-direction</code>：设置<strong>排列方向</strong>（沿纵轴还是横轴）（正序还是倒序）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n<th>动画演示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>row</code></td>\n<td>默认值，水平显示，起点在左端</td>\n<td>1️⃣2️⃣3️⃣4️⃣_ _ _ _</td>\n</tr>\n<tr>\n<td><code>row-reverse</code></td>\n<td>盒子方向相反，且起点在右端</td>\n<td>_ _ _ _4️⃣3️⃣2️⃣1️⃣</td>\n</tr>\n<tr>\n<td><code>column</code></td>\n<td>垂直显示，起点在上端</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>column-reverse</code></td>\n<td>盒子方向相反，且起点在下端</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>justify-content</code>：在<strong>主轴（横轴）上的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n<th>动画演示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在左端</td>\n<td>1️⃣2️⃣3️⃣4️⃣_ _ _ _</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>终点在右端</td>\n<td>_ _ _ _1️⃣2️⃣3️⃣4️⃣</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>居中对齐</td>\n<td>_ _1️⃣2️⃣3️⃣4️⃣ _ _</td>\n</tr>\n<tr>\n<td><code>space-between</code></td>\n<td>项目之间的间隔相等，紧贴左右两端</td>\n<td>1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣</td>\n</tr>\n<tr>\n<td><code>space-around</code></td>\n<td>每个项目两侧的间隔相等</td>\n<td>_ 1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣ _</td>\n</tr>\n<tr>\n<td><code>space-evenly</code></td>\n<td>项目之间的间隔相等，且项目两侧的间隔相等</td>\n<td>_ 1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣ _</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>align-items</code>：在<strong>侧轴（纵轴）上的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在上端</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>终点在下端</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>居中对齐</td>\n</tr>\n<tr>\n<td><code>baseline</code></td>\n<td>基线对齐</td>\n</tr>\n<tr>\n<td><code>stretch</code></td>\n<td><code>auto</code>尽可能接近所在行的尺寸</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>flex-wrap</code>：弹性盒子的<strong>换行方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>nowrap</code></td>\n<td>默认值，不换行，盒子会被压缩</td>\n</tr>\n<tr>\n<td><code>wrap</code></td>\n<td>换行，第一行在上方</td>\n</tr>\n<tr>\n<td><code>wrap-reverse</code></td>\n<td>反向换行，第一行在下方</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>align-content</code>：<strong>多行情况下侧轴（纵轴）的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stretch</code></td>\n<td>默认值<code>auto</code>，将占满整个容器的高度</td>\n</tr>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在上端</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>起点在下端</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>上下居中对齐</td>\n</tr>\n<tr>\n<td><code>space-between</code></td>\n<td>项目之间的间隔相等</td>\n</tr>\n<tr>\n<td><code>space-around</code></td>\n<td>每个项目两侧的间隔相等</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-danger\">\n            <p>该属性只在多行（<code>flex-wrap: wrap</code>或<code>flex-wrap: wrap-reverse</code>）的情况下生效！</p>\n          </div>\n<p>下面是使用CSS和HTML创建的“待办事项”demo！</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/blog-image/main/article/Html%26%26CSS/%E6%A0%B7%E4%BE%8B%E5%B1%95%E7%A4%BA.png\" alt=\"“待办事项”样例展示\"></p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"todolist\"</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"title\"</span>&gt;</span><br>            Richard的todolist<br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"todo-form\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"todo-input\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"请输入待办事项\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"todo-button\"</span>&gt;</span>添加<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item completed\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>吃饭<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"del\"</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>睡觉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"del\"</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>学习<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"del\"</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.completed</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-decoration</span>: line-through;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0.4</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.del</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: red;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.item</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">align-items</span>: center; <span class=\"hljs-comment\">/* 垂直居中对齐 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-sizing</span>: border-box;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">8px</span> auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">16px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span>; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>); <span class=\"hljs-comment\">/* 修复阴影语法 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f9f9f9</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-form</span>{ </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">20px</span> auto; <span class=\"hljs-comment\">/* 居中表单 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>; <span class=\"hljs-comment\">/* 固定表单高度 */</span></span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-input</span>{ </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">15px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#dfe1e5</span>; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">outline</span>: none;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-built_in\">calc</span>(<span class=\"hljs-number\">100%</span> - <span class=\"hljs-number\">100px</span>); <span class=\"hljs-comment\">/* 自动计算宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>; <span class=\"hljs-comment\">/* 与按钮同高 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span>; <span class=\"hljs-comment\">/* 修复语法错误 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-sizing</span>: border-box; <span class=\"hljs-comment\">/* 确保padding不增加总宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-button</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>; <span class=\"hljs-comment\">/* 与输入框同高 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-align</span>: center;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(</span><br><span class=\"language-css\">                to right,</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>),</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">144</span>, <span class=\"hljs-number\">251</span>,<span class=\"hljs-number\">1</span>)</span><br><span class=\"language-css\">            );</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: white;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10px</span>; <span class=\"hljs-comment\">/* 垂直居中文字 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">50px</span>; <span class=\"hljs-comment\">/* 与高度一致实现垂直居中 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">cursor</span>: pointer;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">user-select</span>: none;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-tag\">body</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(</span><br><span class=\"language-css\">                to right,</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>),</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">144</span>, <span class=\"hljs-number\">251</span>,<span class=\"hljs-number\">1</span>)</span><br><span class=\"language-css\">            );</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todolist</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">600px</span>; <span class=\"hljs-comment\">/* 限制最大宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: white;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">40px</span> auto; <span class=\"hljs-comment\">/* 水平居中 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>);</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.title</span>{</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-align</span>: center;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">30px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-weight</span>: <span class=\"hljs-number\">700</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>);</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">30px</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.del</span> {</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>: auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff4444</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">cursor</span>: pointer;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">12px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fef0f0</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.name</span> {</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">        }</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span> <br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=wsTv9y931o8\">Learn CSS Flexbox in 20 Minutes (Course)</a></p>\n","excerpt":"","more":"<h2 id=\"What-is-CSS？\">What is CSS？</h2>\n<p>CSS(Cascading Style Sheet)是用于<strong>控制页面样式与布局</strong>并允许<strong>样式信息与网页内容相分离</strong>的一种标记性语言。如果HTML是人，那么CSS就是我们身上的衣服和化妆品！</p>\n<p>CSS由<strong>选择器</strong>，<strong>属性</strong>和<strong>属性值</strong>组成：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">selector&#123;prosperties:value;&#125;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <ul><li>选择器：用于定义CSS样式名称</li><li>属性：例如网页中的字体样式、字体颜色等</li><li>属性值：例如字体的大小、颜色等</li></ul>\n          </div>\n<div class=\"note note-danger\">\n            <ul><li>属性和属性值必须写在{}内，且用“:”隔开</li><li>每写完一个完整的属性和属性值，必须用“;”隔开</li><li>如果一个属性有多个属性值，每个属性值用<code>space</code>隔开</li></ul>\n          </div>\n<h3 id=\"引入CSS\">引入CSS</h3>\n<h4 id=\"1-内联引入\">1.内联引入</h4>\n<p>每个HTML元素都拥有一个<code>&lt;style&gt;</code>属性，我们的CSS代码都是作为HTML中<code>&lt;style&gt;</code>属性的属性值出现的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: red;&quot;</span>&gt;</span>这是段落<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p style=\"color: red;\">这是段落</p>\n<h4 id=\"2-内部引入\">2.内部引入</h4>\n<p>当我们页面有很多元素时，这样内联引入CSS样式代码显然是不合适的，比如当<strong>同一个元素需要复用同一种样式</strong>，我们需要在每一个<strong>元素内部手动添加</strong>，这样产生很多<strong>重复性</strong>的操作和劳动。所以我们可以将有相同需求的元素整理好<strong>分成许多类别</strong>，让相同类别元素使用同一种样式。</p>\n<p>我们使用<code>&lt;style&gt;</code>标签进行对CSS的引入，在页面的<code>&lt;head&gt;</code>区域引入<code>&lt;style&gt;</code>标签，在其中写入需要的CSS样式：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">    <span class=\"hljs-selector-tag\">p</span>&#123;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">color</span>:red;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">    <span class=\"hljs-selector-tag\">span</span>&#123;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">color</span>:green;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> It&#x27;s been a long day without you, my friend.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>And I&#x27;ll tell you all about it when I see you again.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"3-外部引入\">3.外部引入</h4>\n<p>在我们实际开发过程中，项目的页面不会少，如果我们希望<strong>所有的页面都使用同一个CSS样式</strong>，那么我们就需要将CSS样式单独放在一个文件中（<strong>新建一个以<code>.css</code>为后缀名的样式表</strong>）然后通过<code>&lt;link&gt;</code>标签引入到我们的页面中，这是你还会发现，当我们需要对所有页面进行样式修改时，就只需要修改一个CSS文件，不用对所有页面逐个修改！</p>\n<h3 id=\"CSS选择器\">CSS选择器</h3>\n<h4 id=\"1-元素选择器\">1.元素选择器</h4>\n<p>对HTML元素进行选取，如<code>&lt;p&gt;</code>、<code>&lt;ul&gt;</code>等</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;sytle&gt;<br><span class=\"hljs-selector-tag\">p</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>&#125;<br><span class=\"hljs-selector-tag\">ul</span>&#123;<br>    <span class=\"hljs-attribute\">list-style-type</span>:none;<br>&#125;<br><span class=\"hljs-selector-tag\">a</span>&#123;<br>    <span class=\"hljs-attribute\">text-decoration</span>:none;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>\n<h4 id=\"2-类选择器\">2.类选择器</h4>\n<p>通过<code>class</code>属性确定类名进行选取，<strong>相同类名的元素</strong>含有相同的CSS样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">p</span> class=&quot;title&quot;&gt;我是一个段落&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">div</span> class=&quot;<span class=\"hljs-attribute\">container</span>&quot;&gt;这是一个容器&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;<br>&lt;/<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;sytle type=&quot;<span class=\"hljs-selector-tag\">text</span>/css&quot;&gt;<br><span class=\"hljs-selector-class\">.title</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>:center;<br>&#125;<br>&lt;/sytle&gt;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <ul><li>类选择器前需要加<code>.</code></li><li>在<code>vscode</code>中，属性名+<code>.</code>+<code>类名</code>，<code>Tab</code>自动补全&lt;元素  class=“类名”&gt;的形式</li></ul>\n          </div>\n<h4 id=\"3-ID选择器\">3.ID选择器</h4>\n<p>以上两种都是对同一类元素进行选取和操作，当我们需要<strong>单独为一个元素</strong>进行操作时，通过<code>id</code>属性确定ID名进行选取，如<code>&lt;p id=&quot;title&quot;&gt;</code>、<code>&lt;ul id=&quot;list&quot;&gt;</code>，相同ID名的含有相同的CSS样式</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\">&lt;<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">p</span> id=&quot;title&quot;&gt;我是一个段落&lt;/<span class=\"hljs-selector-tag\">p</span>&gt;<br>&lt;<span class=\"hljs-selector-tag\">div</span> id=&quot;<span class=\"hljs-attribute\">container</span>&quot;&gt;这是一个容器&lt;/<span class=\"hljs-selector-tag\">div</span>&gt;<br>&lt;/<span class=\"hljs-selector-tag\">body</span>&gt;<br>&lt;sytle type=&quot;<span class=\"hljs-selector-tag\">text</span>/css&quot;&gt;<br><span class=\"hljs-selector-id\">#title</span>&#123;<br>    <span class=\"hljs-attribute\">color</span>:red;<br>    <span class=\"hljs-attribute\">font-size</span>:<span class=\"hljs-number\">20px</span>;<br>    <span class=\"hljs-attribute\">text-align</span>:center;<br>&#125;<br><span class=\"hljs-selector-id\">#container</span>&#123;<br>    <span class=\"hljs-attribute\">background-color</span>:yellow;<br>&#125;<br>&lt;/sytle&gt;<br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <ul><li>ID选择器前需要加<code>#</code></li></ul>\n          </div>\n<h2 id=\"网页常用样式\">网页常用样式</h2>\n<h3 id=\"字体\">字体</h3>\n<h4 id=\"font-family字体\"><code>font-family</code>字体</h4>\n<h4 id=\"font-size字号\"><code>font-size</code>字号</h4>\n<div class=\"note note-info\">\n            <ul><li>像素（px）</li><li>点数（pt）</li><li>英寸（in）、厘米（cm）、毫米（mm）</li><li>倍数（em）</li><li>百分比（%）</li></ul>\n          </div>\n<h4 id=\"font-weight字重\"><code>font-weight</code>字重</h4>\n<div class=\"note note-info\">\n            <ul><li>正常（normal）：400</li><li>加粗（bold）：700</li><li>更粗（bolder）</li><li>更细（lighter）</li><li>数字（100~900）：只能写成整百的数字</li></ul>\n          </div>\n<h4 id=\"color颜色\"><code>color</code>颜色</h4>\n<p>相关内容前文有相应介绍，不再赘述</p>\n<div class=\"note note-info\">\n            <ul><li>color_name</li><li>hex_number</li><li>rgb_number</li><li>rgba_number</li></ul>\n          </div>\n<h4 id=\"text-decoration文本修饰\"><code>text-decoration</code>文本修饰</h4>\n<div class=\"note note-info\">\n            <ul><li>none：无修饰</li><li>underline：下划线</li><li>overline：上划线</li><li>line-through：中划线</li><li>blink：闪烁</li></ul>\n          </div>\n<h3 id=\"段落\">段落</h3>\n<h4 id=\"letter-spacing字间距\"><code>letter-spacing</code>字间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>length：长度</li></ul>\n          </div>\n<h4 id=\"word-spacing词间距\"><code>word-spacing</code>词间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>length：长度</li></ul>\n          </div>\n<h4 id=\"text-indent缩进\"><code>text-indent</code>缩进</h4>\n<div class=\"note note-info\">\n            <ul><li>length：长度</li><li>%：百分比</li></ul>\n          </div>\n<h4 id=\"text-align水平对齐\"><code>text-align</code>水平对齐</h4>\n<div class=\"note note-info\">\n            <ul><li>left：左对齐</li><li>right：右对齐</li><li>center：居中对齐</li><li>justify：两端对齐</li></ul>\n          </div>\n<h4 id=\"vertical-align垂直对齐\"><code>vertical-align</code>垂直对齐</h4>\n<div class=\"note note-info\">\n            <ul><li>top：顶部对齐</li><li>middle：垂直居中对齐</li><li>bottom：底部对齐</li></ul>\n          </div>\n<h4 id=\"line-height行间距\"><code>line-height</code>行间距</h4>\n<div class=\"note note-info\">\n            <ul><li>normal：正常</li><li>number：与当前字体尺寸相乘来设置行间距</li><li>length：固定行间距</li></ul>\n          </div>\n<h3 id=\"边框\">边框</h3>\n<h4 id=\"border-style边框线型\"><code>border-style</code>边框线型</h4>\n<div class=\"note note-info\">\n            <ul><li>none：无边框</li><li>hidden：隐藏边框</li><li>dotted：点状边框</li><li>dashed：虚线边框</li><li>solid：实线边框</li><li>double：双线边框</li></ul>\n          </div>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid double dashed;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框是点状<br>右边框是实线<br>下边框是双线<br>左边框是虚线<br></code></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid double;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框是点状<br>右边框和左边框是实线<br>下边框是双线<br></code></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted solid;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">上边框和下边框是点状<br>右边框和左边框是实线<br></code></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-attribute\">border-style</span>:dotted;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">四个边框均为点状<br></code></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"border-color边框颜色\"><code>border-color</code>边框颜色</h4>\n<h4 id=\"border-width边框宽度\"><code>border-width</code>边框宽度</h4>\n<h2 id=\"盒子模型\">盒子模型</h2>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/div.png?raw=true\" alt=\"盒子模型图解\"></p>\n<p>  根据上图，<strong>俯视</strong>这个盒子，内边距（padding）可以理解为<strong>盒子里装的东西和边框的距离</strong>；而边框（border）就是<strong>盒子本身</strong>；内容（content）就是<strong>盒子中装的东西</strong>；外边距就是边框外面自动留出的一段空白；而填充（padding）就是怕盒子里装的东西损坏而添加的泡沫或者其他抗震<strong>材料</strong>；至于边界（margin）则说明盒子摆放时不能全部堆在一起，要<strong>留有一定空隙</strong>保持通风，同时方便取出！</p>\n<h3 id=\"外边距设置\">外边距设置</h3>\n<p>使用<code>margin</code>属性设置<strong>外边距</strong>，<code>margin</code>边界环绕在该元素的<code>content</code>区域四周，如果<code>margin</code>为0，则<code>margin</code>边界与<code>border</code>边界重合。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>margin-top</code></td>\n<td>上外边距</td>\n</tr>\n<tr>\n<td><code>margin-right</code></td>\n<td>右外边距</td>\n</tr>\n<tr>\n<td><code>margin-bottom</code></td>\n<td>下外边距</td>\n</tr>\n<tr>\n<td><code>margin-left</code></td>\n<td>左外边距</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-info\">\n            <p><code>margin</code>属性值仍然有<strong>四个参数</strong>，对应上、右、下、左即<strong>顺时针方向旋转</strong></p>\n          </div>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/div_example_1.png?raw=true\" alt=\"margin效果图\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"> <span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-tag\">div</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>:<span class=\"hljs-number\">200px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>:<span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>:<span class=\"hljs-number\">2px</span> green solid;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>:crimson</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.d2</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-right</span>:auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">40px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>:<span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            // <span class=\"hljs-attribute\">margin</span>:<span class=\"hljs-number\">20px</span> auto <span class=\"hljs-number\">40px</span> <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;d1&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;d2&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;d3&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<div class=\"note note-danger\">\n            <p>当两个垂直外边距相遇时，他们将会<strong>形成一个外边距</strong>，合并后的外边距的高度等于两个<strong>外边距的最大高度</strong>（注意不是外边距相加）</p>\n          </div>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Html&amp;&amp;CSS/margin.png?raw=true\" alt=\"margin外边距合并\"></p>\n<h3 id=\"内边距设置\">内边距设置</h3>\n<p>使用<code>padding</code>属性设置<strong>内边距</strong>，内边距在边框和内容区之间，<code>padding</code>属性接受长度值和百分比，但不允许使用负值。</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>padding-top</code></td>\n<td>上内边距</td>\n</tr>\n<tr>\n<td><code>padding-right</code></td>\n<td>右内边距</td>\n</tr>\n<tr>\n<td><code>padding-bottom</code></td>\n<td>下内边距</td>\n</tr>\n<tr>\n<td><code>padding-left</code></td>\n<td>左内边距</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"弹性盒子\">弹性盒子</h3>\n<div class=\"note note-info\">\n            <p>默认流式布局中，块级元素（如<code>div</code>）会独占一行，多个<code>div</code>会垂直堆叠，无法横向排列；而当我们使用<code>float</code>和<code>inline-box</code>进行横向排列时，会带来间距、对齐、父元素高度塌陷等问题。</p>\n          </div>\n<p>  当一种页面需要<strong>适应不同的屏幕大小以及设备类型</strong>时，弹性盒子可以确保元素拥有恰当行为的布局方式，这样的布局模型能提供一种<strong>更有效的方式来对一个容器中的子元素进行排列、对齐、分配空白空间</strong>！</p>\n<div class=\"note note-danger\">\n            <ul><li>只要给容器设置<code>display: flex;</code><strong>任何一个容器</strong>我们都可以设置为弹性盒子</li><li>设为<code>flex</code>布局以后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code><strong>属性将失效</strong></li></ul>\n          </div>\n<ul>\n<li><code>flex-direction</code>：设置<strong>排列方向</strong>（沿纵轴还是横轴）（正序还是倒序）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n<th>动画演示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>row</code></td>\n<td>默认值，水平显示，起点在左端</td>\n<td>1️⃣2️⃣3️⃣4️⃣_ _ _ _</td>\n</tr>\n<tr>\n<td><code>row-reverse</code></td>\n<td>盒子方向相反，且起点在右端</td>\n<td>_ _ _ _4️⃣3️⃣2️⃣1️⃣</td>\n</tr>\n<tr>\n<td><code>column</code></td>\n<td>垂直显示，起点在上端</td>\n<td>无</td>\n</tr>\n<tr>\n<td><code>column-reverse</code></td>\n<td>盒子方向相反，且起点在下端</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>justify-content</code>：在<strong>主轴（横轴）上的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n<th>动画演示</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在左端</td>\n<td>1️⃣2️⃣3️⃣4️⃣_ _ _ _</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>终点在右端</td>\n<td>_ _ _ _1️⃣2️⃣3️⃣4️⃣</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>居中对齐</td>\n<td>_ _1️⃣2️⃣3️⃣4️⃣ _ _</td>\n</tr>\n<tr>\n<td><code>space-between</code></td>\n<td>项目之间的间隔相等，紧贴左右两端</td>\n<td>1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣</td>\n</tr>\n<tr>\n<td><code>space-around</code></td>\n<td>每个项目两侧的间隔相等</td>\n<td>_ 1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣ _</td>\n</tr>\n<tr>\n<td><code>space-evenly</code></td>\n<td>项目之间的间隔相等，且项目两侧的间隔相等</td>\n<td>_ 1️⃣ _ 2️⃣ _ 3️⃣ _ 4️⃣ _</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>align-items</code>：在<strong>侧轴（纵轴）上的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在上端</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>终点在下端</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>居中对齐</td>\n</tr>\n<tr>\n<td><code>baseline</code></td>\n<td>基线对齐</td>\n</tr>\n<tr>\n<td><code>stretch</code></td>\n<td><code>auto</code>尽可能接近所在行的尺寸</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>flex-wrap</code>：弹性盒子的<strong>换行方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>nowrap</code></td>\n<td>默认值，不换行，盒子会被压缩</td>\n</tr>\n<tr>\n<td><code>wrap</code></td>\n<td>换行，第一行在上方</td>\n</tr>\n<tr>\n<td><code>wrap-reverse</code></td>\n<td>反向换行，第一行在下方</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>align-content</code>：<strong>多行情况下侧轴（纵轴）的对齐方式</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>stretch</code></td>\n<td>默认值<code>auto</code>，将占满整个容器的高度</td>\n</tr>\n<tr>\n<td><code>flex-start</code></td>\n<td>起点在上端</td>\n</tr>\n<tr>\n<td><code>flex-end</code></td>\n<td>起点在下端</td>\n</tr>\n<tr>\n<td><code>center</code></td>\n<td>上下居中对齐</td>\n</tr>\n<tr>\n<td><code>space-between</code></td>\n<td>项目之间的间隔相等</td>\n</tr>\n<tr>\n<td><code>space-around</code></td>\n<td>每个项目两侧的间隔相等</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-danger\">\n            <p>该属性只在多行（<code>flex-wrap: wrap</code>或<code>flex-wrap: wrap-reverse</code>）的情况下生效！</p>\n          </div>\n<p>下面是使用CSS和HTML创建的“待办事项”demo！</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/blog-image/main/article/Html%26%26CSS/%E6%A0%B7%E4%BE%8B%E5%B1%95%E7%A4%BA.png\" alt=\"“待办事项”样例展示\"></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;todolist&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;title&quot;</span>&gt;</span><br>            Richard的todolist<br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;todo-form&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;todo-input&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请输入待办事项&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;todo-button&quot;</span>&gt;</span>添加<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item completed&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>吃饭<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;del&quot;</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>睡觉<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;del&quot;</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>学习<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><br>            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;del&quot;</span>&gt;</span>删除<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.completed</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-decoration</span>: line-through;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">opacity</span>: <span class=\"hljs-number\">0.4</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.del</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: red;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.item</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">align-items</span>: center; <span class=\"hljs-comment\">/* 垂直居中对齐 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-sizing</span>: border-box;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">8px</span> auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">16px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span>; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">2px</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>); <span class=\"hljs-comment\">/* 修复阴影语法 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#f9f9f9</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-form</span>&#123; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">display</span>: flex;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">20px</span> auto; <span class=\"hljs-comment\">/* 居中表单 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>; <span class=\"hljs-comment\">/* 固定表单高度 */</span></span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-input</span>&#123; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">15px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#dfe1e5</span>; </span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">outline</span>: none;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-built_in\">calc</span>(<span class=\"hljs-number\">100%</span> - <span class=\"hljs-number\">100px</span>); <span class=\"hljs-comment\">/* 自动计算宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>; <span class=\"hljs-comment\">/* 与按钮同高 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span>; <span class=\"hljs-comment\">/* 修复语法错误 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-sizing</span>: border-box; <span class=\"hljs-comment\">/* 确保padding不增加总宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">16px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todo-button</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>; <span class=\"hljs-comment\">/* 与输入框同高 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">20px</span> <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-align</span>: center;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(</span><br><span class=\"language-css\">                to right,</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>),</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">144</span>, <span class=\"hljs-number\">251</span>,<span class=\"hljs-number\">1</span>)</span><br><span class=\"language-css\">            );</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: white;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">10px</span>; <span class=\"hljs-comment\">/* 垂直居中文字 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">50px</span>; <span class=\"hljs-comment\">/* 与高度一致实现垂直居中 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">cursor</span>: pointer;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">user-select</span>: none;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-tag\">body</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">linear-gradient</span>(</span><br><span class=\"language-css\">                to right,</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>),</span><br><span class=\"language-css\">                <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">44</span>, <span class=\"hljs-number\">144</span>, <span class=\"hljs-number\">251</span>,<span class=\"hljs-number\">1</span>)</span><br><span class=\"language-css\">            );</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.todolist</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">600px</span>; <span class=\"hljs-comment\">/* 限制最大宽度 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: white;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">40px</span> auto; <span class=\"hljs-comment\">/* 水平居中 */</span></span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">15px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0.1</span>);</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.title</span>&#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">text-align</span>: center;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">30px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">font-weight</span>: <span class=\"hljs-number\">700</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">113</span>,<span class=\"hljs-number\">65</span>,<span class=\"hljs-number\">168</span>);</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">20px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">30px</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.del</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>: auto;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#ff4444</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">cursor</span>: pointer;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">12px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fef0f0</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">        </span><br><span class=\"language-css\">        <span class=\"hljs-selector-class\">.name</span> &#123;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">margin-left</span>: <span class=\"hljs-number\">10px</span>;</span><br><span class=\"language-css\">            <span class=\"hljs-attribute\">flex</span>: <span class=\"hljs-number\">1</span>;</span><br><span class=\"language-css\">        &#125;</span><br><span class=\"language-css\">    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span> <br></code></pre></td></tr></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=wsTv9y931o8\">Learn CSS Flexbox in 20 Minutes (Course)</a></p>\n"},{"title":"Stack and Queue","date":"2025-08-23T06:16:21.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/Stack-and-Queue.png?raw=true","category_bar":true,"description":"Reviewing the chapter about stack and queue in Data Structure","_content":"\n\n## Stack\n栈（stack）是一种遵循**先入后出**(**LIFO**)逻辑的线性数据结构:我们把堆叠元素的顶部称为“**栈顶**”，底部称为“**栈底**”。将把**元素添加到栈顶**的操作叫作“**入栈**”，**删除栈顶元素**的操作叫作“**出栈**”。\n\n### Stack in STL\n```cpp\n#include <stack>\n/* 初始化栈 */\nstack<int> stack;\n\n/* 元素入栈 */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* 访问栈顶元素 */\nint top = stack.top();\n\n/* 元素出栈 */\nstack.pop(); // 无返回值\n\n/* 获取栈的长度 */\nint size = stack.size();\n\n/* 判断是否为空 */\nbool empty = stack.empty();\n```\n\n## 栈的实现\n\n&emsp;&emsp;由于**数组**和**链表**都可以在任意位置添加和删除元素，因此栈可以视为一种**受限制的**数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性，下面我们分别**用数组和链表实现栈的功能**！\n\n### 基于数组的实现\n使用数组实现栈时，我们可以将**数组的尾部作为栈顶**。由于入栈的元素可能会源源不断地增加，因此我们可以使用**动态数组**，这样就无须自行处理**数组扩容问题**。\n```cpp\nvector <int> stack;\n/* 获取栈的长度 */\nint size() {\n    return stack.size();\n}\n/* 判断栈是否为空 */\nbool empty() {\n    return stack.size() == 0;\n}\n/* 入栈 */\nvoid push(int num){\n    stack.push_back(num);\n}\n/* 出栈 */\nvoid pop() {\n    stack.pop_back();\n}\n/* 访问栈顶元素 */\nint top() {\n    if (isempty()) {\n        throw out_of_range(\"栈为空\");\n    }\n    return stack.back();\n}\n```\n\n\n### 基于链表的实现\n\n使用链表实现栈时，我们可以将链表的**头节点视为栈顶**，**尾节点视为栈底**。\n- 对于入栈操作，我们只需将**元素插入链表头部**，这种节点插入方法被称为“**头插法**”。\n- 对于出栈操作，只需**将头节点从链表中删除**即可。\n\n```cpp\n/* 基于链表实现的栈 */\nclass LinkedListStack {\n  private:\n    ListNode *stackTop; // 将头节点作为栈顶\n    int stkSize;        // 栈的长度\n\n  public:\n    LinkedListStack() {\n        stackTop = nullptr;\n        stkSize = 0;\n    }\n\n    ~LinkedListStack() {\n        // 遍历链表删除节点，释放内存\n        freeMemoryLinkedList(stackTop);\n    }\n\n    /* 获取栈的长度 */\n    int size() {\n        return stkSize;\n    }\n\n    /* 判断栈是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入栈 */\n    void push(int num) {\n        ListNode *node = new ListNode(num);\n        node->next = stackTop;\n        stackTop = node;\n        stkSize++;\n    }\n\n    /* 出栈 */\n    int pop() {\n        int num = top();\n        ListNode *tmp = stackTop;\n        stackTop = stackTop->next;\n        // 释放内存\n        delete tmp;\n        stkSize--;\n        return num;\n    }\n\n    /* 访问栈顶元素 */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"栈为空\");\n        return stackTop->val;\n    }\n\n    /* 将 List 转化为 Array 并返回 */\n    vector<int> toVector() {\n        ListNode *node = stackTop;\n        vector<int> res(size());\n        for (int i = res.size() - 1; i >= 0; i--) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n\n## Queue\n队列（queue）是一种遵循**先入先出**（**FIFO**)规则的线性数据结构。队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。我们将队列头部称为“**队首**”，尾部称为“**队尾**”，将把**元素加入队尾**的操作称为“**入队**”，**删除队首元素**的操作称为“**出队**”。\n\n### Queue in STL\n```cpp\n#include <queue>\n/* 初始化队列 */\nqueue<int> queue;\n\n/* 元素入队 */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* 访问队首元素 */\nint front = queue.front();\n\n/* 元素出队 */\nqueue.pop();\n\n/* 获取队列的长度 */\nint size = queue.size();\n\n/* 判断队列是否为空 */\nbool empty = queue.empty();\n```\n\n## 队列的实现\n### 基于数组的实现\n在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而我们可以使用一个变量 `front` 指向**队首元素的索引**，并维护一个变量 `size` 用于**记录队列长度**。定义 `rear = front + size` ，这个公式计算出的 `rear` 指向**队尾元素之后的下一个位置**。\n\n基于此设计，数组中包含元素的**有效区间**为 [`front`, `rear` - 1]。\n\n- **入队**操作：将输入元素赋值给 `rear` 索引处，并将 `size` 增加 1 。\n- **出队**操作：只需将 `front` 增加 1 ，并将 `size` 减少 1 。\n\n\n可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1)\n\n```cpp\n/* 基于环形数组实现的队列 */\nclass ArrayQueue {\n  private:\n    int *nums;       // 用于存储队列元素的数组\n    int front;       // 队首指针，指向队首元素\n    int queSize;     // 队列长度\n    int queCapacity; // 队列容量\n\n  public:\n    ArrayQueue(int capacity) {\n        // 初始化数组\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* 获取队列的容量 */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout << \"队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        // 通过取余操作实现 rear 越过数组尾部后回到头部\n        int rear = (front + queSize) % queCapacity;\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 队首指针向后移动一位，若越过尾部，则返回到数组头部\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        return nums[front];\n    }\n\n    /* 将数组转化为 Vector 并返回 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> arr(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n```\n\n### 基于链表的实现\n```cpp\n/* 基于链表实现的队列 */\nclass LinkedListQueue {\n  private:\n    ListNode *front, *rear; // 头节点 front ，尾节点 rear\n    int queSize;\n\n  public:\n    LinkedListQueue() {\n        front = nullptr;\n        rear = nullptr;\n        queSize = 0;\n    }\n\n    ~LinkedListQueue() {\n        // 遍历链表删除节点，释放内存\n        freeMemoryLinkedList(front);\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        // 在尾节点后添加 num\n        ListNode *node = new ListNode(num);\n        // 如果队列为空，则令头、尾节点都指向该节点\n        if (front == nullptr) {\n            front = node;\n            rear = node;\n        }\n        // 如果队列不为空，则将该节点添加到尾节点后\n        else {\n            rear->next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 删除头节点\n        ListNode *tmp = front;\n        front = front->next;\n        // 释放内存\n        delete tmp;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (size() == 0)\n            throw out_of_range(\"队列为空\");\n        return front->val;\n    }\n\n    /* 将链表转化为 Vector 并返回 */\n    vector<int> toVector() {\n        ListNode *node = front;\n        vector<int> res(size());\n        for (int i = 0; i < res.size(); i++) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n{%fold into @ 在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了，这时应该怎么办呢？%}\n\n我们可以将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 `front` 或 `rear` 在越过数组尾部时，直接**回到数组头部继续遍历**。这种周期性规律可以通过“**取余操作**”来实现！\n\n{%endfold%}\n\n```cpp\n/* 基于环形数组实现的队列 */\nclass ArrayQueue {\n  private:\n    int *nums;       // 用于存储队列元素的数组\n    int front;       // 队首指针，指向队首元素\n    int queSize;     // 队列长度\n    int queCapacity; // 队列容量\n\n  public:\n    ArrayQueue(int capacity) {\n        // 初始化数组\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* 获取队列的容量 */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout << \"队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        // 通过取余操作实现 rear 越过数组尾部后回到头部\n        int rear = (front + queSize) % queCapacity;\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 队首指针向后移动一位，若越过尾部，则返回到数组头部\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        return nums[front];\n    }\n\n    /* 将数组转化为 Vector 并返回 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> arr(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n```\n\n# 双向队列\n\n在队列中，我们仅能删除头部元素或在尾部添加元素。双向队列（double-ended queue）提供了**更高的灵活性**，允许在**头部和尾部**执行元素的添加或删除操作。\n\n```cpp\n#include <deque>\n/* 初始化双向队列 */\ndeque<int> deque;\n\n/* 元素入队 */\ndeque.push_back(2);   // 添加至队尾\ndeque.push_back(5);\ndeque.push_back(4);\n\ndeque.push_front(3);  // 添加至队首\ndeque.push_front(1);\n\n/* 访问元素 */\nint front = deque.front(); // 队首元素\nint back = deque.back();   // 队尾元素\n\n/* 元素出队 */\ndeque.pop_front();  // 队首元素出队\ndeque.pop_back();   // 队尾元素出队\n\n/* 获取双向队列的长度 */\nint size = deque.size();\n\n/* 判断双向队列是否为空 */\nbool empty = deque.empty();\n```\n## 双向队列的实现\n### 基于数组的实现\n```cpp\n/* 基于环形数组实现的双向队列 */\nclass ArrayDeque {\n  private:\n    vector<int> nums; // 用于存储双向队列元素的数组\n    int front;        // 队首指针，指向队首元素\n    int queSize;      // 双向队列长度\n\n  public:\n    /* 构造方法 */\n    ArrayDeque(int capacity) {\n        nums.resize(capacity);\n        front = queSize = 0;\n    }\n\n    /* 获取双向队列的容量 */\n    int capacity() {\n        return nums.size();\n    }\n\n    /* 获取双向队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断双向队列是否为空 */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* 计算环形数组索引 */\n    int index(int i) {\n        // 通过取余操作实现数组首尾相连\n        // 当 i 越过数组尾部后，回到头部\n        // 当 i 越过数组头部后，回到尾部\n        return (i + capacity()) % capacity();\n    }\n\n    /* 队首入队 */\n    void pushFirst(int num) {\n        if (queSize == capacity()) {\n            cout << \"双向队列已满\" << endl;\n            return;\n        }\n        // 队首指针向左移动一位\n        // 通过取余操作实现 front 越过数组头部后回到尾部\n        front = index(front - 1);\n        // 将 num 添加至队首\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* 队尾入队 */\n    void pushLast(int num) {\n        if (queSize == capacity()) {\n            cout << \"双向队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        int rear = index(front + queSize);\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 队首出队 */\n    int popFirst() {\n        int num = peekFirst();\n        // 队首指针向后移动一位\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* 队尾出队 */\n    int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return nums[front];\n    }\n\n    /* 访问队尾元素 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        // 计算尾元素索引\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* 返回数组用于打印 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> res(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n};\n```\n\n### 基于链表的实现\n\n对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个**对称方向**的操作。为此，我们采用“**双向链表**”作为双向队列的底层数据结构。\n\n```cpp\n/* 双向链表节点 */\nstruct DoublyListNode {\n    int val;              // 节点值\n    DoublyListNode *next; // 后继节点指针\n    DoublyListNode *prev; // 前驱节点指针\n    DoublyListNode(int val) : val(val), prev(nullptr), next(nullptr) {\n    }\n};\n\n/* 基于双向链表实现的双向队列 */\nclass LinkedListDeque {\n  private:\n    DoublyListNode *front, *rear; // 头节点 front ，尾节点 rear\n    int queSize = 0;              // 双向队列的长度\n\n  public:\n    /* 构造方法 */\n    LinkedListDeque() : front(nullptr), rear(nullptr) {\n    }\n\n    /* 析构方法 */\n    ~LinkedListDeque() {\n        // 遍历链表删除节点，释放内存\n        DoublyListNode *pre, *cur = front;\n        while (cur != nullptr) {\n            pre = cur;\n            cur = cur->next;\n            delete pre;\n        }\n    }\n\n    /* 获取双向队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断双向队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队操作 */\n    void push(int num, bool isFront) {\n        DoublyListNode *node = new DoublyListNode(num);\n        // 若链表为空，则令 front 和 rear 都指向 node\n        if (isEmpty())\n            front = rear = node;\n        // 队首入队操作\n        else if (isFront) {\n            // 将 node 添加至链表头部\n            front->prev = node;\n            node->next = front;\n            front = node; // 更新头节点\n        // 队尾入队操作\n        } else {\n            // 将 node 添加至链表尾部\n            rear->next = node;\n            node->prev = rear;\n            rear = node; // 更新尾节点\n        }\n        queSize++; // 更新队列长度\n    }\n\n    /* 队首入队 */\n    void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* 队尾入队 */\n    void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* 出队操作 */\n    int pop(bool isFront) {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        int val;\n        // 队首出队操作\n        if (isFront) {\n            val = front->val; // 暂存头节点值\n            // 删除头节点\n            DoublyListNode *fNext = front->next;\n            if (fNext != nullptr) {\n                fNext->prev = nullptr;\n                front->next = nullptr;\n            }\n            delete front;\n            front = fNext; // 更新头节点\n        // 队尾出队操作\n        } else {\n            val = rear->val; // 暂存尾节点值\n            // 删除尾节点\n            DoublyListNode *rPrev = rear->prev;\n            if (rPrev != nullptr) {\n                rPrev->next = nullptr;\n                rear->prev = nullptr;\n            }\n            delete rear;\n            rear = rPrev; // 更新尾节点\n        }\n        queSize--; // 更新队列长度\n        return val;\n    }\n\n    /* 队首出队 */\n    int popFirst() {\n        return pop(true);\n    }\n\n    /* 队尾出队 */\n    int popLast() {\n        return pop(false);\n    }\n\n    /* 访问队首元素 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return front->val;\n    }\n\n    /* 访问队尾元素 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return rear->val;\n    }\n\n    /* 返回数组用于打印 */\n    vector<int> toVector() {\n        DoublyListNode *node = front;\n        vector<int> res(size());\n        for (int i = 0; i < res.size(); i++) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n\n{%fold into @ 撤销（undo）和反撤销（redo）具体是如何实现的？%}\n\n使用两个栈，栈 A 用于**撤销**，栈 B 用于**反撤销**。\n\n每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。\n当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。\n当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。\n\n{%endfold%}","source":"_posts/Data structure/Stack-and-Queue.md","raw":"---\ntitle: Stack and Queue\ndate: 2025-08-23 14:16:21\ntags: [datastructure,stack,queue,updating]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/Stack-and-Queue.png?raw=true\ncategory: Data Structure\ncategory_bar: true\ndescription: Reviewing the chapter about stack and queue in Data Structure\n---\n\n\n## Stack\n栈（stack）是一种遵循**先入后出**(**LIFO**)逻辑的线性数据结构:我们把堆叠元素的顶部称为“**栈顶**”，底部称为“**栈底**”。将把**元素添加到栈顶**的操作叫作“**入栈**”，**删除栈顶元素**的操作叫作“**出栈**”。\n\n### Stack in STL\n```cpp\n#include <stack>\n/* 初始化栈 */\nstack<int> stack;\n\n/* 元素入栈 */\nstack.push(1);\nstack.push(3);\nstack.push(2);\nstack.push(5);\nstack.push(4);\n\n/* 访问栈顶元素 */\nint top = stack.top();\n\n/* 元素出栈 */\nstack.pop(); // 无返回值\n\n/* 获取栈的长度 */\nint size = stack.size();\n\n/* 判断是否为空 */\nbool empty = stack.empty();\n```\n\n## 栈的实现\n\n&emsp;&emsp;由于**数组**和**链表**都可以在任意位置添加和删除元素，因此栈可以视为一种**受限制的**数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性，下面我们分别**用数组和链表实现栈的功能**！\n\n### 基于数组的实现\n使用数组实现栈时，我们可以将**数组的尾部作为栈顶**。由于入栈的元素可能会源源不断地增加，因此我们可以使用**动态数组**，这样就无须自行处理**数组扩容问题**。\n```cpp\nvector <int> stack;\n/* 获取栈的长度 */\nint size() {\n    return stack.size();\n}\n/* 判断栈是否为空 */\nbool empty() {\n    return stack.size() == 0;\n}\n/* 入栈 */\nvoid push(int num){\n    stack.push_back(num);\n}\n/* 出栈 */\nvoid pop() {\n    stack.pop_back();\n}\n/* 访问栈顶元素 */\nint top() {\n    if (isempty()) {\n        throw out_of_range(\"栈为空\");\n    }\n    return stack.back();\n}\n```\n\n\n### 基于链表的实现\n\n使用链表实现栈时，我们可以将链表的**头节点视为栈顶**，**尾节点视为栈底**。\n- 对于入栈操作，我们只需将**元素插入链表头部**，这种节点插入方法被称为“**头插法**”。\n- 对于出栈操作，只需**将头节点从链表中删除**即可。\n\n```cpp\n/* 基于链表实现的栈 */\nclass LinkedListStack {\n  private:\n    ListNode *stackTop; // 将头节点作为栈顶\n    int stkSize;        // 栈的长度\n\n  public:\n    LinkedListStack() {\n        stackTop = nullptr;\n        stkSize = 0;\n    }\n\n    ~LinkedListStack() {\n        // 遍历链表删除节点，释放内存\n        freeMemoryLinkedList(stackTop);\n    }\n\n    /* 获取栈的长度 */\n    int size() {\n        return stkSize;\n    }\n\n    /* 判断栈是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入栈 */\n    void push(int num) {\n        ListNode *node = new ListNode(num);\n        node->next = stackTop;\n        stackTop = node;\n        stkSize++;\n    }\n\n    /* 出栈 */\n    int pop() {\n        int num = top();\n        ListNode *tmp = stackTop;\n        stackTop = stackTop->next;\n        // 释放内存\n        delete tmp;\n        stkSize--;\n        return num;\n    }\n\n    /* 访问栈顶元素 */\n    int top() {\n        if (isEmpty())\n            throw out_of_range(\"栈为空\");\n        return stackTop->val;\n    }\n\n    /* 将 List 转化为 Array 并返回 */\n    vector<int> toVector() {\n        ListNode *node = stackTop;\n        vector<int> res(size());\n        for (int i = res.size() - 1; i >= 0; i--) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n\n## Queue\n队列（queue）是一种遵循**先入先出**（**FIFO**)规则的线性数据结构。队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。我们将队列头部称为“**队首**”，尾部称为“**队尾**”，将把**元素加入队尾**的操作称为“**入队**”，**删除队首元素**的操作称为“**出队**”。\n\n### Queue in STL\n```cpp\n#include <queue>\n/* 初始化队列 */\nqueue<int> queue;\n\n/* 元素入队 */\nqueue.push(1);\nqueue.push(3);\nqueue.push(2);\nqueue.push(5);\nqueue.push(4);\n\n/* 访问队首元素 */\nint front = queue.front();\n\n/* 元素出队 */\nqueue.pop();\n\n/* 获取队列的长度 */\nint size = queue.size();\n\n/* 判断队列是否为空 */\nbool empty = queue.empty();\n```\n\n## 队列的实现\n### 基于数组的实现\n在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而我们可以使用一个变量 `front` 指向**队首元素的索引**，并维护一个变量 `size` 用于**记录队列长度**。定义 `rear = front + size` ，这个公式计算出的 `rear` 指向**队尾元素之后的下一个位置**。\n\n基于此设计，数组中包含元素的**有效区间**为 [`front`, `rear` - 1]。\n\n- **入队**操作：将输入元素赋值给 `rear` 索引处，并将 `size` 增加 1 。\n- **出队**操作：只需将 `front` 增加 1 ，并将 `size` 减少 1 。\n\n\n可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1)\n\n```cpp\n/* 基于环形数组实现的队列 */\nclass ArrayQueue {\n  private:\n    int *nums;       // 用于存储队列元素的数组\n    int front;       // 队首指针，指向队首元素\n    int queSize;     // 队列长度\n    int queCapacity; // 队列容量\n\n  public:\n    ArrayQueue(int capacity) {\n        // 初始化数组\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* 获取队列的容量 */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout << \"队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        // 通过取余操作实现 rear 越过数组尾部后回到头部\n        int rear = (front + queSize) % queCapacity;\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 队首指针向后移动一位，若越过尾部，则返回到数组头部\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        return nums[front];\n    }\n\n    /* 将数组转化为 Vector 并返回 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> arr(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n```\n\n### 基于链表的实现\n```cpp\n/* 基于链表实现的队列 */\nclass LinkedListQueue {\n  private:\n    ListNode *front, *rear; // 头节点 front ，尾节点 rear\n    int queSize;\n\n  public:\n    LinkedListQueue() {\n        front = nullptr;\n        rear = nullptr;\n        queSize = 0;\n    }\n\n    ~LinkedListQueue() {\n        // 遍历链表删除节点，释放内存\n        freeMemoryLinkedList(front);\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        // 在尾节点后添加 num\n        ListNode *node = new ListNode(num);\n        // 如果队列为空，则令头、尾节点都指向该节点\n        if (front == nullptr) {\n            front = node;\n            rear = node;\n        }\n        // 如果队列不为空，则将该节点添加到尾节点后\n        else {\n            rear->next = node;\n            rear = node;\n        }\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 删除头节点\n        ListNode *tmp = front;\n        front = front->next;\n        // 释放内存\n        delete tmp;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (size() == 0)\n            throw out_of_range(\"队列为空\");\n        return front->val;\n    }\n\n    /* 将链表转化为 Vector 并返回 */\n    vector<int> toVector() {\n        ListNode *node = front;\n        vector<int> res(size());\n        for (int i = 0; i < res.size(); i++) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n{%fold into @ 在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了，这时应该怎么办呢？%}\n\n我们可以将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 `front` 或 `rear` 在越过数组尾部时，直接**回到数组头部继续遍历**。这种周期性规律可以通过“**取余操作**”来实现！\n\n{%endfold%}\n\n```cpp\n/* 基于环形数组实现的队列 */\nclass ArrayQueue {\n  private:\n    int *nums;       // 用于存储队列元素的数组\n    int front;       // 队首指针，指向队首元素\n    int queSize;     // 队列长度\n    int queCapacity; // 队列容量\n\n  public:\n    ArrayQueue(int capacity) {\n        // 初始化数组\n        nums = new int[capacity];\n        queCapacity = capacity;\n        front = queSize = 0;\n    }\n\n    ~ArrayQueue() {\n        delete[] nums;\n    }\n\n    /* 获取队列的容量 */\n    int capacity() {\n        return queCapacity;\n    }\n\n    /* 获取队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队 */\n    void push(int num) {\n        if (queSize == queCapacity) {\n            cout << \"队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        // 通过取余操作实现 rear 越过数组尾部后回到头部\n        int rear = (front + queSize) % queCapacity;\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 出队 */\n    int pop() {\n        int num = peek();\n        // 队首指针向后移动一位，若越过尾部，则返回到数组头部\n        front = (front + 1) % queCapacity;\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peek() {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        return nums[front];\n    }\n\n    /* 将数组转化为 Vector 并返回 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> arr(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            arr[i] = nums[j % queCapacity];\n        }\n        return arr;\n    }\n};\n```\n\n# 双向队列\n\n在队列中，我们仅能删除头部元素或在尾部添加元素。双向队列（double-ended queue）提供了**更高的灵活性**，允许在**头部和尾部**执行元素的添加或删除操作。\n\n```cpp\n#include <deque>\n/* 初始化双向队列 */\ndeque<int> deque;\n\n/* 元素入队 */\ndeque.push_back(2);   // 添加至队尾\ndeque.push_back(5);\ndeque.push_back(4);\n\ndeque.push_front(3);  // 添加至队首\ndeque.push_front(1);\n\n/* 访问元素 */\nint front = deque.front(); // 队首元素\nint back = deque.back();   // 队尾元素\n\n/* 元素出队 */\ndeque.pop_front();  // 队首元素出队\ndeque.pop_back();   // 队尾元素出队\n\n/* 获取双向队列的长度 */\nint size = deque.size();\n\n/* 判断双向队列是否为空 */\nbool empty = deque.empty();\n```\n## 双向队列的实现\n### 基于数组的实现\n```cpp\n/* 基于环形数组实现的双向队列 */\nclass ArrayDeque {\n  private:\n    vector<int> nums; // 用于存储双向队列元素的数组\n    int front;        // 队首指针，指向队首元素\n    int queSize;      // 双向队列长度\n\n  public:\n    /* 构造方法 */\n    ArrayDeque(int capacity) {\n        nums.resize(capacity);\n        front = queSize = 0;\n    }\n\n    /* 获取双向队列的容量 */\n    int capacity() {\n        return nums.size();\n    }\n\n    /* 获取双向队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断双向队列是否为空 */\n    bool isEmpty() {\n        return queSize == 0;\n    }\n\n    /* 计算环形数组索引 */\n    int index(int i) {\n        // 通过取余操作实现数组首尾相连\n        // 当 i 越过数组尾部后，回到头部\n        // 当 i 越过数组头部后，回到尾部\n        return (i + capacity()) % capacity();\n    }\n\n    /* 队首入队 */\n    void pushFirst(int num) {\n        if (queSize == capacity()) {\n            cout << \"双向队列已满\" << endl;\n            return;\n        }\n        // 队首指针向左移动一位\n        // 通过取余操作实现 front 越过数组头部后回到尾部\n        front = index(front - 1);\n        // 将 num 添加至队首\n        nums[front] = num;\n        queSize++;\n    }\n\n    /* 队尾入队 */\n    void pushLast(int num) {\n        if (queSize == capacity()) {\n            cout << \"双向队列已满\" << endl;\n            return;\n        }\n        // 计算队尾指针，指向队尾索引 + 1\n        int rear = index(front + queSize);\n        // 将 num 添加至队尾\n        nums[rear] = num;\n        queSize++;\n    }\n\n    /* 队首出队 */\n    int popFirst() {\n        int num = peekFirst();\n        // 队首指针向后移动一位\n        front = index(front + 1);\n        queSize--;\n        return num;\n    }\n\n    /* 队尾出队 */\n    int popLast() {\n        int num = peekLast();\n        queSize--;\n        return num;\n    }\n\n    /* 访问队首元素 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return nums[front];\n    }\n\n    /* 访问队尾元素 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        // 计算尾元素索引\n        int last = index(front + queSize - 1);\n        return nums[last];\n    }\n\n    /* 返回数组用于打印 */\n    vector<int> toVector() {\n        // 仅转换有效长度范围内的列表元素\n        vector<int> res(queSize);\n        for (int i = 0, j = front; i < queSize; i++, j++) {\n            res[i] = nums[index(j)];\n        }\n        return res;\n    }\n};\n```\n\n### 基于链表的实现\n\n对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个**对称方向**的操作。为此，我们采用“**双向链表**”作为双向队列的底层数据结构。\n\n```cpp\n/* 双向链表节点 */\nstruct DoublyListNode {\n    int val;              // 节点值\n    DoublyListNode *next; // 后继节点指针\n    DoublyListNode *prev; // 前驱节点指针\n    DoublyListNode(int val) : val(val), prev(nullptr), next(nullptr) {\n    }\n};\n\n/* 基于双向链表实现的双向队列 */\nclass LinkedListDeque {\n  private:\n    DoublyListNode *front, *rear; // 头节点 front ，尾节点 rear\n    int queSize = 0;              // 双向队列的长度\n\n  public:\n    /* 构造方法 */\n    LinkedListDeque() : front(nullptr), rear(nullptr) {\n    }\n\n    /* 析构方法 */\n    ~LinkedListDeque() {\n        // 遍历链表删除节点，释放内存\n        DoublyListNode *pre, *cur = front;\n        while (cur != nullptr) {\n            pre = cur;\n            cur = cur->next;\n            delete pre;\n        }\n    }\n\n    /* 获取双向队列的长度 */\n    int size() {\n        return queSize;\n    }\n\n    /* 判断双向队列是否为空 */\n    bool isEmpty() {\n        return size() == 0;\n    }\n\n    /* 入队操作 */\n    void push(int num, bool isFront) {\n        DoublyListNode *node = new DoublyListNode(num);\n        // 若链表为空，则令 front 和 rear 都指向 node\n        if (isEmpty())\n            front = rear = node;\n        // 队首入队操作\n        else if (isFront) {\n            // 将 node 添加至链表头部\n            front->prev = node;\n            node->next = front;\n            front = node; // 更新头节点\n        // 队尾入队操作\n        } else {\n            // 将 node 添加至链表尾部\n            rear->next = node;\n            node->prev = rear;\n            rear = node; // 更新尾节点\n        }\n        queSize++; // 更新队列长度\n    }\n\n    /* 队首入队 */\n    void pushFirst(int num) {\n        push(num, true);\n    }\n\n    /* 队尾入队 */\n    void pushLast(int num) {\n        push(num, false);\n    }\n\n    /* 出队操作 */\n    int pop(bool isFront) {\n        if (isEmpty())\n            throw out_of_range(\"队列为空\");\n        int val;\n        // 队首出队操作\n        if (isFront) {\n            val = front->val; // 暂存头节点值\n            // 删除头节点\n            DoublyListNode *fNext = front->next;\n            if (fNext != nullptr) {\n                fNext->prev = nullptr;\n                front->next = nullptr;\n            }\n            delete front;\n            front = fNext; // 更新头节点\n        // 队尾出队操作\n        } else {\n            val = rear->val; // 暂存尾节点值\n            // 删除尾节点\n            DoublyListNode *rPrev = rear->prev;\n            if (rPrev != nullptr) {\n                rPrev->next = nullptr;\n                rear->prev = nullptr;\n            }\n            delete rear;\n            rear = rPrev; // 更新尾节点\n        }\n        queSize--; // 更新队列长度\n        return val;\n    }\n\n    /* 队首出队 */\n    int popFirst() {\n        return pop(true);\n    }\n\n    /* 队尾出队 */\n    int popLast() {\n        return pop(false);\n    }\n\n    /* 访问队首元素 */\n    int peekFirst() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return front->val;\n    }\n\n    /* 访问队尾元素 */\n    int peekLast() {\n        if (isEmpty())\n            throw out_of_range(\"双向队列为空\");\n        return rear->val;\n    }\n\n    /* 返回数组用于打印 */\n    vector<int> toVector() {\n        DoublyListNode *node = front;\n        vector<int> res(size());\n        for (int i = 0; i < res.size(); i++) {\n            res[i] = node->val;\n            node = node->next;\n        }\n        return res;\n    }\n};\n```\n\n{%fold into @ 撤销（undo）和反撤销（redo）具体是如何实现的？%}\n\n使用两个栈，栈 A 用于**撤销**，栈 B 用于**反撤销**。\n\n每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。\n当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。\n当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。\n\n{%endfold%}","slug":"Data structure/Stack-and-Queue","published":1,"updated":"2025-08-26T07:25:42.348Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hco001240w38x9w28aq","content":"<h2 id=\"Stack\">Stack</h2>\n<p>栈（stack）是一种遵循<strong>先入后出</strong>(<strong>LIFO</strong>)逻辑的线性数据结构:我们把堆叠元素的顶部称为“<strong>栈顶</strong>”，底部称为“<strong>栈底</strong>”。将把<strong>元素添加到栈顶</strong>的操作叫作“<strong>入栈</strong>”，<strong>删除栈顶元素</strong>的操作叫作“<strong>出栈</strong>”。</p>\n<h3 id=\"Stack-in-STL\">Stack in STL</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化栈 */</span><br>stack&lt;<span class=\"hljs-type\">int</span>&gt; stack;<br><br><span class=\"hljs-comment\">/* 元素入栈 */</span><br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">3</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">2</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">5</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">4</span>);<br><br><span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br><span class=\"hljs-type\">int</span> top = stack.<span class=\"hljs-built_in\">top</span>();<br><br><span class=\"hljs-comment\">/* 元素出栈 */</span><br>stack.<span class=\"hljs-built_in\">pop</span>(); <span class=\"hljs-comment\">// 无返回值</span><br><br><span class=\"hljs-comment\">/* 获取栈的长度 */</span><br><span class=\"hljs-type\">int</span> size = stack.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = stack.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"栈的实现\">栈的实现</h2>\n<p>  由于<strong>数组</strong>和<strong>链表</strong>都可以在任意位置添加和删除元素，因此栈可以视为一种<strong>受限制的</strong>数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性，下面我们分别<strong>用数组和链表实现栈的功能</strong>！</p>\n<h3 id=\"基于数组的实现\">基于数组的实现</h3>\n<p>使用数组实现栈时，我们可以将<strong>数组的尾部作为栈顶</strong>。由于入栈的元素可能会源源不断地增加，因此我们可以使用<strong>动态数组</strong>，这样就无须自行处理<strong>数组扩容问题</strong>。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector &lt;<span class=\"hljs-type\">int</span>&gt; stack;<br><span class=\"hljs-comment\">/* 获取栈的长度 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">size</span>();<br>}<br><span class=\"hljs-comment\">/* 判断栈是否为空 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>}<br><span class=\"hljs-comment\">/* 入栈 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span>{<br>    stack.<span class=\"hljs-built_in\">push_back</span>(num);<br>}<br><span class=\"hljs-comment\">/* 出栈 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{<br>    stack.<span class=\"hljs-built_in\">pop_back</span>();<br>}<br><span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>{<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isempty</span>()) {<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"栈为空\"</span>);<br>    }<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">back</span>();<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"基于链表的实现\">基于链表的实现</h3>\n<p>使用链表实现栈时，我们可以将链表的<strong>头节点视为栈顶</strong>，<strong>尾节点视为栈底</strong>。</p>\n<ul>\n<li>对于入栈操作，我们只需将<strong>元素插入链表头部</strong>，这种节点插入方法被称为“<strong>头插法</strong>”。</li>\n<li>对于出栈操作，只需<strong>将头节点从链表中删除</strong>即可。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于链表实现的栈 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListStack</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    ListNode *stackTop; <span class=\"hljs-comment\">// 将头节点作为栈顶</span><br>    <span class=\"hljs-type\">int</span> stkSize;        <span class=\"hljs-comment\">// 栈的长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedListStack</span>() {<br>        stackTop = <span class=\"hljs-literal\">nullptr</span>;<br>        stkSize = <span class=\"hljs-number\">0</span>;<br>    }<br><br>    ~<span class=\"hljs-built_in\">LinkedListStack</span>() {<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        <span class=\"hljs-built_in\">freeMemoryLinkedList</span>(stackTop);<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取栈的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> stkSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断栈是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 入栈 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        ListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(num);<br>        node-&gt;next = stackTop;<br>        stackTop = node;<br>        stkSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 出栈 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">top</span>();<br>        ListNode *tmp = stackTop;<br>        stackTop = stackTop-&gt;next;<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">delete</span> tmp;<br>        stkSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"栈为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> stackTop-&gt;val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 将 List 转化为 Array 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        ListNode *node = stackTop;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = res.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) {<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Queue\">Queue</h2>\n<p>队列（queue）是一种遵循<strong>先入先出</strong>（<strong>FIFO</strong>)规则的线性数据结构。队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。我们将队列头部称为“<strong>队首</strong>”，尾部称为“<strong>队尾</strong>”，将把<strong>元素加入队尾</strong>的操作称为“<strong>入队</strong>”，<strong>删除队首元素</strong>的操作称为“<strong>出队</strong>”。</p>\n<h3 id=\"Queue-in-STL\">Queue in STL</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化队列 */</span><br>queue&lt;<span class=\"hljs-type\">int</span>&gt; queue;<br><br><span class=\"hljs-comment\">/* 元素入队 */</span><br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">3</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">2</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">5</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">4</span>);<br><br><span class=\"hljs-comment\">/* 访问队首元素 */</span><br><span class=\"hljs-type\">int</span> front = queue.<span class=\"hljs-built_in\">front</span>();<br><br><span class=\"hljs-comment\">/* 元素出队 */</span><br>queue.<span class=\"hljs-built_in\">pop</span>();<br><br><span class=\"hljs-comment\">/* 获取队列的长度 */</span><br><span class=\"hljs-type\">int</span> size = queue.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = queue.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"队列的实现\">队列的实现</h2>\n<h3 id=\"基于数组的实现-v2\">基于数组的实现</h3>\n<p>在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而我们可以使用一个变量 <code>front</code> 指向<strong>队首元素的索引</strong>，并维护一个变量 <code>size</code> 用于<strong>记录队列长度</strong>。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向<strong>队尾元素之后的下一个位置</strong>。</p>\n<p>基于此设计，数组中包含元素的<strong>有效区间</strong>为 [<code>front</code>, <code>rear</code> - 1]。</p>\n<ul>\n<li><strong>入队</strong>操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li>\n<li><strong>出队</strong>操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li>\n</ul>\n<p>可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1)</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayQueue</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> *nums;       <span class=\"hljs-comment\">// 用于存储队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;       <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;     <span class=\"hljs-comment\">// 队列长度</span><br>    <span class=\"hljs-type\">int</span> queCapacity; <span class=\"hljs-comment\">// 队列容量</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayQueue</span>(<span class=\"hljs-type\">int</span> capacity) {<br>        <span class=\"hljs-comment\">// 初始化数组</span><br>        nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[capacity];<br>        queCapacity = capacity;<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    }<br><br>    ~<span class=\"hljs-built_in\">ArrayQueue</span>() {<br>        <span class=\"hljs-keyword\">delete</span>[] nums;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queCapacity;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (queSize == queCapacity) {<br>            cout &lt;&lt; <span class=\"hljs-string\">\"队列已满\"</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        }<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 rear 越过数组尾部后回到头部</span><br>        <span class=\"hljs-type\">int</span> rear = (front + queSize) % queCapacity;<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span><br>        front = (front + <span class=\"hljs-number\">1</span>) % queCapacity;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    }<br><br>    <span class=\"hljs-comment\">/* 将数组转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) {<br>            arr[i] = nums[j % queCapacity];<br>        }<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"基于链表的实现-v2\">基于链表的实现</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于链表实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListQueue</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    ListNode *front, *rear; <span class=\"hljs-comment\">// 头节点 front ，尾节点 rear</span><br>    <span class=\"hljs-type\">int</span> queSize;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedListQueue</span>() {<br>        front = <span class=\"hljs-literal\">nullptr</span>;<br>        rear = <span class=\"hljs-literal\">nullptr</span>;<br>        queSize = <span class=\"hljs-number\">0</span>;<br>    }<br><br>    ~<span class=\"hljs-built_in\">LinkedListQueue</span>() {<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        <span class=\"hljs-built_in\">freeMemoryLinkedList</span>(front);<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-comment\">// 在尾节点后添加 num</span><br>        ListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(num);<br>        <span class=\"hljs-comment\">// 如果队列为空，则令头、尾节点都指向该节点</span><br>        <span class=\"hljs-keyword\">if</span> (front == <span class=\"hljs-literal\">nullptr</span>) {<br>            front = node;<br>            rear = node;<br>        }<br>        <span class=\"hljs-comment\">// 如果队列不为空，则将该节点添加到尾节点后</span><br>        <span class=\"hljs-keyword\">else</span> {<br>            rear-&gt;next = node;<br>            rear = node;<br>        }<br>        queSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 删除头节点</span><br>        ListNode *tmp = front;<br>        front = front-&gt;next;<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">delete</span> tmp;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> front-&gt;val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 将链表转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        ListNode *node = front;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; res.<span class=\"hljs-built_in\">size</span>(); i++) {<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8c97f03b\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8c97f03b\">\n        <div class=\"fold-arrow\">▶</div> 在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了，这时应该怎么办呢？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8c97f03b\">\n        <div class=\"fold-content\">\n          <p>我们可以将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接<strong>回到数组头部继续遍历</strong>。这种周期性规律可以通过“<strong>取余操作</strong>”来实现！</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayQueue</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> *nums;       <span class=\"hljs-comment\">// 用于存储队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;       <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;     <span class=\"hljs-comment\">// 队列长度</span><br>    <span class=\"hljs-type\">int</span> queCapacity; <span class=\"hljs-comment\">// 队列容量</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayQueue</span>(<span class=\"hljs-type\">int</span> capacity) {<br>        <span class=\"hljs-comment\">// 初始化数组</span><br>        nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[capacity];<br>        queCapacity = capacity;<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    }<br><br>    ~<span class=\"hljs-built_in\">ArrayQueue</span>() {<br>        <span class=\"hljs-keyword\">delete</span>[] nums;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queCapacity;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (queSize == queCapacity) {<br>            cout &lt;&lt; <span class=\"hljs-string\">\"队列已满\"</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        }<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 rear 越过数组尾部后回到头部</span><br>        <span class=\"hljs-type\">int</span> rear = (front + queSize) % queCapacity;<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span><br>        front = (front + <span class=\"hljs-number\">1</span>) % queCapacity;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    }<br><br>    <span class=\"hljs-comment\">/* 将数组转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) {<br>            arr[i] = nums[j % queCapacity];<br>        }<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h1>双向队列</h1>\n<p>在队列中，我们仅能删除头部元素或在尾部添加元素。双向队列（double-ended queue）提供了<strong>更高的灵活性</strong>，允许在<strong>头部和尾部</strong>执行元素的添加或删除操作。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化双向队列 */</span><br>deque&lt;<span class=\"hljs-type\">int</span>&gt; deque;<br><br><span class=\"hljs-comment\">/* 元素入队 */</span><br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// 添加至队尾</span><br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">5</span>);<br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br><br>deque.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// 添加至队首</span><br>deque.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">/* 访问元素 */</span><br><span class=\"hljs-type\">int</span> front = deque.<span class=\"hljs-built_in\">front</span>(); <span class=\"hljs-comment\">// 队首元素</span><br><span class=\"hljs-type\">int</span> back = deque.<span class=\"hljs-built_in\">back</span>();   <span class=\"hljs-comment\">// 队尾元素</span><br><br><span class=\"hljs-comment\">/* 元素出队 */</span><br>deque.<span class=\"hljs-built_in\">pop_front</span>();  <span class=\"hljs-comment\">// 队首元素出队</span><br>deque.<span class=\"hljs-built_in\">pop_back</span>();   <span class=\"hljs-comment\">// 队尾元素出队</span><br><br><span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br><span class=\"hljs-type\">int</span> size = deque.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = deque.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"双向队列的实现\">双向队列的实现</h2>\n<h3 id=\"基于数组的实现-v3\">基于数组的实现</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的双向队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayDeque</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; nums; <span class=\"hljs-comment\">// 用于存储双向队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;        <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;      <span class=\"hljs-comment\">// 双向队列长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">ArrayDeque</span>(<span class=\"hljs-type\">int</span> capacity) {<br>        nums.<span class=\"hljs-built_in\">resize</span>(capacity);<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-built_in\">size</span>();<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 计算环形数组索引 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">index</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>{<br>        <span class=\"hljs-comment\">// 通过取余操作实现数组首尾相连</span><br>        <span class=\"hljs-comment\">// 当 i 越过数组尾部后，回到头部</span><br>        <span class=\"hljs-comment\">// 当 i 越过数组头部后，回到尾部</span><br>        <span class=\"hljs-keyword\">return</span> (i + <span class=\"hljs-built_in\">capacity</span>()) % <span class=\"hljs-built_in\">capacity</span>();<br>    }<br><br>    <span class=\"hljs-comment\">/* 队首入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushFirst</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (queSize == <span class=\"hljs-built_in\">capacity</span>()) {<br>            cout &lt;&lt; <span class=\"hljs-string\">\"双向队列已满\"</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        }<br>        <span class=\"hljs-comment\">// 队首指针向左移动一位</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 front 越过数组头部后回到尾部</span><br>        front = <span class=\"hljs-built_in\">index</span>(front - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-comment\">// 将 num 添加至队首</span><br>        nums[front] = num;<br>        queSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 队尾入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushLast</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (queSize == <span class=\"hljs-built_in\">capacity</span>()) {<br>            cout &lt;&lt; <span class=\"hljs-string\">\"双向队列已满\"</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        }<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-type\">int</span> rear = <span class=\"hljs-built_in\">index</span>(front + queSize);<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    }<br><br>    <span class=\"hljs-comment\">/* 队首出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popFirst</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peekFirst</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位</span><br>        front = <span class=\"hljs-built_in\">index</span>(front + <span class=\"hljs-number\">1</span>);<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 队尾出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popLast</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peekLast</span>();<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekFirst</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"双向队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队尾元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekLast</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"双向队列为空\"</span>);<br>        <span class=\"hljs-comment\">// 计算尾元素索引</span><br>        <span class=\"hljs-type\">int</span> last = <span class=\"hljs-built_in\">index</span>(front + queSize - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[last];<br>    }<br><br>    <span class=\"hljs-comment\">/* 返回数组用于打印 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) {<br>            res[i] = nums[<span class=\"hljs-built_in\">index</span>(j)];<br>        }<br>        <span class=\"hljs-keyword\">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"基于链表的实现-v3\">基于链表的实现</h3>\n<p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个<strong>对称方向</strong>的操作。为此，我们采用“<strong>双向链表</strong>”作为双向队列的底层数据结构。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 双向链表节点 */</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DoublyListNode</span> {<br>    <span class=\"hljs-type\">int</span> val;              <span class=\"hljs-comment\">// 节点值</span><br>    DoublyListNode *next; <span class=\"hljs-comment\">// 后继节点指针</span><br>    DoublyListNode *prev; <span class=\"hljs-comment\">// 前驱节点指针</span><br>    <span class=\"hljs-built_in\">DoublyListNode</span>(<span class=\"hljs-type\">int</span> val) : <span class=\"hljs-built_in\">val</span>(val), <span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) {<br>    }<br>};<br><br><span class=\"hljs-comment\">/* 基于双向链表实现的双向队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListDeque</span> {<br>  <span class=\"hljs-keyword\">private</span>:<br>    DoublyListNode *front, *rear; <span class=\"hljs-comment\">// 头节点 front ，尾节点 rear</span><br>    <span class=\"hljs-type\">int</span> queSize = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// 双向队列的长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">LinkedListDeque</span>() : <span class=\"hljs-built_in\">front</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">rear</span>(<span class=\"hljs-literal\">nullptr</span>) {<br>    }<br><br>    <span class=\"hljs-comment\">/* 析构方法 */</span><br>    ~<span class=\"hljs-built_in\">LinkedListDeque</span>() {<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        DoublyListNode *pre, *cur = front;<br>        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">nullptr</span>) {<br>            pre = cur;<br>            cur = cur-&gt;next;<br>            <span class=\"hljs-keyword\">delete</span> pre;<br>        }<br>    }<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    }<br><br>    <span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    }<br><br>    <span class=\"hljs-comment\">/* 入队操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num, <span class=\"hljs-type\">bool</span> isFront)</span> </span>{<br>        DoublyListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">DoublyListNode</span>(num);<br>        <span class=\"hljs-comment\">// 若链表为空，则令 front 和 rear 都指向 node</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            front = rear = node;<br>        <span class=\"hljs-comment\">// 队首入队操作</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isFront) {<br>            <span class=\"hljs-comment\">// 将 node 添加至链表头部</span><br>            front-&gt;prev = node;<br>            node-&gt;next = front;<br>            front = node; <span class=\"hljs-comment\">// 更新头节点</span><br>        <span class=\"hljs-comment\">// 队尾入队操作</span><br>        } <span class=\"hljs-keyword\">else</span> {<br>            <span class=\"hljs-comment\">// 将 node 添加至链表尾部</span><br>            rear-&gt;next = node;<br>            node-&gt;prev = rear;<br>            rear = node; <span class=\"hljs-comment\">// 更新尾节点</span><br>        }<br>        queSize++; <span class=\"hljs-comment\">// 更新队列长度</span><br>    }<br><br>    <span class=\"hljs-comment\">/* 队首入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushFirst</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-built_in\">push</span>(num, <span class=\"hljs-literal\">true</span>);<br>    }<br><br>    <span class=\"hljs-comment\">/* 队尾入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushLast</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>{<br>        <span class=\"hljs-built_in\">push</span>(num, <span class=\"hljs-literal\">false</span>);<br>    }<br><br>    <span class=\"hljs-comment\">/* 出队操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> isFront)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"队列为空\"</span>);<br>        <span class=\"hljs-type\">int</span> val;<br>        <span class=\"hljs-comment\">// 队首出队操作</span><br>        <span class=\"hljs-keyword\">if</span> (isFront) {<br>            val = front-&gt;val; <span class=\"hljs-comment\">// 暂存头节点值</span><br>            <span class=\"hljs-comment\">// 删除头节点</span><br>            DoublyListNode *fNext = front-&gt;next;<br>            <span class=\"hljs-keyword\">if</span> (fNext != <span class=\"hljs-literal\">nullptr</span>) {<br>                fNext-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>                front-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>            }<br>            <span class=\"hljs-keyword\">delete</span> front;<br>            front = fNext; <span class=\"hljs-comment\">// 更新头节点</span><br>        <span class=\"hljs-comment\">// 队尾出队操作</span><br>        } <span class=\"hljs-keyword\">else</span> {<br>            val = rear-&gt;val; <span class=\"hljs-comment\">// 暂存尾节点值</span><br>            <span class=\"hljs-comment\">// 删除尾节点</span><br>            DoublyListNode *rPrev = rear-&gt;prev;<br>            <span class=\"hljs-keyword\">if</span> (rPrev != <span class=\"hljs-literal\">nullptr</span>) {<br>                rPrev-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>                rear-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>            }<br>            <span class=\"hljs-keyword\">delete</span> rear;<br>            rear = rPrev; <span class=\"hljs-comment\">// 更新尾节点</span><br>        }<br>        queSize--; <span class=\"hljs-comment\">// 更新队列长度</span><br>        <span class=\"hljs-keyword\">return</span> val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 队首出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popFirst</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pop</span>(<span class=\"hljs-literal\">true</span>);<br>    }<br><br>    <span class=\"hljs-comment\">/* 队尾出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popLast</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pop</span>(<span class=\"hljs-literal\">false</span>);<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekFirst</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"双向队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> front-&gt;val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 访问队尾元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekLast</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">\"双向队列为空\"</span>);<br>        <span class=\"hljs-keyword\">return</span> rear-&gt;val;<br>    }<br><br>    <span class=\"hljs-comment\">/* 返回数组用于打印 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>{<br>        DoublyListNode *node = front;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; res.<span class=\"hljs-built_in\">size</span>(); i++) {<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> res;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8f61356f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8f61356f\">\n        <div class=\"fold-arrow\">▶</div> 撤销（undo）和反撤销（redo）具体是如何实现的？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8f61356f\">\n        <div class=\"fold-content\">\n          <p>使用两个栈，栈 A 用于<strong>撤销</strong>，栈 B 用于<strong>反撤销</strong>。</p><p>每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。<br>当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。<br>当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。</p>\n        </div>\n      </div>\n    </div>","excerpt":"","more":"<h2 id=\"Stack\">Stack</h2>\n<p>栈（stack）是一种遵循<strong>先入后出</strong>(<strong>LIFO</strong>)逻辑的线性数据结构:我们把堆叠元素的顶部称为“<strong>栈顶</strong>”，底部称为“<strong>栈底</strong>”。将把<strong>元素添加到栈顶</strong>的操作叫作“<strong>入栈</strong>”，<strong>删除栈顶元素</strong>的操作叫作“<strong>出栈</strong>”。</p>\n<h3 id=\"Stack-in-STL\">Stack in STL</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化栈 */</span><br>stack&lt;<span class=\"hljs-type\">int</span>&gt; stack;<br><br><span class=\"hljs-comment\">/* 元素入栈 */</span><br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">3</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">2</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">5</span>);<br>stack.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">4</span>);<br><br><span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br><span class=\"hljs-type\">int</span> top = stack.<span class=\"hljs-built_in\">top</span>();<br><br><span class=\"hljs-comment\">/* 元素出栈 */</span><br>stack.<span class=\"hljs-built_in\">pop</span>(); <span class=\"hljs-comment\">// 无返回值</span><br><br><span class=\"hljs-comment\">/* 获取栈的长度 */</span><br><span class=\"hljs-type\">int</span> size = stack.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = stack.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"栈的实现\">栈的实现</h2>\n<p>  由于<strong>数组</strong>和<strong>链表</strong>都可以在任意位置添加和删除元素，因此栈可以视为一种<strong>受限制的</strong>数组或链表。换句话说，我们可以“屏蔽”数组或链表的部分无关操作，使其对外表现的逻辑符合栈的特性，下面我们分别<strong>用数组和链表实现栈的功能</strong>！</p>\n<h3 id=\"基于数组的实现\">基于数组的实现</h3>\n<p>使用数组实现栈时，我们可以将<strong>数组的尾部作为栈顶</strong>。由于入栈的元素可能会源源不断地增加，因此我们可以使用<strong>动态数组</strong>，这样就无须自行处理<strong>数组扩容问题</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">vector &lt;<span class=\"hljs-type\">int</span>&gt; stack;<br><span class=\"hljs-comment\">/* 获取栈的长度 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">size</span>();<br>&#125;<br><span class=\"hljs-comment\">/* 判断栈是否为空 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">empty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>&#125;<br><span class=\"hljs-comment\">/* 入栈 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span></span>&#123;<br>    stack.<span class=\"hljs-built_in\">push_back</span>(num);<br>&#125;<br><span class=\"hljs-comment\">/* 出栈 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    stack.<span class=\"hljs-built_in\">pop_back</span>();<br>&#125;<br><span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isempty</span>()) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;栈为空&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> stack.<span class=\"hljs-built_in\">back</span>();<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"基于链表的实现\">基于链表的实现</h3>\n<p>使用链表实现栈时，我们可以将链表的<strong>头节点视为栈顶</strong>，<strong>尾节点视为栈底</strong>。</p>\n<ul>\n<li>对于入栈操作，我们只需将<strong>元素插入链表头部</strong>，这种节点插入方法被称为“<strong>头插法</strong>”。</li>\n<li>对于出栈操作，只需<strong>将头节点从链表中删除</strong>即可。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于链表实现的栈 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListStack</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    ListNode *stackTop; <span class=\"hljs-comment\">// 将头节点作为栈顶</span><br>    <span class=\"hljs-type\">int</span> stkSize;        <span class=\"hljs-comment\">// 栈的长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedListStack</span>() &#123;<br>        stackTop = <span class=\"hljs-literal\">nullptr</span>;<br>        stkSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">LinkedListStack</span>() &#123;<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        <span class=\"hljs-built_in\">freeMemoryLinkedList</span>(stackTop);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取栈的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> stkSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断栈是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 入栈 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        ListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(num);<br>        node-&gt;next = stackTop;<br>        stackTop = node;<br>        stkSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 出栈 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">top</span>();<br>        ListNode *tmp = stackTop;<br>        stackTop = stackTop-&gt;next;<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">delete</span> tmp;<br>        stkSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问栈顶元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">top</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;栈为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> stackTop-&gt;val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 将 List 转化为 Array 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        ListNode *node = stackTop;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = res.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; i--) &#123;<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Queue\">Queue</h2>\n<p>队列（queue）是一种遵循<strong>先入先出</strong>（<strong>FIFO</strong>)规则的线性数据结构。队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开。我们将队列头部称为“<strong>队首</strong>”，尾部称为“<strong>队尾</strong>”，将把<strong>元素加入队尾</strong>的操作称为“<strong>入队</strong>”，<strong>删除队首元素</strong>的操作称为“<strong>出队</strong>”。</p>\n<h3 id=\"Queue-in-STL\">Queue in STL</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化队列 */</span><br>queue&lt;<span class=\"hljs-type\">int</span>&gt; queue;<br><br><span class=\"hljs-comment\">/* 元素入队 */</span><br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">3</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">2</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">5</span>);<br>queue.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">4</span>);<br><br><span class=\"hljs-comment\">/* 访问队首元素 */</span><br><span class=\"hljs-type\">int</span> front = queue.<span class=\"hljs-built_in\">front</span>();<br><br><span class=\"hljs-comment\">/* 元素出队 */</span><br>queue.<span class=\"hljs-built_in\">pop</span>();<br><br><span class=\"hljs-comment\">/* 获取队列的长度 */</span><br><span class=\"hljs-type\">int</span> size = queue.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = queue.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"队列的实现\">队列的实现</h2>\n<h3 id=\"基于数组的实现-v2\">基于数组的实现</h3>\n<p>在数组中删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。然而我们可以使用一个变量 <code>front</code> 指向<strong>队首元素的索引</strong>，并维护一个变量 <code>size</code> 用于<strong>记录队列长度</strong>。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向<strong>队尾元素之后的下一个位置</strong>。</p>\n<p>基于此设计，数组中包含元素的<strong>有效区间</strong>为 [<code>front</code>, <code>rear</code> - 1]。</p>\n<ul>\n<li><strong>入队</strong>操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li>\n<li><strong>出队</strong>操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li>\n</ul>\n<p>可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 O(1)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayQueue</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> *nums;       <span class=\"hljs-comment\">// 用于存储队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;       <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;     <span class=\"hljs-comment\">// 队列长度</span><br>    <span class=\"hljs-type\">int</span> queCapacity; <span class=\"hljs-comment\">// 队列容量</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayQueue</span>(<span class=\"hljs-type\">int</span> capacity) &#123;<br>        <span class=\"hljs-comment\">// 初始化数组</span><br>        nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[capacity];<br>        queCapacity = capacity;<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">ArrayQueue</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] nums;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queCapacity;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (queSize == queCapacity) &#123;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;队列已满&quot;</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 rear 越过数组尾部后回到头部</span><br>        <span class=\"hljs-type\">int</span> rear = (front + queSize) % queCapacity;<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span><br>        front = (front + <span class=\"hljs-number\">1</span>) % queCapacity;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 将数组转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) &#123;<br>            arr[i] = nums[j % queCapacity];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"基于链表的实现-v2\">基于链表的实现</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于链表实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListQueue</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    ListNode *front, *rear; <span class=\"hljs-comment\">// 头节点 front ，尾节点 rear</span><br>    <span class=\"hljs-type\">int</span> queSize;<br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">LinkedListQueue</span>() &#123;<br>        front = <span class=\"hljs-literal\">nullptr</span>;<br>        rear = <span class=\"hljs-literal\">nullptr</span>;<br>        queSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">LinkedListQueue</span>() &#123;<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        <span class=\"hljs-built_in\">freeMemoryLinkedList</span>(front);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 在尾节点后添加 num</span><br>        ListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(num);<br>        <span class=\"hljs-comment\">// 如果队列为空，则令头、尾节点都指向该节点</span><br>        <span class=\"hljs-keyword\">if</span> (front == <span class=\"hljs-literal\">nullptr</span>) &#123;<br>            front = node;<br>            rear = node;<br>        &#125;<br>        <span class=\"hljs-comment\">// 如果队列不为空，则将该节点添加到尾节点后</span><br>        <span class=\"hljs-keyword\">else</span> &#123;<br>            rear-&gt;next = node;<br>            rear = node;<br>        &#125;<br>        queSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 删除头节点</span><br>        ListNode *tmp = front;<br>        front = front-&gt;next;<br>        <span class=\"hljs-comment\">// 释放内存</span><br>        <span class=\"hljs-keyword\">delete</span> tmp;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>)<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> front-&gt;val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 将链表转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        ListNode *node = front;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; res.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8c97f03b\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8c97f03b\">\n        <div class=\"fold-arrow\">▶</div> 在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了，这时应该怎么办呢？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8c97f03b\">\n        <div class=\"fold-content\">\n          <p>我们可以将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接<strong>回到数组头部继续遍历</strong>。这种周期性规律可以通过“<strong>取余操作</strong>”来实现！</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayQueue</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> *nums;       <span class=\"hljs-comment\">// 用于存储队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;       <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;     <span class=\"hljs-comment\">// 队列长度</span><br>    <span class=\"hljs-type\">int</span> queCapacity; <span class=\"hljs-comment\">// 队列容量</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">ArrayQueue</span>(<span class=\"hljs-type\">int</span> capacity) &#123;<br>        <span class=\"hljs-comment\">// 初始化数组</span><br>        nums = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>[capacity];<br>        queCapacity = capacity;<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    ~<span class=\"hljs-built_in\">ArrayQueue</span>() &#123;<br>        <span class=\"hljs-keyword\">delete</span>[] nums;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queCapacity;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (queSize == queCapacity) &#123;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;队列已满&quot;</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 rear 越过数组尾部后回到头部</span><br>        <span class=\"hljs-type\">int</span> rear = (front + queSize) % queCapacity;<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peek</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位，若越过尾部，则返回到数组头部</span><br>        front = (front + <span class=\"hljs-number\">1</span>) % queCapacity;<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 将数组转化为 Vector 并返回 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">arr</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) &#123;<br>            arr[i] = nums[j % queCapacity];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h1>双向队列</h1>\n<p>在队列中，我们仅能删除头部元素或在尾部添加元素。双向队列（double-ended queue）提供了<strong>更高的灵活性</strong>，允许在<strong>头部和尾部</strong>执行元素的添加或删除操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span><br><span class=\"hljs-comment\">/* 初始化双向队列 */</span><br>deque&lt;<span class=\"hljs-type\">int</span>&gt; deque;<br><br><span class=\"hljs-comment\">/* 元素入队 */</span><br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// 添加至队尾</span><br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">5</span>);<br>deque.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-number\">4</span>);<br><br>deque.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">3</span>);  <span class=\"hljs-comment\">// 添加至队首</span><br>deque.<span class=\"hljs-built_in\">push_front</span>(<span class=\"hljs-number\">1</span>);<br><br><span class=\"hljs-comment\">/* 访问元素 */</span><br><span class=\"hljs-type\">int</span> front = deque.<span class=\"hljs-built_in\">front</span>(); <span class=\"hljs-comment\">// 队首元素</span><br><span class=\"hljs-type\">int</span> back = deque.<span class=\"hljs-built_in\">back</span>();   <span class=\"hljs-comment\">// 队尾元素</span><br><br><span class=\"hljs-comment\">/* 元素出队 */</span><br>deque.<span class=\"hljs-built_in\">pop_front</span>();  <span class=\"hljs-comment\">// 队首元素出队</span><br>deque.<span class=\"hljs-built_in\">pop_back</span>();   <span class=\"hljs-comment\">// 队尾元素出队</span><br><br><span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br><span class=\"hljs-type\">int</span> size = deque.<span class=\"hljs-built_in\">size</span>();<br><br><span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br><span class=\"hljs-type\">bool</span> empty = deque.<span class=\"hljs-built_in\">empty</span>();<br></code></pre></td></tr></table></figure>\n<h2 id=\"双向队列的实现\">双向队列的实现</h2>\n<h3 id=\"基于数组的实现-v3\">基于数组的实现</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 基于环形数组实现的双向队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayDeque</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; nums; <span class=\"hljs-comment\">// 用于存储双向队列元素的数组</span><br>    <span class=\"hljs-type\">int</span> front;        <span class=\"hljs-comment\">// 队首指针，指向队首元素</span><br>    <span class=\"hljs-type\">int</span> queSize;      <span class=\"hljs-comment\">// 双向队列长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">ArrayDeque</span>(<span class=\"hljs-type\">int</span> capacity) &#123;<br>        nums.<span class=\"hljs-built_in\">resize</span>(capacity);<br>        front = queSize = <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的容量 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">capacity</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-built_in\">size</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 计算环形数组索引 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">index</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 通过取余操作实现数组首尾相连</span><br>        <span class=\"hljs-comment\">// 当 i 越过数组尾部后，回到头部</span><br>        <span class=\"hljs-comment\">// 当 i 越过数组头部后，回到尾部</span><br>        <span class=\"hljs-keyword\">return</span> (i + <span class=\"hljs-built_in\">capacity</span>()) % <span class=\"hljs-built_in\">capacity</span>();<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队首入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushFirst</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (queSize == <span class=\"hljs-built_in\">capacity</span>()) &#123;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;双向队列已满&quot;</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">// 队首指针向左移动一位</span><br>        <span class=\"hljs-comment\">// 通过取余操作实现 front 越过数组头部后回到尾部</span><br>        front = <span class=\"hljs-built_in\">index</span>(front - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-comment\">// 将 num 添加至队首</span><br>        nums[front] = num;<br>        queSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队尾入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushLast</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (queSize == <span class=\"hljs-built_in\">capacity</span>()) &#123;<br>            cout &lt;&lt; <span class=\"hljs-string\">&quot;双向队列已满&quot;</span> &lt;&lt; endl;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        <span class=\"hljs-comment\">// 计算队尾指针，指向队尾索引 + 1</span><br>        <span class=\"hljs-type\">int</span> rear = <span class=\"hljs-built_in\">index</span>(front + queSize);<br>        <span class=\"hljs-comment\">// 将 num 添加至队尾</span><br>        nums[rear] = num;<br>        queSize++;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队首出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popFirst</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peekFirst</span>();<br>        <span class=\"hljs-comment\">// 队首指针向后移动一位</span><br>        front = <span class=\"hljs-built_in\">index</span>(front + <span class=\"hljs-number\">1</span>);<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队尾出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popLast</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num = <span class=\"hljs-built_in\">peekLast</span>();<br>        queSize--;<br>        <span class=\"hljs-keyword\">return</span> num;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekFirst</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;双向队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[front];<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队尾元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekLast</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;双向队列为空&quot;</span>);<br>        <span class=\"hljs-comment\">// 计算尾元素索引</span><br>        <span class=\"hljs-type\">int</span> last = <span class=\"hljs-built_in\">index</span>(front + queSize - <span class=\"hljs-number\">1</span>);<br>        <span class=\"hljs-keyword\">return</span> nums[last];<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 返回数组用于打印 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 仅转换有效长度范围内的列表元素</span><br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(queSize)</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = front; i &lt; queSize; i++, j++) &#123;<br>            res[i] = nums[<span class=\"hljs-built_in\">index</span>(j)];<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"基于链表的实现-v3\">基于链表的实现</h3>\n<p>对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个<strong>对称方向</strong>的操作。为此，我们采用“<strong>双向链表</strong>”作为双向队列的底层数据结构。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/* 双向链表节点 */</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DoublyListNode</span> &#123;<br>    <span class=\"hljs-type\">int</span> val;              <span class=\"hljs-comment\">// 节点值</span><br>    DoublyListNode *next; <span class=\"hljs-comment\">// 后继节点指针</span><br>    DoublyListNode *prev; <span class=\"hljs-comment\">// 前驱节点指针</span><br>    <span class=\"hljs-built_in\">DoublyListNode</span>(<span class=\"hljs-type\">int</span> val) : <span class=\"hljs-built_in\">val</span>(val), <span class=\"hljs-built_in\">prev</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">next</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/* 基于双向链表实现的双向队列 */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LinkedListDeque</span> &#123;<br>  <span class=\"hljs-keyword\">private</span>:<br>    DoublyListNode *front, *rear; <span class=\"hljs-comment\">// 头节点 front ，尾节点 rear</span><br>    <span class=\"hljs-type\">int</span> queSize = <span class=\"hljs-number\">0</span>;              <span class=\"hljs-comment\">// 双向队列的长度</span><br><br>  <span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">/* 构造方法 */</span><br>    <span class=\"hljs-built_in\">LinkedListDeque</span>() : <span class=\"hljs-built_in\">front</span>(<span class=\"hljs-literal\">nullptr</span>), <span class=\"hljs-built_in\">rear</span>(<span class=\"hljs-literal\">nullptr</span>) &#123;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 析构方法 */</span><br>    ~<span class=\"hljs-built_in\">LinkedListDeque</span>() &#123;<br>        <span class=\"hljs-comment\">// 遍历链表删除节点，释放内存</span><br>        DoublyListNode *pre, *cur = front;<br>        <span class=\"hljs-keyword\">while</span> (cur != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>            pre = cur;<br>            cur = cur-&gt;next;<br>            <span class=\"hljs-keyword\">delete</span> pre;<br>        &#125;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 获取双向队列的长度 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> queSize;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 判断双向队列是否为空 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 入队操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num, <span class=\"hljs-type\">bool</span> isFront)</span> </span>&#123;<br>        DoublyListNode *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">DoublyListNode</span>(num);<br>        <span class=\"hljs-comment\">// 若链表为空，则令 front 和 rear 都指向 node</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            front = rear = node;<br>        <span class=\"hljs-comment\">// 队首入队操作</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isFront) &#123;<br>            <span class=\"hljs-comment\">// 将 node 添加至链表头部</span><br>            front-&gt;prev = node;<br>            node-&gt;next = front;<br>            front = node; <span class=\"hljs-comment\">// 更新头节点</span><br>        <span class=\"hljs-comment\">// 队尾入队操作</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 将 node 添加至链表尾部</span><br>            rear-&gt;next = node;<br>            node-&gt;prev = rear;<br>            rear = node; <span class=\"hljs-comment\">// 更新尾节点</span><br>        &#125;<br>        queSize++; <span class=\"hljs-comment\">// 更新队列长度</span><br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队首入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushFirst</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-built_in\">push</span>(num, <span class=\"hljs-literal\">true</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队尾入队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">pushLast</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> num)</span> </span>&#123;<br>        <span class=\"hljs-built_in\">push</span>(num, <span class=\"hljs-literal\">false</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 出队操作 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> isFront)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;队列为空&quot;</span>);<br>        <span class=\"hljs-type\">int</span> val;<br>        <span class=\"hljs-comment\">// 队首出队操作</span><br>        <span class=\"hljs-keyword\">if</span> (isFront) &#123;<br>            val = front-&gt;val; <span class=\"hljs-comment\">// 暂存头节点值</span><br>            <span class=\"hljs-comment\">// 删除头节点</span><br>            DoublyListNode *fNext = front-&gt;next;<br>            <span class=\"hljs-keyword\">if</span> (fNext != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>                fNext-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>                front-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">delete</span> front;<br>            front = fNext; <span class=\"hljs-comment\">// 更新头节点</span><br>        <span class=\"hljs-comment\">// 队尾出队操作</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            val = rear-&gt;val; <span class=\"hljs-comment\">// 暂存尾节点值</span><br>            <span class=\"hljs-comment\">// 删除尾节点</span><br>            DoublyListNode *rPrev = rear-&gt;prev;<br>            <span class=\"hljs-keyword\">if</span> (rPrev != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>                rPrev-&gt;next = <span class=\"hljs-literal\">nullptr</span>;<br>                rear-&gt;prev = <span class=\"hljs-literal\">nullptr</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">delete</span> rear;<br>            rear = rPrev; <span class=\"hljs-comment\">// 更新尾节点</span><br>        &#125;<br>        queSize--; <span class=\"hljs-comment\">// 更新队列长度</span><br>        <span class=\"hljs-keyword\">return</span> val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队首出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popFirst</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pop</span>(<span class=\"hljs-literal\">true</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 队尾出队 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">popLast</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pop</span>(<span class=\"hljs-literal\">false</span>);<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队首元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekFirst</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;双向队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> front-&gt;val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 访问队尾元素 */</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">peekLast</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isEmpty</span>())<br>            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-built_in\">out_of_range</span>(<span class=\"hljs-string\">&quot;双向队列为空&quot;</span>);<br>        <span class=\"hljs-keyword\">return</span> rear-&gt;val;<br>    &#125;<br><br>    <span class=\"hljs-comment\">/* 返回数组用于打印 */</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">toVector</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        DoublyListNode *node = front;<br>        <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">res</span><span class=\"hljs-params\">(size())</span></span>;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; res.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>            res[i] = node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8f61356f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8f61356f\">\n        <div class=\"fold-arrow\">▶</div> 撤销（undo）和反撤销（redo）具体是如何实现的？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8f61356f\">\n        <div class=\"fold-content\">\n          <p>使用两个栈，栈 A 用于<strong>撤销</strong>，栈 B 用于<strong>反撤销</strong>。</p><p>每当用户执行一个操作，将这个操作压入栈 A ，并清空栈 B 。<br>当用户执行“撤销”时，从栈 A 中弹出最近的操作，并将其压入栈 B 。<br>当用户执行“反撤销”时，从栈 B 中弹出最近的操作，并将其压入栈 A 。</p>\n        </div>\n      </div>\n    </div>"},{"title":"HTML Fundamentals Guide","date":"2025-08-12T09:37:03.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/HTML.png?raw=true","category_bar":true,"description":"A brief tutorial on HTML, including the basic grammar, detailed example and demonstration!","_content":"\n\n\n{%note default%}\n或许我现在才深刻认识到计算机是一门实践的学科还不算太晚，上学期我抱着书将HTML和CSS啃完，看似语法从“入门”到“精通”，但没有项目进行实战，导致记忆并不深刻，仅仅“**纸上得来终觉浅**” ，遂现在以一个案例进行引入，学习（亦或是复习）HTML和CSS的语法！{%endnote%}\n\n进阶速通版本参看 [Web-Dev-Beginner - Quick start to front & back-end Dev](https://doc.duke486.com/)\n\n## What is HTML？\n\nHTML(Hyper Text Markup Language)是**超文本编辑语言**，与我们平时学习的c++、python等编程语言，它是一种标记语言，可以理解为markdown语法的进阶，毕竟我们博客撰写的markdown最后都是通过渲染为HTML展示在用户面前的，其由一套标记标签组成，大多数标签**由一对尖括号包裹**，他们定义了网页中每个元素的作用和显示方式，像是这样：`<标签名>文本内容</标签名>`，这种形式的叫做**双标签**，标签内的内容会被浏览器渲染。比如：\n\n```html\n<p>这是一个段落</p>\n```\n\n有些标签是单独存在的，不需要结束标签，这些叫做**自闭和标签**，例如：\n\n```html\n<img sre=\"image.jpg\" alt=\"描述\">\n```\n## HTML basic structure\n在vscode中输入`!`，在按下`Tab`，会自动补全HTML的基本结构：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>\n```\n1. 开始标签`<html>`：限定了文档的开始和结束点\n2. 头部标签`<head>`：描述文档的各种属性和信息\n3. 标题标签`<title>`：定义文档标题，通常会直接显示在浏览器窗口的标题栏或状态栏上，当用户将网页收藏或作为书签时，标题将成为文档链接的默认名称\n4. 主题标签`<body>`：包含文档所有内容，后续我们主要的HTML代码也在这里编写\n5. 元信息标签`<meta>`：提供有关页面的信息，其永远位于head元素内部\n6. `<!DOCTYPE>`标签:必须位于HTML文档第一行，没有结束标签，且不区分大小写\n\n## HTML基本语法\n### 标题文字\n```html\n    <h1>一级标题</h1>\n    <h2>二级标题</h2>\n    <h3>三级标题</h3>\n    <h4>四级标题</h4>\n    <h5>五级标题</h5>\n    <h6>六级标题</h6>\n```\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n{%note primary%}\n看上去与markdown中的`#`效果差不多{%endnote%}\n\n{%note danger%}\n不要为了使文字加粗而使用h标签，文字加粗使用b标签\n这里标题会在目录形成**树形结构**！{%endnote%}\n\n### 文字对齐\n\n网页中都是使用**默认的对齐方式**，但当我们需要其他的对齐方式时就需要使用`align`属性进行设置\n\n|属性值|含义|\n|-----|-------|\nleft|左对齐（默认）|\ncenter|居中对齐|\nright|右对齐|\n```html\nalign=\"对齐方式\"\n```\n```html\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n```\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n\n### 文字样式\n在HTML中，字体效果必须在浏览器安装相应字体后才能浏览，否则还是会被浏览器中的通用字体所替代。\n| 字体名称           | 适用场景                |\n|--------------------|------------------------|\n| **微软雅黑**       | 中文网页/UI设计首选字体 |\n| **黑体**           | 中文标题/广告宣传       |\n| **宋体**           | 中文印刷/正式文档       |\n| **楷体**           | 中文手写风格/艺术排版   |\n| **仿宋**           | 中文公文/古籍排版       |\n| **Georgia**        | 标题、优雅排版          |\n| **Times New Roman**|  印刷品、正式文档        |\n```html\n<font face=\"Simsun\">应用了宋体文字</font>\n```\n<font face=\"Simsun\">应用了宋体文字</font>\n\n### 段落换行\n```html\n<br>此处换行\n```\n\n```html\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again</p>\n\n\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again</p>\n```\n\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again.</p>\n\n\n\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again.</p>\n\n——《See You Again》\n\n\n\n### 字体颜色\n```html\n<font color=\"颜色参数\"></font>\n```\n颜色参数值有多种表达形式：\n#### 1. 颜色关键字\n直接使用预定义的颜色名称（不区分大小写）：\n```html\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n```\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n\n\n#### 2. 十六进制（HEX）\n格式：#RRGGBB 或 #RGB（简写）\n```html\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n```\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n\n#### 3. RGB/RGBA\n格式：rgb(R, G, B) 或 rgba(R, G, B, A)（带透明度）\n```html\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n```\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n\n### 文字的上下标\n```html\n<sup></sup>上标标签\n<sub></sub>下标标签\n```\n```html\nx<sup>3</sup>+x<sup>2</sup>+x+1=0\nx<sub>3</sub>+x<sub>2</sub>+x+1=0\n```\nx<sup>3</sup>+x<sup>2</sup>+x+1=0\nx<sub>3</sub>+x<sub>2</sub>+x+1=0\n\n### 文字的删除线\n```html\n<strike>删除的文字</strike>\n```\n<strike>删除的文字</strike>\n\n### 文字加粗\n```html\n<br>需要加粗的文字</br>\n```\n**需要加粗的文字**\n\n### 给网页添加图片\n#### 图片格式\n网页中的图像格式通常有三种，即GIF、JPEG、PNG，目前前两者的支持情况最佳，多数浏览器都可以兼容，而PNG格式的图片属于无损压缩，其清晰度更高，且支持图片保留透明度，因而其所占存储空间对比GIF和JPEG稍大。\n\n```html\n<img src=\"图片文件地址\">\n```\nsrc可以是绝对路径，也可以是相对路径，也可以是图片的网络链接地址\n```html\n<img src=\"/banner_img/background.jpg\">\n```\n<img src=\"/banner_img/background.jpg\">\n\n#### 图片大小\n```html\n<img src=\"图片文件地址\" width=\"图片的宽度\" height=\"图片的高度\">\n```\n```\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n```\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n\n#### 水平间距\n如果不进行换行，那么添加得到图像会紧跟在文字后面，也可以用来设置图片间间距效果\n```html\n<img src=\"图片文件地址\" hspace=\"水平间距\">\n```\n```html\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n```\n\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n\n#### 提示文字\n当指针放在图片上面时会有提示文字\n```html\n<img src=\"图片文件地址\" title=\"提示文字\">\n```\n```html\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n```\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n\n### 创建表格\n|标记|含义|\n|-----|-------|\n`<table></table>`|表格标记|\n`<tr></tr>`|行标记|\n`<td></td>`|单元格标记|\n```html\n<table>\n<tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>123456</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>654321</td>\n    <td>85</td>\n</tr>\n</table>\n```\n`<th></th>`为表格文字加粗\n\n<table>\n<tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>08241110</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>08241120</td>\n    <td>95</td>\n</tr>\n</table>\n\n### 行的的背景\n```html\n<tr bgcolor=\"颜色值\"><tr>\n```\n\n### 表格的对齐方式\n#### 水平对齐\n```html\n<tr align=\"水平对齐方式\"><tr>\n```\n#### 垂直对齐\n```html\n<tr valign=\"垂直对齐方式\"><tr>\n```\n### 表格的的背景\n#### 背景颜色\n```html\n<tr bgcolor=\"颜色值\"><tr>\n```\n#### 背景图片\n```html\n<table background=\"图片地址\"></table>\n```\n\n### 单元格格式\n```html\n<td width=\"单元格宽度\" height=\"单元格高度\">单元格内容</td>\n```\n### 合并单元格\n- colspan合并的是行相邻的单元格\n- rowspan合并的是列相邻的单元格\n\n```html\n<table>\n<tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</table>\n```\n\n<table>\n<tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</table>\n\n### 无序列表\n```html\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n```\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n\n```html\n<ul type=\"符号类型\"></ul>\n```\n\n|参数值|含义|\n|-----|-----|\n|disc|实心圆形|\n|circle|空心圆形|\n|square|实心方形|\n\n```html\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n```\n\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n\n同时也可以给每一个无序列表的选项进行符号类型的选择：\n\n```html\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n```\n\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n\n### 有序列表\n```html\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n```\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n\n也可以自定义起始值和序号类型\n```html\n<ol start=起始数值 type=\"序号类型\"></ol>\n```\n{%note info %}\n无论数字还是字母等类型，起始值只能是数字！\n{%endnote %}\n\n### 创建超链接\n\n#### 内部链接\n\n```html\n<a href=\"链接地址\" target=\"目标窗口的打开方式\">链接文字</a>\n```\n| `target`属性值 | 打开方式 |\n|----------|-----------|\n|`_self`|在当前窗口打开|\n|`_blank`|在新窗口打开|\n|`_parent`|在父窗口打开|\n|`_top`|在顶层窗口打开|\n\n\n#### 外部链接\n\n```html\n<a href=\"http://...\">...</a>\n```\n至此，你已经学会了有关静态网页HTML的语法，可以尝试使用HTML完成个人博客的简单撰写！\n\n## 表单\nHTML 表单用于收集用户的输入信息，当我们需要与用户进行交互，制作动态网页时，就需要使用到表单！\n```html\n<form name=\"test\" action=\"mail:08241120@cumt.edu.cn\" method=\"post\" target=\"_blank\">\n</form>\n```\n{%note info %}\n- 处理动作`action`：定义表单要提交的地址，也就是表单中收集到的资料将要传递的程序地址\n  \n  - 绝对地址\n  - 相对地址\n  - E-mail地址等\n- 表单名称`name`：定义表单的名称，这个名称将作为表单的标识符，用于提交表单时使用\n- 传送方式`method`：定义表单中数据的传送方式\n\n  - `get`：用户端直接发送给服务器，速度快，但数据长度不能太长\n  - `post`：用户端计算机通知服务器来读取数据，数据长度没有限制，但速度较慢\n- 目标显示方式`target`：定义表单提交后，结果显示在哪个窗口中（相关参数见上文）\n\n{%endnote %}\n\n### `input`标签\n```html\n<form>\n    <input name=\"空间名称\" type=\"控件类型\"/>\n</form>\n```\n|`type`取值 |含义|\n|----|----|\n|`text`|文本字段|\n|`password`|密码字段|\n|`radio`|单选按钮|\n|`checkbox`|复选框|\n|`button`|普通按钮|\n|`submit`|提交按钮|\n|`reset`|重置按钮|\n\n#### 文字字段`text`\n```html\n     <input name=\"控件名称\" type=\"text\" value=\"字段默认值\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n{%note warning %}\n- `name`：文字字段名称，用来与其他控件进行区分\n- `size`：文本框的显示长度\n- `maxlength`：文本框中最多可输入的文字数\n- `value`：文本框中的默认值\n{%endnote%}\n\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n\n```html\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n```\n\n#### 密码域`password`\n\n输入到密码域的文字内容都以“*”或者圆点显示。\n```html\n     <input name=\"控件名称\" type=\"password\" value=\"字段默认值\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n\n```html\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n```\n虽然密码域的输入字符已经以掩码的形式显示了，但是没有做到**真正的保密**，因为用户可以通过复制改密码没中的内容并粘贴到其它文档中，查看到密码的“真面目”。为了实现密码的真正安全，可以将密码域的**复制功能屏蔽**，同时**改变密码域的掩码字符**！\n\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n\n```html\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n```\n\n#### 复选框`checkbox`\n```html\n     <input name=\"复选框名称\" type=\"checkbox\" value=\"复选框的值\" checked=\"checked/>\n```\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n确保所有相关复选框有相同的name属性，这样才能将选中的复选框值一起提交。\n```html\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n```\n\n\n#### 表单按钮`button`\n```html\n<input name=\"按钮名称\" type=\"button\" value=\"按钮的值\" onclick=\"处理程序\">\n```\n\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n\n```html\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n```\n\n#### 提交按钮`submit`\n```html\n<input name=\"按钮名称\" type=\"submit\" value=\"按钮的值\">\n```\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n```html\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n```\n\n#### 重置按钮`reset`\n用来清楚用户在页面上输入的信息\n```html\n<input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n```\n\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n\n```html\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n```\n#### 文件域`file`\n用于在表单中添加图片或者文件\n```html\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n\n```html\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n```\n\n#### 文本域`textarea`\n```html\n<textarea name=\"名称\"cols=\"列数\" rows=\"行数\" value=\"文本默认值\">文本内容</textarea>\n```\n\n<form>\n<textarea name=\"名称\"cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n\n```html\n<form>\n<textarea name=\"名称\"cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n```\n### `label`表单定义标签\n{%note info %}\n- 显式关联：将文本和表单控件一起放在`label`标签内\n- 隐式关联：将`label`标签的`for`属性与表单控件的`id`属性关联起来\n{%endnote%}\n\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\"/>\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\"/>\n</form>\n\n\n```html\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\"/>\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\"/>\n</form>\n```\n\n这样我们就将**文本内容与控件关联起来**，当点击表单控件前文字时，该表单控件就可以被选中。\n\n#### 列表表单\n```html\n<select mutiple size=\"可见选项数\">\n<option value=\"值\" selected=\"seclected\"></option>\n</select>\n```\n\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n\n```html\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n```\n\n封面来源：[HTML & CSS for Beginners | FREE MEGA COURSE (7+ Hours!)](https://www.youtube.com/watch?v=iG2jotQo9NI&t=2120s)","source":"_posts/Full-Stack/Html.md","raw":"---\ntitle: HTML Fundamentals Guide\ndate: 2025-08-12 17:37:03\ntags: [html]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/HTML.png?raw=true\ncategory: Full Stack\ncategory_bar: true\ndescription: A brief tutorial on HTML, including the basic grammar, detailed example and demonstration!\n---\n\n\n\n{%note default%}\n或许我现在才深刻认识到计算机是一门实践的学科还不算太晚，上学期我抱着书将HTML和CSS啃完，看似语法从“入门”到“精通”，但没有项目进行实战，导致记忆并不深刻，仅仅“**纸上得来终觉浅**” ，遂现在以一个案例进行引入，学习（亦或是复习）HTML和CSS的语法！{%endnote%}\n\n进阶速通版本参看 [Web-Dev-Beginner - Quick start to front & back-end Dev](https://doc.duke486.com/)\n\n## What is HTML？\n\nHTML(Hyper Text Markup Language)是**超文本编辑语言**，与我们平时学习的c++、python等编程语言，它是一种标记语言，可以理解为markdown语法的进阶，毕竟我们博客撰写的markdown最后都是通过渲染为HTML展示在用户面前的，其由一套标记标签组成，大多数标签**由一对尖括号包裹**，他们定义了网页中每个元素的作用和显示方式，像是这样：`<标签名>文本内容</标签名>`，这种形式的叫做**双标签**，标签内的内容会被浏览器渲染。比如：\n\n```html\n<p>这是一个段落</p>\n```\n\n有些标签是单独存在的，不需要结束标签，这些叫做**自闭和标签**，例如：\n\n```html\n<img sre=\"image.jpg\" alt=\"描述\">\n```\n## HTML basic structure\n在vscode中输入`!`，在按下`Tab`，会自动补全HTML的基本结构：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    \n</body>\n</html>\n```\n1. 开始标签`<html>`：限定了文档的开始和结束点\n2. 头部标签`<head>`：描述文档的各种属性和信息\n3. 标题标签`<title>`：定义文档标题，通常会直接显示在浏览器窗口的标题栏或状态栏上，当用户将网页收藏或作为书签时，标题将成为文档链接的默认名称\n4. 主题标签`<body>`：包含文档所有内容，后续我们主要的HTML代码也在这里编写\n5. 元信息标签`<meta>`：提供有关页面的信息，其永远位于head元素内部\n6. `<!DOCTYPE>`标签:必须位于HTML文档第一行，没有结束标签，且不区分大小写\n\n## HTML基本语法\n### 标题文字\n```html\n    <h1>一级标题</h1>\n    <h2>二级标题</h2>\n    <h3>三级标题</h3>\n    <h4>四级标题</h4>\n    <h5>五级标题</h5>\n    <h6>六级标题</h6>\n```\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n{%note primary%}\n看上去与markdown中的`#`效果差不多{%endnote%}\n\n{%note danger%}\n不要为了使文字加粗而使用h标签，文字加粗使用b标签\n这里标题会在目录形成**树形结构**！{%endnote%}\n\n### 文字对齐\n\n网页中都是使用**默认的对齐方式**，但当我们需要其他的对齐方式时就需要使用`align`属性进行设置\n\n|属性值|含义|\n|-----|-------|\nleft|左对齐（默认）|\ncenter|居中对齐|\nright|右对齐|\n```html\nalign=\"对齐方式\"\n```\n```html\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n```\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n\n### 文字样式\n在HTML中，字体效果必须在浏览器安装相应字体后才能浏览，否则还是会被浏览器中的通用字体所替代。\n| 字体名称           | 适用场景                |\n|--------------------|------------------------|\n| **微软雅黑**       | 中文网页/UI设计首选字体 |\n| **黑体**           | 中文标题/广告宣传       |\n| **宋体**           | 中文印刷/正式文档       |\n| **楷体**           | 中文手写风格/艺术排版   |\n| **仿宋**           | 中文公文/古籍排版       |\n| **Georgia**        | 标题、优雅排版          |\n| **Times New Roman**|  印刷品、正式文档        |\n```html\n<font face=\"Simsun\">应用了宋体文字</font>\n```\n<font face=\"Simsun\">应用了宋体文字</font>\n\n### 段落换行\n```html\n<br>此处换行\n```\n\n```html\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again</p>\n\n\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again</p>\n```\n\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again.</p>\n\n\n\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again.</p>\n\n——《See You Again》\n\n\n\n### 字体颜色\n```html\n<font color=\"颜色参数\"></font>\n```\n颜色参数值有多种表达形式：\n#### 1. 颜色关键字\n直接使用预定义的颜色名称（不区分大小写）：\n```html\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n```\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n\n\n#### 2. 十六进制（HEX）\n格式：#RRGGBB 或 #RGB（简写）\n```html\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n```\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n\n#### 3. RGB/RGBA\n格式：rgb(R, G, B) 或 rgba(R, G, B, A)（带透明度）\n```html\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n```\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n\n### 文字的上下标\n```html\n<sup></sup>上标标签\n<sub></sub>下标标签\n```\n```html\nx<sup>3</sup>+x<sup>2</sup>+x+1=0\nx<sub>3</sub>+x<sub>2</sub>+x+1=0\n```\nx<sup>3</sup>+x<sup>2</sup>+x+1=0\nx<sub>3</sub>+x<sub>2</sub>+x+1=0\n\n### 文字的删除线\n```html\n<strike>删除的文字</strike>\n```\n<strike>删除的文字</strike>\n\n### 文字加粗\n```html\n<br>需要加粗的文字</br>\n```\n**需要加粗的文字**\n\n### 给网页添加图片\n#### 图片格式\n网页中的图像格式通常有三种，即GIF、JPEG、PNG，目前前两者的支持情况最佳，多数浏览器都可以兼容，而PNG格式的图片属于无损压缩，其清晰度更高，且支持图片保留透明度，因而其所占存储空间对比GIF和JPEG稍大。\n\n```html\n<img src=\"图片文件地址\">\n```\nsrc可以是绝对路径，也可以是相对路径，也可以是图片的网络链接地址\n```html\n<img src=\"/banner_img/background.jpg\">\n```\n<img src=\"/banner_img/background.jpg\">\n\n#### 图片大小\n```html\n<img src=\"图片文件地址\" width=\"图片的宽度\" height=\"图片的高度\">\n```\n```\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n```\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n\n#### 水平间距\n如果不进行换行，那么添加得到图像会紧跟在文字后面，也可以用来设置图片间间距效果\n```html\n<img src=\"图片文件地址\" hspace=\"水平间距\">\n```\n```html\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"70px\" height=\"40px\" hspace=\"30px\">\n```\n\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n\n#### 提示文字\n当指针放在图片上面时会有提示文字\n```html\n<img src=\"图片文件地址\" title=\"提示文字\">\n```\n```html\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n```\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n\n### 创建表格\n|标记|含义|\n|-----|-------|\n`<table></table>`|表格标记|\n`<tr></tr>`|行标记|\n`<td></td>`|单元格标记|\n```html\n<table>\n<tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>123456</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>654321</td>\n    <td>85</td>\n</tr>\n</table>\n```\n`<th></th>`为表格文字加粗\n\n<table>\n<tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>08241110</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>08241120</td>\n    <td>95</td>\n</tr>\n</table>\n\n### 行的的背景\n```html\n<tr bgcolor=\"颜色值\"><tr>\n```\n\n### 表格的对齐方式\n#### 水平对齐\n```html\n<tr align=\"水平对齐方式\"><tr>\n```\n#### 垂直对齐\n```html\n<tr valign=\"垂直对齐方式\"><tr>\n```\n### 表格的的背景\n#### 背景颜色\n```html\n<tr bgcolor=\"颜色值\"><tr>\n```\n#### 背景图片\n```html\n<table background=\"图片地址\"></table>\n```\n\n### 单元格格式\n```html\n<td width=\"单元格宽度\" height=\"单元格高度\">单元格内容</td>\n```\n### 合并单元格\n- colspan合并的是行相邻的单元格\n- rowspan合并的是列相邻的单元格\n\n```html\n<table>\n<tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</table>\n```\n\n<table>\n<tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</table>\n\n### 无序列表\n```html\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n```\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n\n```html\n<ul type=\"符号类型\"></ul>\n```\n\n|参数值|含义|\n|-----|-----|\n|disc|实心圆形|\n|circle|空心圆形|\n|square|实心方形|\n\n```html\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n```\n\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n\n同时也可以给每一个无序列表的选项进行符号类型的选择：\n\n```html\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n```\n\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n\n### 有序列表\n```html\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n```\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n\n也可以自定义起始值和序号类型\n```html\n<ol start=起始数值 type=\"序号类型\"></ol>\n```\n{%note info %}\n无论数字还是字母等类型，起始值只能是数字！\n{%endnote %}\n\n### 创建超链接\n\n#### 内部链接\n\n```html\n<a href=\"链接地址\" target=\"目标窗口的打开方式\">链接文字</a>\n```\n| `target`属性值 | 打开方式 |\n|----------|-----------|\n|`_self`|在当前窗口打开|\n|`_blank`|在新窗口打开|\n|`_parent`|在父窗口打开|\n|`_top`|在顶层窗口打开|\n\n\n#### 外部链接\n\n```html\n<a href=\"http://...\">...</a>\n```\n至此，你已经学会了有关静态网页HTML的语法，可以尝试使用HTML完成个人博客的简单撰写！\n\n## 表单\nHTML 表单用于收集用户的输入信息，当我们需要与用户进行交互，制作动态网页时，就需要使用到表单！\n```html\n<form name=\"test\" action=\"mail:08241120@cumt.edu.cn\" method=\"post\" target=\"_blank\">\n</form>\n```\n{%note info %}\n- 处理动作`action`：定义表单要提交的地址，也就是表单中收集到的资料将要传递的程序地址\n  \n  - 绝对地址\n  - 相对地址\n  - E-mail地址等\n- 表单名称`name`：定义表单的名称，这个名称将作为表单的标识符，用于提交表单时使用\n- 传送方式`method`：定义表单中数据的传送方式\n\n  - `get`：用户端直接发送给服务器，速度快，但数据长度不能太长\n  - `post`：用户端计算机通知服务器来读取数据，数据长度没有限制，但速度较慢\n- 目标显示方式`target`：定义表单提交后，结果显示在哪个窗口中（相关参数见上文）\n\n{%endnote %}\n\n### `input`标签\n```html\n<form>\n    <input name=\"空间名称\" type=\"控件类型\"/>\n</form>\n```\n|`type`取值 |含义|\n|----|----|\n|`text`|文本字段|\n|`password`|密码字段|\n|`radio`|单选按钮|\n|`checkbox`|复选框|\n|`button`|普通按钮|\n|`submit`|提交按钮|\n|`reset`|重置按钮|\n\n#### 文字字段`text`\n```html\n     <input name=\"控件名称\" type=\"text\" value=\"字段默认值\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n{%note warning %}\n- `name`：文字字段名称，用来与其他控件进行区分\n- `size`：文本框的显示长度\n- `maxlength`：文本框中最多可输入的文字数\n- `value`：文本框中的默认值\n{%endnote%}\n\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n\n```html\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n```\n\n#### 密码域`password`\n\n输入到密码域的文字内容都以“*”或者圆点显示。\n```html\n     <input name=\"控件名称\" type=\"password\" value=\"字段默认值\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n\n```html\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n```\n虽然密码域的输入字符已经以掩码的形式显示了，但是没有做到**真正的保密**，因为用户可以通过复制改密码没中的内容并粘贴到其它文档中，查看到密码的“真面目”。为了实现密码的真正安全，可以将密码域的**复制功能屏蔽**，同时**改变密码域的掩码字符**！\n\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n\n```html\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n```\n\n#### 复选框`checkbox`\n```html\n     <input name=\"复选框名称\" type=\"checkbox\" value=\"复选框的值\" checked=\"checked/>\n```\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n确保所有相关复选框有相同的name属性，这样才能将选中的复选框值一起提交。\n```html\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n```\n\n\n#### 表单按钮`button`\n```html\n<input name=\"按钮名称\" type=\"button\" value=\"按钮的值\" onclick=\"处理程序\">\n```\n\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n\n```html\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n```\n\n#### 提交按钮`submit`\n```html\n<input name=\"按钮名称\" type=\"submit\" value=\"按钮的值\">\n```\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n```html\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n```\n\n#### 重置按钮`reset`\n用来清楚用户在页面上输入的信息\n```html\n<input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n```\n\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n\n```html\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n```\n#### 文件域`file`\n用于在表单中添加图片或者文件\n```html\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n```\n\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n\n```html\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n```\n\n#### 文本域`textarea`\n```html\n<textarea name=\"名称\"cols=\"列数\" rows=\"行数\" value=\"文本默认值\">文本内容</textarea>\n```\n\n<form>\n<textarea name=\"名称\"cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n\n```html\n<form>\n<textarea name=\"名称\"cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n```\n### `label`表单定义标签\n{%note info %}\n- 显式关联：将文本和表单控件一起放在`label`标签内\n- 隐式关联：将`label`标签的`for`属性与表单控件的`id`属性关联起来\n{%endnote%}\n\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\"/>\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\"/>\n</form>\n\n\n```html\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\"/>\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\"/>\n</form>\n```\n\n这样我们就将**文本内容与控件关联起来**，当点击表单控件前文字时，该表单控件就可以被选中。\n\n#### 列表表单\n```html\n<select mutiple size=\"可见选项数\">\n<option value=\"值\" selected=\"seclected\"></option>\n</select>\n```\n\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n\n```html\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n```\n\n封面来源：[HTML & CSS for Beginners | FREE MEGA COURSE (7+ Hours!)](https://www.youtube.com/watch?v=iG2jotQo9NI&t=2120s)","slug":"Full-Stack/Html","published":1,"updated":"2025-08-23T07:32:05.791Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcp001440w3950k4nbk","content":"<div class=\"note note-info\">\n            <p>或许我现在才深刻认识到计算机是一门实践的学科还不算太晚，上学期我抱着书将HTML和CSS啃完，看似语法从“入门”到“精通”，但没有项目进行实战，导致记忆并不深刻，仅仅“<strong>纸上得来终觉浅</strong>” ，遂现在以一个案例进行引入，学习（亦或是复习）HTML和CSS的语法！</p>\n          </div>\n<p>进阶速通版本参看 <a href=\"https://doc.duke486.com/\">Web-Dev-Beginner - Quick start to front &amp; back-end Dev</a></p>\n<h2 id=\"What-is-HTML？\">What is HTML？</h2>\n<p>HTML(Hyper Text Markup Language)是<strong>超文本编辑语言</strong>，与我们平时学习的c++、python等编程语言，它是一种标记语言，可以理解为markdown语法的进阶，毕竟我们博客撰写的markdown最后都是通过渲染为HTML展示在用户面前的，其由一套标记标签组成，大多数标签<strong>由一对尖括号包裹</strong>，他们定义了网页中每个元素的作用和显示方式，像是这样：<code>&lt;标签名&gt;文本内容&lt;/标签名&gt;</code>，这种形式的叫做<strong>双标签</strong>，标签内的内容会被浏览器渲染。比如：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>这是一个段落<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>有些标签是单独存在的，不需要结束标签，这些叫做<strong>自闭和标签</strong>，例如：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">sre</span>=<span class=\"hljs-string\">\"image.jpg\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"描述\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"HTML-basic-structure\">HTML basic structure</h2>\n<p>在vscode中输入<code>!</code>，在按下<code>Tab</code>，会自动补全HTML的基本结构：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ol>\n<li>开始标签<code>&lt;html&gt;</code>：限定了文档的开始和结束点</li>\n<li>头部标签<code>&lt;head&gt;</code>：描述文档的各种属性和信息</li>\n<li>标题标签<code>&lt;title&gt;</code>：定义文档标题，通常会直接显示在浏览器窗口的标题栏或状态栏上，当用户将网页收藏或作为书签时，标题将成为文档链接的默认名称</li>\n<li>主题标签<code>&lt;body&gt;</code>：包含文档所有内容，后续我们主要的HTML代码也在这里编写</li>\n<li>元信息标签<code>&lt;meta&gt;</code>：提供有关页面的信息，其永远位于head元素内部</li>\n<li><code>&lt;!DOCTYPE&gt;</code>标签:必须位于HTML文档第一行，没有结束标签，且不区分大小写</li>\n</ol>\n<h2 id=\"HTML基本语法\">HTML基本语法</h2>\n<h3 id=\"标题文字\">标题文字</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>一级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>二级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>三级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>四级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span>&gt;</span>五级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h6</span>&gt;</span>六级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h6</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n<div class=\"note note-primary\">\n            <p>看上去与markdown中的<code>#</code>效果差不多</p>\n          </div>\n<div class=\"note note-danger\">\n            <p>不要为了使文字加粗而使用h标签，文字加粗使用b标签<br>这里标题会在目录形成<strong>树形结构</strong>！</p>\n          </div>\n<h3 id=\"文字对齐\">文字对齐</h3>\n<p>网页中都是使用<strong>默认的对齐方式</strong>，但当我们需要其他的对齐方式时就需要使用<code>align</code>属性进行设置</p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>left</td>\n<td>左对齐（默认）</td>\n</tr>\n<tr>\n<td>center</td>\n<td>居中对齐</td>\n</tr>\n<tr>\n<td>right</td>\n<td>右对齐</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">align=\"对齐方式\"<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>这是一个居中的一级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n<h3 id=\"文字样式\">文字样式</h3>\n<p>在HTML中，字体效果必须在浏览器安装相应字体后才能浏览，否则还是会被浏览器中的通用字体所替代。</p>\n<table>\n<thead>\n<tr>\n<th>字体名称</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>微软雅黑</strong></td>\n<td>中文网页/UI设计首选字体</td>\n</tr>\n<tr>\n<td><strong>黑体</strong></td>\n<td>中文标题/广告宣传</td>\n</tr>\n<tr>\n<td><strong>宋体</strong></td>\n<td>中文印刷/正式文档</td>\n</tr>\n<tr>\n<td><strong>楷体</strong></td>\n<td>中文手写风格/艺术排版</td>\n</tr>\n<tr>\n<td><strong>仿宋</strong></td>\n<td>中文公文/古籍排版</td>\n</tr>\n<tr>\n<td><strong>Georgia</strong></td>\n<td>标题、优雅排版</td>\n</tr>\n<tr>\n<td><strong>Times New Roman</strong></td>\n<td>印刷品、正式文档</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">\"Simsun\"</span>&gt;</span>应用了宋体文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p><font face=\"Simsun\">应用了宋体文字</font></p>\n<h3 id=\"段落换行\">段落换行</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>此处换行<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>It's been a long day without you, my friend.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>And I'll tell you all about it when I see you again.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>We've come a long way from where we began.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>Oh I'll tell you all about it when I see you again<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again.</p>\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again.</p>\n<p>——《See You Again》</p>\n<h3 id=\"字体颜色\">字体颜色</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"颜色参数\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>颜色参数值有多种表达形式：</p>\n<h4 id=\"1-颜色关键字\">1. 颜色关键字</h4>\n<p>直接使用预定义的颜色名称（不区分大小写）：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: red;\"</span>&gt;</span>红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: blue;\"</span>&gt;</span>蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: green;\"</span>&gt;</span>绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: orange;\"</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: purple;\"</span>&gt;</span>紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: gray;\"</span>&gt;</span>灰色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: black;\"</span>&gt;</span>黑色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n<h4 id=\"2-十六进制（HEX）\">2. 十六进制（HEX）</h4>\n<p>格式：#RRGGBB 或 #RGB（简写）</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #FF0000;\"</span>&gt;</span>红色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #00FF00;\"</span>&gt;</span>绿色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #0000FF;\"</span>&gt;</span>蓝色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #F00;\"</span>&gt;</span>红色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #0F0;\"</span>&gt;</span>绿色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #00F;\"</span>&gt;</span>蓝色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #FFA500;\"</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: #800080;\"</span>&gt;</span>紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n<h4 id=\"3-RGB-RGBA\">3. RGB/RGBA</h4>\n<p>格式：rgb(R, G, B) 或 rgba(R, G, B, A)（带透明度）</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgb(255, 0, 0);\"</span>&gt;</span>红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgb(0, 255, 0);\"</span>&gt;</span>绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgb(0, 0, 255);\"</span>&gt;</span>蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgba(255, 0, 0, 0.5);\"</span>&gt;</span>半透明红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgba(0, 255, 0, 0.3);\"</span>&gt;</span>30%透明绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgba(0, 0, 255, 0.7);\"</span>&gt;</span>70%透明蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgb(255, 165, 0);\"</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"color: rgba(128, 0, 128, 0.6);\"</span>&gt;</span>60%透明紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n<h3 id=\"文字的上下标\">文字的上下标</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>上标标签<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>下标标签<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>+x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>+x+1=0<br>x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>+x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>+x+1=0<br></code></pre></td></tr></tbody></table></figure>\n<p>x<sup>3</sup>+x<sup>2</sup>+x+1=0<br>\nx<sub>3</sub>+x<sub>2</sub>+x+1=0</p>\n<h3 id=\"文字的删除线\">文字的删除线</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">strike</span>&gt;</span>删除的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">strike</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strike>删除的文字</strike></p>\n<h3 id=\"文字加粗\">文字加粗</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>需要加粗的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">br</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>需要加粗的文字</strong></p>\n<h3 id=\"给网页添加图片\">给网页添加图片</h3>\n<h4 id=\"图片格式\">图片格式</h4>\n<p>网页中的图像格式通常有三种，即GIF、JPEG、PNG，目前前两者的支持情况最佳，多数浏览器都可以兼容，而PNG格式的图片属于无损压缩，其清晰度更高，且支持图片保留透明度，因而其所占存储空间对比GIF和JPEG稍大。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"图片文件地址\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>src可以是绝对路径，也可以是相对路径，也可以是图片的网络链接地址</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<img src=\"/banner_img/background.jpg\">\n<h4 id=\"图片大小\">图片大小</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"图片文件地址\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"图片的宽度\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"图片的高度\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight routeros\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&lt;img <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span> <span class=\"hljs-attribute\">width</span>=<span class=\"hljs-string\">\"500px\"</span> <span class=\"hljs-attribute\">height</span>=<span class=\"hljs-string\">\"300px\"</span>&gt;<br></code></pre></td></tr></tbody></table></figure>\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n<h4 id=\"水平间距\">水平间距</h4>\n<p>如果不进行换行，那么添加得到图像会紧跟在文字后面，也可以用来设置图片间间距效果</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"图片文件地址\"</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">\"水平间距\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"70px\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"40px\"</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">\"30px\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"70px\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"40px\"</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">\"30px\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"70px\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"40px\"</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">\"30px\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<h4 id=\"提示文字\">提示文字</h4>\n<p>当指针放在图片上面时会有提示文字</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"图片文件地址\"</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"提示文字\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"/banner_img/background.jpg\"</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"background\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n<h3 id=\"创建表格\">创建表格</h3>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;table&gt;&lt;/table&gt;</code></td>\n<td>表格标记</td>\n</tr>\n<tr>\n<td><code>&lt;tr&gt;&lt;/tr&gt;</code></td>\n<td>行标记</td>\n</tr>\n<tr>\n<td><code>&lt;td&gt;&lt;/td&gt;</code></td>\n<td>单元格标记</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>姓名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>学号<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>成绩<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>张三<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>123456<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>90<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>李四<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>654321<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>85<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p><code>&lt;th&gt;&lt;/th&gt;</code>为表格文字加粗</p>\n<table>\n<tbody><tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>08241110</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>08241120</td>\n    <td>95</td>\n</tr>\n</tbody></table>\n<h3 id=\"行的的背景\">行的的背景</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">\"颜色值\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"表格的对齐方式\">表格的对齐方式</h3>\n<h4 id=\"水平对齐\">水平对齐</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"水平对齐方式\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"垂直对齐\">垂直对齐</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">valign</span>=<span class=\"hljs-string\">\"垂直对齐方式\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"表格的的背景\">表格的的背景</h3>\n<h4 id=\"背景颜色\">背景颜色</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">\"颜色值\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"背景图片\">背景图片</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">background</span>=<span class=\"hljs-string\">\"图片地址\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"单元格格式\">单元格格式</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"单元格宽度\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"单元格高度\"</span>&gt;</span>单元格内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"合并单元格\">合并单元格</h3>\n<ul>\n<li>colspan合并的是行相邻的单元格</li>\n<li>rowspan合并的是列相邻的单元格</li>\n</ul>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期二<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期四<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期五<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">rowspan</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>语文<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>数学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>英语<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>化学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">colspan</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">\"center\"</span>&gt;</span>课间活动<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>化学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>政治<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>政治<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>历史<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>地理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<tbody><tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</tbody></table>\n<h3 id=\"无序列表\">无序列表</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"符号类型\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>disc</td>\n<td>实心圆形</td>\n</tr>\n<tr>\n<td>circle</td>\n<td>空心圆形</td>\n</tr>\n<tr>\n<td>square</td>\n<td>实心方形</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"circle\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>无序列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>有序列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>定义列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n<p>同时也可以给每一个无序列表的选项进行符号类型的选择：</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"disc\"</span>&gt;</span>实心列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"circle\"</span>&gt;</span>空心列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"square\"</span>&gt;</span>方形列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n<h3 id=\"有序列表\">有序列表</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ol</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ol</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n<p>也可以自定义起始值和序号类型</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ol</span> <span class=\"hljs-attr\">start</span>=<span class=\"hljs-string\">起始数值</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"序号类型\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ol</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <p>无论数字还是字母等类型，起始值只能是数字！</p>\n          </div>\n<h3 id=\"创建超链接\">创建超链接</h3>\n<h4 id=\"内部链接\">内部链接</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"链接地址\"</span> <span class=\"hljs-attr\">target</span>=<span class=\"hljs-string\">\"目标窗口的打开方式\"</span>&gt;</span>链接文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th><code>target</code>属性值</th>\n<th>打开方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_self</code></td>\n<td>在当前窗口打开</td>\n</tr>\n<tr>\n<td><code>_blank</code></td>\n<td>在新窗口打开</td>\n</tr>\n<tr>\n<td><code>_parent</code></td>\n<td>在父窗口打开</td>\n</tr>\n<tr>\n<td><code>_top</code></td>\n<td>在顶层窗口打开</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"外部链接\">外部链接</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"http://...\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>至此，你已经学会了有关静态网页HTML的语法，可以尝试使用HTML完成个人博客的简单撰写！</p>\n<h2 id=\"表单\">表单</h2>\n<p>HTML 表单用于收集用户的输入信息，当我们需要与用户进行交互，制作动态网页时，就需要使用到表单！</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"test\"</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"mail:08241120@cumt.edu.cn\"</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span> <span class=\"hljs-attr\">target</span>=<span class=\"hljs-string\">\"_blank\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <ul><li><p>处理动作<code>action</code>：定义表单要提交的地址，也就是表单中收集到的资料将要传递的程序地址</p><ul><li>绝对地址</li><li>相对地址</li><li>E-mail地址等</li></ul></li><li><p>表单名称<code>name</code>：定义表单的名称，这个名称将作为表单的标识符，用于提交表单时使用</p></li><li><p>传送方式<code>method</code>：定义表单中数据的传送方式</p><ul><li><code>get</code>：用户端直接发送给服务器，速度快，但数据长度不能太长</li><li><code>post</code>：用户端计算机通知服务器来读取数据，数据长度没有限制，但速度较慢</li></ul></li><li><p>目标显示方式<code>target</code>：定义表单提交后，结果显示在哪个窗口中（相关参数见上文）</p></li></ul>\n          </div>\n<h3 id=\"input标签\"><code>input</code>标签</h3>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"空间名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"控件类型\"</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th><code>type</code>取值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>text</code></td>\n<td>文本字段</td>\n</tr>\n<tr>\n<td><code>password</code></td>\n<td>密码字段</td>\n</tr>\n<tr>\n<td><code>radio</code></td>\n<td>单选按钮</td>\n</tr>\n<tr>\n<td><code>checkbox</code></td>\n<td>复选框</td>\n</tr>\n<tr>\n<td><code>button</code></td>\n<td>普通按钮</td>\n</tr>\n<tr>\n<td><code>submit</code></td>\n<td>提交按钮</td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置按钮</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"文字字段text\">文字字段<code>text</code></h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"控件名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"字段默认值\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"控件长度\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"最长字符数\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-warning\">\n            <ul><li><code>name</code>：文字字段名称，用来与其他控件进行区分</li><li><code>size</code>：文本框的显示长度</li><li><code>maxlength</code>：文本框中最多可输入的文字数</li><li><code>value</code>：文本框中的默认值</li></ul>\n          </div>\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"test\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"请输入你的想法\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"15\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"密码域password\">密码域<code>password</code></h4>\n<p>输入到密码域的文字内容都以“*”或者圆点显示。</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"控件名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"password\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"字段默认值\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"控件长度\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"最长字符数\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"test\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"password\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"请输入你的想法\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"15\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>虽然密码域的输入字符已经以掩码的形式显示了，但是没有做到<strong>真正的保密</strong>，因为用户可以通过复制改密码没中的内容并粘贴到其它文档中，查看到密码的“真面目”。为了实现密码的真正安全，可以将密码域的<strong>复制功能屏蔽</strong>，同时<strong>改变密码域的掩码字符</strong>！</p>\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"test\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"password\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"请输入你的想法\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"15\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">oncopy</span>=<span class=\"hljs-string\">\"return false\"</span> <span class=\"hljs-attr\">oncut</span>=<span class=\"hljs-string\">\"return false\"</span> <span class=\"hljs-attr\">onpaste</span>=<span class=\"hljs-string\">\"return false\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"复选框checkbox\">复选框<code>checkbox</code></h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"复选框名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"复选框的值\"</span> <span class=\"hljs-attr\">checked</span>=<span class=\"hljs-string\">\"checked/&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked=\"\"> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n确保所有相关复选框有相同的name属性，这样才能将选中的复选框值一起提交。\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"colors\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"red\"</span> <span class=\"hljs-attr\">checked</span>&gt;</span> Red<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"colors\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"green\"</span>&gt;</span> Green<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"colors\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"blue\"</span>&gt;</span> Blue<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"表单按钮button\">表单按钮<code>button</code></h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"按钮的值\"</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">\"处理程序\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"点击试试\"</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">\"window.close()\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"提交按钮submit\">提交按钮<code>submit</code></h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"按钮的值\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"提交\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"重置按钮reset\">重置按钮<code>reset</code></h4>\n<p>用来清楚用户在页面上输入的信息</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"reset\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"重置\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"按钮名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"reset\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"重置\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"文件域file\">文件域<code>file</code></h4>\n<p>用于在表单中添加图片或者文件</p>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"file\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"控件长度\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"最长字符数\"</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"名称\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"file\"</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"控件长度\"</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">\"最长字符数\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"文本域textarea\">文本域<code>textarea</code></h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"名称\"</span><span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">\"列数\"</span> <span class=\"hljs-attr\">rows</span>=<span class=\"hljs-string\">\"行数\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"文本默认值\"</span>&gt;</span>文本内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n<textarea name=\"名称\" cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"名称\"</span><span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">\"40\"</span> <span class=\"hljs-attr\">rows</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>文本内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"label表单定义标签\"><code>label</code>表单定义标签</h3>\n<div class=\"note note-info\">\n            <ul><li>显式关联：将文本和表单控件一起放在<code>label</code>标签内</li><li>隐式关联：将<code>label</code>标签的<code>for</code>属性与表单控件的<code>id</code>属性关联起来</li></ul>\n          </div>\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\">\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\">\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"male\"</span>&gt;</span>姓名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sex\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"male\"</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"female\"</span>&gt;</span>密码<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"sex\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"female\"</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>这样我们就将<strong>文本内容与控件关联起来</strong>，当点击表单控件前文字时，该表单控件就可以被选中。</p>\n<h4 id=\"列表表单\">列表表单</h4>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">mutiple</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"可见选项数\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"值\"</span> <span class=\"hljs-attr\">selected</span>=<span class=\"hljs-string\">\"seclected\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple=\"\" size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"list1\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"美食小吃\"</span>&gt;</span>美食小吃<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"火锅\"</span>&gt;</span>火锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"麻辣烫\"</span>&gt;</span>麻辣烫<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"砂锅\"</span>&gt;</span>砂锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"list1\"</span> <span class=\"hljs-attr\">mutiple</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">\"4\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"美食小吃\"</span>&gt;</span>美食小吃<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"火锅\"</span>&gt;</span>火锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"麻辣烫\"</span>&gt;</span>麻辣烫<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"砂锅\"</span>&gt;</span>砂锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=iG2jotQo9NI&amp;t=2120s\">HTML &amp; CSS for Beginners | FREE MEGA COURSE (7+ Hours!)</a></p>\n","excerpt":"","more":"<div class=\"note note-info\">\n            <p>或许我现在才深刻认识到计算机是一门实践的学科还不算太晚，上学期我抱着书将HTML和CSS啃完，看似语法从“入门”到“精通”，但没有项目进行实战，导致记忆并不深刻，仅仅“<strong>纸上得来终觉浅</strong>” ，遂现在以一个案例进行引入，学习（亦或是复习）HTML和CSS的语法！</p>\n          </div>\n<p>进阶速通版本参看 <a href=\"https://doc.duke486.com/\">Web-Dev-Beginner - Quick start to front &amp; back-end Dev</a></p>\n<h2 id=\"What-is-HTML？\">What is HTML？</h2>\n<p>HTML(Hyper Text Markup Language)是<strong>超文本编辑语言</strong>，与我们平时学习的c++、python等编程语言，它是一种标记语言，可以理解为markdown语法的进阶，毕竟我们博客撰写的markdown最后都是通过渲染为HTML展示在用户面前的，其由一套标记标签组成，大多数标签<strong>由一对尖括号包裹</strong>，他们定义了网页中每个元素的作用和显示方式，像是这样：<code>&lt;标签名&gt;文本内容&lt;/标签名&gt;</code>，这种形式的叫做<strong>双标签</strong>，标签内的内容会被浏览器渲染。比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>这是一个段落<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>有些标签是单独存在的，不需要结束标签，这些叫做<strong>自闭和标签</strong>，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">sre</span>=<span class=\"hljs-string\">&quot;image.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;描述&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"HTML-basic-structure\">HTML basic structure</h2>\n<p>在vscode中输入<code>!</code>，在按下<code>Tab</code>，会自动补全HTML的基本结构：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>开始标签<code>&lt;html&gt;</code>：限定了文档的开始和结束点</li>\n<li>头部标签<code>&lt;head&gt;</code>：描述文档的各种属性和信息</li>\n<li>标题标签<code>&lt;title&gt;</code>：定义文档标题，通常会直接显示在浏览器窗口的标题栏或状态栏上，当用户将网页收藏或作为书签时，标题将成为文档链接的默认名称</li>\n<li>主题标签<code>&lt;body&gt;</code>：包含文档所有内容，后续我们主要的HTML代码也在这里编写</li>\n<li>元信息标签<code>&lt;meta&gt;</code>：提供有关页面的信息，其永远位于head元素内部</li>\n<li><code>&lt;!DOCTYPE&gt;</code>标签:必须位于HTML文档第一行，没有结束标签，且不区分大小写</li>\n</ol>\n<h2 id=\"HTML基本语法\">HTML基本语法</h2>\n<h3 id=\"标题文字\">标题文字</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>一级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>二级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>三级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>四级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span>&gt;</span>五级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h6</span>&gt;</span>六级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h6</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n<h4>四级标题</h4>\n<h5>五级标题</h5>\n<h6>六级标题</h6>\n<div class=\"note note-primary\">\n            <p>看上去与markdown中的<code>#</code>效果差不多</p>\n          </div>\n<div class=\"note note-danger\">\n            <p>不要为了使文字加粗而使用h标签，文字加粗使用b标签<br>这里标题会在目录形成<strong>树形结构</strong>！</p>\n          </div>\n<h3 id=\"文字对齐\">文字对齐</h3>\n<p>网页中都是使用<strong>默认的对齐方式</strong>，但当我们需要其他的对齐方式时就需要使用<code>align</code>属性进行设置</p>\n<table>\n<thead>\n<tr>\n<th>属性值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>left</td>\n<td>左对齐（默认）</td>\n</tr>\n<tr>\n<td>center</td>\n<td>居中对齐</td>\n</tr>\n<tr>\n<td>right</td>\n<td>右对齐</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">align=&quot;对齐方式&quot;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">&quot;center&quot;</span>&gt;</span>这是一个居中的一级标题<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h1 align=\"center\">这是一个居中的一级标题</h1>\n<h3 id=\"文字样式\">文字样式</h3>\n<p>在HTML中，字体效果必须在浏览器安装相应字体后才能浏览，否则还是会被浏览器中的通用字体所替代。</p>\n<table>\n<thead>\n<tr>\n<th>字体名称</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>微软雅黑</strong></td>\n<td>中文网页/UI设计首选字体</td>\n</tr>\n<tr>\n<td><strong>黑体</strong></td>\n<td>中文标题/广告宣传</td>\n</tr>\n<tr>\n<td><strong>宋体</strong></td>\n<td>中文印刷/正式文档</td>\n</tr>\n<tr>\n<td><strong>楷体</strong></td>\n<td>中文手写风格/艺术排版</td>\n</tr>\n<tr>\n<td><strong>仿宋</strong></td>\n<td>中文公文/古籍排版</td>\n</tr>\n<tr>\n<td><strong>Georgia</strong></td>\n<td>标题、优雅排版</td>\n</tr>\n<tr>\n<td><strong>Times New Roman</strong></td>\n<td>印刷品、正式文档</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">&quot;Simsun&quot;</span>&gt;</span>应用了宋体文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><font face=\"Simsun\">应用了宋体文字</font></p>\n<h3 id=\"段落换行\">段落换行</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>此处换行<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>It&#x27;s been a long day without you, my friend.And I&#x27;ll tell you all about it when I see you again.We&#x27;ve come a long way from where we began.Oh I&#x27;ll tell you all about it when I see you again<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>It&#x27;s been a long day without you, my friend.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>And I&#x27;ll tell you all about it when I see you again.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>We&#x27;ve come a long way from where we began.<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>Oh I&#x27;ll tell you all about it when I see you again<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>It's been a long day without you, my friend.And I'll tell you all about it when I see you again.We've come a long way from where we began.Oh I'll tell you all about it when I see you again.</p>\n<p>It's been a long day without you, my friend.<br>And I'll tell you all about it when I see you again.<br>We've come a long way from where we began.<br>Oh I'll tell you all about it when I see you again.</p>\n<p>——《See You Again》</p>\n<h3 id=\"字体颜色\">字体颜色</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">&quot;颜色参数&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>颜色参数值有多种表达形式：</p>\n<h4 id=\"1-颜色关键字\">1. 颜色关键字</h4>\n<p>直接使用预定义的颜色名称（不区分大小写）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: red;&quot;</span>&gt;</span>红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: blue;&quot;</span>&gt;</span>蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: green;&quot;</span>&gt;</span>绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: orange;&quot;</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: purple;&quot;</span>&gt;</span>紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: gray;&quot;</span>&gt;</span>灰色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: black;&quot;</span>&gt;</span>黑色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p style=\"color: red;\">红色</p>\n<p style=\"color: blue;\">蓝色</p>\n<p style=\"color: green;\">绿色</p>\n<p style=\"color: orange;\">橙色</p>\n<p style=\"color: purple;\">紫色</p>\n<p style=\"color: gray;\">灰色</p>\n<p style=\"color: black;\">黑色</p>\n<h4 id=\"2-十六进制（HEX）\">2. 十六进制（HEX）</h4>\n<p>格式：#RRGGBB 或 #RGB（简写）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #FF0000;&quot;</span>&gt;</span>红色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #00FF00;&quot;</span>&gt;</span>绿色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #0000FF;&quot;</span>&gt;</span>蓝色（完整）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #F00;&quot;</span>&gt;</span>红色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #0F0;&quot;</span>&gt;</span>绿色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #00F;&quot;</span>&gt;</span>蓝色（简写）<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #FFA500;&quot;</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: #800080;&quot;</span>&gt;</span>紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p style=\"color: #FF0000;\">红色（完整）</p>\n<p style=\"color: #00FF00;\">绿色（完整）</p>\n<p style=\"color: #0000FF;\">蓝色（完整）</p>\n<p style=\"color: #F00;\">红色（简写）</p>\n<p style=\"color: #0F0;\">绿色（简写）</p>\n<p style=\"color: #00F;\">蓝色（简写）</p>\n<p style=\"color: #FFA500;\">橙色</p>\n<p style=\"color: #800080;\">紫色</p>\n<h4 id=\"3-RGB-RGBA\">3. RGB/RGBA</h4>\n<p>格式：rgb(R, G, B) 或 rgba(R, G, B, A)（带透明度）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgb(255, 0, 0);&quot;</span>&gt;</span>红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgb(0, 255, 0);&quot;</span>&gt;</span>绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgb(0, 0, 255);&quot;</span>&gt;</span>蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgba(255, 0, 0, 0.5);&quot;</span>&gt;</span>半透明红色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgba(0, 255, 0, 0.3);&quot;</span>&gt;</span>30%透明绿色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgba(0, 0, 255, 0.7);&quot;</span>&gt;</span>70%透明蓝色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgb(255, 165, 0);&quot;</span>&gt;</span>橙色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;color: rgba(128, 0, 128, 0.6);&quot;</span>&gt;</span>60%透明紫色<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p style=\"color: rgb(255, 0, 0);\">红色</p>\n<p style=\"color: rgb(0, 255, 0);\">绿色</p>\n<p style=\"color: rgb(0, 0, 255);\">蓝色</p>\n<p style=\"color: rgba(255, 0, 0, 0.5);\">半透明红色</p>\n<p style=\"color: rgba(0, 255, 0, 0.3);\">30%透明绿色</p>\n<p style=\"color: rgba(0, 0, 255, 0.7);\">70%透明蓝色</p>\n<p style=\"color: rgb(255, 165, 0);\">橙色</p>\n<p style=\"color: rgba(128, 0, 128, 0.6);\">60%透明紫色</p>\n<h3 id=\"文字的上下标\">文字的上下标</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>上标标签<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>下标标签<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>+x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sup</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sup</span>&gt;</span>+x+1=0<br>x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span>3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>+x<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sub</span>&gt;</span>2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sub</span>&gt;</span>+x+1=0<br></code></pre></td></tr></table></figure>\n<p>x<sup>3</sup>+x<sup>2</sup>+x+1=0<br>\nx<sub>3</sub>+x<sub>2</sub>+x+1=0</p>\n<h3 id=\"文字的删除线\">文字的删除线</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">strike</span>&gt;</span>删除的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">strike</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strike>删除的文字</strike></p>\n<h3 id=\"文字加粗\">文字加粗</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>需要加粗的文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">br</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><strong>需要加粗的文字</strong></p>\n<h3 id=\"给网页添加图片\">给网页添加图片</h3>\n<h4 id=\"图片格式\">图片格式</h4>\n<p>网页中的图像格式通常有三种，即GIF、JPEG、PNG，目前前两者的支持情况最佳，多数浏览器都可以兼容，而PNG格式的图片属于无损压缩，其清晰度更高，且支持图片保留透明度，因而其所占存储空间对比GIF和JPEG稍大。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;图片文件地址&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>src可以是绝对路径，也可以是相对路径，也可以是图片的网络链接地址</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<img src=\"/banner_img/background.jpg\">\n<h4 id=\"图片大小\">图片大小</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;图片文件地址&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;图片的宽度&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;图片的高度&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">&lt;img <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span> <span class=\"hljs-attribute\">width</span>=<span class=\"hljs-string\">&quot;500px&quot;</span> <span class=\"hljs-attribute\">height</span>=<span class=\"hljs-string\">&quot;300px&quot;</span>&gt;<br></code></pre></td></tr></table></figure>\n<img src=\"/banner_img/background.jpg\" width=\"500px\" height=\"300px\">\n<h4 id=\"水平间距\">水平间距</h4>\n<p>如果不进行换行，那么添加得到图像会紧跟在文字后面，也可以用来设置图片间间距效果</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;图片文件地址&quot;</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">&quot;水平间距&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;70px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;40px&quot;</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">&quot;30px&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;70px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;40px&quot;</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">&quot;30px&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;70px&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;40px&quot;</span> <span class=\"hljs-attr\">hspace</span>=<span class=\"hljs-string\">&quot;30px&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<img src=\"/banner_img/background.jpg\" width=\"100px\" height=\"60px\" hspace=\"30px\">\n<h4 id=\"提示文字\">提示文字</h4>\n<p>当指针放在图片上面时会有提示文字</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;图片文件地址&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;提示文字&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;/banner_img/background.jpg&quot;</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">&quot;background&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<img src=\"/banner_img/background.jpg\" title=\"background\">\n<h3 id=\"创建表格\">创建表格</h3>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;table&gt;&lt;/table&gt;</code></td>\n<td>表格标记</td>\n</tr>\n<tr>\n<td><code>&lt;tr&gt;&lt;/tr&gt;</code></td>\n<td>行标记</td>\n</tr>\n<tr>\n<td><code>&lt;td&gt;&lt;/td&gt;</code></td>\n<td>单元格标记</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>姓名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>学号<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>成绩<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>张三<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>123456<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>90<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>李四<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>654321<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>85<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p><code>&lt;th&gt;&lt;/th&gt;</code>为表格文字加粗</p>\n<table>\n<tr>\n    <th>姓名</th>\n    <th>学号</th>\n    <th>成绩</th>\n</tr>\n<tr>\n    <td>张三</td>\n    <td>08241110</td>\n    <td>90</td>\n</tr>\n<tr>\n    <td>李四</td>\n    <td>08241120</td>\n    <td>95</td>\n</tr>\n</table>\n<h3 id=\"行的的背景\">行的的背景</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">&quot;颜色值&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"表格的对齐方式\">表格的对齐方式</h3>\n<h4 id=\"水平对齐\">水平对齐</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">&quot;水平对齐方式&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"垂直对齐\">垂直对齐</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">valign</span>=<span class=\"hljs-string\">&quot;垂直对齐方式&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"表格的的背景\">表格的的背景</h3>\n<h4 id=\"背景颜色\">背景颜色</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">&quot;颜色值&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"背景图片\">背景图片</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">background</span>=<span class=\"hljs-string\">&quot;图片地址&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"单元格格式\">单元格格式</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">&quot;单元格宽度&quot;</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">&quot;单元格高度&quot;</span>&gt;</span>单元格内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"合并单元格\">合并单元格</h3>\n<ul>\n<li>colspan合并的是行相邻的单元格</li>\n<li>rowspan合并的是列相邻的单元格</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期一<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期二<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期四<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>星期五<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">rowspan</span>=<span class=\"hljs-string\">&quot;2&quot;</span>&gt;</span>语文<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>数学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>英语<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>化学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">colspan</span>=<span class=\"hljs-string\">&quot;4&quot;</span> <span class=\"hljs-attr\">align</span>=<span class=\"hljs-string\">&quot;center&quot;</span>&gt;</span>课间活动<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>物理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>化学<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>政治<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>政治<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>历史<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>地理<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>生物<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<table>\n<tr>\n<th>星期一</th>\n<th>星期二</th>\n<th>星期四</th>\n<th>星期五</th>\n</tr>\n<tr>\n    <td rowspan=\"2\">语文</td>\n    <td>数学</td>\n    <td>英语</td>\n    <td>物理</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n</tr>\n<tr>\n<td colspan=\"4\" align=\"center\">课间活动</td>\n</tr>\n<tr>\n    <td>物理</td>\n    <td>化学</td>\n    <td>生物</td>\n    <td>政治</td>\n</tr>\n<tr>\n    <td>政治</td>\n    <td>历史</td>\n    <td>地理</td>\n    <td>生物</td>\n</tr>\n</table>\n<h3 id=\"无序列表\">无序列表</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;符号类型&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>disc</td>\n<td>实心圆形</td>\n</tr>\n<tr>\n<td>circle</td>\n<td>空心圆形</td>\n</tr>\n<tr>\n<td>square</td>\n<td>实心方形</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;circle&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>无序列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>有序列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>定义列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ul type=\"circle\">\n    <li>无序列表</li>\n    <li>有序列表</li>\n    <li>定义列表</li>\n</ul>\n<p>同时也可以给每一个无序列表的选项进行符号类型的选择：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>    <br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;disc&quot;</span>&gt;</span>实心列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;circle&quot;</span>&gt;</span>空心列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;square&quot;</span>&gt;</span>方形列表<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ul>    \n    <li type=\"disc\">实心列表</li>\n    <li type=\"circle\">空心列表</li>\n    <li type=\"square\">方形列表</li>\n</ul>\n<h3 id=\"有序列表\">有序列表</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ol</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>列表项目3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ol>\n<li>列表项目1</li>\n<li>列表项目2</li>\n<li>列表项目3</li>\n</ol>\n<p>也可以自定义起始值和序号类型</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ol</span> <span class=\"hljs-attr\">start</span>=<span class=\"hljs-string\">起始数值</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;序号类型&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <p>无论数字还是字母等类型，起始值只能是数字！</p>\n          </div>\n<h3 id=\"创建超链接\">创建超链接</h3>\n<h4 id=\"内部链接\">内部链接</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;链接地址&quot;</span> <span class=\"hljs-attr\">target</span>=<span class=\"hljs-string\">&quot;目标窗口的打开方式&quot;</span>&gt;</span>链接文字<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th><code>target</code>属性值</th>\n<th>打开方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>_self</code></td>\n<td>在当前窗口打开</td>\n</tr>\n<tr>\n<td><code>_blank</code></td>\n<td>在新窗口打开</td>\n</tr>\n<tr>\n<td><code>_parent</code></td>\n<td>在父窗口打开</td>\n</tr>\n<tr>\n<td><code>_top</code></td>\n<td>在顶层窗口打开</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"外部链接\">外部链接</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;http://...&quot;</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>至此，你已经学会了有关静态网页HTML的语法，可以尝试使用HTML完成个人博客的简单撰写！</p>\n<h2 id=\"表单\">表单</h2>\n<p>HTML 表单用于收集用户的输入信息，当我们需要与用户进行交互，制作动态网页时，就需要使用到表单！</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;test&quot;</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;mail:08241120@cumt.edu.cn&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">&quot;post&quot;</span> <span class=\"hljs-attr\">target</span>=<span class=\"hljs-string\">&quot;_blank&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <ul><li><p>处理动作<code>action</code>：定义表单要提交的地址，也就是表单中收集到的资料将要传递的程序地址</p><ul><li>绝对地址</li><li>相对地址</li><li>E-mail地址等</li></ul></li><li><p>表单名称<code>name</code>：定义表单的名称，这个名称将作为表单的标识符，用于提交表单时使用</p></li><li><p>传送方式<code>method</code>：定义表单中数据的传送方式</p><ul><li><code>get</code>：用户端直接发送给服务器，速度快，但数据长度不能太长</li><li><code>post</code>：用户端计算机通知服务器来读取数据，数据长度没有限制，但速度较慢</li></ul></li><li><p>目标显示方式<code>target</code>：定义表单提交后，结果显示在哪个窗口中（相关参数见上文）</p></li></ul>\n          </div>\n<h3 id=\"input标签\"><code>input</code>标签</h3>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;空间名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;控件类型&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th><code>type</code>取值</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>text</code></td>\n<td>文本字段</td>\n</tr>\n<tr>\n<td><code>password</code></td>\n<td>密码字段</td>\n</tr>\n<tr>\n<td><code>radio</code></td>\n<td>单选按钮</td>\n</tr>\n<tr>\n<td><code>checkbox</code></td>\n<td>复选框</td>\n</tr>\n<tr>\n<td><code>button</code></td>\n<td>普通按钮</td>\n</tr>\n<tr>\n<td><code>submit</code></td>\n<td>提交按钮</td>\n</tr>\n<tr>\n<td><code>reset</code></td>\n<td>重置按钮</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"文字字段text\">文字字段<code>text</code></h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;控件名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;字段默认值&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;控件长度&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;最长字符数&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<div class=\"note note-warning\">\n            <ul><li><code>name</code>：文字字段名称，用来与其他控件进行区分</li><li><code>size</code>：文本框的显示长度</li><li><code>maxlength</code>：文本框中最多可输入的文字数</li><li><code>value</code>：文本框中的默认值</li></ul>\n          </div>\n<form>\n <input name=\"test\" type=\"text\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;test&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;请输入你的想法&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;15&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;100&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"密码域password\">密码域<code>password</code></h4>\n<p>输入到密码域的文字内容都以“*”或者圆点显示。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;控件名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;字段默认值&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;控件长度&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;最长字符数&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;test&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;请输入你的想法&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;15&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;100&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>虽然密码域的输入字符已经以掩码的形式显示了，但是没有做到<strong>真正的保密</strong>，因为用户可以通过复制改密码没中的内容并粘贴到其它文档中，查看到密码的“真面目”。为了实现密码的真正安全，可以将密码域的<strong>复制功能屏蔽</strong>，同时<strong>改变密码域的掩码字符</strong>！</p>\n<form>\n  <input name=\"test\" type=\"password\" value=\"请输入你的想法\" size=\"15\" maxlength=\"100\" oncopy=\"return false\" oncut=\"return false\" onpaste=\"return false\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;test&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;请输入你的想法&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;15&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;100&quot;</span> <span class=\"hljs-attr\">oncopy</span>=<span class=\"hljs-string\">&quot;return false&quot;</span> <span class=\"hljs-attr\">oncut</span>=<span class=\"hljs-string\">&quot;return false&quot;</span> <span class=\"hljs-attr\">onpaste</span>=<span class=\"hljs-string\">&quot;return false&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"复选框checkbox\">复选框<code>checkbox</code></h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;复选框名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;复选框的值&quot;</span> <span class=\"hljs-attr\">checked</span>=<span class=\"hljs-string\">&quot;checked/&gt;</span></span><br></code></pre></td></tr></table></figure>\n<form>\n  <input type=\"checkbox\" name=\"colors\" value=\"red\" checked> Red<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"green\"> Green<br>\n  <input type=\"checkbox\" name=\"colors\" value=\"blue\"> Blue<br>\n</form>\n确保所有相关复选框有相同的name属性，这样才能将选中的复选框值一起提交。\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colors&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;red&quot;</span> <span class=\"hljs-attr\">checked</span>&gt;</span> Red<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colors&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;green&quot;</span>&gt;</span> Green<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colors&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;blue&quot;</span>&gt;</span> Blue<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"表单按钮button\">表单按钮<code>button</code></h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;按钮的值&quot;</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;处理程序&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n  <input name=\"按钮名称\" type=\"button\" value=\"点击试试\" onclick=\"window.close()\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;button&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;点击试试&quot;</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;window.close()&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"提交按钮submit\">提交按钮<code>submit</code></h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;按钮的值&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n<input name=\"按钮名称\" type=\"submit\" value=\"提交\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;提交&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"重置按钮reset\">重置按钮<code>reset</code></h4>\n<p>用来清楚用户在页面上输入的信息</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;reset&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;重置&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n  <input name=\"按钮名称\" type=\"reset\" value=\"重置\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;按钮名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;reset&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;重置&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"文件域file\">文件域<code>file</code></h4>\n<p>用于在表单中添加图片或者文件</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;file&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;控件长度&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;最长字符数&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n<input name=\"名称\" type=\"file\" size=\"控件长度\" maxlength=\"最长字符数\">\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;名称&quot;</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;file&quot;</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;控件长度&quot;</span> <span class=\"hljs-attr\">maxlength</span>=<span class=\"hljs-string\">&quot;最长字符数&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"文本域textarea\">文本域<code>textarea</code></h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;名称&quot;</span><span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">&quot;列数&quot;</span> <span class=\"hljs-attr\">rows</span>=<span class=\"hljs-string\">&quot;行数&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;文本默认值&quot;</span>&gt;</span>文本内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n<textarea name=\"名称\"cols=\"40\" rows=\"3\">文本内容</textarea>\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;名称&quot;</span><span class=\"hljs-attr\">cols</span>=<span class=\"hljs-string\">&quot;40&quot;</span> <span class=\"hljs-attr\">rows</span>=<span class=\"hljs-string\">&quot;3&quot;</span>&gt;</span>文本内容<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"label表单定义标签\"><code>label</code>表单定义标签</h3>\n<div class=\"note note-info\">\n            <ul><li>显式关联：将文本和表单控件一起放在<code>label</code>标签内</li><li>隐式关联：将<code>label</code>标签的<code>for</code>属性与表单控件的<code>id</code>属性关联起来</li></ul>\n          </div>\n<form>\n    <label for=\"male\">姓名</label>\n    <input type=\"checkbox\" name=\"sex\" id=\"male\"/>\n    <br>\n    <label for=\"female\">密码</label>\n    <input type=\"radio\" name=\"sex\" id=\"female\"/>\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;male&quot;</span>&gt;</span>姓名<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;sex&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;male&quot;</span>/&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;female&quot;</span>&gt;</span>密码<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;radio&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;sex&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;female&quot;</span>/&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>这样我们就将<strong>文本内容与控件关联起来</strong>，当点击表单控件前文字时，该表单控件就可以被选中。</p>\n<h4 id=\"列表表单\">列表表单</h4>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">mutiple</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;可见选项数&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;值&quot;</span> <span class=\"hljs-attr\">selected</span>=<span class=\"hljs-string\">&quot;seclected&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<form>\n  <select name=\"list1\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n </select>\n <select name=\"list1\" mutiple size=\"4\">\n    <option value=\"美食小吃\">美食小吃</option>\n    <option value=\"火锅\">火锅</option>\n    <option value=\"麻辣烫\">麻辣烫</option>\n    <option value=\"砂锅\">砂锅</option>\n</select>\n</form>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;list1&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;美食小吃&quot;</span>&gt;</span>美食小吃<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;火锅&quot;</span>&gt;</span>火锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;麻辣烫&quot;</span>&gt;</span>麻辣烫<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;砂锅&quot;</span>&gt;</span>砂锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;list1&quot;</span> <span class=\"hljs-attr\">mutiple</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">&quot;4&quot;</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;美食小吃&quot;</span>&gt;</span>美食小吃<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;火锅&quot;</span>&gt;</span>火锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;麻辣烫&quot;</span>&gt;</span>麻辣烫<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;砂锅&quot;</span>&gt;</span>砂锅<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=iG2jotQo9NI&amp;t=2120s\">HTML &amp; CSS for Beginners | FREE MEGA COURSE (7+ Hours!)</a></p>\n"},{"title":"JavaScript Tutorial","date":"2025-09-01T13:23:14.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/JavaScript.png?raw=true","category_bar":true,"description":"Mastering the basic syntax of JavaScript, laying the groundwork for subsequent Node.js backend development!","_content":"\n&emsp;&emsp;相信各位读者已经掌握了2~3种编程语言，在此基础上再学习JavaScript并非难事，因此**主要展示大致语法结构**，及JavaScript相比其他语言的“特性”，skip 一些简单的执行流程原理！\n\n## Usage\n与在HTML中引入CSS相同，提供两种方式进行引入：\n\n1. 行内式\n```html\n<script>\n    // 这是JavaScript代码\n</script>\n```\n\n2. 外部式\n```html\n<script src=\"js/script.js\"></script>\n```\n\n{%note info%}\n可以将脚本放置在`<head>`或`<body>`中（建议包含在**后者**中）\n{%endnote%}\n\n{%note danger%}\n外部脚本不能包含`<script>`标签\n{%endnote%}\n\n## Basic Syntax\n- JavaScript 并不强求每个语句以`;`结束，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上`;`，但防止某些情况下会改变程序的语义，导致运行结果与期望不一致，我们建议都在结尾使用`;`！\n\n### 注释\n```javascript\n// 这是单行注释\n```\n\n```javascript\n/*\n这是多行注释\n这是多行注释\n*/\n```\n\n### 输出\n#### 控制台\n\n```javascript\nconsole.log(\"输出一条日志\");//最常用\nconsole.info(\"输出一条信息\");\nconsole.warn(\"输出一条警告\");\nconsole.error(\"输出一条错误\");\n```\n#### 窗口\n\n```javascript\nalert(\"这是一条警告\");\n```\n#### 页面\n\n```javascript\ndocument.write(\"这是一条警告\");\n```\n\n### 比较运算符\n- 第一种是`==`比较，它会**自动转换数据类型再比较**，很多时候，会得到非常诡异的结果；\n- 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n**建议使用`===`比较**，因为它的比较规则更严格，不会出现自动转换数据类型的情况。\n\n{%note danger%}\n另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：\n```javascript\nNaN === NaN; // false\n```\n\n只有当`isNaN()`才相等，返回`true`：\n\n```javascript\nisNaN(NaN); // true\n```\n{%endnote%}\n\n### 基本数据类型\n- 数值（Number）\n- 字符串（String）\n- 布尔值（Boolean）\n- `null`\n- `undefined`：使用`var`声明变量但未对其加以初始化\n- 对象（Object）\n\n与C++等语言不同，JavaScript的数值类型**不区分整数和浮点数**，统一用Number表示，以下都是合法的Number类型：\n\n```javascript\n123; // 整数123\n0.456; // 浮点数0.456\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\n-99; // 负数\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n### 声明变量\n因为 JavaScript 是**弱类型**语言，因此**变量的类型可以动态改变**。在 JavaScript 中，可以使用`var`、`let`、`const`声明变量，它们的区别是：\n\n- **作用域**不同\n   \n   - `var` 声明的变量具有**函数作用域**，即只在声明它的函数内部有效，在函数外部无法访问。如果在函数外部使用 `var` 声明变量，则该变量会成为全局变量\n   - `let` 和 `const` 声明的变量具有**块级作用域**，即只在声明它的代码块（如 `if`、`for`、`while` 等语句的花括号内）中有效，在代码块外部无法访问\n\n```javascript\nfunction testVar() {\n  if (true) {\n    var message = \"Hello\"; // var声明的变量具有函数作用域\n    console.log(message); // 输出: Hello\n  }\n  console.log(message); // 仍能访问，输出: Hello（因为在同一函数内）\n}\ntestVar();\nconsole.log(message); // 报错: message is not defined（函数外部无法访问）\n```\n\n```javascript\nfunction testLet() {\n  if (true) {\n    let message = \"Hello\"; // let声明的变量具有块级作用域(const同理)\n    console.log(message); // 输出: Hello\n  }\n  console.log(message); // 报错: message is not defined（块外部无法访问）\n}\ntestLet();\n```\n\n- **可修改性**不同\n   \n   - `var` 和 `let` 声明的变量**可以被重新赋值**\n   - `const` 声明的变量是**常量**，一旦声明就**不能被重新赋值**。但需要注意的是，如果 `const` 声明的是对象或数组，对象的属性或数组的元素是可以被修改的，因为 `const` 只保证变量**指向的内存地址不变**，而**不保证内存地址中的内容不变**\n\n```javascript\nvar a = 10;\na = \"hello\"; // 允许重新赋值\nconsole.log(a); // 输出: hello\n```\n\n- **重复声明**不同\n    \n    - `var` **允许在同一作用域内重复声明同一个变量**\n    - `let` 和 `const` 不允许在同一作用域内重复声明同一个变量，否则会抛出 SyntaxError 错误\n\n```javascript\nvar x = 10;\nvar x = 20; // 允许重复声明，会覆盖之前的值\nconsole.log(x); // 输出: 20\n```\n\n### 循环、控制语句\n与 CPP 基本相同，不再赘述\n\n### Function\n```javascript\nfunction test1(x) {\n    console.log(`Input x value is ${x}`)\n    x++;\n    let y = 100\n    console.log(`Now the x value in this function is ${x}`)\n}\n\nlet x = 10\ntest1(x)\nconsole.log(`Now the x outside the function is ${x}`)\n```\n\n```text\nInput x value is 10\nNow the x value in this function is 11\nNow the x outside the function is 10\n```\n- 基本类型的传递为**值传递**\n- 对象、数组、函数等类型的传递为**引用传递**\n\n### OOP in JavaScript\n\n## Reference\n\n[【 javascript】用一篇文章让你搞清楚var、let、const声明变量和不用var声明变量的区别](https://blog.csdn.net/weixin_55846296/article/details/126604513?fromshare=blogdetail&sharetype=blogdetail&sharerId=126604513&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)","source":"_posts/Full-Stack/JavaScript.md","raw":"---\ntitle: JavaScript Tutorial\ndate: 2025-09-01 21:23:14\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/JavaScript.png?raw=true\ntags: [JavaScript]\ncategory: Full-Stack\ncategory_bar: true\ndescription: Mastering the basic syntax of JavaScript, laying the groundwork for subsequent Node.js backend development!\n---\n\n&emsp;&emsp;相信各位读者已经掌握了2~3种编程语言，在此基础上再学习JavaScript并非难事，因此**主要展示大致语法结构**，及JavaScript相比其他语言的“特性”，skip 一些简单的执行流程原理！\n\n## Usage\n与在HTML中引入CSS相同，提供两种方式进行引入：\n\n1. 行内式\n```html\n<script>\n    // 这是JavaScript代码\n</script>\n```\n\n2. 外部式\n```html\n<script src=\"js/script.js\"></script>\n```\n\n{%note info%}\n可以将脚本放置在`<head>`或`<body>`中（建议包含在**后者**中）\n{%endnote%}\n\n{%note danger%}\n外部脚本不能包含`<script>`标签\n{%endnote%}\n\n## Basic Syntax\n- JavaScript 并不强求每个语句以`;`结束，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上`;`，但防止某些情况下会改变程序的语义，导致运行结果与期望不一致，我们建议都在结尾使用`;`！\n\n### 注释\n```javascript\n// 这是单行注释\n```\n\n```javascript\n/*\n这是多行注释\n这是多行注释\n*/\n```\n\n### 输出\n#### 控制台\n\n```javascript\nconsole.log(\"输出一条日志\");//最常用\nconsole.info(\"输出一条信息\");\nconsole.warn(\"输出一条警告\");\nconsole.error(\"输出一条错误\");\n```\n#### 窗口\n\n```javascript\nalert(\"这是一条警告\");\n```\n#### 页面\n\n```javascript\ndocument.write(\"这是一条警告\");\n```\n\n### 比较运算符\n- 第一种是`==`比较，它会**自动转换数据类型再比较**，很多时候，会得到非常诡异的结果；\n- 第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。\n\n**建议使用`===`比较**，因为它的比较规则更严格，不会出现自动转换数据类型的情况。\n\n{%note danger%}\n另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：\n```javascript\nNaN === NaN; // false\n```\n\n只有当`isNaN()`才相等，返回`true`：\n\n```javascript\nisNaN(NaN); // true\n```\n{%endnote%}\n\n### 基本数据类型\n- 数值（Number）\n- 字符串（String）\n- 布尔值（Boolean）\n- `null`\n- `undefined`：使用`var`声明变量但未对其加以初始化\n- 对象（Object）\n\n与C++等语言不同，JavaScript的数值类型**不区分整数和浮点数**，统一用Number表示，以下都是合法的Number类型：\n\n```javascript\n123; // 整数123\n0.456; // 浮点数0.456\n1.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5\n-99; // 负数\nNaN; // NaN表示Not a Number，当无法计算结果时用NaN表示\nInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity\n```\n\n### 声明变量\n因为 JavaScript 是**弱类型**语言，因此**变量的类型可以动态改变**。在 JavaScript 中，可以使用`var`、`let`、`const`声明变量，它们的区别是：\n\n- **作用域**不同\n   \n   - `var` 声明的变量具有**函数作用域**，即只在声明它的函数内部有效，在函数外部无法访问。如果在函数外部使用 `var` 声明变量，则该变量会成为全局变量\n   - `let` 和 `const` 声明的变量具有**块级作用域**，即只在声明它的代码块（如 `if`、`for`、`while` 等语句的花括号内）中有效，在代码块外部无法访问\n\n```javascript\nfunction testVar() {\n  if (true) {\n    var message = \"Hello\"; // var声明的变量具有函数作用域\n    console.log(message); // 输出: Hello\n  }\n  console.log(message); // 仍能访问，输出: Hello（因为在同一函数内）\n}\ntestVar();\nconsole.log(message); // 报错: message is not defined（函数外部无法访问）\n```\n\n```javascript\nfunction testLet() {\n  if (true) {\n    let message = \"Hello\"; // let声明的变量具有块级作用域(const同理)\n    console.log(message); // 输出: Hello\n  }\n  console.log(message); // 报错: message is not defined（块外部无法访问）\n}\ntestLet();\n```\n\n- **可修改性**不同\n   \n   - `var` 和 `let` 声明的变量**可以被重新赋值**\n   - `const` 声明的变量是**常量**，一旦声明就**不能被重新赋值**。但需要注意的是，如果 `const` 声明的是对象或数组，对象的属性或数组的元素是可以被修改的，因为 `const` 只保证变量**指向的内存地址不变**，而**不保证内存地址中的内容不变**\n\n```javascript\nvar a = 10;\na = \"hello\"; // 允许重新赋值\nconsole.log(a); // 输出: hello\n```\n\n- **重复声明**不同\n    \n    - `var` **允许在同一作用域内重复声明同一个变量**\n    - `let` 和 `const` 不允许在同一作用域内重复声明同一个变量，否则会抛出 SyntaxError 错误\n\n```javascript\nvar x = 10;\nvar x = 20; // 允许重复声明，会覆盖之前的值\nconsole.log(x); // 输出: 20\n```\n\n### 循环、控制语句\n与 CPP 基本相同，不再赘述\n\n### Function\n```javascript\nfunction test1(x) {\n    console.log(`Input x value is ${x}`)\n    x++;\n    let y = 100\n    console.log(`Now the x value in this function is ${x}`)\n}\n\nlet x = 10\ntest1(x)\nconsole.log(`Now the x outside the function is ${x}`)\n```\n\n```text\nInput x value is 10\nNow the x value in this function is 11\nNow the x outside the function is 10\n```\n- 基本类型的传递为**值传递**\n- 对象、数组、函数等类型的传递为**引用传递**\n\n### OOP in JavaScript\n\n## Reference\n\n[【 javascript】用一篇文章让你搞清楚var、let、const声明变量和不用var声明变量的区别](https://blog.csdn.net/weixin_55846296/article/details/126604513?fromshare=blogdetail&sharetype=blogdetail&sharerId=126604513&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)","slug":"Full-Stack/JavaScript","published":1,"updated":"2025-09-02T14:46:56.565Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcp001840w39foy141v","content":"<p>  相信各位读者已经掌握了2~3种编程语言，在此基础上再学习JavaScript并非难事，因此<strong>主要展示大致语法结构</strong>，及JavaScript相比其他语言的“特性”，skip 一些简单的执行流程原理！</p>\n<h2 id=\"Usage\">Usage</h2>\n<p>与在HTML中引入CSS相同，提供两种方式进行引入：</p>\n<ol>\n<li>行内式</li>\n</ol>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 这是JavaScript代码</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"2\">\n<li>外部式</li>\n</ol>\n<figure class=\"highlight html\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"js/script.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <p>可以将脚本放置在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>中（建议包含在<strong>后者</strong>中）</p>\n          </div>\n<div class=\"note note-danger\">\n            <p>外部脚本不能包含<code>&lt;script&gt;</code>标签</p>\n          </div>\n<h2 id=\"Basic-Syntax\">Basic Syntax</h2>\n<ul>\n<li>JavaScript 并不强求每个语句以<code>;</code>结束，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上<code>;</code>，但防止某些情况下会改变程序的语义，导致运行结果与期望不一致，我们建议都在结尾使用<code>;</code>！</li>\n</ul>\n<h3 id=\"注释\">注释</h3>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 这是单行注释</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"输出\">输出</h3>\n<h4 id=\"控制台\">控制台</h4>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">\"输出一条日志\"</span>);<span class=\"hljs-comment\">//最常用</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">\"输出一条信息\"</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">\"输出一条警告\"</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">\"输出一条错误\"</span>);<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"窗口\">窗口</h4>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">\"这是一条警告\"</span>);<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"页面\">页面</h4>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">\"这是一条警告\"</span>);<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"比较运算符\">比较运算符</h3>\n<ul>\n<li>第一种是<code>==</code>比较，它会<strong>自动转换数据类型再比较</strong>，很多时候，会得到非常诡异的结果；</li>\n<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>\n</ul>\n<p><strong>建议使用<code>===</code>比较</strong>，因为它的比较规则更严格，不会出现自动转换数据类型的情况。</p>\n<div class=\"note note-danger\">\n            <p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></tbody></table></figure><p>只有当<code>isNaN()</code>才相等，返回<code>true</code>：</p><figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">isNaN</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<h3 id=\"基本数据类型\">基本数据类型</h3>\n<ul>\n<li>数值（Number）</li>\n<li>字符串（String）</li>\n<li>布尔值（Boolean）</li>\n<li><code>null</code></li>\n<li><code>undefined</code>：使用<code>var</code>声明变量但未对其加以初始化</li>\n<li>对象（Object）</li>\n</ul>\n<p>与C++等语言不同，JavaScript的数值类型<strong>不区分整数和浮点数</strong>，统一用Number表示，以下都是合法的Number类型：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 整数123</span><br><span class=\"hljs-number\">0.456</span>; <span class=\"hljs-comment\">// 浮点数0.456</span><br><span class=\"hljs-number\">1.2345e3</span>; <span class=\"hljs-comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span><br>-<span class=\"hljs-number\">99</span>; <span class=\"hljs-comment\">// 负数</span><br><span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class=\"hljs-title class_\">Infinity</span>; <span class=\"hljs-comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"声明变量\">声明变量</h3>\n<p>因为 JavaScript 是<strong>弱类型</strong>语言，因此<strong>变量的类型可以动态改变</strong>。在 JavaScript 中，可以使用<code>var</code>、<code>let</code>、<code>const</code>声明变量，它们的区别是：</p>\n<ul>\n<li>\n<p><strong>作用域</strong>不同</p>\n<ul>\n<li><code>var</code> 声明的变量具有<strong>函数作用域</strong>，即只在声明它的函数内部有效，在函数外部无法访问。如果在函数外部使用 <code>var</code> 声明变量，则该变量会成为全局变量</li>\n<li><code>let</code> 和 <code>const</code> 声明的变量具有<strong>块级作用域</strong>，即只在声明它的代码块（如 <code>if</code>、<code>for</code>、<code>while</code> 等语句的花括号内）中有效，在代码块外部无法访问</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testVar</span>(<span class=\"hljs-params\"></span>) {<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {<br>    <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">\"Hello\"</span>; <span class=\"hljs-comment\">// var声明的变量具有函数作用域</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 输出: Hello</span><br>  }<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 仍能访问，输出: Hello（因为在同一函数内）</span><br>}<br><span class=\"hljs-title function_\">testVar</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 报错: message is not defined（函数外部无法访问）</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testLet</span>(<span class=\"hljs-params\"></span>) {<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {<br>    <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">\"Hello\"</span>; <span class=\"hljs-comment\">// let声明的变量具有块级作用域(const同理)</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 输出: Hello</span><br>  }<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 报错: message is not defined（块外部无法访问）</span><br>}<br><span class=\"hljs-title function_\">testLet</span>();<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>\n<p><strong>可修改性</strong>不同</p>\n<ul>\n<li><code>var</code> 和 <code>let</code> 声明的变量<strong>可以被重新赋值</strong></li>\n<li><code>const</code> 声明的变量是<strong>常量</strong>，一旦声明就<strong>不能被重新赋值</strong>。但需要注意的是，如果 <code>const</code> 声明的是对象或数组，对象的属性或数组的元素是可以被修改的，因为 <code>const</code> 只保证变量<strong>指向的内存地址不变</strong>，而<strong>不保证内存地址中的内容不变</strong></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;<br>a = <span class=\"hljs-string\">\"hello\"</span>; <span class=\"hljs-comment\">// 允许重新赋值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出: hello</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>\n<p><strong>重复声明</strong>不同</p>\n<ul>\n<li><code>var</code> <strong>允许在同一作用域内重复声明同一个变量</strong></li>\n<li><code>let</code> 和 <code>const</code> 不允许在同一作用域内重复声明同一个变量，否则会抛出 SyntaxError 错误</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// 允许重复声明，会覆盖之前的值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// 输出: 20</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"循环、控制语句\">循环、控制语句</h3>\n<p>与 CPP 基本相同，不再赘述</p>\n<h3 id=\"Function\">Function</h3>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test1</span>(<span class=\"hljs-params\">x</span>) {<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Input x value is <span class=\"hljs-subst\">${x}</span>`</span>)<br>    x++;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">100</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Now the x value in this function is <span class=\"hljs-subst\">${x}</span>`</span>)<br>}<br><br><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">10</span><br><span class=\"hljs-title function_\">test1</span>(x)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Now the x outside the function is <span class=\"hljs-subst\">${x}</span>`</span>)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight text\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">Input x value is 10<br>Now the x value in this function is 11<br>Now the x outside the function is 10<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>基本类型的传递为<strong>值传递</strong></li>\n<li>对象、数组、函数等类型的传递为<strong>引用传递</strong></li>\n</ul>\n<h3 id=\"OOP-in-JavaScript\">OOP in JavaScript</h3>\n<h2 id=\"Reference\">Reference</h2>\n<p><a href=\"https://blog.csdn.net/weixin_55846296/article/details/126604513?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=126604513&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">【 javascript】用一篇文章让你搞清楚var、let、const声明变量和不用var声明变量的区别</a></p>\n","excerpt":"","more":"<p>  相信各位读者已经掌握了2~3种编程语言，在此基础上再学习JavaScript并非难事，因此<strong>主要展示大致语法结构</strong>，及JavaScript相比其他语言的“特性”，skip 一些简单的执行流程原理！</p>\n<h2 id=\"Usage\">Usage</h2>\n<p>与在HTML中引入CSS相同，提供两种方式进行引入：</p>\n<ol>\n<li>行内式</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">    <span class=\"hljs-comment\">// 这是JavaScript代码</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>外部式</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;js/script.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <p>可以将脚本放置在<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>中（建议包含在<strong>后者</strong>中）</p>\n          </div>\n<div class=\"note note-danger\">\n            <p>外部脚本不能包含<code>&lt;script&gt;</code>标签</p>\n          </div>\n<h2 id=\"Basic-Syntax\">Basic Syntax</h2>\n<ul>\n<li>JavaScript 并不强求每个语句以<code>;</code>结束，浏览器中负责执行 JavaScript 代码的引擎会自动在每个语句的结尾补上<code>;</code>，但防止某些情况下会改变程序的语义，导致运行结果与期望不一致，我们建议都在结尾使用<code>;</code>！</li>\n</ul>\n<h3 id=\"注释\">注释</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 这是单行注释</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">这是多行注释</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"输出\">输出</h3>\n<h4 id=\"控制台\">控制台</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;输出一条日志&quot;</span>);<span class=\"hljs-comment\">//最常用</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">info</span>(<span class=\"hljs-string\">&quot;输出一条信息&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">warn</span>(<span class=\"hljs-string\">&quot;输出一条警告&quot;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;输出一条错误&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"窗口\">窗口</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;这是一条警告&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h4 id=\"页面\">页面</h4>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">&quot;这是一条警告&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"比较运算符\">比较运算符</h3>\n<ul>\n<li>第一种是<code>==</code>比较，它会<strong>自动转换数据类型再比较</strong>，很多时候，会得到非常诡异的结果；</li>\n<li>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</li>\n</ul>\n<p><strong>建议使用<code>===</code>比较</strong>，因为它的比较规则更严格，不会出现自动转换数据类型的情况。</p>\n<div class=\"note note-danger\">\n            <p>另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">NaN</span> === <span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure><p>只有当<code>isNaN()</code>才相等，返回<code>true</code>：</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">isNaN</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n          </div>\n<h3 id=\"基本数据类型\">基本数据类型</h3>\n<ul>\n<li>数值（Number）</li>\n<li>字符串（String）</li>\n<li>布尔值（Boolean）</li>\n<li><code>null</code></li>\n<li><code>undefined</code>：使用<code>var</code>声明变量但未对其加以初始化</li>\n<li>对象（Object）</li>\n</ul>\n<p>与C++等语言不同，JavaScript的数值类型<strong>不区分整数和浮点数</strong>，统一用Number表示，以下都是合法的Number类型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-number\">123</span>; <span class=\"hljs-comment\">// 整数123</span><br><span class=\"hljs-number\">0.456</span>; <span class=\"hljs-comment\">// 浮点数0.456</span><br><span class=\"hljs-number\">1.2345e3</span>; <span class=\"hljs-comment\">// 科学计数法表示1.2345x1000，等同于1234.5</span><br>-<span class=\"hljs-number\">99</span>; <span class=\"hljs-comment\">// 负数</span><br><span class=\"hljs-title class_\">NaN</span>; <span class=\"hljs-comment\">// NaN表示Not a Number，当无法计算结果时用NaN表示</span><br><span class=\"hljs-title class_\">Infinity</span>; <span class=\"hljs-comment\">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"声明变量\">声明变量</h3>\n<p>因为 JavaScript 是<strong>弱类型</strong>语言，因此<strong>变量的类型可以动态改变</strong>。在 JavaScript 中，可以使用<code>var</code>、<code>let</code>、<code>const</code>声明变量，它们的区别是：</p>\n<ul>\n<li>\n<p><strong>作用域</strong>不同</p>\n<ul>\n<li><code>var</code> 声明的变量具有<strong>函数作用域</strong>，即只在声明它的函数内部有效，在函数外部无法访问。如果在函数外部使用 <code>var</code> 声明变量，则该变量会成为全局变量</li>\n<li><code>let</code> 和 <code>const</code> 声明的变量具有<strong>块级作用域</strong>，即只在声明它的代码块（如 <code>if</code>、<code>for</code>、<code>while</code> 等语句的花括号内）中有效，在代码块外部无法访问</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testVar</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-string\">&quot;Hello&quot;</span>; <span class=\"hljs-comment\">// var声明的变量具有函数作用域</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 输出: Hello</span><br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 仍能访问，输出: Hello（因为在同一函数内）</span><br>&#125;<br><span class=\"hljs-title function_\">testVar</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 报错: message is not defined（函数外部无法访问）</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">testLet</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> message = <span class=\"hljs-string\">&quot;Hello&quot;</span>; <span class=\"hljs-comment\">// let声明的变量具有块级作用域(const同理)</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 输出: Hello</span><br>  &#125;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(message); <span class=\"hljs-comment\">// 报错: message is not defined（块外部无法访问）</span><br>&#125;<br><span class=\"hljs-title function_\">testLet</span>();<br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><strong>可修改性</strong>不同</p>\n<ul>\n<li><code>var</code> 和 <code>let</code> 声明的变量<strong>可以被重新赋值</strong></li>\n<li><code>const</code> 声明的变量是<strong>常量</strong>，一旦声明就<strong>不能被重新赋值</strong>。但需要注意的是，如果 <code>const</code> 声明的是对象或数组，对象的属性或数组的元素是可以被修改的，因为 <code>const</code> 只保证变量<strong>指向的内存地址不变</strong>，而<strong>不保证内存地址中的内容不变</strong></li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">10</span>;<br>a = <span class=\"hljs-string\">&quot;hello&quot;</span>; <span class=\"hljs-comment\">// 允许重新赋值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(a); <span class=\"hljs-comment\">// 输出: hello</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li>\n<p><strong>重复声明</strong>不同</p>\n<ul>\n<li><code>var</code> <strong>允许在同一作用域内重复声明同一个变量</strong></li>\n<li><code>let</code> 和 <code>const</code> 不允许在同一作用域内重复声明同一个变量，否则会抛出 SyntaxError 错误</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">20</span>; <span class=\"hljs-comment\">// 允许重复声明，会覆盖之前的值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(x); <span class=\"hljs-comment\">// 输出: 20</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"循环、控制语句\">循环、控制语句</h3>\n<p>与 CPP 基本相同，不再赘述</p>\n<h3 id=\"Function\">Function</h3>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">test1</span>(<span class=\"hljs-params\">x</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Input x value is <span class=\"hljs-subst\">$&#123;x&#125;</span>`</span>)<br>    x++;<br>    <span class=\"hljs-keyword\">let</span> y = <span class=\"hljs-number\">100</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Now the x value in this function is <span class=\"hljs-subst\">$&#123;x&#125;</span>`</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">10</span><br><span class=\"hljs-title function_\">test1</span>(x)<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Now the x outside the function is <span class=\"hljs-subst\">$&#123;x&#125;</span>`</span>)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs text\">Input x value is 10<br>Now the x value in this function is 11<br>Now the x outside the function is 10<br></code></pre></td></tr></table></figure>\n<ul>\n<li>基本类型的传递为<strong>值传递</strong></li>\n<li>对象、数组、函数等类型的传递为<strong>引用传递</strong></li>\n</ul>\n<h3 id=\"OOP-in-JavaScript\">OOP in JavaScript</h3>\n<h2 id=\"Reference\">Reference</h2>\n<p><a href=\"https://blog.csdn.net/weixin_55846296/article/details/126604513?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=126604513&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">【 javascript】用一篇文章让你搞清楚var、let、const声明变量和不用var声明变量的区别</a></p>\n"},{"title":"Basic Python Tutorial","date":"2025-09-13T02:45:52.000Z","archive":true,"_content":"最近决心入门Python，之前仅仅高中的底子显然不够看，遂再来进行学习！\n\n## 数据结构\n### 列表\n可以存储**任意类型**的数据，**动态改变大小**，类似于CPP中的`vector`，用方括号`[]`表示，元素之间用逗号隔开。\n\n```python\nmy_list=[1,2,3,4,5]\n```\n\n```python\nmy_list=[1,str,1.2,'hello']\nprint(my_list)\n# [1, <class 'str'>, 1.2, 'hello']\n```\n\n\n#### 添加元素\n`append()`方法\n```python\nmy_list.append(6)\nmy_list.append('world')\n```\n#### 修改元素\n直接通过索引值进行修改\n```python\nmy_list[0]=100\n```\n#### 删除元素\n`del`关键字\n```python\ndel my_list[0]\n```\n\n\n### 元组\n元组与列表类似，但是元组是**不可变的**，用圆括号`()`表示，元素之间用逗号隔开。\n```python\nmy_tuple=(1,1.2,'hello')\n```\n\n\n### 字典\n字典`dict`，字典中的元素是**键值对**，类似与CPP中的`unordered_map`，用花括号`{}`表示，键-值对之间用**冒号**分隔，元素之间用**逗号**分隔\n```python\nmy_dict={'name':'richard','age':18,'city':'Nanjing'}\nprint(my_dict['name']) # 输出键为'name'的值：richard\nprint(my_dict['age']) # 输出键为'age'的值：18\nprint(my_dict['city']) # 输出键为'city'的值：Nanjing\n```\n\n\n### 集合\n集合`set`，集合中的元素是**不重复且无序**的，用花括号`{}`表示，元素之间用逗号隔开。\n```python\nmy_set={1,2,3,4,5,5,5}\n```\n#### 添加元素\n`add()`方法\n```python\nmy_set.add(6)\n```\n#### 删除元素\n`remove()`方法\n```python\nmy_set.remove(1)\n```\n### 字符串\n字符串`str`，用引号`''`或`\"\"`表示，引号中的内容就是字符串的内容。\n```python\nmy_string='hello world'\n```\n## 序列\n序列可以帮助我们方便的存储和访问多个元素：\n### 索引(index)\n索引`index`，索引用于访问序列中的元素，索引从0开始。\n- **正整数**表示从前往后数\n- **负整数**表示从后往前数\n```python\nmy_string='hello world'\nprint(my_string[0]) # 输出第一个字符：h\nprint(my_string[-1]) # 输出最后一个字符：d\n```\n### 切片(slice)\n获取序列中的子序列，用**冒号**分隔，**左闭右开**，通用格式为：\n\n$$[start:end]、[start:end:step]$$\n- **start**表示起始索引，默认为0\n- **end**表示结束索引，默认为序列长度\n- **step**表示**步长**，默认为1\n```python\nmy_string='hello world'\nprint(my_string[0:5]) # 输出从索引0到索引4的子序列：hello\n```\n\n### 长度（length）\n```python\nmy_list=[1,2,3,4,5]\nprint(len(my_list)) # 输出列表的长度：5\n```\n### 追加（append）\n```python\nmy_list.append(6)\n```\n\n### 拼接（concatenate）\n```python\nmy_list1=[1,2,3]\nmy_list2=[4,5,6]\nnew_list=my_list1+my_list2\nmy_list1.append(my_list2)\n```\n### 删除（delete）\n```python\ndel my_list[0]\n```\n### 重复（repeat）\n```python\nmy_list=[1,2,3,4,5]\nmy_list*2\n```\n### 查找（find）\n```python\nmy_list=[1,2,3,4,5]\nprint(my_list.index(3)) # 输出3的索引：2\n```\n### 计数（count）\n ```python\n my_list=[1,2,3,4,5]\n print(my_list.count(1)) # 输出1的个数：1\n```\n### 排序（sort）\n```python\nmy_list=[3,1,5,2,4]\nmy_list.sort()\nprint(my_list) # 输出排序后的列表：[1, 2, 3, 4, 5]\n```\n## 程序控制语句\n### 条件语句\n```python\nif condition:\n    do something\nelif another_condition:\n    do something else\nelse:\n    do something else\n```\n### for 循环语句\n#### 列表\n```python\nfruits=['apple','banana','orange']\nfor fruit in fruits:\n    print(fruit)\n```\n#### 字符串\n```python\nfor char in 'hello':\n    print(char)\n```\n#### range()范围函数\n```python\nfor i in range(10):\n    print(i)\n```\n#### 字典\n```python\nperson={'name':'richard','age':18,'city':'Nanjing'}\nfor key,value in person.items():\n    print(key,value)\n```\n### 其他语句\n#### with 语句\nwith语句用于简化资源的管理，能在代码块执行完毕后自动关闭资源。\n```python\nwith open('file.txt','r') as f:\n    data=f.read()\n    print(data)\n```\n#### try 语句\n常用于**捕获和处理可能发生的异常**。\n- try: 可能出现异常的代码\n- except: 特定类型的异常\n- else: 未发生异常的情况\n- finally: 无论是否发生异常都会执行\n```python\ntry:\n    result=10/0\nexcept:\n    print('发生异常')\nelse:\n    print('没有发生异常')\nfinally:\n    print('finally')\n```\n","source":"_posts/Python/Basic-Python-Tutorial.md","raw":"---\ntitle: Basic Python Tutorial\ndate: 2025-09-13 10:45:52\ntags:\narchive: true\n---\n最近决心入门Python，之前仅仅高中的底子显然不够看，遂再来进行学习！\n\n## 数据结构\n### 列表\n可以存储**任意类型**的数据，**动态改变大小**，类似于CPP中的`vector`，用方括号`[]`表示，元素之间用逗号隔开。\n\n```python\nmy_list=[1,2,3,4,5]\n```\n\n```python\nmy_list=[1,str,1.2,'hello']\nprint(my_list)\n# [1, <class 'str'>, 1.2, 'hello']\n```\n\n\n#### 添加元素\n`append()`方法\n```python\nmy_list.append(6)\nmy_list.append('world')\n```\n#### 修改元素\n直接通过索引值进行修改\n```python\nmy_list[0]=100\n```\n#### 删除元素\n`del`关键字\n```python\ndel my_list[0]\n```\n\n\n### 元组\n元组与列表类似，但是元组是**不可变的**，用圆括号`()`表示，元素之间用逗号隔开。\n```python\nmy_tuple=(1,1.2,'hello')\n```\n\n\n### 字典\n字典`dict`，字典中的元素是**键值对**，类似与CPP中的`unordered_map`，用花括号`{}`表示，键-值对之间用**冒号**分隔，元素之间用**逗号**分隔\n```python\nmy_dict={'name':'richard','age':18,'city':'Nanjing'}\nprint(my_dict['name']) # 输出键为'name'的值：richard\nprint(my_dict['age']) # 输出键为'age'的值：18\nprint(my_dict['city']) # 输出键为'city'的值：Nanjing\n```\n\n\n### 集合\n集合`set`，集合中的元素是**不重复且无序**的，用花括号`{}`表示，元素之间用逗号隔开。\n```python\nmy_set={1,2,3,4,5,5,5}\n```\n#### 添加元素\n`add()`方法\n```python\nmy_set.add(6)\n```\n#### 删除元素\n`remove()`方法\n```python\nmy_set.remove(1)\n```\n### 字符串\n字符串`str`，用引号`''`或`\"\"`表示，引号中的内容就是字符串的内容。\n```python\nmy_string='hello world'\n```\n## 序列\n序列可以帮助我们方便的存储和访问多个元素：\n### 索引(index)\n索引`index`，索引用于访问序列中的元素，索引从0开始。\n- **正整数**表示从前往后数\n- **负整数**表示从后往前数\n```python\nmy_string='hello world'\nprint(my_string[0]) # 输出第一个字符：h\nprint(my_string[-1]) # 输出最后一个字符：d\n```\n### 切片(slice)\n获取序列中的子序列，用**冒号**分隔，**左闭右开**，通用格式为：\n\n$$[start:end]、[start:end:step]$$\n- **start**表示起始索引，默认为0\n- **end**表示结束索引，默认为序列长度\n- **step**表示**步长**，默认为1\n```python\nmy_string='hello world'\nprint(my_string[0:5]) # 输出从索引0到索引4的子序列：hello\n```\n\n### 长度（length）\n```python\nmy_list=[1,2,3,4,5]\nprint(len(my_list)) # 输出列表的长度：5\n```\n### 追加（append）\n```python\nmy_list.append(6)\n```\n\n### 拼接（concatenate）\n```python\nmy_list1=[1,2,3]\nmy_list2=[4,5,6]\nnew_list=my_list1+my_list2\nmy_list1.append(my_list2)\n```\n### 删除（delete）\n```python\ndel my_list[0]\n```\n### 重复（repeat）\n```python\nmy_list=[1,2,3,4,5]\nmy_list*2\n```\n### 查找（find）\n```python\nmy_list=[1,2,3,4,5]\nprint(my_list.index(3)) # 输出3的索引：2\n```\n### 计数（count）\n ```python\n my_list=[1,2,3,4,5]\n print(my_list.count(1)) # 输出1的个数：1\n```\n### 排序（sort）\n```python\nmy_list=[3,1,5,2,4]\nmy_list.sort()\nprint(my_list) # 输出排序后的列表：[1, 2, 3, 4, 5]\n```\n## 程序控制语句\n### 条件语句\n```python\nif condition:\n    do something\nelif another_condition:\n    do something else\nelse:\n    do something else\n```\n### for 循环语句\n#### 列表\n```python\nfruits=['apple','banana','orange']\nfor fruit in fruits:\n    print(fruit)\n```\n#### 字符串\n```python\nfor char in 'hello':\n    print(char)\n```\n#### range()范围函数\n```python\nfor i in range(10):\n    print(i)\n```\n#### 字典\n```python\nperson={'name':'richard','age':18,'city':'Nanjing'}\nfor key,value in person.items():\n    print(key,value)\n```\n### 其他语句\n#### with 语句\nwith语句用于简化资源的管理，能在代码块执行完毕后自动关闭资源。\n```python\nwith open('file.txt','r') as f:\n    data=f.read()\n    print(data)\n```\n#### try 语句\n常用于**捕获和处理可能发生的异常**。\n- try: 可能出现异常的代码\n- except: 特定类型的异常\n- else: 未发生异常的情况\n- finally: 无论是否发生异常都会执行\n```python\ntry:\n    result=10/0\nexcept:\n    print('发生异常')\nelse:\n    print('没有发生异常')\nfinally:\n    print('finally')\n```\n","slug":"Python/Basic-Python-Tutorial","published":1,"updated":"2025-09-13T05:02:22.861Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcp001c40w35546f2e1","content":"<p>最近决心入门Python，之前仅仅高中的底子显然不够看，遂再来进行学习！</p>\n<h2 id=\"数据结构\">数据结构</h2>\n<h3 id=\"列表\">列表</h3>\n<p>可以存储<strong>任意类型</strong>的数据，<strong>动态改变大小</strong>，类似于CPP中的<code>vector</code>，用方括号<code>[]</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">str</span>,<span class=\"hljs-number\">1.2</span>,<span class=\"hljs-string\">'hello'</span>]<br><span class=\"hljs-built_in\">print</span>(my_list)<br><span class=\"hljs-comment\"># [1, &lt;class 'str'&gt;, 1.2, 'hello']</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"添加元素\">添加元素</h4>\n<p><code>append()</code>方法</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list.append(<span class=\"hljs-number\">6</span>)<br>my_list.append(<span class=\"hljs-string\">'world'</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"修改元素\">修改元素</h4>\n<p>直接通过索引值进行修改</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">100</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"删除元素\">删除元素</h4>\n<p><code>del</code>关键字</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">del</span> my_list[<span class=\"hljs-number\">0</span>]<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"元组\">元组</h3>\n<p>元组与列表类似，但是元组是<strong>不可变的</strong>，用圆括号<code>()</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_tuple=(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1.2</span>,<span class=\"hljs-string\">'hello'</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"字典\">字典</h3>\n<p>字典<code>dict</code>，字典中的元素是<strong>键值对</strong>，类似与CPP中的<code>unordered_map</code>，用花括号<code>{}</code>表示，键-值对之间用<strong>冒号</strong>分隔，元素之间用<strong>逗号</strong>分隔</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_dict={<span class=\"hljs-string\">'name'</span>:<span class=\"hljs-string\">'richard'</span>,<span class=\"hljs-string\">'age'</span>:<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">'city'</span>:<span class=\"hljs-string\">'Nanjing'</span>}<br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">'name'</span>]) <span class=\"hljs-comment\"># 输出键为'name'的值：richard</span><br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">'age'</span>]) <span class=\"hljs-comment\"># 输出键为'age'的值：18</span><br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">'city'</span>]) <span class=\"hljs-comment\"># 输出键为'city'的值：Nanjing</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"集合\">集合</h3>\n<p>集合<code>set</code>，集合中的元素是<strong>不重复且无序</strong>的，用花括号<code>{}</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set={<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">5</span>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"添加元素-v2\">添加元素</h4>\n<p><code>add()</code>方法</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set.add(<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"删除元素-v2\">删除元素</h4>\n<p><code>remove()</code>方法</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set.remove(<span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"字符串\">字符串</h3>\n<p>字符串<code>str</code>，用引号<code>''</code>或<code>\"\"</code>表示，引号中的内容就是字符串的内容。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">'hello world'</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"序列\">序列</h2>\n<p>序列可以帮助我们方便的存储和访问多个元素：</p>\n<h3 id=\"索引-index\">索引(index)</h3>\n<p>索引<code>index</code>，索引用于访问序列中的元素，索引从0开始。</p>\n<ul>\n<li><strong>正整数</strong>表示从前往后数</li>\n<li><strong>负整数</strong>表示从后往前数</li>\n</ul>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">'hello world'</span><br><span class=\"hljs-built_in\">print</span>(my_string[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-comment\"># 输出第一个字符：h</span><br><span class=\"hljs-built_in\">print</span>(my_string[-<span class=\"hljs-number\">1</span>]) <span class=\"hljs-comment\"># 输出最后一个字符：d</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"切片-slice\">切片(slice)</h3>\n<p>获取序列中的子序列，用<strong>冒号</strong>分隔，<strong>左闭右开</strong>，通用格式为：</p>\n<p>$$[start:end]、[start🔚step]$$</p>\n<ul>\n<li><strong>start</strong>表示起始索引，默认为0</li>\n<li><strong>end</strong>表示结束索引，默认为序列长度</li>\n<li><strong>step</strong>表示<strong>步长</strong>，默认为1</li>\n</ul>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">'hello world'</span><br><span class=\"hljs-built_in\">print</span>(my_string[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">5</span>]) <span class=\"hljs-comment\"># 输出从索引0到索引4的子序列：hello</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"长度（length）\">长度（length）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">len</span>(my_list)) <span class=\"hljs-comment\"># 输出列表的长度：5</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"追加（append）\">追加（append）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list.append(<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"拼接（concatenate）\">拼接（concatenate）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list1=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br>my_list2=[<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>]<br>new_list=my_list1+my_list2<br>my_list1.append(my_list2)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"删除（delete）\">删除（delete）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">del</span> my_list[<span class=\"hljs-number\">0</span>]<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"重复（repeat）\">重复（repeat）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>my_list*<span class=\"hljs-number\">2</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"查找（find）\">查找（find）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(my_list.index(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\"># 输出3的索引：2</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"计数（count）\">计数（count）</h3>\n <figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(my_list.count(<span class=\"hljs-number\">1</span>)) <span class=\"hljs-comment\"># 输出1的个数：1</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"排序（sort）\">排序（sort）</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>]<br>my_list.sort()<br><span class=\"hljs-built_in\">print</span>(my_list) <span class=\"hljs-comment\"># 输出排序后的列表：[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"程序控制语句\">程序控制语句</h2>\n<h3 id=\"条件语句\">条件语句</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> condition:<br>    do something<br><span class=\"hljs-keyword\">elif</span> another_condition:<br>    do something <span class=\"hljs-keyword\">else</span><br><span class=\"hljs-keyword\">else</span>:<br>    do something <span class=\"hljs-keyword\">else</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"for-循环语句\">for 循环语句</h3>\n<h4 id=\"列表-v2\">列表</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fruits=[<span class=\"hljs-string\">'apple'</span>,<span class=\"hljs-string\">'banana'</span>,<span class=\"hljs-string\">'orange'</span>]<br><span class=\"hljs-keyword\">for</span> fruit <span class=\"hljs-keyword\">in</span> fruits:<br>    <span class=\"hljs-built_in\">print</span>(fruit)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"字符串-v2\">字符串</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">'hello'</span>:<br>    <span class=\"hljs-built_in\">print</span>(char)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"range-范围函数\">range()范围函数</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>):<br>    <span class=\"hljs-built_in\">print</span>(i)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"字典-v2\">字典</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">person={<span class=\"hljs-string\">'name'</span>:<span class=\"hljs-string\">'richard'</span>,<span class=\"hljs-string\">'age'</span>:<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">'city'</span>:<span class=\"hljs-string\">'Nanjing'</span>}<br><span class=\"hljs-keyword\">for</span> key,value <span class=\"hljs-keyword\">in</span> person.items():<br>    <span class=\"hljs-built_in\">print</span>(key,value)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"其他语句\">其他语句</h3>\n<h4 id=\"with-语句\">with 语句</h4>\n<p>with语句用于简化资源的管理，能在代码块执行完毕后自动关闭资源。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">'file.txt'</span>,<span class=\"hljs-string\">'r'</span>) <span class=\"hljs-keyword\">as</span> f:<br>    data=f.read()<br>    <span class=\"hljs-built_in\">print</span>(data)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"try-语句\">try 语句</h4>\n<p>常用于<strong>捕获和处理可能发生的异常</strong>。</p>\n<ul>\n<li>try: 可能出现异常的代码</li>\n<li>except: 特定类型的异常</li>\n<li>else: 未发生异常的情况</li>\n<li>finally: 无论是否发生异常都会执行</li>\n</ul>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    result=<span class=\"hljs-number\">10</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'发生异常'</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'没有发生异常'</span>)<br><span class=\"hljs-keyword\">finally</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'finally'</span>)<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<p>最近决心入门Python，之前仅仅高中的底子显然不够看，遂再来进行学习！</p>\n<h2 id=\"数据结构\">数据结构</h2>\n<h3 id=\"列表\">列表</h3>\n<p>可以存储<strong>任意类型</strong>的数据，<strong>动态改变大小</strong>，类似于CPP中的<code>vector</code>，用方括号<code>[]</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-built_in\">str</span>,<span class=\"hljs-number\">1.2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>]<br><span class=\"hljs-built_in\">print</span>(my_list)<br><span class=\"hljs-comment\"># [1, &lt;class &#x27;str&#x27;&gt;, 1.2, &#x27;hello&#x27;]</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"添加元素\">添加元素</h4>\n<p><code>append()</code>方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list.append(<span class=\"hljs-number\">6</span>)<br>my_list.append(<span class=\"hljs-string\">&#x27;world&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h4 id=\"修改元素\">修改元素</h4>\n<p>直接通过索引值进行修改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">100</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"删除元素\">删除元素</h4>\n<p><code>del</code>关键字</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">del</span> my_list[<span class=\"hljs-number\">0</span>]<br></code></pre></td></tr></table></figure>\n<h3 id=\"元组\">元组</h3>\n<p>元组与列表类似，但是元组是<strong>不可变的</strong>，用圆括号<code>()</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_tuple=(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1.2</span>,<span class=\"hljs-string\">&#x27;hello&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"字典\">字典</h3>\n<p>字典<code>dict</code>，字典中的元素是<strong>键值对</strong>，类似与CPP中的<code>unordered_map</code>，用花括号<code>&#123;&#125;</code>表示，键-值对之间用<strong>冒号</strong>分隔，元素之间用<strong>逗号</strong>分隔</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_dict=&#123;<span class=\"hljs-string\">&#x27;name&#x27;</span>:<span class=\"hljs-string\">&#x27;richard&#x27;</span>,<span class=\"hljs-string\">&#x27;age&#x27;</span>:<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&#x27;city&#x27;</span>:<span class=\"hljs-string\">&#x27;Nanjing&#x27;</span>&#125;<br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">&#x27;name&#x27;</span>]) <span class=\"hljs-comment\"># 输出键为&#x27;name&#x27;的值：richard</span><br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">&#x27;age&#x27;</span>]) <span class=\"hljs-comment\"># 输出键为&#x27;age&#x27;的值：18</span><br><span class=\"hljs-built_in\">print</span>(my_dict[<span class=\"hljs-string\">&#x27;city&#x27;</span>]) <span class=\"hljs-comment\"># 输出键为&#x27;city&#x27;的值：Nanjing</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"集合\">集合</h3>\n<p>集合<code>set</code>，集合中的元素是<strong>不重复且无序</strong>的，用花括号<code>&#123;&#125;</code>表示，元素之间用逗号隔开。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set=&#123;<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">5</span>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"添加元素-v2\">添加元素</h4>\n<p><code>add()</code>方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set.add(<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></table></figure>\n<h4 id=\"删除元素-v2\">删除元素</h4>\n<p><code>remove()</code>方法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_set.remove(<span class=\"hljs-number\">1</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"字符串\">字符串</h3>\n<p>字符串<code>str</code>，用引号<code>''</code>或<code>&quot;&quot;</code>表示，引号中的内容就是字符串的内容。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">&#x27;hello world&#x27;</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"序列\">序列</h2>\n<p>序列可以帮助我们方便的存储和访问多个元素：</p>\n<h3 id=\"索引-index\">索引(index)</h3>\n<p>索引<code>index</code>，索引用于访问序列中的元素，索引从0开始。</p>\n<ul>\n<li><strong>正整数</strong>表示从前往后数</li>\n<li><strong>负整数</strong>表示从后往前数</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">&#x27;hello world&#x27;</span><br><span class=\"hljs-built_in\">print</span>(my_string[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-comment\"># 输出第一个字符：h</span><br><span class=\"hljs-built_in\">print</span>(my_string[-<span class=\"hljs-number\">1</span>]) <span class=\"hljs-comment\"># 输出最后一个字符：d</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"切片-slice\">切片(slice)</h3>\n<p>获取序列中的子序列，用<strong>冒号</strong>分隔，<strong>左闭右开</strong>，通用格式为：</p>\n<p>$$[start:end]、[start🔚step]$$</p>\n<ul>\n<li><strong>start</strong>表示起始索引，默认为0</li>\n<li><strong>end</strong>表示结束索引，默认为序列长度</li>\n<li><strong>step</strong>表示<strong>步长</strong>，默认为1</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_string=<span class=\"hljs-string\">&#x27;hello world&#x27;</span><br><span class=\"hljs-built_in\">print</span>(my_string[<span class=\"hljs-number\">0</span>:<span class=\"hljs-number\">5</span>]) <span class=\"hljs-comment\"># 输出从索引0到索引4的子序列：hello</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"长度（length）\">长度（length）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">len</span>(my_list)) <span class=\"hljs-comment\"># 输出列表的长度：5</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"追加（append）\">追加（append）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list.append(<span class=\"hljs-number\">6</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"拼接（concatenate）\">拼接（concatenate）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list1=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br>my_list2=[<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>]<br>new_list=my_list1+my_list2<br>my_list1.append(my_list2)<br></code></pre></td></tr></table></figure>\n<h3 id=\"删除（delete）\">删除（delete）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">del</span> my_list[<span class=\"hljs-number\">0</span>]<br></code></pre></td></tr></table></figure>\n<h3 id=\"重复（repeat）\">重复（repeat）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>my_list*<span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"查找（find）\">查找（find）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(my_list.index(<span class=\"hljs-number\">3</span>)) <span class=\"hljs-comment\"># 输出3的索引：2</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"计数（count）\">计数（count）</h3>\n <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-built_in\">print</span>(my_list.count(<span class=\"hljs-number\">1</span>)) <span class=\"hljs-comment\"># 输出1的个数：1</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"排序（sort）\">排序（sort）</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">my_list=[<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>]<br>my_list.sort()<br><span class=\"hljs-built_in\">print</span>(my_list) <span class=\"hljs-comment\"># 输出排序后的列表：[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"程序控制语句\">程序控制语句</h2>\n<h3 id=\"条件语句\">条件语句</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">if</span> condition:<br>    do something<br><span class=\"hljs-keyword\">elif</span> another_condition:<br>    do something <span class=\"hljs-keyword\">else</span><br><span class=\"hljs-keyword\">else</span>:<br>    do something <span class=\"hljs-keyword\">else</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"for-循环语句\">for 循环语句</h3>\n<h4 id=\"列表-v2\">列表</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">fruits=[<span class=\"hljs-string\">&#x27;apple&#x27;</span>,<span class=\"hljs-string\">&#x27;banana&#x27;</span>,<span class=\"hljs-string\">&#x27;orange&#x27;</span>]<br><span class=\"hljs-keyword\">for</span> fruit <span class=\"hljs-keyword\">in</span> fruits:<br>    <span class=\"hljs-built_in\">print</span>(fruit)<br></code></pre></td></tr></table></figure>\n<h4 id=\"字符串-v2\">字符串</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> char <span class=\"hljs-keyword\">in</span> <span class=\"hljs-string\">&#x27;hello&#x27;</span>:<br>    <span class=\"hljs-built_in\">print</span>(char)<br></code></pre></td></tr></table></figure>\n<h4 id=\"range-范围函数\">range()范围函数</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>):<br>    <span class=\"hljs-built_in\">print</span>(i)<br></code></pre></td></tr></table></figure>\n<h4 id=\"字典-v2\">字典</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">person=&#123;<span class=\"hljs-string\">&#x27;name&#x27;</span>:<span class=\"hljs-string\">&#x27;richard&#x27;</span>,<span class=\"hljs-string\">&#x27;age&#x27;</span>:<span class=\"hljs-number\">18</span>,<span class=\"hljs-string\">&#x27;city&#x27;</span>:<span class=\"hljs-string\">&#x27;Nanjing&#x27;</span>&#125;<br><span class=\"hljs-keyword\">for</span> key,value <span class=\"hljs-keyword\">in</span> person.items():<br>    <span class=\"hljs-built_in\">print</span>(key,value)<br></code></pre></td></tr></table></figure>\n<h3 id=\"其他语句\">其他语句</h3>\n<h4 id=\"with-语句\">with 语句</h4>\n<p>with语句用于简化资源的管理，能在代码块执行完毕后自动关闭资源。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">&#x27;file.txt&#x27;</span>,<span class=\"hljs-string\">&#x27;r&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>    data=f.read()<br>    <span class=\"hljs-built_in\">print</span>(data)<br></code></pre></td></tr></table></figure>\n<h4 id=\"try-语句\">try 语句</h4>\n<p>常用于<strong>捕获和处理可能发生的异常</strong>。</p>\n<ul>\n<li>try: 可能出现异常的代码</li>\n<li>except: 特定类型的异常</li>\n<li>else: 未发生异常的情况</li>\n<li>finally: 无论是否发生异常都会执行</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    result=<span class=\"hljs-number\">10</span>/<span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">except</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;发生异常&#x27;</span>)<br><span class=\"hljs-keyword\">else</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;没有发生异常&#x27;</span>)<br><span class=\"hljs-keyword\">finally</span>:<br>    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;finally&#x27;</span>)<br></code></pre></td></tr></table></figure>\n"},{"title":"The CS61A Lab Notebook1","date":"2025-07-25T15:11:35.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/The-CS61A-Lab-Notebook.png","category_bar":true,"description":"This blog will document my notes and insights as I work through this challenging yet rewarding curriculum!","_content":"\n\n\n{%note info%}笔者在学校仅仅学习了C++，对其他语言知之甚少，然而在实际应用中，Python的应用场景之广泛令人惊叹：无论是数学建模中的数据可视化、数据分析，还是计算机视觉领域的机器学习与深度学习，Python都展现出无可替代的重要性。虽然高中时曾对Python有所涉猎，但不成体系。{%endnote%}\n\n{%note info%}我深知在计算机领域，自主学习能力至关重要。然而平日既要应对繁重的课业，又要准备各类竞赛，实在分身乏术。值此暑假时间充裕之际，我决定研读计算机领域的标杆课程——CS61A。希望能够有所收获！以下是我的学习笔记，大家共勉！{%endnote%}\n\n## What's the CS61A?\n&emsp;&emsp;`CS61A`是加州大学伯克利分校（`UC Berkeley`）计算机科学专业的入门课程，全称为\"计算机程序的结构与解释\"(`Structure and Interpretation of Computer Programs`)。这门课程**采用`Python`作为主要教学语言**，同时涵盖`Scheme`和`SQL`。课程核心在于**培养计算思维**而非单纯编程技巧，**重点教授抽象思想、函数式编程和元语言抽象**，被誉为\"真正教会学生如何思考的计算入门课\"！\n\n这里是[CS61A官方网站](https://cs61a.org/)，里面包含了相关的`videos`、`slides`和`homework`帮助你学习！\n英语和我一样不很出彩的可以观看b站双语翻译版本：\n[【完结】【CS61A精翻双语·英文原声】伯克利大学《计算机程序的结构与解释》(2024)](https://www.bilibili.com/video/BV1sy411z7nA?spm_id_from=333.788.videopod.sections&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n\n\n## Functions\n```python\ndef <name>(<formal parameters>):\n    return <return expression>\n ```\n \n函数与变量的区别：变量是**一次性赋值**的，函数在**每次调用时会重新计算**。\n```python\n>>> radius=10\n>>> area=mul(radius,radius)*pi\n>>> area\n314.1592653589793\n>>> radius=20\n>>> area\n314.1592653589793\n```\n这里我们发现变量`area`在第一次进行赋值后，尽管`radius`进行改变，但是其值不再发生变化，可见赋值是一次性的，不是动态的！\n```python\n>>> def area():\n...     return mul(radius,radius)*pi\n...\n>>> area()\n1256.6370614359173\n>>> radius=10\n>>> area()\n314.1592653589793\n>>> radius=1\n>>> area()\n3.141592653589793\n```\n于是我们考虑将`area`变成函数，发现每次调用`area()`时，`area()`都会根据表达式的值重新计算，做到了动态变化！\n\n```python\n>>> print(print(1),print(2))\n1\n2\nNone None\n```\n| 步骤 | 代码        | 行为     | 输出      |\n|-------------|----------------|-----------------------------------|----------|\n| 1    | `print(1)`     | 调用 `print(1)`，打印 `1`，返回 `None` | `1`      |\n| 2    | `print(2)`     | 调用 `print(2)`，打印 `2`，返回 `None`| `2`      |\n| 3    | `print(None, None)` | 调用 `print(None, None)`，打印 `None None` | `None None` |\n\n`Python`会先计算所有参数，再执行外层函数，`print()`的**返回值永远是 `None`**，但它会先执行打印。\n```python\nfrom operator import floordiv,mod\ndef divide_exact(N,D):\n    \"\"\"Return the quotient and remainder of dividing N by D.\n\n    >>>q,r=divide_exact(2013,10)\n    >>>q\n    201\n    >>>r\n    3\n    \"\"\"\n    return floordiv(N,D),mod(N,D)\n```\n项目中函数的**形式参数用大写字母表示**，提供**文档字符串**：在函数定义`def`的第一行添加注释，**表明这个函数的作用**，并**添加一个实例说明**（可以在`python`**交互式界面**进行演示）。\n```python\ndef fib(n):\n    \"\"\"Compute the nth Fibonacci number?\"\"\"\n\n    pred,curr=1,0\n    k=0\n    while k < n:\n        pred,curr=curr,curr+pred\n        k=k+1\n    return curr\n```\n通过`while`控制语句实现求值斐波那契数列索引的元素值！\n## Higher-Order Functions\n\n\n```python\n\"\"\"Generalization.\"\"\"\n\nfrom math import pi,sqrt\n\ndef area(r,shape_constant):\n    assert r>0,\"A length must be positive\"\n    return r*r*shape_constant\n\ndef area_square(r):\n    return area(r,1)\n\ndef area_circle(r):\n    return area(r,pi)\n\ndef area_hexagon(r):\n    return area(r,3*sqrt(3)/2)\n```\n1. `assert` 的防御性编程作用：**防止非法的负值或零值输入**导致数学错误！\n```pythono\nassert r > 0, \"A length must be positive\"\n```\n2. 将不同图形的面积计算**抽象为统一公式**：`r² × 形状系数`：\n\n - **避免为每个图形重复编写**` r*r `的计算逻辑\n\n- 新增图形时**只需提供对应的形状常数**，**无需修改核心算法**，**增强代码整体的泛化能力**\n\n- **集中维护输入验证逻辑**（如` assert `检查）\n\n```python\n\"\"\"Generalization.\"\"\"\n\ndef identity(k):\n    return k\n\ndef cube(k):\n    return pow(k,3)\n\ndef summation(n,term):\n    \"\"\"Sum the first N terms of a sequence.\n\n    >>> summation(5,cube)\n    225\n    \"\"\"\n    total,k=0,1\n    while k<=n:\n        total,k=total+term(k),k+1\n    return total\n\ndef sum_naturals(n):\n    \"\"\"Sum the first N natural numbers.\n\n    <<< sum_naturals(5)\n    15\n    \"\"\"\n    return summation(n,identity)\n\ndef sum_cubes(n):\n    \"\"\" Sum the first N cubes of natural numbers.\n\n    >>> sum_cubes(5)\n    225\n    \"\"\"\n    return summation(n,cube)\n```\n这里传入的参数`term`是一个已定义的函数名，我们通过参数`term`对求和类型进行修改和新定义，而**整体框架无需改动**。\n```python \n\"\"\"Generalization.\"\"\"\n\ndef make_adder(n):\n    \"\"\"Return a function that takes one argument\n    K and return K+N.\n\n    >>> add_three=make_adder(3)\n    >>> add_three(4)\n    7\n    >>> make_adder(3)(4)\n    7\n    \"\"\"\n    def adder(k):\n        return k+n\n    return adder\n```\n这是一个返回值为函数的函数（函数的嵌套）叫作：\n- 函数工厂（`Factory Pattern`）:\n`make_adder` 是一个 生成函数的函数（工厂）\n根据参数 n 动态生成不同功能的加法函数\n\n以上表明函数与编程语言中的其他值一样，可以**作为参数传递**也可以**作为返回值返回**，这就是**高阶函数**(**Higher-Order Function**)。\n\n## Environments\n### lambda表达式\n`def`和`lambda`表达式的区别：\n| 特性               | Lambda 表达式                          | 普通函数 (`def`)                     |\n|--------------------|---------------------------------------|--------------------------------------|\n| **语法**           | 单行匿名表达式：`lambda x: x + 1`     | 多行命名定义：`def func(x): return x + 1` |\n| **名称**           | 匿名（无函数名）                       | 有函数名（可通过 `func.__name__` 获取） |\n| **代码复杂度**      | 仅限单个表达式（不能包含语句）         | 可包含多行语句、循环、条件等复杂逻辑    |\n| **返回值**         | 自动返回表达式结果                     | 需显式使用 `return`                   |\n| **作用域**         | 只能访问全局变量和参数                 | 可访问全局、局部变量，支持闭包          |\n| **适用场景**       | 简单逻辑、临时函数                     | 复杂逻辑、需复用的功能                 |\n\n### Function Currying(函数柯里化)\n&emsp;&emsp;**柯里化**（`Currying`）是一种将接受多个参数的函数转换为一系列只接受单个参数的函数链式调用的技术，其核心特点是分步传递参数和延迟计算。\n\n```python\ndef curry(f):\n    def g(x):\n        def h(y):\n            return f(x,y)\n        return h\n    return g\n```\n&emsp;&emsp;在这个例子中我们发现柯里化进行了**参数分解**：原始函数` f(x,y) `需要同时接收两个参数，而柯里化后通过`curry(f)` 生成的新函数链 `g(x)(y)` 允许先传` x `再传 `y`。\n\n```python\na=1\ndef f(g):\n    a=2\n    return lambda y:a*g(y)\nf(lambda y:a+y)(a)\n```\n&emsp;&emsp;在这个例子中，先定义了`a=1`全局变量（`local frame`），在函数`f`内部定义局部变量`a=2`（`global frame`）所以结果是（`2*(1+1)`）！\n\n## Abstraction\n&emsp;&emsp;函数抽象是给某个计算过程起个名字，然后整个项目过程都引用这个名字，而不用担心具体的实现细节。\n\n- 需要知道函数需要**传递几个参数**\n- 需要知道**函数的功能**\n- 不需要知道函数的**实现过程**\n\n比如平方函数：\n\n```python\ndef square(x):\n    return x*x\n```\n```python\nfrom operator import mul\ndef square(x):\n    return mul(x,x-1)+x\n```\n\n```python\ndef square(x):\n    return pow(x,2)\n```\n封面来源于`CS61A`中`lecture1`的`slide`，是其标志性的表达式树！\n","source":"_posts/Python/The-CS61A-Lab-Notebook1.md","raw":"---\ntitle: The CS61A Lab Notebook1\ndate: 2025-07-25 23:11:35\ntags: [Python,function]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/The-CS61A-Lab-Notebook.png\ncategory: Python\ncategory_bar: true\ndescription: This blog will document my notes and insights as I work through this challenging yet rewarding curriculum!\n---\n\n\n\n{%note info%}笔者在学校仅仅学习了C++，对其他语言知之甚少，然而在实际应用中，Python的应用场景之广泛令人惊叹：无论是数学建模中的数据可视化、数据分析，还是计算机视觉领域的机器学习与深度学习，Python都展现出无可替代的重要性。虽然高中时曾对Python有所涉猎，但不成体系。{%endnote%}\n\n{%note info%}我深知在计算机领域，自主学习能力至关重要。然而平日既要应对繁重的课业，又要准备各类竞赛，实在分身乏术。值此暑假时间充裕之际，我决定研读计算机领域的标杆课程——CS61A。希望能够有所收获！以下是我的学习笔记，大家共勉！{%endnote%}\n\n## What's the CS61A?\n&emsp;&emsp;`CS61A`是加州大学伯克利分校（`UC Berkeley`）计算机科学专业的入门课程，全称为\"计算机程序的结构与解释\"(`Structure and Interpretation of Computer Programs`)。这门课程**采用`Python`作为主要教学语言**，同时涵盖`Scheme`和`SQL`。课程核心在于**培养计算思维**而非单纯编程技巧，**重点教授抽象思想、函数式编程和元语言抽象**，被誉为\"真正教会学生如何思考的计算入门课\"！\n\n这里是[CS61A官方网站](https://cs61a.org/)，里面包含了相关的`videos`、`slides`和`homework`帮助你学习！\n英语和我一样不很出彩的可以观看b站双语翻译版本：\n[【完结】【CS61A精翻双语·英文原声】伯克利大学《计算机程序的结构与解释》(2024)](https://www.bilibili.com/video/BV1sy411z7nA?spm_id_from=333.788.videopod.sections&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n\n\n## Functions\n```python\ndef <name>(<formal parameters>):\n    return <return expression>\n ```\n \n函数与变量的区别：变量是**一次性赋值**的，函数在**每次调用时会重新计算**。\n```python\n>>> radius=10\n>>> area=mul(radius,radius)*pi\n>>> area\n314.1592653589793\n>>> radius=20\n>>> area\n314.1592653589793\n```\n这里我们发现变量`area`在第一次进行赋值后，尽管`radius`进行改变，但是其值不再发生变化，可见赋值是一次性的，不是动态的！\n```python\n>>> def area():\n...     return mul(radius,radius)*pi\n...\n>>> area()\n1256.6370614359173\n>>> radius=10\n>>> area()\n314.1592653589793\n>>> radius=1\n>>> area()\n3.141592653589793\n```\n于是我们考虑将`area`变成函数，发现每次调用`area()`时，`area()`都会根据表达式的值重新计算，做到了动态变化！\n\n```python\n>>> print(print(1),print(2))\n1\n2\nNone None\n```\n| 步骤 | 代码        | 行为     | 输出      |\n|-------------|----------------|-----------------------------------|----------|\n| 1    | `print(1)`     | 调用 `print(1)`，打印 `1`，返回 `None` | `1`      |\n| 2    | `print(2)`     | 调用 `print(2)`，打印 `2`，返回 `None`| `2`      |\n| 3    | `print(None, None)` | 调用 `print(None, None)`，打印 `None None` | `None None` |\n\n`Python`会先计算所有参数，再执行外层函数，`print()`的**返回值永远是 `None`**，但它会先执行打印。\n```python\nfrom operator import floordiv,mod\ndef divide_exact(N,D):\n    \"\"\"Return the quotient and remainder of dividing N by D.\n\n    >>>q,r=divide_exact(2013,10)\n    >>>q\n    201\n    >>>r\n    3\n    \"\"\"\n    return floordiv(N,D),mod(N,D)\n```\n项目中函数的**形式参数用大写字母表示**，提供**文档字符串**：在函数定义`def`的第一行添加注释，**表明这个函数的作用**，并**添加一个实例说明**（可以在`python`**交互式界面**进行演示）。\n```python\ndef fib(n):\n    \"\"\"Compute the nth Fibonacci number?\"\"\"\n\n    pred,curr=1,0\n    k=0\n    while k < n:\n        pred,curr=curr,curr+pred\n        k=k+1\n    return curr\n```\n通过`while`控制语句实现求值斐波那契数列索引的元素值！\n## Higher-Order Functions\n\n\n```python\n\"\"\"Generalization.\"\"\"\n\nfrom math import pi,sqrt\n\ndef area(r,shape_constant):\n    assert r>0,\"A length must be positive\"\n    return r*r*shape_constant\n\ndef area_square(r):\n    return area(r,1)\n\ndef area_circle(r):\n    return area(r,pi)\n\ndef area_hexagon(r):\n    return area(r,3*sqrt(3)/2)\n```\n1. `assert` 的防御性编程作用：**防止非法的负值或零值输入**导致数学错误！\n```pythono\nassert r > 0, \"A length must be positive\"\n```\n2. 将不同图形的面积计算**抽象为统一公式**：`r² × 形状系数`：\n\n - **避免为每个图形重复编写**` r*r `的计算逻辑\n\n- 新增图形时**只需提供对应的形状常数**，**无需修改核心算法**，**增强代码整体的泛化能力**\n\n- **集中维护输入验证逻辑**（如` assert `检查）\n\n```python\n\"\"\"Generalization.\"\"\"\n\ndef identity(k):\n    return k\n\ndef cube(k):\n    return pow(k,3)\n\ndef summation(n,term):\n    \"\"\"Sum the first N terms of a sequence.\n\n    >>> summation(5,cube)\n    225\n    \"\"\"\n    total,k=0,1\n    while k<=n:\n        total,k=total+term(k),k+1\n    return total\n\ndef sum_naturals(n):\n    \"\"\"Sum the first N natural numbers.\n\n    <<< sum_naturals(5)\n    15\n    \"\"\"\n    return summation(n,identity)\n\ndef sum_cubes(n):\n    \"\"\" Sum the first N cubes of natural numbers.\n\n    >>> sum_cubes(5)\n    225\n    \"\"\"\n    return summation(n,cube)\n```\n这里传入的参数`term`是一个已定义的函数名，我们通过参数`term`对求和类型进行修改和新定义，而**整体框架无需改动**。\n```python \n\"\"\"Generalization.\"\"\"\n\ndef make_adder(n):\n    \"\"\"Return a function that takes one argument\n    K and return K+N.\n\n    >>> add_three=make_adder(3)\n    >>> add_three(4)\n    7\n    >>> make_adder(3)(4)\n    7\n    \"\"\"\n    def adder(k):\n        return k+n\n    return adder\n```\n这是一个返回值为函数的函数（函数的嵌套）叫作：\n- 函数工厂（`Factory Pattern`）:\n`make_adder` 是一个 生成函数的函数（工厂）\n根据参数 n 动态生成不同功能的加法函数\n\n以上表明函数与编程语言中的其他值一样，可以**作为参数传递**也可以**作为返回值返回**，这就是**高阶函数**(**Higher-Order Function**)。\n\n## Environments\n### lambda表达式\n`def`和`lambda`表达式的区别：\n| 特性               | Lambda 表达式                          | 普通函数 (`def`)                     |\n|--------------------|---------------------------------------|--------------------------------------|\n| **语法**           | 单行匿名表达式：`lambda x: x + 1`     | 多行命名定义：`def func(x): return x + 1` |\n| **名称**           | 匿名（无函数名）                       | 有函数名（可通过 `func.__name__` 获取） |\n| **代码复杂度**      | 仅限单个表达式（不能包含语句）         | 可包含多行语句、循环、条件等复杂逻辑    |\n| **返回值**         | 自动返回表达式结果                     | 需显式使用 `return`                   |\n| **作用域**         | 只能访问全局变量和参数                 | 可访问全局、局部变量，支持闭包          |\n| **适用场景**       | 简单逻辑、临时函数                     | 复杂逻辑、需复用的功能                 |\n\n### Function Currying(函数柯里化)\n&emsp;&emsp;**柯里化**（`Currying`）是一种将接受多个参数的函数转换为一系列只接受单个参数的函数链式调用的技术，其核心特点是分步传递参数和延迟计算。\n\n```python\ndef curry(f):\n    def g(x):\n        def h(y):\n            return f(x,y)\n        return h\n    return g\n```\n&emsp;&emsp;在这个例子中我们发现柯里化进行了**参数分解**：原始函数` f(x,y) `需要同时接收两个参数，而柯里化后通过`curry(f)` 生成的新函数链 `g(x)(y)` 允许先传` x `再传 `y`。\n\n```python\na=1\ndef f(g):\n    a=2\n    return lambda y:a*g(y)\nf(lambda y:a+y)(a)\n```\n&emsp;&emsp;在这个例子中，先定义了`a=1`全局变量（`local frame`），在函数`f`内部定义局部变量`a=2`（`global frame`）所以结果是（`2*(1+1)`）！\n\n## Abstraction\n&emsp;&emsp;函数抽象是给某个计算过程起个名字，然后整个项目过程都引用这个名字，而不用担心具体的实现细节。\n\n- 需要知道函数需要**传递几个参数**\n- 需要知道**函数的功能**\n- 不需要知道函数的**实现过程**\n\n比如平方函数：\n\n```python\ndef square(x):\n    return x*x\n```\n```python\nfrom operator import mul\ndef square(x):\n    return mul(x,x-1)+x\n```\n\n```python\ndef square(x):\n    return pow(x,2)\n```\n封面来源于`CS61A`中`lecture1`的`slide`，是其标志性的表达式树！\n","slug":"Python/The-CS61A-Lab-Notebook1","published":1,"updated":"2025-08-21T09:49:32.257Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcq001f40w32rd58gyq","content":"<div class=\"note note-info\">\n            <p>笔者在学校仅仅学习了C++，对其他语言知之甚少，然而在实际应用中，Python的应用场景之广泛令人惊叹：无论是数学建模中的数据可视化、数据分析，还是计算机视觉领域的机器学习与深度学习，Python都展现出无可替代的重要性。虽然高中时曾对Python有所涉猎，但不成体系。</p>\n          </div>\n<div class=\"note note-info\">\n            <p>我深知在计算机领域，自主学习能力至关重要。然而平日既要应对繁重的课业，又要准备各类竞赛，实在分身乏术。值此暑假时间充裕之际，我决定研读计算机领域的标杆课程——CS61A。希望能够有所收获！以下是我的学习笔记，大家共勉！</p>\n          </div>\n<h2 id=\"What’s-the-CS61A\">What’s the CS61A?</h2>\n<p>  <code>CS61A</code>是加州大学伯克利分校（<code>UC Berkeley</code>）计算机科学专业的入门课程，全称为\"计算机程序的结构与解释\"(<code>Structure and Interpretation of Computer Programs</code>)。这门课程<strong>采用<code>Python</code>作为主要教学语言</strong>，同时涵盖<code>Scheme</code>和<code>SQL</code>。课程核心在于<strong>培养计算思维</strong>而非单纯编程技巧，<strong>重点教授抽象思想、函数式编程和元语言抽象</strong>，被誉为\"真正教会学生如何思考的计算入门课\"！</p>\n<p>这里是<a href=\"https://cs61a.org/\">CS61A官方网站</a>，里面包含了相关的<code>videos</code>、<code>slides</code>和<code>homework</code>帮助你学习！<br>\n英语和我一样不很出彩的可以观看b站双语翻译版本：<br>\n<a href=\"https://www.bilibili.com/video/BV1sy411z7nA?spm_id_from=333.788.videopod.sections&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">【完结】【CS61A精翻双语·英文原声】伯克利大学《计算机程序的结构与解释》(2024)</a></p>\n<h2 id=\"Functions\">Functions</h2>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class=\"hljs-keyword\">return</span> &lt;<span class=\"hljs-keyword\">return</span> expression&gt;<br></code></pre></td></tr></tbody></table></figure>\n<p>函数与变量的区别：变量是<strong>一次性赋值</strong>的，函数在<strong>每次调用时会重新计算</strong>。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">10</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area=mul(radius,radius)*pi<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area<br><span class=\"hljs-number\">314.1592653589793</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">20</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area<br><span class=\"hljs-number\">314.1592653589793</span><br></code></pre></td></tr></tbody></table></figure>\n<p>这里我们发现变量<code>area</code>在第一次进行赋值后，尽管<code>radius</code>进行改变，但是其值不再发生变化，可见赋值是一次性的，不是动态的！</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area</span>():<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">return</span> mul(radius,radius)*pi<br>...<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">1256.6370614359173</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">10</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">314.1592653589793</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">1</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">3.141592653589793</span><br></code></pre></td></tr></tbody></table></figure>\n<p>于是我们考虑将<code>area</code>变成函数，发现每次调用<code>area()</code>时，<code>area()</code>都会根据表达式的值重新计算，做到了动态变化！</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-number\">1</span>),<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-number\">2</span>))<br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-literal\">None</span> <span class=\"hljs-literal\">None</span><br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>代码</th>\n<th>行为</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>print(1)</code></td>\n<td>调用 <code>print(1)</code>，打印 <code>1</code>，返回 <code>None</code></td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>print(2)</code></td>\n<td>调用 <code>print(2)</code>，打印 <code>2</code>，返回 <code>None</code></td>\n<td><code>2</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>print(None, None)</code></td>\n<td>调用 <code>print(None, None)</code>，打印 <code>None None</code></td>\n<td><code>None None</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>Python</code>会先计算所有参数，再执行外层函数，<code>print()</code>的<strong>返回值永远是 <code>None</code></strong>，但它会先执行打印。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> operator <span class=\"hljs-keyword\">import</span> floordiv,mod<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">divide_exact</span>(<span class=\"hljs-params\">N,D</span>):<br>    <span class=\"hljs-string\">\"\"\"Return the quotient and remainder of dividing N by D.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt;q,r=divide_exact(2013,10)</span><br><span class=\"hljs-string\">    &gt;&gt;&gt;q</span><br><span class=\"hljs-string\">    201</span><br><span class=\"hljs-string\">    &gt;&gt;&gt;r</span><br><span class=\"hljs-string\">    3</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    <span class=\"hljs-keyword\">return</span> floordiv(N,D),mod(N,D)<br></code></pre></td></tr></tbody></table></figure>\n<p>项目中函数的<strong>形式参数用大写字母表示</strong>，提供<strong>文档字符串</strong>：在函数定义<code>def</code>的第一行添加注释，<strong>表明这个函数的作用</strong>，并<strong>添加一个实例说明</strong>（可以在<code>python</code><strong>交互式界面</strong>进行演示）。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">\"\"\"Compute the nth Fibonacci number?\"\"\"</span><br><br>    pred,curr=<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span><br>    k=<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">while</span> k &lt; n:<br>        pred,curr=curr,curr+pred<br>        k=k+<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> curr<br></code></pre></td></tr></tbody></table></figure>\n<p>通过<code>while</code>控制语句实现求值斐波那契数列索引的元素值！</p>\n<h2 id=\"Higher-Order-Functions\">Higher-Order Functions</h2>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\"Generalization.\"\"\"</span><br><br><span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> pi,sqrt<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area</span>(<span class=\"hljs-params\">r,shape_constant</span>):<br>    <span class=\"hljs-keyword\">assert</span> r&gt;<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">\"A length must be positive\"</span><br>    <span class=\"hljs-keyword\">return</span> r*r*shape_constant<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_square</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_circle</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,pi)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_hexagon</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,<span class=\"hljs-number\">3</span>*sqrt(<span class=\"hljs-number\">3</span>)/<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></tbody></table></figure>\n<ol>\n<li><code>assert</code> 的防御性编程作用：<strong>防止非法的负值或零值输入</strong>导致数学错误！</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pythono\">assert r &gt; 0, \"A length must be positive\"<br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"2\">\n<li>将不同图形的面积计算<strong>抽象为统一公式</strong>：<code>r² × 形状系数</code>：</li>\n</ol>\n<ul>\n<li>\n<p><strong>避免为每个图形重复编写</strong><code>r*r</code>的计算逻辑</p>\n</li>\n<li>\n<p>新增图形时<strong>只需提供对应的形状常数</strong>，<strong>无需修改核心算法</strong>，<strong>增强代码整体的泛化能力</strong></p>\n</li>\n<li>\n<p><strong>集中维护输入验证逻辑</strong>（如<code>assert</code>检查）</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\"Generalization.\"\"\"</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">identity</span>(<span class=\"hljs-params\">k</span>):<br>    <span class=\"hljs-keyword\">return</span> k<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cube</span>(<span class=\"hljs-params\">k</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(k,<span class=\"hljs-number\">3</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">summation</span>(<span class=\"hljs-params\">n,term</span>):<br>    <span class=\"hljs-string\">\"\"\"Sum the first N terms of a sequence.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; summation(5,cube)</span><br><span class=\"hljs-string\">    225</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    total,k=<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">while</span> k&lt;=n:<br>        total,k=total+term(k),k+<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> total<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sum_naturals</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">\"\"\"Sum the first N natural numbers.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &lt;&lt;&lt; sum_naturals(5)</span><br><span class=\"hljs-string\">    15</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    <span class=\"hljs-keyword\">return</span> summation(n,identity)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sum_cubes</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">\"\"\" Sum the first N cubes of natural numbers.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; sum_cubes(5)</span><br><span class=\"hljs-string\">    225</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    <span class=\"hljs-keyword\">return</span> summation(n,cube)<br></code></pre></td></tr></tbody></table></figure>\n<p>这里传入的参数<code>term</code>是一个已定义的函数名，我们通过参数<code>term</code>对求和类型进行修改和新定义，而<strong>整体框架无需改动</strong>。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">\"\"\"Generalization.\"\"\"</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_adder</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">\"\"\"Return a function that takes one argument</span><br><span class=\"hljs-string\">    K and return K+N.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; add_three=make_adder(3)</span><br><span class=\"hljs-string\">    &gt;&gt;&gt; add_three(4)</span><br><span class=\"hljs-string\">    7</span><br><span class=\"hljs-string\">    &gt;&gt;&gt; make_adder(3)(4)</span><br><span class=\"hljs-string\">    7</span><br><span class=\"hljs-string\">    \"\"\"</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">adder</span>(<span class=\"hljs-params\">k</span>):<br>        <span class=\"hljs-keyword\">return</span> k+n<br>    <span class=\"hljs-keyword\">return</span> adder<br></code></pre></td></tr></tbody></table></figure>\n<p>这是一个返回值为函数的函数（函数的嵌套）叫作：</p>\n<ul>\n<li>函数工厂（<code>Factory Pattern</code>）:<br>\n<code>make_adder</code> 是一个 生成函数的函数（工厂）<br>\n根据参数 n 动态生成不同功能的加法函数</li>\n</ul>\n<p>以上表明函数与编程语言中的其他值一样，可以<strong>作为参数传递</strong>也可以<strong>作为返回值返回</strong>，这就是<strong>高阶函数</strong>(<strong>Higher-Order Function</strong>)。</p>\n<h2 id=\"Environments\">Environments</h2>\n<h3 id=\"lambda表达式\">lambda表达式</h3>\n<p><code>def</code>和<code>lambda</code>表达式的区别：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Lambda 表达式</th>\n<th>普通函数 (<code>def</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法</strong></td>\n<td>单行匿名表达式：<code>lambda x: x + 1</code></td>\n<td>多行命名定义：<code>def func(x): return x + 1</code></td>\n</tr>\n<tr>\n<td><strong>名称</strong></td>\n<td>匿名（无函数名）</td>\n<td>有函数名（可通过 <code>func.__name__</code> 获取）</td>\n</tr>\n<tr>\n<td><strong>代码复杂度</strong></td>\n<td>仅限单个表达式（不能包含语句）</td>\n<td>可包含多行语句、循环、条件等复杂逻辑</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>自动返回表达式结果</td>\n<td>需显式使用 <code>return</code></td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>只能访问全局变量和参数</td>\n<td>可访问全局、局部变量，支持闭包</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>简单逻辑、临时函数</td>\n<td>复杂逻辑、需复用的功能</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Function-Currying-函数柯里化\">Function Currying(函数柯里化)</h3>\n<p>  <strong>柯里化</strong>（<code>Currying</code>）是一种将接受多个参数的函数转换为一系列只接受单个参数的函数链式调用的技术，其核心特点是分步传递参数和延迟计算。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">f</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\">x</span>):<br>        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-params\">y</span>):<br>            <span class=\"hljs-keyword\">return</span> f(x,y)<br>        <span class=\"hljs-keyword\">return</span> h<br>    <span class=\"hljs-keyword\">return</span> g<br></code></pre></td></tr></tbody></table></figure>\n<p>  在这个例子中我们发现柯里化进行了<strong>参数分解</strong>：原始函数<code>f(x,y)</code>需要同时接收两个参数，而柯里化后通过<code>curry(f)</code> 生成的新函数链 <code>g(x)(y)</code> 允许先传<code>x</code>再传 <code>y</code>。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a=<span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">g</span>):<br>    a=<span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">lambda</span> y:a*g(y)<br>f(<span class=\"hljs-keyword\">lambda</span> y:a+y)(a)<br></code></pre></td></tr></tbody></table></figure>\n<p>  在这个例子中，先定义了<code>a=1</code>全局变量（<code>local frame</code>），在函数<code>f</code>内部定义局部变量<code>a=2</code>（<code>global frame</code>）所以结果是（<code>2*(1+1)</code>）！</p>\n<h2 id=\"Abstraction\">Abstraction</h2>\n<p>  函数抽象是给某个计算过程起个名字，然后整个项目过程都引用这个名字，而不用担心具体的实现细节。</p>\n<ul>\n<li>需要知道函数需要<strong>传递几个参数</strong></li>\n<li>需要知道<strong>函数的功能</strong></li>\n<li>不需要知道函数的<strong>实现过程</strong></li>\n</ul>\n<p>比如平方函数：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> x*x<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> operator <span class=\"hljs-keyword\">import</span> mul<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> mul(x,x-<span class=\"hljs-number\">1</span>)+x<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(x,<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源于<code>CS61A</code>中<code>lecture1</code>的<code>slide</code>，是其标志性的表达式树！</p>\n","excerpt":"","more":"<div class=\"note note-info\">\n            <p>笔者在学校仅仅学习了C++，对其他语言知之甚少，然而在实际应用中，Python的应用场景之广泛令人惊叹：无论是数学建模中的数据可视化、数据分析，还是计算机视觉领域的机器学习与深度学习，Python都展现出无可替代的重要性。虽然高中时曾对Python有所涉猎，但不成体系。</p>\n          </div>\n<div class=\"note note-info\">\n            <p>我深知在计算机领域，自主学习能力至关重要。然而平日既要应对繁重的课业，又要准备各类竞赛，实在分身乏术。值此暑假时间充裕之际，我决定研读计算机领域的标杆课程——CS61A。希望能够有所收获！以下是我的学习笔记，大家共勉！</p>\n          </div>\n<h2 id=\"What’s-the-CS61A\">What’s the CS61A?</h2>\n<p>  <code>CS61A</code>是加州大学伯克利分校（<code>UC Berkeley</code>）计算机科学专业的入门课程，全称为&quot;计算机程序的结构与解释&quot;(<code>Structure and Interpretation of Computer Programs</code>)。这门课程<strong>采用<code>Python</code>作为主要教学语言</strong>，同时涵盖<code>Scheme</code>和<code>SQL</code>。课程核心在于<strong>培养计算思维</strong>而非单纯编程技巧，<strong>重点教授抽象思想、函数式编程和元语言抽象</strong>，被誉为&quot;真正教会学生如何思考的计算入门课&quot;！</p>\n<p>这里是<a href=\"https://cs61a.org/\">CS61A官方网站</a>，里面包含了相关的<code>videos</code>、<code>slides</code>和<code>homework</code>帮助你学习！<br>\n英语和我一样不很出彩的可以观看b站双语翻译版本：<br>\n<a href=\"https://www.bilibili.com/video/BV1sy411z7nA?spm_id_from=333.788.videopod.sections&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">【完结】【CS61A精翻双语·英文原声】伯克利大学《计算机程序的结构与解释》(2024)</a></p>\n<h2 id=\"Functions\">Functions</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> &lt;name&gt;(&lt;formal parameters&gt;):<br>    <span class=\"hljs-keyword\">return</span> &lt;<span class=\"hljs-keyword\">return</span> expression&gt;<br></code></pre></td></tr></table></figure>\n<p>函数与变量的区别：变量是<strong>一次性赋值</strong>的，函数在<strong>每次调用时会重新计算</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">10</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area=mul(radius,radius)*pi<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area<br><span class=\"hljs-number\">314.1592653589793</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">20</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area<br><span class=\"hljs-number\">314.1592653589793</span><br></code></pre></td></tr></table></figure>\n<p>这里我们发现变量<code>area</code>在第一次进行赋值后，尽管<code>radius</code>进行改变，但是其值不再发生变化，可见赋值是一次性的，不是动态的！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area</span>():<br><span class=\"hljs-meta\">... </span>    <span class=\"hljs-keyword\">return</span> mul(radius,radius)*pi<br>...<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">1256.6370614359173</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">10</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">314.1592653589793</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>radius=<span class=\"hljs-number\">1</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>area()<br><span class=\"hljs-number\">3.141592653589793</span><br></code></pre></td></tr></table></figure>\n<p>于是我们考虑将<code>area</code>变成函数，发现每次调用<code>area()</code>时，<code>area()</code>都会根据表达式的值重新计算，做到了动态变化！</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-number\">1</span>),<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-number\">2</span>))<br><span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">2</span><br><span class=\"hljs-literal\">None</span> <span class=\"hljs-literal\">None</span><br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>步骤</th>\n<th>代码</th>\n<th>行为</th>\n<th>输出</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td><code>print(1)</code></td>\n<td>调用 <code>print(1)</code>，打印 <code>1</code>，返回 <code>None</code></td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td><code>print(2)</code></td>\n<td>调用 <code>print(2)</code>，打印 <code>2</code>，返回 <code>None</code></td>\n<td><code>2</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td><code>print(None, None)</code></td>\n<td>调用 <code>print(None, None)</code>，打印 <code>None None</code></td>\n<td><code>None None</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>Python</code>会先计算所有参数，再执行外层函数，<code>print()</code>的<strong>返回值永远是 <code>None</code></strong>，但它会先执行打印。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> operator <span class=\"hljs-keyword\">import</span> floordiv,mod<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">divide_exact</span>(<span class=\"hljs-params\">N,D</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;Return the quotient and remainder of dividing N by D.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt;q,r=divide_exact(2013,10)</span><br><span class=\"hljs-string\">    &gt;&gt;&gt;q</span><br><span class=\"hljs-string\">    201</span><br><span class=\"hljs-string\">    &gt;&gt;&gt;r</span><br><span class=\"hljs-string\">    3</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">return</span> floordiv(N,D),mod(N,D)<br></code></pre></td></tr></table></figure>\n<p>项目中函数的<strong>形式参数用大写字母表示</strong>，提供<strong>文档字符串</strong>：在函数定义<code>def</code>的第一行添加注释，<strong>表明这个函数的作用</strong>，并<strong>添加一个实例说明</strong>（可以在<code>python</code><strong>交互式界面</strong>进行演示）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;Compute the nth Fibonacci number?&quot;&quot;&quot;</span><br><br>    pred,curr=<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span><br>    k=<span class=\"hljs-number\">0</span><br>    <span class=\"hljs-keyword\">while</span> k &lt; n:<br>        pred,curr=curr,curr+pred<br>        k=k+<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> curr<br></code></pre></td></tr></table></figure>\n<p>通过<code>while</code>控制语句实现求值斐波那契数列索引的元素值！</p>\n<h2 id=\"Higher-Order-Functions\">Higher-Order Functions</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;&quot;&quot;Generalization.&quot;&quot;&quot;</span><br><br><span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> pi,sqrt<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area</span>(<span class=\"hljs-params\">r,shape_constant</span>):<br>    <span class=\"hljs-keyword\">assert</span> r&gt;<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&quot;A length must be positive&quot;</span><br>    <span class=\"hljs-keyword\">return</span> r*r*shape_constant<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_square</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,<span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_circle</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,pi)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">area_hexagon</span>(<span class=\"hljs-params\">r</span>):<br>    <span class=\"hljs-keyword\">return</span> area(r,<span class=\"hljs-number\">3</span>*sqrt(<span class=\"hljs-number\">3</span>)/<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n<ol>\n<li><code>assert</code> 的防御性编程作用：<strong>防止非法的负值或零值输入</strong>导致数学错误！</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs pythono\">assert r &gt; 0, &quot;A length must be positive&quot;<br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>将不同图形的面积计算<strong>抽象为统一公式</strong>：<code>r² × 形状系数</code>：</li>\n</ol>\n<ul>\n<li>\n<p><strong>避免为每个图形重复编写</strong><code>r*r</code>的计算逻辑</p>\n</li>\n<li>\n<p>新增图形时<strong>只需提供对应的形状常数</strong>，<strong>无需修改核心算法</strong>，<strong>增强代码整体的泛化能力</strong></p>\n</li>\n<li>\n<p><strong>集中维护输入验证逻辑</strong>（如<code>assert</code>检查）</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;&quot;&quot;Generalization.&quot;&quot;&quot;</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">identity</span>(<span class=\"hljs-params\">k</span>):<br>    <span class=\"hljs-keyword\">return</span> k<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">cube</span>(<span class=\"hljs-params\">k</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(k,<span class=\"hljs-number\">3</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">summation</span>(<span class=\"hljs-params\">n,term</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;Sum the first N terms of a sequence.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; summation(5,cube)</span><br><span class=\"hljs-string\">    225</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    total,k=<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">while</span> k&lt;=n:<br>        total,k=total+term(k),k+<span class=\"hljs-number\">1</span><br>    <span class=\"hljs-keyword\">return</span> total<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sum_naturals</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;Sum the first N natural numbers.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &lt;&lt;&lt; sum_naturals(5)</span><br><span class=\"hljs-string\">    15</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">return</span> summation(n,identity)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">sum_cubes</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot; Sum the first N cubes of natural numbers.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; sum_cubes(5)</span><br><span class=\"hljs-string\">    225</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">return</span> summation(n,cube)<br></code></pre></td></tr></table></figure>\n<p>这里传入的参数<code>term</code>是一个已定义的函数名，我们通过参数<code>term</code>对求和类型进行修改和新定义，而<strong>整体框架无需改动</strong>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;&quot;&quot;Generalization.&quot;&quot;&quot;</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">make_adder</span>(<span class=\"hljs-params\">n</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;Return a function that takes one argument</span><br><span class=\"hljs-string\">    K and return K+N.</span><br><span class=\"hljs-string\"></span><br><span class=\"hljs-string\">    &gt;&gt;&gt; add_three=make_adder(3)</span><br><span class=\"hljs-string\">    &gt;&gt;&gt; add_three(4)</span><br><span class=\"hljs-string\">    7</span><br><span class=\"hljs-string\">    &gt;&gt;&gt; make_adder(3)(4)</span><br><span class=\"hljs-string\">    7</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">adder</span>(<span class=\"hljs-params\">k</span>):<br>        <span class=\"hljs-keyword\">return</span> k+n<br>    <span class=\"hljs-keyword\">return</span> adder<br></code></pre></td></tr></table></figure>\n<p>这是一个返回值为函数的函数（函数的嵌套）叫作：</p>\n<ul>\n<li>函数工厂（<code>Factory Pattern</code>）:<br>\n<code>make_adder</code> 是一个 生成函数的函数（工厂）<br>\n根据参数 n 动态生成不同功能的加法函数</li>\n</ul>\n<p>以上表明函数与编程语言中的其他值一样，可以<strong>作为参数传递</strong>也可以<strong>作为返回值返回</strong>，这就是<strong>高阶函数</strong>(<strong>Higher-Order Function</strong>)。</p>\n<h2 id=\"Environments\">Environments</h2>\n<h3 id=\"lambda表达式\">lambda表达式</h3>\n<p><code>def</code>和<code>lambda</code>表达式的区别：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>Lambda 表达式</th>\n<th>普通函数 (<code>def</code>)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>语法</strong></td>\n<td>单行匿名表达式：<code>lambda x: x + 1</code></td>\n<td>多行命名定义：<code>def func(x): return x + 1</code></td>\n</tr>\n<tr>\n<td><strong>名称</strong></td>\n<td>匿名（无函数名）</td>\n<td>有函数名（可通过 <code>func.__name__</code> 获取）</td>\n</tr>\n<tr>\n<td><strong>代码复杂度</strong></td>\n<td>仅限单个表达式（不能包含语句）</td>\n<td>可包含多行语句、循环、条件等复杂逻辑</td>\n</tr>\n<tr>\n<td><strong>返回值</strong></td>\n<td>自动返回表达式结果</td>\n<td>需显式使用 <code>return</code></td>\n</tr>\n<tr>\n<td><strong>作用域</strong></td>\n<td>只能访问全局变量和参数</td>\n<td>可访问全局、局部变量，支持闭包</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>简单逻辑、临时函数</td>\n<td>复杂逻辑、需复用的功能</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Function-Currying-函数柯里化\">Function Currying(函数柯里化)</h3>\n<p>  <strong>柯里化</strong>（<code>Currying</code>）是一种将接受多个参数的函数转换为一系列只接受单个参数的函数链式调用的技术，其核心特点是分步传递参数和延迟计算。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">f</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">g</span>(<span class=\"hljs-params\">x</span>):<br>        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">h</span>(<span class=\"hljs-params\">y</span>):<br>            <span class=\"hljs-keyword\">return</span> f(x,y)<br>        <span class=\"hljs-keyword\">return</span> h<br>    <span class=\"hljs-keyword\">return</span> g<br></code></pre></td></tr></table></figure>\n<p>  在这个例子中我们发现柯里化进行了<strong>参数分解</strong>：原始函数<code>f(x,y)</code>需要同时接收两个参数，而柯里化后通过<code>curry(f)</code> 生成的新函数链 <code>g(x)(y)</code> 允许先传<code>x</code>再传 <code>y</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">a=<span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">g</span>):<br>    a=<span class=\"hljs-number\">2</span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">lambda</span> y:a*g(y)<br>f(<span class=\"hljs-keyword\">lambda</span> y:a+y)(a)<br></code></pre></td></tr></table></figure>\n<p>  在这个例子中，先定义了<code>a=1</code>全局变量（<code>local frame</code>），在函数<code>f</code>内部定义局部变量<code>a=2</code>（<code>global frame</code>）所以结果是（<code>2*(1+1)</code>）！</p>\n<h2 id=\"Abstraction\">Abstraction</h2>\n<p>  函数抽象是给某个计算过程起个名字，然后整个项目过程都引用这个名字，而不用担心具体的实现细节。</p>\n<ul>\n<li>需要知道函数需要<strong>传递几个参数</strong></li>\n<li>需要知道<strong>函数的功能</strong></li>\n<li>不需要知道函数的<strong>实现过程</strong></li>\n</ul>\n<p>比如平方函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> x*x<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">from</span> operator <span class=\"hljs-keyword\">import</span> mul<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> mul(x,x-<span class=\"hljs-number\">1</span>)+x<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">square</span>(<span class=\"hljs-params\">x</span>):<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(x,<span class=\"hljs-number\">2</span>)<br></code></pre></td></tr></table></figure>\n<p>封面来源于<code>CS61A</code>中<code>lecture1</code>的<code>slide</code>，是其标志性的表达式树！</p>\n"},{"title":"College Physics 2","date":"2025-09-02T13:11:58.000Z","category_bar":true,"archive":true,"math":true,"_content":"\n理想气体的**物态方程**\n\n$$PV=\\frac{m}{M_{mol}}RT$$\n\n$\\frac{m}{M}$ 叫做物质的量\n\n $R $ 叫做普适气体常量\n\n$$PV=nRT$$\n\n\n道尔顿**分压定律**：混合气体的压强等于各个气体的压强之和\n$$ P=P_{1}+P_{2}+P_{3}+...=(n_{1}+n_{2}+n_{3}+...)kT$$\n\n\n$$ \\begin{aligned}\nP &= \\frac{F}{S} = \\frac{I}{l_2l_3\\Delta t} = \\frac{m_0}{l_1l_2l_3} \\sum_{i=1}^{N} v_{ix}^2 = \\frac{Nm_0}{l_1l_2l_3} \\frac{\\sum_{i=1}^{N} v_{ix}^2}{N} \n= \\frac{N}{V}m_0\\overline{v_x^2} = nm_0\\overline{v_x^2} \n= \\frac{1}{3}nm_0\\overline{v^2} = \\frac{2}{3}n\\overline{\\varepsilon}\n\\end{aligned} $$\n\n又因为：\n\n$$\\overline{\\varepsilon} = \\frac{1}{2} m_0 \\overline{v^2} = \\frac{3}{2} kT$$\n所以，**方均根速率**：\n$$\\sqrt{\\overline{v^2}} = \\sqrt{\\frac{3kT}{m_0}} = \\sqrt{\\frac{3RT}{M}}$$\n\n### 能量均分定理、内能\n每个分子的**平均动能**：\n$$\\overline{E_k} = \\frac{i}{2}kT$$\n\n其中：$k = \\frac{R}{N_A}$\n\n| 分子类型           | 原子数 (N) | 平动自由度 | 转动自由度 | 振动自由度 | 总自由度 (3N) |\n| :----------------- | :--------: | :--------: | :--------: | :--------: | :-----------: |\n| **单原子**         |     1      |     3      |     0      |     0      |       3       |\n| **双原子（线性）** |     2      |     3      |     2      |     1      |       6       |\n| **多原子（线性）** |     N      |     3      |     2      |  3N - 5    |      3N       |\n| **多原子（非线性）**|     N      |     3      |     3      |  3N - 6    |      3N       |\n\n单原子分子有三个自由度：\n$$\\overline{E_k} = \\frac{3}{2}kT$$\n\n双原子分子有五个自由度：\n$$\\overline{E_k} = \\frac{5}{2}kT$$\n\n多原子分子有六个自由度：\n\n$$\\overline{E_k} = 3kT$$\n\n理想气体内能：\n$$E= \\frac{m}{M}\\frac{i}{2}RT $$\n\n### 麦克斯韦速率分布\n速率分布曲线**归一化**处理：\n$$\\int_{0}^{\\infty} f(v)  dv = 1$$\n\n#### 平均速率\n$$\\overline{\\nu} = \\int_{0}^{\\nu_o} vf(v)  dv=1.60\\sqrt{\\frac{RT}{M}}$$\n\n#### 方均根速率\n$$\\overline{\\nu^2} = \\int_{0}^{\\infty} v^2 f(\\nu)  d\\nu$$\n\n$$\\sqrt{\\overline{\\nu^2}}=1.73\\sqrt{\\frac{RT}{M}}$$\n\n#### 最概然速率\n$$v_p=1.41\\sqrt{\\frac{RT}{M}}$$\n\n### 分子碰撞与自由程\n\n#### 平均碰撞频率\n$$\\overline{Z}=\\sqrt{2} \\pi d^2 \\overline{\\nu} n$$\n\n#### 平均自由程\n$$\\overline{\\lambda} = \\frac{\\overline{v}}{\\overline{Z}} = \\frac{1}{\\sqrt{2} \\pi d^2 n}$$","source":"_posts/Review/College-Physics-2.md","raw":"---\ntitle: College Physics 2\ndate: 2025-09-02 21:11:58\ntags: [College Physics]\ncategory: Review\ncategory_bar: true\narchive: true\nmath: true\n---\n\n理想气体的**物态方程**\n\n$$PV=\\frac{m}{M_{mol}}RT$$\n\n$\\frac{m}{M}$ 叫做物质的量\n\n $R $ 叫做普适气体常量\n\n$$PV=nRT$$\n\n\n道尔顿**分压定律**：混合气体的压强等于各个气体的压强之和\n$$ P=P_{1}+P_{2}+P_{3}+...=(n_{1}+n_{2}+n_{3}+...)kT$$\n\n\n$$ \\begin{aligned}\nP &= \\frac{F}{S} = \\frac{I}{l_2l_3\\Delta t} = \\frac{m_0}{l_1l_2l_3} \\sum_{i=1}^{N} v_{ix}^2 = \\frac{Nm_0}{l_1l_2l_3} \\frac{\\sum_{i=1}^{N} v_{ix}^2}{N} \n= \\frac{N}{V}m_0\\overline{v_x^2} = nm_0\\overline{v_x^2} \n= \\frac{1}{3}nm_0\\overline{v^2} = \\frac{2}{3}n\\overline{\\varepsilon}\n\\end{aligned} $$\n\n又因为：\n\n$$\\overline{\\varepsilon} = \\frac{1}{2} m_0 \\overline{v^2} = \\frac{3}{2} kT$$\n所以，**方均根速率**：\n$$\\sqrt{\\overline{v^2}} = \\sqrt{\\frac{3kT}{m_0}} = \\sqrt{\\frac{3RT}{M}}$$\n\n### 能量均分定理、内能\n每个分子的**平均动能**：\n$$\\overline{E_k} = \\frac{i}{2}kT$$\n\n其中：$k = \\frac{R}{N_A}$\n\n| 分子类型           | 原子数 (N) | 平动自由度 | 转动自由度 | 振动自由度 | 总自由度 (3N) |\n| :----------------- | :--------: | :--------: | :--------: | :--------: | :-----------: |\n| **单原子**         |     1      |     3      |     0      |     0      |       3       |\n| **双原子（线性）** |     2      |     3      |     2      |     1      |       6       |\n| **多原子（线性）** |     N      |     3      |     2      |  3N - 5    |      3N       |\n| **多原子（非线性）**|     N      |     3      |     3      |  3N - 6    |      3N       |\n\n单原子分子有三个自由度：\n$$\\overline{E_k} = \\frac{3}{2}kT$$\n\n双原子分子有五个自由度：\n$$\\overline{E_k} = \\frac{5}{2}kT$$\n\n多原子分子有六个自由度：\n\n$$\\overline{E_k} = 3kT$$\n\n理想气体内能：\n$$E= \\frac{m}{M}\\frac{i}{2}RT $$\n\n### 麦克斯韦速率分布\n速率分布曲线**归一化**处理：\n$$\\int_{0}^{\\infty} f(v)  dv = 1$$\n\n#### 平均速率\n$$\\overline{\\nu} = \\int_{0}^{\\nu_o} vf(v)  dv=1.60\\sqrt{\\frac{RT}{M}}$$\n\n#### 方均根速率\n$$\\overline{\\nu^2} = \\int_{0}^{\\infty} v^2 f(\\nu)  d\\nu$$\n\n$$\\sqrt{\\overline{\\nu^2}}=1.73\\sqrt{\\frac{RT}{M}}$$\n\n#### 最概然速率\n$$v_p=1.41\\sqrt{\\frac{RT}{M}}$$\n\n### 分子碰撞与自由程\n\n#### 平均碰撞频率\n$$\\overline{Z}=\\sqrt{2} \\pi d^2 \\overline{\\nu} n$$\n\n#### 平均自由程\n$$\\overline{\\lambda} = \\frac{\\overline{v}}{\\overline{Z}} = \\frac{1}{\\sqrt{2} \\pi d^2 n}$$","slug":"Review/College-Physics-2","published":1,"updated":"2025-09-12T07:11:05.885Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcq001i40w39xuc5csn","content":"<p>理想气体的<strong>物态方程</strong></p>\n<p>$$PV=\\frac{m}{M_{mol}}RT$$</p>\n<p>$\\frac{m}{M}$ 叫做物质的量</p>\n<p>$R $ 叫做普适气体常量</p>\n<p>$$PV=nRT$$</p>\n<p>道尔顿<strong>分压定律</strong>：混合气体的压强等于各个气体的压强之和<br>\n$$ P=P_{1}+P_{2}+P_{3}+…=(n_{1}+n_{2}+n_{3}+…)kT$$</p>\n<p>$$ \\begin{aligned}<br>\nP &amp;= \\frac{F}{S} = \\frac{I}{l_2l_3\\Delta t} = \\frac{m_0}{l_1l_2l_3} \\sum_{i=1}^{N} v_{ix}^2 = \\frac{Nm_0}{l_1l_2l_3} \\frac{\\sum_{i=1}^{N} v_{ix}^2}{N}<br>\n= \\frac{N}{V}m_0\\overline{v_x^2} = nm_0\\overline{v_x^2}<br>\n= \\frac{1}{3}nm_0\\overline{v^2} = \\frac{2}{3}n\\overline{\\varepsilon}<br>\n\\end{aligned} $$</p>\n<p>又因为：</p>\n<p>$$\\overline{\\varepsilon} = \\frac{1}{2} m_0 \\overline{v^2} = \\frac{3}{2} kT$$<br>\n所以，<strong>方均根速率</strong>：<br>\n$$\\sqrt{\\overline{v^2}} = \\sqrt{\\frac{3kT}{m_0}} = \\sqrt{\\frac{3RT}{M}}$$</p>\n<h3 id=\"能量均分定理、内能\">能量均分定理、内能</h3>\n<p>每个分子的<strong>平均动能</strong>：<br>\n$$\\overline{E_k} = \\frac{i}{2}kT$$</p>\n<p>其中：$k = \\frac{R}{N_A}$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分子类型</th>\n<th style=\"text-align:center\">原子数 (N)</th>\n<th style=\"text-align:center\">平动自由度</th>\n<th style=\"text-align:center\">转动自由度</th>\n<th style=\"text-align:center\">振动自由度</th>\n<th style=\"text-align:center\">总自由度 (3N)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>单原子</strong></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>双原子（线性）</strong></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>多原子（线性）</strong></td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3N - 5</td>\n<td style=\"text-align:center\">3N</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>多原子（非线性）</strong></td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3N - 6</td>\n<td style=\"text-align:center\">3N</td>\n</tr>\n</tbody>\n</table>\n<p>单原子分子有三个自由度：<br>\n$$\\overline{E_k} = \\frac{3}{2}kT$$</p>\n<p>双原子分子有五个自由度：<br>\n$$\\overline{E_k} = \\frac{5}{2}kT$$</p>\n<p>多原子分子有六个自由度：</p>\n<p>$$\\overline{E_k} = 3kT$$</p>\n<p>理想气体内能：<br>\n$$E= \\frac{m}{M}\\frac{i}{2}RT $$</p>\n<h3 id=\"麦克斯韦速率分布\">麦克斯韦速率分布</h3>\n<p>速率分布曲线<strong>归一化</strong>处理：<br>\n$$\\int_{0}^{\\infty} f(v)  dv = 1$$</p>\n<h4 id=\"平均速率\">平均速率</h4>\n<p>$$\\overline{\\nu} = \\int_{0}^{\\nu_o} vf(v)  dv=1.60\\sqrt{\\frac{RT}{M}}$$</p>\n<h4 id=\"方均根速率\">方均根速率</h4>\n<p>$$\\overline{\\nu^2} = \\int_{0}^{\\infty} v^2 f(\\nu)  d\\nu$$</p>\n<p>$$\\sqrt{\\overline{\\nu^2}}=1.73\\sqrt{\\frac{RT}{M}}$$</p>\n<h4 id=\"最概然速率\">最概然速率</h4>\n<p>$$v_p=1.41\\sqrt{\\frac{RT}{M}}$$</p>\n<h3 id=\"分子碰撞与自由程\">分子碰撞与自由程</h3>\n<h4 id=\"平均碰撞频率\">平均碰撞频率</h4>\n<p>$$\\overline{Z}=\\sqrt{2} \\pi d^2 \\overline{\\nu} n$$</p>\n<h4 id=\"平均自由程\">平均自由程</h4>\n<p>$$\\overline{\\lambda} = \\frac{\\overline{v}}{\\overline{Z}} = \\frac{1}{\\sqrt{2} \\pi d^2 n}$$</p>\n","excerpt":"","more":"<p>理想气体的<strong>物态方程</strong></p>\n<p>$$PV=\\frac{m}{M_{mol}}RT$$</p>\n<p>$\\frac{m}{M}$ 叫做物质的量</p>\n<p>$R $ 叫做普适气体常量</p>\n<p>$$PV=nRT$$</p>\n<p>道尔顿<strong>分压定律</strong>：混合气体的压强等于各个气体的压强之和<br>\n$$ P=P_{1}+P_{2}+P_{3}+…=(n_{1}+n_{2}+n_{3}+…)kT$$</p>\n<p>$$ \\begin{aligned}<br>\nP &amp;= \\frac{F}{S} = \\frac{I}{l_2l_3\\Delta t} = \\frac{m_0}{l_1l_2l_3} \\sum_{i=1}^{N} v_{ix}^2 = \\frac{Nm_0}{l_1l_2l_3} \\frac{\\sum_{i=1}^{N} v_{ix}^2}{N}<br>\n= \\frac{N}{V}m_0\\overline{v_x^2} = nm_0\\overline{v_x^2}<br>\n= \\frac{1}{3}nm_0\\overline{v^2} = \\frac{2}{3}n\\overline{\\varepsilon}<br>\n\\end{aligned} $$</p>\n<p>又因为：</p>\n<p>$$\\overline{\\varepsilon} = \\frac{1}{2} m_0 \\overline{v^2} = \\frac{3}{2} kT$$<br>\n所以，<strong>方均根速率</strong>：<br>\n$$\\sqrt{\\overline{v^2}} = \\sqrt{\\frac{3kT}{m_0}} = \\sqrt{\\frac{3RT}{M}}$$</p>\n<h3 id=\"能量均分定理、内能\">能量均分定理、内能</h3>\n<p>每个分子的<strong>平均动能</strong>：<br>\n$$\\overline{E_k} = \\frac{i}{2}kT$$</p>\n<p>其中：$k = \\frac{R}{N_A}$</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">分子类型</th>\n<th style=\"text-align:center\">原子数 (N)</th>\n<th style=\"text-align:center\">平动自由度</th>\n<th style=\"text-align:center\">转动自由度</th>\n<th style=\"text-align:center\">振动自由度</th>\n<th style=\"text-align:center\">总自由度 (3N)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>单原子</strong></td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>双原子（线性）</strong></td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">6</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>多原子（线性）</strong></td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3N - 5</td>\n<td style=\"text-align:center\">3N</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>多原子（非线性）</strong></td>\n<td style=\"text-align:center\">N</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3N - 6</td>\n<td style=\"text-align:center\">3N</td>\n</tr>\n</tbody>\n</table>\n<p>单原子分子有三个自由度：<br>\n$$\\overline{E_k} = \\frac{3}{2}kT$$</p>\n<p>双原子分子有五个自由度：<br>\n$$\\overline{E_k} = \\frac{5}{2}kT$$</p>\n<p>多原子分子有六个自由度：</p>\n<p>$$\\overline{E_k} = 3kT$$</p>\n<p>理想气体内能：<br>\n$$E= \\frac{m}{M}\\frac{i}{2}RT $$</p>\n<h3 id=\"麦克斯韦速率分布\">麦克斯韦速率分布</h3>\n<p>速率分布曲线<strong>归一化</strong>处理：<br>\n$$\\int_{0}^{\\infty} f(v)  dv = 1$$</p>\n<h4 id=\"平均速率\">平均速率</h4>\n<p>$$\\overline{\\nu} = \\int_{0}^{\\nu_o} vf(v)  dv=1.60\\sqrt{\\frac{RT}{M}}$$</p>\n<h4 id=\"方均根速率\">方均根速率</h4>\n<p>$$\\overline{\\nu^2} = \\int_{0}^{\\infty} v^2 f(\\nu)  d\\nu$$</p>\n<p>$$\\sqrt{\\overline{\\nu^2}}=1.73\\sqrt{\\frac{RT}{M}}$$</p>\n<h4 id=\"最概然速率\">最概然速率</h4>\n<p>$$v_p=1.41\\sqrt{\\frac{RT}{M}}$$</p>\n<h3 id=\"分子碰撞与自由程\">分子碰撞与自由程</h3>\n<h4 id=\"平均碰撞频率\">平均碰撞频率</h4>\n<p>$$\\overline{Z}=\\sqrt{2} \\pi d^2 \\overline{\\nu} n$$</p>\n<h4 id=\"平均自由程\">平均自由程</h4>\n<p>$$\\overline{\\lambda} = \\frac{\\overline{v}}{\\overline{Z}} = \\frac{1}{\\sqrt{2} \\pi d^2 n}$$</p>\n"},{"title":"Matplotlib:Python Visualization","date":"2025-09-13T01:52:54.000Z","archive":true,"_content":"\n","source":"_posts/Python/Matplotlib-Python-Visualization.md","raw":"---\ntitle: Matplotlib:Python Visualization\ndate: 2025-09-13 09:52:54\ntags:\narchive: true\n---\n\n","slug":"Python/Matplotlib-Python-Visualization","published":1,"updated":"2025-09-13T02:46:32.166Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcq001l40w3d2p1ga7w","content":"","excerpt":"","more":""},{"title":"Pandas: Data Analysis","date":"2025-09-13T05:01:56.000Z","archive":true,"_content":"\n{%note info%}\n{%fold into @ 什么是 pip ？ %}\n`pip`是 Python 的包管理工具，全称是 Python Install Packages，所有人都可以下载或上传自己开发的库到 PyPI 上，常见的指令有：\n```bash\npip install pandas\n```\n{%endfold%}\n{%endnote%}\n\n### Series对象\nSeries对象是pandas中可**存储多种类型的一维数组**，由**数据**与**索引**组成。\n#### 默认索引为0\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5])\nprint(s1)\n```\n```\n0    1\n1    2\n2    3\n3    4\n4    5\n```\n这里就可以采用**位置**进行索引\n#### 自定义索引\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1)\n```\n```\na    1\nb    2\nc    3\nd    4\ne    5\n```\n这里就可以使用自定义的**标签**进行索引\n***\n同时上述两种方法也都可以支持**切片索引**\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1['a':'d'])\n```\n```\na    1\nb    2\nc    3\nd    4\n```\n***\n我们也可以**同时获取数据与索引**\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1.index)\nprint(s1.values)\n```\n```\nIndex(['a', 'b', 'c', 'd', 'e'], dtype='object')\n[1 2 3 4 5]\n```\n***\n\n### DataFrame对象\n```python\npandas.DataFrame(data,index,columns)\n# 分别对应数据 行索引 列索引\n```\n#### 列表创建DataFrame对象\n当对象更注重**列方向**数据关联时：\n```python\nimport pandas as pd\ndata=[[110,135,125],[115,140,130],[120,145,135]]\ncolumns=['语文','数学','英语']\ndf=pd.DataFrame(data=data,columns=columns)\nprint(df)\n```\n#### 字典创建DataFrame对象\n当对象更注重**行方向**数据关联时：\n```python\nimport pandas as pd\ndf=pd.DataFrame({\n'语文':[110,115,120],\n'数学':[135,140,145],\n'英语':[125,130,135],\n'班级':'24-3班'\n})\nprint(df)\n```\n```\n    语文   数学   英语     班级\n0  110  135  125  24-3班\n1  115  140  130  24-3班\n2  120  145  135  24-3班\n```\n\n## 导入外部数据\n### 导入 .xls 和 .xlsx 文件\n```python\npandas.read_excel(file_path,sheet_name)\n```\n默认情况下，sheet_name参数为0，表示读取第一个工作表。\n- `sheet_name=1` 表示读取第二个工作表\n- `sheet_name='sheet_name'` 表示读取**指定名称的工作表**\n- `sheet_name=None` 读取**所有工作表**\n- `sheet_name=[1,2,'Sheet4']` 读取**指定索引或名称的工作表**\n\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.head()) # 输出前五行\nprint(df.tail()) # 输出最后五行\n```\n```\n  序号  孕妇代码  年龄     身高    体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0   1  A001  31  160.0  72.0  ...   0.027484      NaN    1     0      是\n1   2  A001  31  160.0  73.0  ...   0.019617      NaN    1     0      是\n2   3  A001  31  160.0  73.0  ...   0.022312      NaN    1     0      是\n3   4  A001  31  160.0  74.0  ...   0.023280      NaN    1     0      是\n4   5  A002  32  149.0  74.0  ...   0.024212      NaN    2     1      否\n```\n#### 行/列索引\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',index_col=3)\nprint(df.head())\nprint(df.tail())\n# 将第四列放在首列作为行索引\n```\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',header=None)\nprint(df.head())\nprint(df.tail())\n# 将数字作为列索引\n```\n#### 导入指定行/列\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',usecols=[1])\nprint(df.head())\nprint(df.tail())\n# 导入第二列的数据\n```\n- `usecols=[1,2,3]` 指定**多列进行导入**，导入第1、2、3列的数据\n- `usecols='A:C'` 导入A列到C列的数据\n```\n   序号  孕妇代码  年龄\n0   1  A001  31\n1   2  A001  31\n2   3  A001  31\n3   4  A001  31\n4   5  A002  32\n```\n- `usecols=['孕妇代码','年龄']` 导入**指定列名**的数据\n\n## 数据清洗\n### 缺失值处理\n#### 查找缺失值\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.info())\n```\n{%fold into @查看运行结果%}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1082 entries, 0 to 1081\nData columns (total 31 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   序号            1082 non-null   int64  \n 1   孕妇代码          1082 non-null   object \n 2   年龄            1082 non-null   int64  \n 3   身高            1082 non-null   float64\n 4   体重            1082 non-null   float64\n 5   末次月经          1070 non-null   object \n 6   IVF妊娠         1082 non-null   object \n 7   检测日期          1082 non-null   object \n 8   检测抽血次数        1082 non-null   int64  \n 9   检测孕周          1082 non-null   object \n 10  孕妇BMI         1082 non-null   float64\n 11  原始读段数         1082 non-null   int64  \n 12  在参考基因组上比对的比例  1082 non-null   float64\n 13  重复读段的比例       1082 non-null   float64\n 14  唯一比对的读段数      1082 non-null   int64  \n 15  GC含量          1082 non-null   float64\n 16  13号染色体的Z值     1082 non-null   float64\n 17  18号染色体的Z值     1082 non-null   float64\n 18  21号染色体的Z值     1082 non-null   float64\n 19  X染色体的Z值       1082 non-null   float64\n 20  Y染色体的Z值       1082 non-null   float64\n 21  Y染色体浓度        1082 non-null   float64\n 22  X染色体浓度        1082 non-null   float64\n 23  13号染色体的GC含量   1082 non-null   float64\n 24  18号染色体的GC含量   1082 non-null   float64\n 25  21号染色体的GC含量   1082 non-null   float64\n 26  被过滤掉读段数的比例    1082 non-null   float64\n 27  染色体的非整倍体      126 non-null    object \n 28  怀孕次数          1082 non-null   object \n 29  生产次数          1082 non-null   int64  \n 30  胎儿是否健康        1082 non-null   object \ndtypes: float64(17), int64(6), object(8)\nmemory usage: 262.2+ KB\nNone\n```\n缺失值一般用**NaN**表示，在第三列中大部分非空数量为1082，而第二十七行为126行，说明第二十七行有缺失值。\n{%endfold%}\n\n也可以使用`isnull()`方法查看缺失值：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.isnull())\n```\n\n{%fold into @查看运行结果%}\n```\n         序号   孕妇代码     年龄     身高  ...  染色体的非整倍体   怀孕次数   生产次数  胎儿是否健康\n0     False  False  False  False  ...      True  False  False   False\n1     False  False  False  False  ...      True  False  False   False\n2     False  False  False  False  ...      True  False  False   False\n3     False  False  False  False  ...      True  False  False   False\n4     False  False  False  False  ...      True  False  False   False\n...     ...    ...    ...    ...  ...       ...    ...    ...     ...\n1077  False  False  False  False  ...     False  False  False   False\n1078  False  False  False  False  ...     False  False  False   False\n1079  False  False  False  False  ...      True  False  False   False\n1080  False  False  False  False  ...      True  False  False   False\n1081  False  False  False  False  ...      True  False  False   False\n```\n{%endfold%}\n***\n#### 删除缺失值\n`dropna()`方法可以删除缺失值，默认情况下，删除所有行中**有缺失值的行**：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf.dropna(inplace=True)\nprint(df)\n```\n{%fold into @查看运行结果%}\n未删除前：\n```\n[1082 rows x 31 columns]\n```\n删除后：\n```\n[126 rows x 31 columns]\n```\n{%endfold%}\n***\n#### 填充缺失值\n### 重复值处理\n#### 判断重复值\n`duplicated()`方法可以判断数据是否重复，若没有传入参数，则默认会按照所有列的组合来判断重复值，即如果两行的所有列的值完全相同，则判定为重复行，返回 True\n\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf=df.duplicated('年龄')\n# 注意要将处理值赋给原始数据df\nprint(df)\n```\n{%fold into @查看运行结果%}\n默认情况，**无参数**：\n```\n0       False\n1       False\n2       False\n3       False\n4       False\n```\n**含参数**，只判断某一列重复值：\n```\n0       False\n1        True\n2        True\n3        True\n4       False\n```\n{%endfold%}\n***\n#### 删除重复值\n`drop_duplicates()`方法可以删除重复值，默认情况下，删除所有行中**有重复值的行**：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf=df.drop_duplicates('孕妇代码')\nprint(df)\n```\n```python\ndf=df.drop_duplicates('孕妇代码',keep='last')\n```\n参数**默认保留重复的第一行**，可选参数保留重复的最后一行或任意行\n{%fold into @查看运行结果%}\n默认情况，**无参数**：\n```\n        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0        1  A001  31  160.0  72.00  ...   0.027484      NaN    1     0      是\n1        2  A001  31  160.0  73.00  ...   0.019617      NaN    1     0      是\n2        3  A001  31  160.0  73.00  ...   0.022312      NaN    1     0      是\n3        4  A001  31  160.0  74.00  ...   0.023280      NaN    1     0      是\n4        5  A002  32  149.0  74.00  ...   0.024212      NaN    2     1      否\n...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...\n1077  1078  A266  30  159.0  83.35  ...   0.017951      T18    1     0      是\n1078  1079  A267  28  155.0  73.76  ...   0.022549      T21    1     0      是\n1079  1080  A267  28  155.0  74.06  ...   0.021330      NaN    1     0      是\n1080  1081  A267  28  155.0  74.74  ...   0.022013      NaN    1     0      是\n1081  1082  A267  28  155.0  75.85  ...   0.016906      NaN    1     0      是\n\n[1082 rows x 31 columns]\n```\n**含参数**\n```\n        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0        1  A001  31  160.0  72.00  ...   0.027484      NaN    1     0      是\n4        5  A002  32  149.0  74.00  ...   0.024212      NaN    2     1      否\n9       10  A003  35  160.0  78.70  ...   0.021138      T21   ≥3     1      是\n15      16  A004  26  158.0  71.50  ...   0.021022      NaN   ≥3     1      是\n19      20  A005  30  150.0  67.40  ...   0.025210      NaN   ≥3     1      是\n...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...\n1062  1063  A263  30  157.0  72.34  ...   0.024222      T21    1     0      是\n1066  1067  A264  30  171.0  94.95  ...   0.024366      NaN    1     0      是\n1070  1071  A265  32  168.0  95.17  ...   0.025949      NaN    1     0      是\n1074  1075  A266  30  159.0  81.24  ...   0.025132   T13T18    1     0      是\n1078  1079  A267  28  155.0  73.76  ...   0.022549      T21    1     0      是\n\n[267 rows x 31 columns]\n```\n{%endfold%}\n\n### 异常值处理\n#### 箱型线法\n箱型线法是基于数据的**四分位数**构建 “箱体” 和 “须”，通过设定合理范围识别异常值，超过**设定的上限或下限**都可以被认定为异常值，具有**不依赖数据分布**、**对极端值鲁棒**的特点。\n```python\nimport pandas as pd\n# 读取数据\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\n# 1. 计算Q1、Q3、IQR和上下限（同步骤1）\nQ1 = df['体重'].quantile(0.25) # 下四分位数\nQ3 = df['体重'].quantile(0.75) # 上四分位数\nIQR = Q3 - Q1 # 四分位距\nlower_bound = Q1 - 1.5 * IQR # 下异常值下限\nupper_bound = Q3 + 1.5 * IQR # 上异常值上限\n# 2. 筛选异常值（低于下限 或 高于上限）\noutliers_lower = df[df['体重'] < lower_bound]  # 下异常值\noutliers_upper = df[df['体重'] > upper_bound]  # 上异常值\nall_outliers = pd.concat([outliers_lower, outliers_upper])  # 所有异常值\n```\n#### 删除异常值\n```python\nimport pandas as pd\n\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# 筛选正常数据（排除异常值）\ndf_cleaned = df[(df['体重'] >= lower_bound) & (df['体重'] <= upper_bound)]\n```\n#### 填充异常值\n```python\nimport pandas as pd\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n# 计算填充值（用体重列的中位数）\nweight_median = df['体重'].median()\n# 用中位数填充下异常值（体重 < 下限）\ndf.loc[df['体重'] < lower_bound, '体重'] = weight_median\n# 用中位数填充上异常值（体重 > 上限）\ndf.loc[df['体重'] > upper_bound, '体重'] = weight_median\n```\n#### 盖帽处理\n```python\nimport pandas as pd\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n# 下异常值替换为下限\ndf.loc[df['体重'] < lower_bound, '体重'] = lower_bound\n# 上异常值替换为上限\ndf.loc[df['体重'] > upper_bound, '体重'] = upper_bound\n```","source":"_posts/Python/Pandas-Data-Analysis.md","raw":"---\ntitle: 'Pandas: Data Analysis'\ndate: 2025-09-13 13:01:56\ntags:\narchive: true\n---\n\n{%note info%}\n{%fold into @ 什么是 pip ？ %}\n`pip`是 Python 的包管理工具，全称是 Python Install Packages，所有人都可以下载或上传自己开发的库到 PyPI 上，常见的指令有：\n```bash\npip install pandas\n```\n{%endfold%}\n{%endnote%}\n\n### Series对象\nSeries对象是pandas中可**存储多种类型的一维数组**，由**数据**与**索引**组成。\n#### 默认索引为0\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5])\nprint(s1)\n```\n```\n0    1\n1    2\n2    3\n3    4\n4    5\n```\n这里就可以采用**位置**进行索引\n#### 自定义索引\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1)\n```\n```\na    1\nb    2\nc    3\nd    4\ne    5\n```\n这里就可以使用自定义的**标签**进行索引\n***\n同时上述两种方法也都可以支持**切片索引**\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1['a':'d'])\n```\n```\na    1\nb    2\nc    3\nd    4\n```\n***\n我们也可以**同时获取数据与索引**\n```python\nimport pandas as pd\ns1=pd.Series([1,2,3,4,5],index=['a','b','c','d','e'])\nprint(s1.index)\nprint(s1.values)\n```\n```\nIndex(['a', 'b', 'c', 'd', 'e'], dtype='object')\n[1 2 3 4 5]\n```\n***\n\n### DataFrame对象\n```python\npandas.DataFrame(data,index,columns)\n# 分别对应数据 行索引 列索引\n```\n#### 列表创建DataFrame对象\n当对象更注重**列方向**数据关联时：\n```python\nimport pandas as pd\ndata=[[110,135,125],[115,140,130],[120,145,135]]\ncolumns=['语文','数学','英语']\ndf=pd.DataFrame(data=data,columns=columns)\nprint(df)\n```\n#### 字典创建DataFrame对象\n当对象更注重**行方向**数据关联时：\n```python\nimport pandas as pd\ndf=pd.DataFrame({\n'语文':[110,115,120],\n'数学':[135,140,145],\n'英语':[125,130,135],\n'班级':'24-3班'\n})\nprint(df)\n```\n```\n    语文   数学   英语     班级\n0  110  135  125  24-3班\n1  115  140  130  24-3班\n2  120  145  135  24-3班\n```\n\n## 导入外部数据\n### 导入 .xls 和 .xlsx 文件\n```python\npandas.read_excel(file_path,sheet_name)\n```\n默认情况下，sheet_name参数为0，表示读取第一个工作表。\n- `sheet_name=1` 表示读取第二个工作表\n- `sheet_name='sheet_name'` 表示读取**指定名称的工作表**\n- `sheet_name=None` 读取**所有工作表**\n- `sheet_name=[1,2,'Sheet4']` 读取**指定索引或名称的工作表**\n\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.head()) # 输出前五行\nprint(df.tail()) # 输出最后五行\n```\n```\n  序号  孕妇代码  年龄     身高    体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0   1  A001  31  160.0  72.0  ...   0.027484      NaN    1     0      是\n1   2  A001  31  160.0  73.0  ...   0.019617      NaN    1     0      是\n2   3  A001  31  160.0  73.0  ...   0.022312      NaN    1     0      是\n3   4  A001  31  160.0  74.0  ...   0.023280      NaN    1     0      是\n4   5  A002  32  149.0  74.0  ...   0.024212      NaN    2     1      否\n```\n#### 行/列索引\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',index_col=3)\nprint(df.head())\nprint(df.tail())\n# 将第四列放在首列作为行索引\n```\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',header=None)\nprint(df.head())\nprint(df.tail())\n# 将数字作为列索引\n```\n#### 导入指定行/列\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据',usecols=[1])\nprint(df.head())\nprint(df.tail())\n# 导入第二列的数据\n```\n- `usecols=[1,2,3]` 指定**多列进行导入**，导入第1、2、3列的数据\n- `usecols='A:C'` 导入A列到C列的数据\n```\n   序号  孕妇代码  年龄\n0   1  A001  31\n1   2  A001  31\n2   3  A001  31\n3   4  A001  31\n4   5  A002  32\n```\n- `usecols=['孕妇代码','年龄']` 导入**指定列名**的数据\n\n## 数据清洗\n### 缺失值处理\n#### 查找缺失值\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.info())\n```\n{%fold into @查看运行结果%}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 1082 entries, 0 to 1081\nData columns (total 31 columns):\n #   Column        Non-Null Count  Dtype  \n---  ------        --------------  -----  \n 0   序号            1082 non-null   int64  \n 1   孕妇代码          1082 non-null   object \n 2   年龄            1082 non-null   int64  \n 3   身高            1082 non-null   float64\n 4   体重            1082 non-null   float64\n 5   末次月经          1070 non-null   object \n 6   IVF妊娠         1082 non-null   object \n 7   检测日期          1082 non-null   object \n 8   检测抽血次数        1082 non-null   int64  \n 9   检测孕周          1082 non-null   object \n 10  孕妇BMI         1082 non-null   float64\n 11  原始读段数         1082 non-null   int64  \n 12  在参考基因组上比对的比例  1082 non-null   float64\n 13  重复读段的比例       1082 non-null   float64\n 14  唯一比对的读段数      1082 non-null   int64  \n 15  GC含量          1082 non-null   float64\n 16  13号染色体的Z值     1082 non-null   float64\n 17  18号染色体的Z值     1082 non-null   float64\n 18  21号染色体的Z值     1082 non-null   float64\n 19  X染色体的Z值       1082 non-null   float64\n 20  Y染色体的Z值       1082 non-null   float64\n 21  Y染色体浓度        1082 non-null   float64\n 22  X染色体浓度        1082 non-null   float64\n 23  13号染色体的GC含量   1082 non-null   float64\n 24  18号染色体的GC含量   1082 non-null   float64\n 25  21号染色体的GC含量   1082 non-null   float64\n 26  被过滤掉读段数的比例    1082 non-null   float64\n 27  染色体的非整倍体      126 non-null    object \n 28  怀孕次数          1082 non-null   object \n 29  生产次数          1082 non-null   int64  \n 30  胎儿是否健康        1082 non-null   object \ndtypes: float64(17), int64(6), object(8)\nmemory usage: 262.2+ KB\nNone\n```\n缺失值一般用**NaN**表示，在第三列中大部分非空数量为1082，而第二十七行为126行，说明第二十七行有缺失值。\n{%endfold%}\n\n也可以使用`isnull()`方法查看缺失值：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\nprint(df.isnull())\n```\n\n{%fold into @查看运行结果%}\n```\n         序号   孕妇代码     年龄     身高  ...  染色体的非整倍体   怀孕次数   生产次数  胎儿是否健康\n0     False  False  False  False  ...      True  False  False   False\n1     False  False  False  False  ...      True  False  False   False\n2     False  False  False  False  ...      True  False  False   False\n3     False  False  False  False  ...      True  False  False   False\n4     False  False  False  False  ...      True  False  False   False\n...     ...    ...    ...    ...  ...       ...    ...    ...     ...\n1077  False  False  False  False  ...     False  False  False   False\n1078  False  False  False  False  ...     False  False  False   False\n1079  False  False  False  False  ...      True  False  False   False\n1080  False  False  False  False  ...      True  False  False   False\n1081  False  False  False  False  ...      True  False  False   False\n```\n{%endfold%}\n***\n#### 删除缺失值\n`dropna()`方法可以删除缺失值，默认情况下，删除所有行中**有缺失值的行**：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf.dropna(inplace=True)\nprint(df)\n```\n{%fold into @查看运行结果%}\n未删除前：\n```\n[1082 rows x 31 columns]\n```\n删除后：\n```\n[126 rows x 31 columns]\n```\n{%endfold%}\n***\n#### 填充缺失值\n### 重复值处理\n#### 判断重复值\n`duplicated()`方法可以判断数据是否重复，若没有传入参数，则默认会按照所有列的组合来判断重复值，即如果两行的所有列的值完全相同，则判定为重复行，返回 True\n\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf=df.duplicated('年龄')\n# 注意要将处理值赋给原始数据df\nprint(df)\n```\n{%fold into @查看运行结果%}\n默认情况，**无参数**：\n```\n0       False\n1       False\n2       False\n3       False\n4       False\n```\n**含参数**，只判断某一列重复值：\n```\n0       False\n1        True\n2        True\n3        True\n4       False\n```\n{%endfold%}\n***\n#### 删除重复值\n`drop_duplicates()`方法可以删除重复值，默认情况下，删除所有行中**有重复值的行**：\n```python\nimport pandas as pd\ndf=pd.read_excel('附件.xlsx','男胎检测数据')\ndf=df.drop_duplicates('孕妇代码')\nprint(df)\n```\n```python\ndf=df.drop_duplicates('孕妇代码',keep='last')\n```\n参数**默认保留重复的第一行**，可选参数保留重复的最后一行或任意行\n{%fold into @查看运行结果%}\n默认情况，**无参数**：\n```\n        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0        1  A001  31  160.0  72.00  ...   0.027484      NaN    1     0      是\n1        2  A001  31  160.0  73.00  ...   0.019617      NaN    1     0      是\n2        3  A001  31  160.0  73.00  ...   0.022312      NaN    1     0      是\n3        4  A001  31  160.0  74.00  ...   0.023280      NaN    1     0      是\n4        5  A002  32  149.0  74.00  ...   0.024212      NaN    2     1      否\n...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...\n1077  1078  A266  30  159.0  83.35  ...   0.017951      T18    1     0      是\n1078  1079  A267  28  155.0  73.76  ...   0.022549      T21    1     0      是\n1079  1080  A267  28  155.0  74.06  ...   0.021330      NaN    1     0      是\n1080  1081  A267  28  155.0  74.74  ...   0.022013      NaN    1     0      是\n1081  1082  A267  28  155.0  75.85  ...   0.016906      NaN    1     0      是\n\n[1082 rows x 31 columns]\n```\n**含参数**\n```\n        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康\n0        1  A001  31  160.0  72.00  ...   0.027484      NaN    1     0      是\n4        5  A002  32  149.0  74.00  ...   0.024212      NaN    2     1      否\n9       10  A003  35  160.0  78.70  ...   0.021138      T21   ≥3     1      是\n15      16  A004  26  158.0  71.50  ...   0.021022      NaN   ≥3     1      是\n19      20  A005  30  150.0  67.40  ...   0.025210      NaN   ≥3     1      是\n...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...\n1062  1063  A263  30  157.0  72.34  ...   0.024222      T21    1     0      是\n1066  1067  A264  30  171.0  94.95  ...   0.024366      NaN    1     0      是\n1070  1071  A265  32  168.0  95.17  ...   0.025949      NaN    1     0      是\n1074  1075  A266  30  159.0  81.24  ...   0.025132   T13T18    1     0      是\n1078  1079  A267  28  155.0  73.76  ...   0.022549      T21    1     0      是\n\n[267 rows x 31 columns]\n```\n{%endfold%}\n\n### 异常值处理\n#### 箱型线法\n箱型线法是基于数据的**四分位数**构建 “箱体” 和 “须”，通过设定合理范围识别异常值，超过**设定的上限或下限**都可以被认定为异常值，具有**不依赖数据分布**、**对极端值鲁棒**的特点。\n```python\nimport pandas as pd\n# 读取数据\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\n# 1. 计算Q1、Q3、IQR和上下限（同步骤1）\nQ1 = df['体重'].quantile(0.25) # 下四分位数\nQ3 = df['体重'].quantile(0.75) # 上四分位数\nIQR = Q3 - Q1 # 四分位距\nlower_bound = Q1 - 1.5 * IQR # 下异常值下限\nupper_bound = Q3 + 1.5 * IQR # 上异常值上限\n# 2. 筛选异常值（低于下限 或 高于上限）\noutliers_lower = df[df['体重'] < lower_bound]  # 下异常值\noutliers_upper = df[df['体重'] > upper_bound]  # 上异常值\nall_outliers = pd.concat([outliers_lower, outliers_upper])  # 所有异常值\n```\n#### 删除异常值\n```python\nimport pandas as pd\n\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# 筛选正常数据（排除异常值）\ndf_cleaned = df[(df['体重'] >= lower_bound) & (df['体重'] <= upper_bound)]\n```\n#### 填充异常值\n```python\nimport pandas as pd\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n# 计算填充值（用体重列的中位数）\nweight_median = df['体重'].median()\n# 用中位数填充下异常值（体重 < 下限）\ndf.loc[df['体重'] < lower_bound, '体重'] = weight_median\n# 用中位数填充上异常值（体重 > 上限）\ndf.loc[df['体重'] > upper_bound, '体重'] = weight_median\n```\n#### 盖帽处理\n```python\nimport pandas as pd\ndf = pd.read_excel('附件.xlsx', '男胎检测数据')\nQ1 = df['体重'].quantile(0.25)\nQ3 = df['体重'].quantile(0.75)\nIQR = Q3 - Q1\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n# 下异常值替换为下限\ndf.loc[df['体重'] < lower_bound, '体重'] = lower_bound\n# 上异常值替换为上限\ndf.loc[df['体重'] > upper_bound, '体重'] = upper_bound\n```","slug":"Python/Pandas-Data-Analysis","published":1,"updated":"2025-09-14T03:59:34.235Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcr001m40w35z2s5vqc","content":"<div class=\"note note-info\">\n            <div class=\"fold\">  <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-4cc89ac7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-4cc89ac7\">    <div class=\"fold-arrow\">▶</div> 什么是 pip ？  </div>  <div class=\"fold-collapse collapse\" id=\"collapse-4cc89ac7\">    <div class=\"fold-content\">      <p><code>pip</code>是 Python 的包管理工具，全称是 Python Install Packages，所有人都可以下载或上传自己开发的库到 PyPI 上，常见的指令有：</p><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pandas<br></code></pre></td></tr></tbody></table></figure>    </div>  </div></div>\n          </div>\n<h3 id=\"Series对象\">Series对象</h3>\n<p>Series对象是pandas中可<strong>存储多种类型的一维数组</strong>，由<strong>数据</strong>与<strong>索引</strong>组成。</p>\n<h4 id=\"默认索引为0\">默认索引为0</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>])<br><span class=\"hljs-built_in\">print</span>(s1)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>   <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">1 </span>   <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">2 </span>   <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">3 </span>   <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">4 </span>   <span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure>\n<p>这里就可以采用<strong>位置</strong>进行索引</p>\n<h4 id=\"自定义索引\">自定义索引</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">'a'</span>,<span class=\"hljs-string\">'b'</span>,<span class=\"hljs-string\">'c'</span>,<span class=\"hljs-string\">'d'</span>,<span class=\"hljs-string\">'e'</span>])<br><span class=\"hljs-built_in\">print</span>(s1)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">a</span>    <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">b</span>    <span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">c</span>    <span class=\"hljs-number\">3</span><br><span class=\"hljs-attribute\">d</span>    <span class=\"hljs-number\">4</span><br><span class=\"hljs-attribute\">e</span>    <span class=\"hljs-number\">5</span><br></code></pre></td></tr></tbody></table></figure>\n<p>这里就可以使用自定义的<strong>标签</strong>进行索引</p>\n<hr>\n<p>同时上述两种方法也都可以支持<strong>切片索引</strong></p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">'a'</span>,<span class=\"hljs-string\">'b'</span>,<span class=\"hljs-string\">'c'</span>,<span class=\"hljs-string\">'d'</span>,<span class=\"hljs-string\">'e'</span>])<br><span class=\"hljs-built_in\">print</span>(s1[<span class=\"hljs-string\">'a'</span>:<span class=\"hljs-string\">'d'</span>])<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">a</span>    <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">b</span>    <span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">c</span>    <span class=\"hljs-number\">3</span><br><span class=\"hljs-attribute\">d</span>    <span class=\"hljs-number\">4</span><br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<p>我们也可以<strong>同时获取数据与索引</strong></p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">'a'</span>,<span class=\"hljs-string\">'b'</span>,<span class=\"hljs-string\">'c'</span>,<span class=\"hljs-string\">'d'</span>,<span class=\"hljs-string\">'e'</span>])<br><span class=\"hljs-built_in\">print</span>(s1.index)<br><span class=\"hljs-built_in\">print</span>(s1.values)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight stylus\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Index</span><span class=\"hljs-params\">([<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-string\">'d'</span>, <span class=\"hljs-string\">'e'</span>], dtype=<span class=\"hljs-string\">'object'</span>)</span></span><br><span class=\"hljs-selector-attr\">[1 2 3 4 5]</span><br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h3 id=\"DataFrame对象\">DataFrame对象</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pandas.DataFrame(data,index,columns)<br><span class=\"hljs-comment\"># 分别对应数据 行索引 列索引</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"列表创建DataFrame对象\">列表创建DataFrame对象</h4>\n<p>当对象更注重<strong>列方向</strong>数据关联时：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>data=[[<span class=\"hljs-number\">110</span>,<span class=\"hljs-number\">135</span>,<span class=\"hljs-number\">125</span>],[<span class=\"hljs-number\">115</span>,<span class=\"hljs-number\">140</span>,<span class=\"hljs-number\">130</span>],[<span class=\"hljs-number\">120</span>,<span class=\"hljs-number\">145</span>,<span class=\"hljs-number\">135</span>]]<br>columns=[<span class=\"hljs-string\">'语文'</span>,<span class=\"hljs-string\">'数学'</span>,<span class=\"hljs-string\">'英语'</span>]<br>df=pd.DataFrame(data=data,columns=columns)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"字典创建DataFrame对象\">字典创建DataFrame对象</h4>\n<p>当对象更注重<strong>行方向</strong>数据关联时：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.DataFrame({<br><span class=\"hljs-string\">'语文'</span>:[<span class=\"hljs-number\">110</span>,<span class=\"hljs-number\">115</span>,<span class=\"hljs-number\">120</span>],<br><span class=\"hljs-string\">'数学'</span>:[<span class=\"hljs-number\">135</span>,<span class=\"hljs-number\">140</span>,<span class=\"hljs-number\">145</span>],<br><span class=\"hljs-string\">'英语'</span>:[<span class=\"hljs-number\">125</span>,<span class=\"hljs-number\">130</span>,<span class=\"hljs-number\">135</span>],<br><span class=\"hljs-string\">'班级'</span>:<span class=\"hljs-string\">'24-3班'</span><br>})<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">    语文   数学   英语     班级<br>0 <span class=\"hljs-number\"> 110 </span><span class=\"hljs-number\"> 135 </span><span class=\"hljs-number\"> 125 </span> 24-3班<br>1 <span class=\"hljs-number\"> 115 </span><span class=\"hljs-number\"> 140 </span><span class=\"hljs-number\"> 130 </span> 24-3班<br>2 <span class=\"hljs-number\"> 120 </span><span class=\"hljs-number\"> 145 </span><span class=\"hljs-number\"> 135 </span> 24-3班<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"导入外部数据\">导入外部数据</h2>\n<h3 id=\"导入-xls-和-xlsx-文件\">导入 .xls 和 .xlsx 文件</h3>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pandas.read_excel(file_path,sheet_name)<br></code></pre></td></tr></tbody></table></figure>\n<p>默认情况下，sheet_name参数为0，表示读取第一个工作表。</p>\n<ul>\n<li><code>sheet_name=1</code> 表示读取第二个工作表</li>\n<li><code>sheet_name='sheet_name'</code> 表示读取<strong>指定名称的工作表</strong></li>\n<li><code>sheet_name=None</code> 读取<strong>所有工作表</strong></li>\n<li><code>sheet_name=[1,2,'Sheet4']</code> 读取<strong>指定索引或名称的工作表</strong></li>\n</ul>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br><span class=\"hljs-built_in\">print</span>(df.head()) <span class=\"hljs-comment\"># 输出前五行</span><br><span class=\"hljs-built_in\">print</span>(df.tail()) <span class=\"hljs-comment\"># 输出最后五行</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  序号  孕妇代码  年龄     身高    体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0  <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.0  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1  <span class=\"hljs-number\"> 2 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.0  ...   0.019617      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>2  <span class=\"hljs-number\"> 3 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.0  ...   0.022312      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>3  <span class=\"hljs-number\"> 4 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  74.0  ...   0.023280      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4  <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.0  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"行-列索引\">行/列索引</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>,index_col=<span class=\"hljs-number\">3</span>)<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 将第四列放在首列作为行索引</span><br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>,header=<span class=\"hljs-literal\">None</span>)<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 将数字作为列索引</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"导入指定行-列\">导入指定行/列</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>,usecols=[<span class=\"hljs-number\">1</span>])<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 导入第二列的数据</span><br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>usecols=[1,2,3]</code> 指定<strong>多列进行导入</strong>，导入第1、2、3列的数据</li>\n<li><code>usecols='A:C'</code> 导入A列到C列的数据</li>\n</ul>\n<figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">   序号  孕妇代码  年龄<br>0  <span class=\"hljs-number\"> 1 </span> A001  31<br>1  <span class=\"hljs-number\"> 2 </span> A001  31<br>2  <span class=\"hljs-number\"> 3 </span> A001  31<br>3  <span class=\"hljs-number\"> 4 </span> A001  31<br>4  <span class=\"hljs-number\"> 5 </span> A002  32<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>usecols=['孕妇代码','年龄']</code> 导入<strong>指定列名</strong>的数据</li>\n</ul>\n<h2 id=\"数据清洗\">数据清洗</h2>\n<h3 id=\"缺失值处理\">缺失值处理</h3>\n<h4 id=\"查找缺失值\">查找缺失值</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br><span class=\"hljs-built_in\">print</span>(df.info())<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-28a9adf3\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-28a9adf3\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-28a9adf3\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">&lt;class 'pandas.core.frame.DataFrame'&gt;<br>RangeIndex:<span class=\"hljs-number\"> 1082 </span>entries,<span class=\"hljs-number\"> 0 </span>to 1081<br>Data columns (total<span class=\"hljs-number\"> 31 </span>columns):<br> <span class=\"hljs-comment\">#   Column        Non-Null Count  Dtype  </span><br>---  ------        --------------  -----  <br><span class=\"hljs-number\"> 0 </span>  序号           <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 1 </span>  孕妇代码         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 2 </span>  年龄           <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 3 </span>  身高           <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 4 </span>  体重           <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 5 </span>  末次月经         <span class=\"hljs-number\"> 1070 </span>non-null   object <br><span class=\"hljs-number\"> 6 </span>  IVF妊娠        <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 7 </span>  检测日期         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 8 </span>  检测抽血次数       <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 9 </span>  检测孕周         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 10 </span> 孕妇BMI        <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 11 </span> 原始读段数        <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 12 </span> 在参考基因组上比对的比例 <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 13 </span> 重复读段的比例      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 14 </span> 唯一比对的读段数     <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 15 </span> GC含量         <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 16 </span> 13号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 17 </span> 18号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 18 </span> 21号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 19 </span> X染色体的Z值      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 20 </span> Y染色体的Z值      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 21 </span> Y染色体浓度       <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 22 </span> X染色体浓度       <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 23 </span> 13号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 24 </span> 18号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 25 </span> 21号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 26 </span> 被过滤掉读段数的比例   <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 27 </span> 染色体的非整倍体     <span class=\"hljs-number\"> 126 </span>non-null    object <br><span class=\"hljs-number\"> 28 </span> 怀孕次数         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 29 </span> 生产次数         <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 30 </span> 胎儿是否健康       <span class=\"hljs-number\"> 1082 </span>non-null   object <br>dtypes: float64(17), int64(6), object(8)<br>memory usage: 262.2+ KB<br>None<br></code></pre></td></tr></tbody></table></figure><p>缺失值一般用<strong>NaN</strong>表示，在第三列中大部分非空数量为1082，而第二十七行为126行，说明第二十七行有缺失值。</p>\n        </div>\n      </div>\n    </div>\n<p>也可以使用<code>isnull()</code>方法查看缺失值：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br><span class=\"hljs-built_in\">print</span>(df.isnull())<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-639614a5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-639614a5\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-639614a5\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight mathematica\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\">         序号   孕妇代码     年龄     身高  <span class=\"hljs-operator\">...</span>  染色体的非整倍体   怀孕次数   生产次数  胎儿是否健康<br><span class=\"hljs-number\">0</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">2</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">3</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">4</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-operator\">...</span>     <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>  <span class=\"hljs-operator\">...</span>       <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>     <span class=\"hljs-operator\">...</span><br><span class=\"hljs-number\">1077</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1078</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1079</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1080</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1081</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"删除缺失值\">删除缺失值</h4>\n<p><code>dropna()</code>方法可以删除缺失值，默认情况下，删除所有行中<strong>有缺失值的行</strong>：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br>df.dropna(inplace=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-dfc7457c\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-dfc7457c\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-dfc7457c\">\n        <div class=\"fold-content\">\n          <p>未删除前：</p><figure class=\"highlight excel\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">[<span class=\"hljs-number\">1082</span> <span class=\"hljs-built_in\">rows</span> x <span class=\"hljs-number\">31</span> <span class=\"hljs-built_in\">columns</span>]<br></code></pre></td></tr></tbody></table></figure><p>删除后：</p><figure class=\"highlight excel\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">[<span class=\"hljs-number\">126</span> <span class=\"hljs-built_in\">rows</span> x <span class=\"hljs-number\">31</span> <span class=\"hljs-built_in\">columns</span>]<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"填充缺失值\">填充缺失值</h4>\n<h3 id=\"重复值处理\">重复值处理</h3>\n<h4 id=\"判断重复值\">判断重复值</h4>\n<p><code>duplicated()</code>方法可以判断数据是否重复，若没有传入参数，则默认会按照所有列的组合来判断重复值，即如果两行的所有列的值完全相同，则判定为重复行，返回 True</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br>df=df.duplicated(<span class=\"hljs-string\">'年龄'</span>)<br><span class=\"hljs-comment\"># 注意要将处理值赋给原始数据df</span><br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></tbody></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8466fca8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8466fca8\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8466fca8\">\n        <div class=\"fold-content\">\n          <p>默认情况，<strong>无参数</strong>：</p><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>      False<br><span class=\"hljs-symbol\">1 </span>      False<br><span class=\"hljs-symbol\">2 </span>      False<br><span class=\"hljs-symbol\">3 </span>      False<br><span class=\"hljs-symbol\">4 </span>      False<br></code></pre></td></tr></tbody></table></figure><p><strong>含参数</strong>，只判断某一列重复值：</p><figure class=\"highlight basic\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>      False<br><span class=\"hljs-symbol\">1 </span>       True<br><span class=\"hljs-symbol\">2 </span>       True<br><span class=\"hljs-symbol\">3 </span>       True<br><span class=\"hljs-symbol\">4 </span>      False<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"删除重复值\">删除重复值</h4>\n<p><code>drop_duplicates()</code>方法可以删除重复值，默认情况下，删除所有行中<strong>有重复值的行</strong>：</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>,<span class=\"hljs-string\">'男胎检测数据'</span>)<br>df=df.drop_duplicates(<span class=\"hljs-string\">'孕妇代码'</span>)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">df=df.drop_duplicates(<span class=\"hljs-string\">'孕妇代码'</span>,keep=<span class=\"hljs-string\">'last'</span>)<br></code></pre></td></tr></tbody></table></figure>\n<p>参数<strong>默认保留重复的第一行</strong>，可选参数保留重复的最后一行或任意行</p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-1af6d403\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-1af6d403\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-1af6d403\">\n        <div class=\"fold-content\">\n          <p>默认情况，<strong>无参数</strong>：</p><figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0       <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.00  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1       <span class=\"hljs-number\"> 2 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.00  ...   0.019617      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>2       <span class=\"hljs-number\"> 3 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.00  ...   0.022312      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>3       <span class=\"hljs-number\"> 4 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  74.00  ...   0.023280      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4       <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.00  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br>...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...<br>1077 <span class=\"hljs-number\"> 1078 </span> A266 <span class=\"hljs-number\"> 30 </span> 159.0  83.35  ...   0.017951      T18   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1078 <span class=\"hljs-number\"> 1079 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  73.76  ...   0.022549      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1079 <span class=\"hljs-number\"> 1080 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  74.06  ...   0.021330      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1080 <span class=\"hljs-number\"> 1081 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  74.74  ...   0.022013      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1081 <span class=\"hljs-number\"> 1082 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  75.85  ...   0.016906      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br><br>[1082 rows x<span class=\"hljs-number\"> 31 </span>columns]<br></code></pre></td></tr></tbody></table></figure><p><strong>含参数</strong></p><figure class=\"highlight tap\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0       <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.00  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4       <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.00  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br>9      <span class=\"hljs-number\"> 10 </span> A003 <span class=\"hljs-number\"> 35 </span> 160.0  78.70  ...   0.021138      T21   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>15     <span class=\"hljs-number\"> 16 </span> A004 <span class=\"hljs-number\"> 26 </span> 158.0  71.50  ...   0.021022      NaN   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>19     <span class=\"hljs-number\"> 20 </span> A005 <span class=\"hljs-number\"> 30 </span> 150.0  67.40  ...   0.025210      NaN   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...<br>1062 <span class=\"hljs-number\"> 1063 </span> A263 <span class=\"hljs-number\"> 30 </span> 157.0  72.34  ...   0.024222      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1066 <span class=\"hljs-number\"> 1067 </span> A264 <span class=\"hljs-number\"> 30 </span> 171.0  94.95  ...   0.024366      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1070 <span class=\"hljs-number\"> 1071 </span> A265 <span class=\"hljs-number\"> 32 </span> 168.0  95.17  ...   0.025949      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1074 <span class=\"hljs-number\"> 1075 </span> A266 <span class=\"hljs-number\"> 30 </span> 159.0  81.24  ...   0.025132   T13T18   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1078 <span class=\"hljs-number\"> 1079 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  73.76  ...   0.022549      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br><br>[267 rows x<span class=\"hljs-number\"> 31 </span>columns]<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"异常值处理\">异常值处理</h3>\n<h4 id=\"箱型线法\">箱型线法</h4>\n<p>箱型线法是基于数据的<strong>四分位数</strong>构建 “箱体” 和 “须”，通过设定合理范围识别异常值，超过<strong>设定的上限或下限</strong>都可以被认定为异常值，具有<strong>不依赖数据分布</strong>、<strong>对极端值鲁棒</strong>的特点。</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><span class=\"hljs-comment\"># 读取数据</span><br>df = pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>, <span class=\"hljs-string\">'男胎检测数据'</span>)<br><span class=\"hljs-comment\"># 1. 计算Q1、Q3、IQR和上下限（同步骤1）</span><br>Q1 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.25</span>) <span class=\"hljs-comment\"># 下四分位数</span><br>Q3 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.75</span>) <span class=\"hljs-comment\"># 上四分位数</span><br>IQR = Q3 - Q1 <span class=\"hljs-comment\"># 四分位距</span><br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR <span class=\"hljs-comment\"># 下异常值下限</span><br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR <span class=\"hljs-comment\"># 上异常值上限</span><br><span class=\"hljs-comment\"># 2. 筛选异常值（低于下限 或 高于上限）</span><br>outliers_lower = df[df[<span class=\"hljs-string\">'体重'</span>] &lt; lower_bound]  <span class=\"hljs-comment\"># 下异常值</span><br>outliers_upper = df[df[<span class=\"hljs-string\">'体重'</span>] &gt; upper_bound]  <span class=\"hljs-comment\"># 上异常值</span><br>all_outliers = pd.concat([outliers_lower, outliers_upper])  <span class=\"hljs-comment\"># 所有异常值</span><br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"删除异常值\">删除异常值</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><br>df = pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>, <span class=\"hljs-string\">'男胎检测数据'</span>)<br>Q1 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><br><span class=\"hljs-comment\"># 筛选正常数据（排除异常值）</span><br>df_cleaned = df[(df[<span class=\"hljs-string\">'体重'</span>] &gt;= lower_bound) &amp; (df[<span class=\"hljs-string\">'体重'</span>] &lt;= upper_bound)]<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"填充异常值\">填充异常值</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df = pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>, <span class=\"hljs-string\">'男胎检测数据'</span>)<br>Q1 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><span class=\"hljs-comment\"># 计算填充值（用体重列的中位数）</span><br>weight_median = df[<span class=\"hljs-string\">'体重'</span>].median()<br><span class=\"hljs-comment\"># 用中位数填充下异常值（体重 &lt; 下限）</span><br>df.loc[df[<span class=\"hljs-string\">'体重'</span>] &lt; lower_bound, <span class=\"hljs-string\">'体重'</span>] = weight_median<br><span class=\"hljs-comment\"># 用中位数填充上异常值（体重 &gt; 上限）</span><br>df.loc[df[<span class=\"hljs-string\">'体重'</span>] &gt; upper_bound, <span class=\"hljs-string\">'体重'</span>] = weight_median<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"盖帽处理\">盖帽处理</h4>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df = pd.read_excel(<span class=\"hljs-string\">'附件.xlsx'</span>, <span class=\"hljs-string\">'男胎检测数据'</span>)<br>Q1 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">'体重'</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><span class=\"hljs-comment\"># 下异常值替换为下限</span><br>df.loc[df[<span class=\"hljs-string\">'体重'</span>] &lt; lower_bound, <span class=\"hljs-string\">'体重'</span>] = lower_bound<br><span class=\"hljs-comment\"># 上异常值替换为上限</span><br>df.loc[df[<span class=\"hljs-string\">'体重'</span>] &gt; upper_bound, <span class=\"hljs-string\">'体重'</span>] = upper_bound<br></code></pre></td></tr></tbody></table></figure>","excerpt":"","more":"<div class=\"note note-info\">\n            <div class=\"fold\">  <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-4cc89ac7\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-4cc89ac7\">    <div class=\"fold-arrow\">▶</div> 什么是 pip ？  </div>  <div class=\"fold-collapse collapse\" id=\"collapse-4cc89ac7\">    <div class=\"fold-content\">      <p><code>pip</code>是 Python 的包管理工具，全称是 Python Install Packages，所有人都可以下载或上传自己开发的库到 PyPI 上，常见的指令有：</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">pip install pandas<br></code></pre></td></tr></table></figure>    </div>  </div></div>\n          </div>\n<h3 id=\"Series对象\">Series对象</h3>\n<p>Series对象是pandas中可<strong>存储多种类型的一维数组</strong>，由<strong>数据</strong>与<strong>索引</strong>组成。</p>\n<h4 id=\"默认索引为0\">默认索引为0</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>])<br><span class=\"hljs-built_in\">print</span>(s1)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>   <span class=\"hljs-number\">1</span><br><span class=\"hljs-symbol\">1 </span>   <span class=\"hljs-number\">2</span><br><span class=\"hljs-symbol\">2 </span>   <span class=\"hljs-number\">3</span><br><span class=\"hljs-symbol\">3 </span>   <span class=\"hljs-number\">4</span><br><span class=\"hljs-symbol\">4 </span>   <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n<p>这里就可以采用<strong>位置</strong>进行索引</p>\n<h4 id=\"自定义索引\">自定义索引</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>])<br><span class=\"hljs-built_in\">print</span>(s1)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">a</span>    <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">b</span>    <span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">c</span>    <span class=\"hljs-number\">3</span><br><span class=\"hljs-attribute\">d</span>    <span class=\"hljs-number\">4</span><br><span class=\"hljs-attribute\">e</span>    <span class=\"hljs-number\">5</span><br></code></pre></td></tr></table></figure>\n<p>这里就可以使用自定义的<strong>标签</strong>进行索引</p>\n<hr>\n<p>同时上述两种方法也都可以支持<strong>切片索引</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>])<br><span class=\"hljs-built_in\">print</span>(s1[<span class=\"hljs-string\">&#x27;a&#x27;</span>:<span class=\"hljs-string\">&#x27;d&#x27;</span>])<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">a</span>    <span class=\"hljs-number\">1</span><br><span class=\"hljs-attribute\">b</span>    <span class=\"hljs-number\">2</span><br><span class=\"hljs-attribute\">c</span>    <span class=\"hljs-number\">3</span><br><span class=\"hljs-attribute\">d</span>    <span class=\"hljs-number\">4</span><br></code></pre></td></tr></table></figure>\n<hr>\n<p>我们也可以<strong>同时获取数据与索引</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>s1=pd.Series([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>],index=[<span class=\"hljs-string\">&#x27;a&#x27;</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>,<span class=\"hljs-string\">&#x27;c&#x27;</span>,<span class=\"hljs-string\">&#x27;d&#x27;</span>,<span class=\"hljs-string\">&#x27;e&#x27;</span>])<br><span class=\"hljs-built_in\">print</span>(s1.index)<br><span class=\"hljs-built_in\">print</span>(s1.values)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Index</span><span class=\"hljs-params\">([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>], dtype=<span class=\"hljs-string\">&#x27;object&#x27;</span>)</span></span><br><span class=\"hljs-selector-attr\">[1 2 3 4 5]</span><br></code></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"DataFrame对象\">DataFrame对象</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pandas.DataFrame(data,index,columns)<br><span class=\"hljs-comment\"># 分别对应数据 行索引 列索引</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"列表创建DataFrame对象\">列表创建DataFrame对象</h4>\n<p>当对象更注重<strong>列方向</strong>数据关联时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>data=[[<span class=\"hljs-number\">110</span>,<span class=\"hljs-number\">135</span>,<span class=\"hljs-number\">125</span>],[<span class=\"hljs-number\">115</span>,<span class=\"hljs-number\">140</span>,<span class=\"hljs-number\">130</span>],[<span class=\"hljs-number\">120</span>,<span class=\"hljs-number\">145</span>,<span class=\"hljs-number\">135</span>]]<br>columns=[<span class=\"hljs-string\">&#x27;语文&#x27;</span>,<span class=\"hljs-string\">&#x27;数学&#x27;</span>,<span class=\"hljs-string\">&#x27;英语&#x27;</span>]<br>df=pd.DataFrame(data=data,columns=columns)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></table></figure>\n<h4 id=\"字典创建DataFrame对象\">字典创建DataFrame对象</h4>\n<p>当对象更注重<strong>行方向</strong>数据关联时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.DataFrame(&#123;<br><span class=\"hljs-string\">&#x27;语文&#x27;</span>:[<span class=\"hljs-number\">110</span>,<span class=\"hljs-number\">115</span>,<span class=\"hljs-number\">120</span>],<br><span class=\"hljs-string\">&#x27;数学&#x27;</span>:[<span class=\"hljs-number\">135</span>,<span class=\"hljs-number\">140</span>,<span class=\"hljs-number\">145</span>],<br><span class=\"hljs-string\">&#x27;英语&#x27;</span>:[<span class=\"hljs-number\">125</span>,<span class=\"hljs-number\">130</span>,<span class=\"hljs-number\">135</span>],<br><span class=\"hljs-string\">&#x27;班级&#x27;</span>:<span class=\"hljs-string\">&#x27;24-3班&#x27;</span><br>&#125;)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">    语文   数学   英语     班级<br>0 <span class=\"hljs-number\"> 110 </span><span class=\"hljs-number\"> 135 </span><span class=\"hljs-number\"> 125 </span> 24-3班<br>1 <span class=\"hljs-number\"> 115 </span><span class=\"hljs-number\"> 140 </span><span class=\"hljs-number\"> 130 </span> 24-3班<br>2 <span class=\"hljs-number\"> 120 </span><span class=\"hljs-number\"> 145 </span><span class=\"hljs-number\"> 135 </span> 24-3班<br></code></pre></td></tr></table></figure>\n<h2 id=\"导入外部数据\">导入外部数据</h2>\n<h3 id=\"导入-xls-和-xlsx-文件\">导入 .xls 和 .xlsx 文件</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">pandas.read_excel(file_path,sheet_name)<br></code></pre></td></tr></table></figure>\n<p>默认情况下，sheet_name参数为0，表示读取第一个工作表。</p>\n<ul>\n<li><code>sheet_name=1</code> 表示读取第二个工作表</li>\n<li><code>sheet_name='sheet_name'</code> 表示读取<strong>指定名称的工作表</strong></li>\n<li><code>sheet_name=None</code> 读取<strong>所有工作表</strong></li>\n<li><code>sheet_name=[1,2,'Sheet4']</code> 读取<strong>指定索引或名称的工作表</strong></li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(df.head()) <span class=\"hljs-comment\"># 输出前五行</span><br><span class=\"hljs-built_in\">print</span>(df.tail()) <span class=\"hljs-comment\"># 输出最后五行</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">  序号  孕妇代码  年龄     身高    体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0  <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.0  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1  <span class=\"hljs-number\"> 2 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.0  ...   0.019617      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>2  <span class=\"hljs-number\"> 3 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.0  ...   0.022312      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>3  <span class=\"hljs-number\"> 4 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  74.0  ...   0.023280      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4  <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.0  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br></code></pre></td></tr></table></figure>\n<h4 id=\"行-列索引\">行/列索引</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>,index_col=<span class=\"hljs-number\">3</span>)<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 将第四列放在首列作为行索引</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>,header=<span class=\"hljs-literal\">None</span>)<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 将数字作为列索引</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"导入指定行-列\">导入指定行/列</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>,usecols=[<span class=\"hljs-number\">1</span>])<br><span class=\"hljs-built_in\">print</span>(df.head())<br><span class=\"hljs-built_in\">print</span>(df.tail())<br><span class=\"hljs-comment\"># 导入第二列的数据</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>usecols=[1,2,3]</code> 指定<strong>多列进行导入</strong>，导入第1、2、3列的数据</li>\n<li><code>usecols='A:C'</code> 导入A列到C列的数据</li>\n</ul>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">   序号  孕妇代码  年龄<br>0  <span class=\"hljs-number\"> 1 </span> A001  31<br>1  <span class=\"hljs-number\"> 2 </span> A001  31<br>2  <span class=\"hljs-number\"> 3 </span> A001  31<br>3  <span class=\"hljs-number\"> 4 </span> A001  31<br>4  <span class=\"hljs-number\"> 5 </span> A002  32<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>usecols=['孕妇代码','年龄']</code> 导入<strong>指定列名</strong>的数据</li>\n</ul>\n<h2 id=\"数据清洗\">数据清洗</h2>\n<h3 id=\"缺失值处理\">缺失值处理</h3>\n<h4 id=\"查找缺失值\">查找缺失值</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(df.info())<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-28a9adf3\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-28a9adf3\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-28a9adf3\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;<br>RangeIndex:<span class=\"hljs-number\"> 1082 </span>entries,<span class=\"hljs-number\"> 0 </span>to 1081<br>Data columns (total<span class=\"hljs-number\"> 31 </span>columns):<br> <span class=\"hljs-comment\">#   Column        Non-Null Count  Dtype  </span><br>---  ------        --------------  -----  <br><span class=\"hljs-number\"> 0 </span>  序号           <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 1 </span>  孕妇代码         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 2 </span>  年龄           <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 3 </span>  身高           <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 4 </span>  体重           <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 5 </span>  末次月经         <span class=\"hljs-number\"> 1070 </span>non-null   object <br><span class=\"hljs-number\"> 6 </span>  IVF妊娠        <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 7 </span>  检测日期         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 8 </span>  检测抽血次数       <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 9 </span>  检测孕周         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 10 </span> 孕妇BMI        <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 11 </span> 原始读段数        <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 12 </span> 在参考基因组上比对的比例 <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 13 </span> 重复读段的比例      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 14 </span> 唯一比对的读段数     <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 15 </span> GC含量         <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 16 </span> 13号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 17 </span> 18号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 18 </span> 21号染色体的Z值    <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 19 </span> X染色体的Z值      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 20 </span> Y染色体的Z值      <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 21 </span> Y染色体浓度       <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 22 </span> X染色体浓度       <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 23 </span> 13号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 24 </span> 18号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 25 </span> 21号染色体的GC含量  <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 26 </span> 被过滤掉读段数的比例   <span class=\"hljs-number\"> 1082 </span>non-null   float64<br><span class=\"hljs-number\"> 27 </span> 染色体的非整倍体     <span class=\"hljs-number\"> 126 </span>non-null    object <br><span class=\"hljs-number\"> 28 </span> 怀孕次数         <span class=\"hljs-number\"> 1082 </span>non-null   object <br><span class=\"hljs-number\"> 29 </span> 生产次数         <span class=\"hljs-number\"> 1082 </span>non-null   int64  <br><span class=\"hljs-number\"> 30 </span> 胎儿是否健康       <span class=\"hljs-number\"> 1082 </span>non-null   object <br>dtypes: float64(17), int64(6), object(8)<br>memory usage: 262.2+ KB<br>None<br></code></pre></td></tr></table></figure><p>缺失值一般用<strong>NaN</strong>表示，在第三列中大部分非空数量为1082，而第二十七行为126行，说明第二十七行有缺失值。</p>\n        </div>\n      </div>\n    </div>\n<p>也可以使用<code>isnull()</code>方法查看缺失值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(df.isnull())<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-639614a5\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-639614a5\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-639614a5\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight mathematica\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mathematica\">         序号   孕妇代码     年龄     身高  <span class=\"hljs-operator\">...</span>  染色体的非整倍体   怀孕次数   生产次数  胎儿是否健康<br><span class=\"hljs-number\">0</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">2</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">3</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">4</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-operator\">...</span>     <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>  <span class=\"hljs-operator\">...</span>       <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>    <span class=\"hljs-operator\">...</span>     <span class=\"hljs-operator\">...</span><br><span class=\"hljs-number\">1077</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1078</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>     <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1079</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1080</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br><span class=\"hljs-number\">1081</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-operator\">...</span>      <span class=\"hljs-built_in\">True</span>  <span class=\"hljs-built_in\">False</span>  <span class=\"hljs-built_in\">False</span>   <span class=\"hljs-built_in\">False</span><br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"删除缺失值\">删除缺失值</h4>\n<p><code>dropna()</code>方法可以删除缺失值，默认情况下，删除所有行中<strong>有缺失值的行</strong>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>df.dropna(inplace=<span class=\"hljs-literal\">True</span>)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-dfc7457c\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-dfc7457c\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-dfc7457c\">\n        <div class=\"fold-content\">\n          <p>未删除前：</p><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">[<span class=\"hljs-number\">1082</span> <span class=\"hljs-built_in\">rows</span> x <span class=\"hljs-number\">31</span> <span class=\"hljs-built_in\">columns</span>]<br></code></pre></td></tr></table></figure><p>删除后：</p><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs excel\">[<span class=\"hljs-number\">126</span> <span class=\"hljs-built_in\">rows</span> x <span class=\"hljs-number\">31</span> <span class=\"hljs-built_in\">columns</span>]<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"填充缺失值\">填充缺失值</h4>\n<h3 id=\"重复值处理\">重复值处理</h3>\n<h4 id=\"判断重复值\">判断重复值</h4>\n<p><code>duplicated()</code>方法可以判断数据是否重复，若没有传入参数，则默认会按照所有列的组合来判断重复值，即如果两行的所有列的值完全相同，则判定为重复行，返回 True</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>df=df.duplicated(<span class=\"hljs-string\">&#x27;年龄&#x27;</span>)<br><span class=\"hljs-comment\"># 注意要将处理值赋给原始数据df</span><br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></table></figure>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8466fca8\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8466fca8\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8466fca8\">\n        <div class=\"fold-content\">\n          <p>默认情况，<strong>无参数</strong>：</p><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>      False<br><span class=\"hljs-symbol\">1 </span>      False<br><span class=\"hljs-symbol\">2 </span>      False<br><span class=\"hljs-symbol\">3 </span>      False<br><span class=\"hljs-symbol\">4 </span>      False<br></code></pre></td></tr></table></figure><p><strong>含参数</strong>，只判断某一列重复值：</p><figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs basic\"><span class=\"hljs-symbol\">0 </span>      False<br><span class=\"hljs-symbol\">1 </span>       True<br><span class=\"hljs-symbol\">2 </span>       True<br><span class=\"hljs-symbol\">3 </span>       True<br><span class=\"hljs-symbol\">4 </span>      False<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<hr>\n<h4 id=\"删除重复值\">删除重复值</h4>\n<p><code>drop_duplicates()</code>方法可以删除重复值，默认情况下，删除所有行中<strong>有重复值的行</strong>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df=pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>,<span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>df=df.drop_duplicates(<span class=\"hljs-string\">&#x27;孕妇代码&#x27;</span>)<br><span class=\"hljs-built_in\">print</span>(df)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">df=df.drop_duplicates(<span class=\"hljs-string\">&#x27;孕妇代码&#x27;</span>,keep=<span class=\"hljs-string\">&#x27;last&#x27;</span>)<br></code></pre></td></tr></table></figure>\n<p>参数<strong>默认保留重复的第一行</strong>，可选参数保留重复的最后一行或任意行</p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-1af6d403\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-1af6d403\">\n        <div class=\"fold-arrow\">▶</div>查看运行结果\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-1af6d403\">\n        <div class=\"fold-content\">\n          <p>默认情况，<strong>无参数</strong>：</p><figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0       <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.00  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1       <span class=\"hljs-number\"> 2 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.00  ...   0.019617      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>2       <span class=\"hljs-number\"> 3 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  73.00  ...   0.022312      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>3       <span class=\"hljs-number\"> 4 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  74.00  ...   0.023280      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4       <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.00  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br>...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...<br>1077 <span class=\"hljs-number\"> 1078 </span> A266 <span class=\"hljs-number\"> 30 </span> 159.0  83.35  ...   0.017951      T18   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1078 <span class=\"hljs-number\"> 1079 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  73.76  ...   0.022549      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1079 <span class=\"hljs-number\"> 1080 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  74.06  ...   0.021330      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1080 <span class=\"hljs-number\"> 1081 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  74.74  ...   0.022013      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1081 <span class=\"hljs-number\"> 1082 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  75.85  ...   0.016906      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br><br>[1082 rows x<span class=\"hljs-number\"> 31 </span>columns]<br></code></pre></td></tr></table></figure><p><strong>含参数</strong></p><figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">        序号  孕妇代码  年龄     身高     体重  ... 被过滤掉读段数的比例 染色体的非整倍体 怀孕次数  生产次数 胎儿是否健康<br>0       <span class=\"hljs-number\"> 1 </span> A001 <span class=\"hljs-number\"> 31 </span> 160.0  72.00  ...   0.027484      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>4       <span class=\"hljs-number\"> 5 </span> A002 <span class=\"hljs-number\"> 32 </span> 149.0  74.00  ...   0.024212      NaN   <span class=\"hljs-number\"> 2 </span>   <span class=\"hljs-number\"> 1 </span>     否<br>9      <span class=\"hljs-number\"> 10 </span> A003 <span class=\"hljs-number\"> 35 </span> 160.0  78.70  ...   0.021138      T21   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>15     <span class=\"hljs-number\"> 16 </span> A004 <span class=\"hljs-number\"> 26 </span> 158.0  71.50  ...   0.021022      NaN   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>19     <span class=\"hljs-number\"> 20 </span> A005 <span class=\"hljs-number\"> 30 </span> 150.0  67.40  ...   0.025210      NaN   ≥3    <span class=\"hljs-number\"> 1 </span>     是<br>...    ...   ...  ..    ...    ...  ...        ...      ...  ...   ...    ...<br>1062 <span class=\"hljs-number\"> 1063 </span> A263 <span class=\"hljs-number\"> 30 </span> 157.0  72.34  ...   0.024222      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1066 <span class=\"hljs-number\"> 1067 </span> A264 <span class=\"hljs-number\"> 30 </span> 171.0  94.95  ...   0.024366      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1070 <span class=\"hljs-number\"> 1071 </span> A265 <span class=\"hljs-number\"> 32 </span> 168.0  95.17  ...   0.025949      NaN   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1074 <span class=\"hljs-number\"> 1075 </span> A266 <span class=\"hljs-number\"> 30 </span> 159.0  81.24  ...   0.025132   T13T18   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br>1078 <span class=\"hljs-number\"> 1079 </span> A267 <span class=\"hljs-number\"> 28 </span> 155.0  73.76  ...   0.022549      T21   <span class=\"hljs-number\"> 1 </span>   <span class=\"hljs-number\"> 0 </span>     是<br><br>[267 rows x<span class=\"hljs-number\"> 31 </span>columns]<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"异常值处理\">异常值处理</h3>\n<h4 id=\"箱型线法\">箱型线法</h4>\n<p>箱型线法是基于数据的<strong>四分位数</strong>构建 “箱体” 和 “须”，通过设定合理范围识别异常值，超过<strong>设定的上限或下限</strong>都可以被认定为异常值，具有<strong>不依赖数据分布</strong>、<strong>对极端值鲁棒</strong>的特点。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><span class=\"hljs-comment\"># 读取数据</span><br>df = pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>, <span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br><span class=\"hljs-comment\"># 1. 计算Q1、Q3、IQR和上下限（同步骤1）</span><br>Q1 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.25</span>) <span class=\"hljs-comment\"># 下四分位数</span><br>Q3 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.75</span>) <span class=\"hljs-comment\"># 上四分位数</span><br>IQR = Q3 - Q1 <span class=\"hljs-comment\"># 四分位距</span><br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR <span class=\"hljs-comment\"># 下异常值下限</span><br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR <span class=\"hljs-comment\"># 上异常值上限</span><br><span class=\"hljs-comment\"># 2. 筛选异常值（低于下限 或 高于上限）</span><br>outliers_lower = df[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &lt; lower_bound]  <span class=\"hljs-comment\"># 下异常值</span><br>outliers_upper = df[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &gt; upper_bound]  <span class=\"hljs-comment\"># 上异常值</span><br>all_outliers = pd.concat([outliers_lower, outliers_upper])  <span class=\"hljs-comment\"># 所有异常值</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"删除异常值\">删除异常值</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br><br>df = pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>, <span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>Q1 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><br><span class=\"hljs-comment\"># 筛选正常数据（排除异常值）</span><br>df_cleaned = df[(df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &gt;= lower_bound) &amp; (df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &lt;= upper_bound)]<br></code></pre></td></tr></table></figure>\n<h4 id=\"填充异常值\">填充异常值</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df = pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>, <span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>Q1 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><span class=\"hljs-comment\"># 计算填充值（用体重列的中位数）</span><br>weight_median = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].median()<br><span class=\"hljs-comment\"># 用中位数填充下异常值（体重 &lt; 下限）</span><br>df.loc[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &lt; lower_bound, <span class=\"hljs-string\">&#x27;体重&#x27;</span>] = weight_median<br><span class=\"hljs-comment\"># 用中位数填充上异常值（体重 &gt; 上限）</span><br>df.loc[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &gt; upper_bound, <span class=\"hljs-string\">&#x27;体重&#x27;</span>] = weight_median<br></code></pre></td></tr></table></figure>\n<h4 id=\"盖帽处理\">盖帽处理</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd<br>df = pd.read_excel(<span class=\"hljs-string\">&#x27;附件.xlsx&#x27;</span>, <span class=\"hljs-string\">&#x27;男胎检测数据&#x27;</span>)<br>Q1 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.25</span>)<br>Q3 = df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>].quantile(<span class=\"hljs-number\">0.75</span>)<br>IQR = Q3 - Q1<br>lower_bound = Q1 - <span class=\"hljs-number\">1.5</span> * IQR<br>upper_bound = Q3 + <span class=\"hljs-number\">1.5</span> * IQR<br><span class=\"hljs-comment\"># 下异常值替换为下限</span><br>df.loc[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &lt; lower_bound, <span class=\"hljs-string\">&#x27;体重&#x27;</span>] = lower_bound<br><span class=\"hljs-comment\"># 上异常值替换为上限</span><br>df.loc[df[<span class=\"hljs-string\">&#x27;体重&#x27;</span>] &gt; upper_bound, <span class=\"hljs-string\">&#x27;体重&#x27;</span>] = upper_bound<br></code></pre></td></tr></table></figure>"},{"title":"Probability Theory","date":"2025-09-04T04:54:45.000Z","archive":true,"_content":"\n## 随机事件及其概率\n因为$A\\overline{B} = A - B$，所以在概率计算中，有 $P(A\\overline{B}) = P(A - B)$。结合概率的性质 $P(A - B) = P(A) - P(AB)$，因此有：\n\n$$P(A\\overline{B}) = P(A） - P（AB)$$\n\n条件概率：$P(A \\mid B) = \\frac{P(AB)}{P(B)}$\n\n通常反向利用：$P(A \\mid B) {P(B)} = {P(AB)}$\n\n## 随机变量及其分布\n二项分布：\n$$P{X=K}=C^k_n p^k(1-p)^{n-k}$$\n泊松分布：\n$$P{X=k}=\\frac{\\lambda^k}{k!}e^{-\\lambda}$$\n当二项分布的n很大，p很小，且$\\lambda=np$时，二项分布可近似为泊松分布。\n随机变量的分布函数\n用于研究某一变量落某个区间内的概率\n$$F(x)=P{X\\leq x}$$\n满足：\n分布函数有界性（正无穷、负无穷极限）\n$$\\lim_{x \\to +\\infty} F(x) = 1, \\quad \\lim_{x \\to -\\infty} F(x) = 0$$","source":"_posts/Review/Probability-Theory.md","raw":"---\ntitle: Probability Theory\ndate: 2025-09-04 12:54:45\ntags:\narchive: true\n---\n\n## 随机事件及其概率\n因为$A\\overline{B} = A - B$，所以在概率计算中，有 $P(A\\overline{B}) = P(A - B)$。结合概率的性质 $P(A - B) = P(A) - P(AB)$，因此有：\n\n$$P(A\\overline{B}) = P(A） - P（AB)$$\n\n条件概率：$P(A \\mid B) = \\frac{P(AB)}{P(B)}$\n\n通常反向利用：$P(A \\mid B) {P(B)} = {P(AB)}$\n\n## 随机变量及其分布\n二项分布：\n$$P{X=K}=C^k_n p^k(1-p)^{n-k}$$\n泊松分布：\n$$P{X=k}=\\frac{\\lambda^k}{k!}e^{-\\lambda}$$\n当二项分布的n很大，p很小，且$\\lambda=np$时，二项分布可近似为泊松分布。\n随机变量的分布函数\n用于研究某一变量落某个区间内的概率\n$$F(x)=P{X\\leq x}$$\n满足：\n分布函数有界性（正无穷、负无穷极限）\n$$\\lim_{x \\to +\\infty} F(x) = 1, \\quad \\lim_{x \\to -\\infty} F(x) = 0$$","slug":"Review/Probability-Theory","published":1,"updated":"2025-09-12T06:20:41.064Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcr001r40w35vjtcnud","content":"<h2 id=\"随机事件及其概率\">随机事件及其概率</h2>\n<p>因为$A\\overline{B} = A - B$，所以在概率计算中，有 $P(A\\overline{B}) = P(A - B)$。结合概率的性质 $P(A - B) = P(A) - P(AB)$，因此有：</p>\n<p>$$P(A\\overline{B}) = P(A） - P（AB)$$</p>\n<p>条件概率：$P(A \\mid B) = \\frac{P(AB)}{P(B)}$</p>\n<p>通常反向利用：$P(A \\mid B) {P(B)} = {P(AB)}$</p>\n<h2 id=\"随机变量及其分布\">随机变量及其分布</h2>\n<p>二项分布：<br>\n$$P{X=K}=C^k_n p<sup>k(1-p)</sup>{n-k}$$<br>\n泊松分布：<br>\n$$P{X=k}=\\frac{\\lambda<sup>k}{k!}e</sup>{-\\lambda}$$<br>\n当二项分布的n很大，p很小，且$\\lambda=np$时，二项分布可近似为泊松分布。<br>\n随机变量的分布函数<br>\n用于研究某一变量落某个区间内的概率<br>\n$$F(x)=P{X\\leq x}$$<br>\n满足：<br>\n分布函数有界性（正无穷、负无穷极限）<br>\n$$\\lim_{x \\to +\\infty} F(x) = 1, \\quad \\lim_{x \\to -\\infty} F(x) = 0$$</p>\n","excerpt":"","more":"<h2 id=\"随机事件及其概率\">随机事件及其概率</h2>\n<p>因为$A\\overline{B} = A - B$，所以在概率计算中，有 $P(A\\overline{B}) = P(A - B)$。结合概率的性质 $P(A - B) = P(A) - P(AB)$，因此有：</p>\n<p>$$P(A\\overline{B}) = P(A） - P（AB)$$</p>\n<p>条件概率：$P(A \\mid B) = \\frac{P(AB)}{P(B)}$</p>\n<p>通常反向利用：$P(A \\mid B) {P(B)} = {P(AB)}$</p>\n<h2 id=\"随机变量及其分布\">随机变量及其分布</h2>\n<p>二项分布：<br>\n$$P{X=K}=C^k_n p<sup>k(1-p)</sup>{n-k}$$<br>\n泊松分布：<br>\n$$P{X=k}=\\frac{\\lambda<sup>k}{k!}e</sup>{-\\lambda}$$<br>\n当二项分布的n很大，p很小，且$\\lambda=np$时，二项分布可近似为泊松分布。<br>\n随机变量的分布函数<br>\n用于研究某一变量落某个区间内的概率<br>\n$$F(x)=P{X\\leq x}$$<br>\n满足：<br>\n分布函数有界性（正无穷、负无穷极限）<br>\n$$\\lim_{x \\to +\\infty} F(x) = 1, \\quad \\lim_{x \\to -\\infty} F(x) = 0$$</p>\n"},{"title":"About Me and My Blog","date":"2025-06-04T10:33:26.000Z","sticky":100,"index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/About%20Me%20and%20My%20Blog.png","category_bar":true,"description":"Brief Self-Introduction and the Motivation Behind Deploying My Blog!!!","_content":"\n## Before The Blog\n&emsp;&emsp;从高中到大学，我一直保持着系统化记笔记的学习习惯。然而，计算机专业的独特性让我一度感到不适应——知识的海洋如此浩瀚，技术栈的广度令人惊叹，传统的应试学习方法在这里显得捉襟见肘。\n\n&emsp;&emsp;机缘巧合之下我在牛客等招聘网站上看到优秀求职者的技术博客链接，又注意到同学在朋友圈分享的博客文章，相互交换博客链接，相互学习。这些见闻就像一粒种子，在我心中悄然生根发芽。\n\n&emsp;&emsp;但向来语文表达能力欠佳的我，对于博客撰写还是稍有抵触态度的，只是在CSDN上慢慢开始了尝试，逐渐发现在**AI大模型**语言润色写作的支持下，或许并不困难。甚至这种**将知识咀嚼在二次消化的“反刍”过程**，使我内心产生了巨大的**成就感**！\n\n这里引用一下我的这位同学博客里的原话：\n\n{% note default %}&emsp;&emsp;“无论是解题、写作，还是费曼学习法，其本质都是**通过输出来强化知识**的吸收。当你能够流畅地演绎一道数学题的多种解法，或是将庞杂的知识梳理成清晰的逻辑链条，甚至写成一篇能让读者受益的博客时，你便完成了**从输入到输出**的有效做功。而这一过程，不仅让知识真正内化，更赋予人莫大的成就感。”{% endnote %}\n\n{% note default %}\n&emsp;&emsp;“然而，写作——尤其是高质量的博客写作——远非简单的文字堆砌。回想高中写议论文时的经历，你是否也曾感到一种“言不尽意”的挫败？**灵感的闪现 ≠ 逻辑的成型 ≠ 语言的表达 ≠ 理想的呈现**。很多时候，我们脑海中的所谓“灵感”，不过是零星的思维火花，距离一篇结构严谨、论证充分、兼具深度与可读性的文章，仍有漫长的路要走。”\n{% endnote %}\n\n{% note default %}\n&emsp;&emsp;“而这，正是博客写作的真正挑战，也是它最珍贵的训练价值——**如何将飘忽的灵感锤炼成扎实的文字，在逻辑与专业之间找到平衡，最终实现清晰而有力的表达。**”\n{% endnote %}\n\n\n&emsp;&emsp;在CSDN的简单试水中，我收获了莫大的自信，遂趁着期末周刚结束，全身心地投入到Github个人博客的创建中来！\n\n![截止2025年7月13日CSDN状态图](https://github.com/Richard110206/Blog-image/blob/main/article/General/About%20Me%20and%20My%20Blog/About-Me-and-My-Blog.png?raw=true)\n\n\n## About Myself\n\n {% note primary%}\n I am **Li Qinxuan (李沁轩)**, a dedicated Computer Science and Technology scholar at **China University of Mining and Technology (中国矿业大学)**. My academic pursuits encompass diverse domains of computing, with specialized expertise and fervent enthusiasm for **computer vision** and **algorithmic design**.{% endnote %}\n\n<div style=\"text-align: center;\">\n  <strong style=\"color: red; font-size: 2em;\">KEEP CODING!!!</strong>\n</div>\n\n\n\n### Programming Languages\n- C++\n- Python\n- HTML\n- Matlab\n- Javascript (still learning)\n\n\n### Tools\n- Git\n- LaTex\n- Vim\n- Markdown\n- Bash\n\n\n\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cplusplus/cplusplus-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"C++\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Python\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"HTML5\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"JavaScript\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Bash\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Git\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/latex/latex-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"LaTeX\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Linux\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/numpy/numpy-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"NumPy\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pytorch/pytorch-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"PyTorch\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/matplotlib/matplotlib-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Matplotlib\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pandas/pandas-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Pandas\"/>\n\n### Currently Learning\n- Full-Stack Development\n- Python for Data Analysis and Visualization\n- Probability and Statistics\n\n### Contact With Me\n\n + lqx3222482537@qq.com\n + richardli.11.02.06@gmail.com\n + 08241120@cumt.edu.cn\n\n### My Blog in CSDN\n[不在了情绪的CSDN博客账号](https://blog.csdn.net/2401_86849688?type=blog)\n\n### GitHub Stats:\n\n**I am always an active commiter! Love Coding Everyday!** 🫡😍\n\n[Richard's Github](https://github.com/Richard110206)\n\n[![GitHub Streak](https://streak-stats.demolab.com/?user=Richard110206&theme=radical)](https://git.io/streak-stats)\n\n\n\n<img src=\"https://ghchart.rshah.org/Richard110206\" alt=\"Li Qinxuan's Github Contributions\" />\n\n### Photos\n- 图片多从YouTube和[unsplash](https://unsplash.com/)上获取\n- 使用[PicGo插件](https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here)和Github实现**图床**功能\n\n可以参考这篇博客：[Offload Your Hexo Images](https://richard110206.github.io/2025/08/21/Tutorial/Offload-Your-Hexo-Images/)\n\n***\n\n网站使用Github Pages 和 Hexo静态部署，fluid主题，相关链接地址如下：\n- [Hexo Fluid 用户手册](https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97)\n- [fluid-dev for hexo theme](https://github.com/fluid-dev/hexo-theme-fluid)\n- [开始使用 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/start/)\n- [配置指南 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/guide/)\n\n\n\n\n如果大家有任何疑问，欢迎提issue，也欢迎通过邮箱联系我，我们一起进步！\n\n\n封面来源：[Who are you?](https://www.youtube.com/watch?v=GWGbOjlJDkU)\n\n","source":"_posts/other/About Me and My Blog.md","raw":"---\ntitle: About Me and My Blog\ndate: 2025-06-04 18:33:26\ntags: [Motivation]\nsticky: 100\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/About%20Me%20and%20My%20Blog.png\ncategory_bar: true\ndescription: Brief Self-Introduction and the Motivation Behind Deploying My Blog!!!\n---\n\n## Before The Blog\n&emsp;&emsp;从高中到大学，我一直保持着系统化记笔记的学习习惯。然而，计算机专业的独特性让我一度感到不适应——知识的海洋如此浩瀚，技术栈的广度令人惊叹，传统的应试学习方法在这里显得捉襟见肘。\n\n&emsp;&emsp;机缘巧合之下我在牛客等招聘网站上看到优秀求职者的技术博客链接，又注意到同学在朋友圈分享的博客文章，相互交换博客链接，相互学习。这些见闻就像一粒种子，在我心中悄然生根发芽。\n\n&emsp;&emsp;但向来语文表达能力欠佳的我，对于博客撰写还是稍有抵触态度的，只是在CSDN上慢慢开始了尝试，逐渐发现在**AI大模型**语言润色写作的支持下，或许并不困难。甚至这种**将知识咀嚼在二次消化的“反刍”过程**，使我内心产生了巨大的**成就感**！\n\n这里引用一下我的这位同学博客里的原话：\n\n{% note default %}&emsp;&emsp;“无论是解题、写作，还是费曼学习法，其本质都是**通过输出来强化知识**的吸收。当你能够流畅地演绎一道数学题的多种解法，或是将庞杂的知识梳理成清晰的逻辑链条，甚至写成一篇能让读者受益的博客时，你便完成了**从输入到输出**的有效做功。而这一过程，不仅让知识真正内化，更赋予人莫大的成就感。”{% endnote %}\n\n{% note default %}\n&emsp;&emsp;“然而，写作——尤其是高质量的博客写作——远非简单的文字堆砌。回想高中写议论文时的经历，你是否也曾感到一种“言不尽意”的挫败？**灵感的闪现 ≠ 逻辑的成型 ≠ 语言的表达 ≠ 理想的呈现**。很多时候，我们脑海中的所谓“灵感”，不过是零星的思维火花，距离一篇结构严谨、论证充分、兼具深度与可读性的文章，仍有漫长的路要走。”\n{% endnote %}\n\n{% note default %}\n&emsp;&emsp;“而这，正是博客写作的真正挑战，也是它最珍贵的训练价值——**如何将飘忽的灵感锤炼成扎实的文字，在逻辑与专业之间找到平衡，最终实现清晰而有力的表达。**”\n{% endnote %}\n\n\n&emsp;&emsp;在CSDN的简单试水中，我收获了莫大的自信，遂趁着期末周刚结束，全身心地投入到Github个人博客的创建中来！\n\n![截止2025年7月13日CSDN状态图](https://github.com/Richard110206/Blog-image/blob/main/article/General/About%20Me%20and%20My%20Blog/About-Me-and-My-Blog.png?raw=true)\n\n\n## About Myself\n\n {% note primary%}\n I am **Li Qinxuan (李沁轩)**, a dedicated Computer Science and Technology scholar at **China University of Mining and Technology (中国矿业大学)**. My academic pursuits encompass diverse domains of computing, with specialized expertise and fervent enthusiasm for **computer vision** and **algorithmic design**.{% endnote %}\n\n<div style=\"text-align: center;\">\n  <strong style=\"color: red; font-size: 2em;\">KEEP CODING!!!</strong>\n</div>\n\n\n\n### Programming Languages\n- C++\n- Python\n- HTML\n- Matlab\n- Javascript (still learning)\n\n\n### Tools\n- Git\n- LaTex\n- Vim\n- Markdown\n- Bash\n\n\n\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cplusplus/cplusplus-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"C++\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Python\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"HTML5\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"JavaScript\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Bash\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Git\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/latex/latex-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"LaTeX\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Linux\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/numpy/numpy-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"NumPy\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pytorch/pytorch-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"PyTorch\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/matplotlib/matplotlib-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Matplotlib\"/>\n  <img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pandas/pandas-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Pandas\"/>\n\n### Currently Learning\n- Full-Stack Development\n- Python for Data Analysis and Visualization\n- Probability and Statistics\n\n### Contact With Me\n\n + lqx3222482537@qq.com\n + richardli.11.02.06@gmail.com\n + 08241120@cumt.edu.cn\n\n### My Blog in CSDN\n[不在了情绪的CSDN博客账号](https://blog.csdn.net/2401_86849688?type=blog)\n\n### GitHub Stats:\n\n**I am always an active commiter! Love Coding Everyday!** 🫡😍\n\n[Richard's Github](https://github.com/Richard110206)\n\n[![GitHub Streak](https://streak-stats.demolab.com/?user=Richard110206&theme=radical)](https://git.io/streak-stats)\n\n\n\n<img src=\"https://ghchart.rshah.org/Richard110206\" alt=\"Li Qinxuan's Github Contributions\" />\n\n### Photos\n- 图片多从YouTube和[unsplash](https://unsplash.com/)上获取\n- 使用[PicGo插件](https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here)和Github实现**图床**功能\n\n可以参考这篇博客：[Offload Your Hexo Images](https://richard110206.github.io/2025/08/21/Tutorial/Offload-Your-Hexo-Images/)\n\n***\n\n网站使用Github Pages 和 Hexo静态部署，fluid主题，相关链接地址如下：\n- [Hexo Fluid 用户手册](https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97)\n- [fluid-dev for hexo theme](https://github.com/fluid-dev/hexo-theme-fluid)\n- [开始使用 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/start/)\n- [配置指南 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/guide/)\n\n\n\n\n如果大家有任何疑问，欢迎提issue，也欢迎通过邮箱联系我，我们一起进步！\n\n\n封面来源：[Who are you?](https://www.youtube.com/watch?v=GWGbOjlJDkU)\n\n","slug":"other/About Me and My Blog","published":1,"updated":"2025-09-03T06:22:50.613Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcs001u40w33jbr6zsz","content":"<h2 id=\"Before-The-Blog\">Before The Blog</h2>\n<p>  从高中到大学，我一直保持着系统化记笔记的学习习惯。然而，计算机专业的独特性让我一度感到不适应——知识的海洋如此浩瀚，技术栈的广度令人惊叹，传统的应试学习方法在这里显得捉襟见肘。</p>\n<p>  机缘巧合之下我在牛客等招聘网站上看到优秀求职者的技术博客链接，又注意到同学在朋友圈分享的博客文章，相互交换博客链接，相互学习。这些见闻就像一粒种子，在我心中悄然生根发芽。</p>\n<p>  但向来语文表达能力欠佳的我，对于博客撰写还是稍有抵触态度的，只是在CSDN上慢慢开始了尝试，逐渐发现在<strong>AI大模型</strong>语言润色写作的支持下，或许并不困难。甚至这种<strong>将知识咀嚼在二次消化的“反刍”过程</strong>，使我内心产生了巨大的<strong>成就感</strong>！</p>\n<p>这里引用一下我的这位同学博客里的原话：</p>\n<div class=\"note note-info\">\n            <p>  “无论是解题、写作，还是费曼学习法，其本质都是<strong>通过输出来强化知识</strong>的吸收。当你能够流畅地演绎一道数学题的多种解法，或是将庞杂的知识梳理成清晰的逻辑链条，甚至写成一篇能让读者受益的博客时，你便完成了<strong>从输入到输出</strong>的有效做功。而这一过程，不仅让知识真正内化，更赋予人莫大的成就感。”</p>\n          </div>\n<div class=\"note note-info\">\n            <p>  “然而，写作——尤其是高质量的博客写作——远非简单的文字堆砌。回想高中写议论文时的经历，你是否也曾感到一种“言不尽意”的挫败？<strong>灵感的闪现 ≠ 逻辑的成型 ≠ 语言的表达 ≠ 理想的呈现</strong>。很多时候，我们脑海中的所谓“灵感”，不过是零星的思维火花，距离一篇结构严谨、论证充分、兼具深度与可读性的文章，仍有漫长的路要走。”</p>\n          </div>\n<div class=\"note note-info\">\n            <p>  “而这，正是博客写作的真正挑战，也是它最珍贵的训练价值——<strong>如何将飘忽的灵感锤炼成扎实的文字，在逻辑与专业之间找到平衡，最终实现清晰而有力的表达。</strong>”</p>\n          </div>\n<p>  在CSDN的简单试水中，我收获了莫大的自信，遂趁着期末周刚结束，全身心地投入到Github个人博客的创建中来！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/About%20Me%20and%20My%20Blog/About-Me-and-My-Blog.png?raw=true\" alt=\"截止2025年7月13日CSDN状态图\"></p>\n<h2 id=\"About-Myself\">About Myself</h2>\n <div class=\"note note-primary\">\n            <p>I am <strong>Li Qinxuan (李沁轩)</strong>, a dedicated Computer Science and Technology scholar at <strong>China University of Mining and Technology (中国矿业大学)</strong>. My academic pursuits encompass diverse domains of computing, with specialized expertise and fervent enthusiasm for <strong>computer vision</strong> and <strong>algorithmic design</strong>.</p>\n          </div>\n<div style=\"text-align: center;\">\n  <strong style=\"color: red; font-size: 2em;\">KEEP CODING!!!</strong>\n</div>\n<h3 id=\"Programming-Languages\">Programming Languages</h3>\n<ul>\n<li>C++</li>\n<li>Python</li>\n<li>HTML</li>\n<li>Matlab</li>\n<li>Javascript (still learning)</li>\n</ul>\n<h3 id=\"Tools\">Tools</h3>\n<ul>\n<li>\n<p>Git</p>\n</li>\n<li>\n<p>LaTex</p>\n</li>\n<li>\n<p>Vim</p>\n</li>\n<li>\n<p>Markdown</p>\n</li>\n<li>\n<p>Bash</p>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cplusplus/cplusplus-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"C++\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Python\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"HTML5\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"JavaScript\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Bash\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Git\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/latex/latex-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"LaTeX\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Linux\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/numpy/numpy-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"NumPy\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pytorch/pytorch-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"PyTorch\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/matplotlib/matplotlib-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Matplotlib\">\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pandas/pandas-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Pandas\">\n</li>\n</ul>\n<h3 id=\"Currently-Learning\">Currently Learning</h3>\n<ul>\n<li>Full-Stack Development</li>\n<li>Python for Data Analysis and Visualization</li>\n<li>Probability and Statistics</li>\n</ul>\n<h3 id=\"Contact-With-Me\">Contact With Me</h3>\n<ul>\n<li><a href=\"mailto:lqx3222482537@qq.com\">lqx3222482537@qq.com</a></li>\n<li><a href=\"mailto:richardli.11.02.06@gmail.com\">richardli.11.02.06@gmail.com</a></li>\n<li><a href=\"mailto:08241120@cumt.edu.cn\">08241120@cumt.edu.cn</a></li>\n</ul>\n<h3 id=\"My-Blog-in-CSDN\">My Blog in CSDN</h3>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪的CSDN博客账号</a></p>\n<h3 id=\"GitHub-Stats\">GitHub Stats:</h3>\n<p><strong>I am always an active commiter! Love Coding Everyday!</strong> 🫡😍</p>\n<p><a href=\"https://github.com/Richard110206\">Richard’s Github</a></p>\n<p><a href=\"https://git.io/streak-stats\"><img src=\"https://streak-stats.demolab.com/?user=Richard110206&amp;theme=radical\" alt=\"GitHub Streak\"></a></p>\n<img src=\"https://ghchart.rshah.org/Richard110206\" alt=\"Li Qinxuan's Github Contributions\">\n<h3 id=\"Photos\">Photos</h3>\n<ul>\n<li>图片多从YouTube和<a href=\"https://unsplash.com/\">unsplash</a>上获取</li>\n<li>使用<a href=\"https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\">PicGo插件</a>和Github实现<strong>图床</strong>功能</li>\n</ul>\n<p>可以参考这篇博客：<a href=\"https://richard110206.github.io/2025/08/21/Tutorial/Offload-Your-Hexo-Images/\">Offload Your Hexo Images</a></p>\n<hr>\n<p>网站使用Github Pages 和 Hexo静态部署，fluid主题，相关链接地址如下：</p>\n<ul>\n<li><a href=\"https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97\">Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid-dev for hexo theme</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/\">开始使用 | Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/guide/\">配置指南 | Hexo Fluid 用户手册</a></li>\n</ul>\n<p>如果大家有任何疑问，欢迎提issue，也欢迎通过邮箱联系我，我们一起进步！</p>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=GWGbOjlJDkU\">Who are you?</a></p>\n","excerpt":"","more":"<h2 id=\"Before-The-Blog\">Before The Blog</h2>\n<p>  从高中到大学，我一直保持着系统化记笔记的学习习惯。然而，计算机专业的独特性让我一度感到不适应——知识的海洋如此浩瀚，技术栈的广度令人惊叹，传统的应试学习方法在这里显得捉襟见肘。</p>\n<p>  机缘巧合之下我在牛客等招聘网站上看到优秀求职者的技术博客链接，又注意到同学在朋友圈分享的博客文章，相互交换博客链接，相互学习。这些见闻就像一粒种子，在我心中悄然生根发芽。</p>\n<p>  但向来语文表达能力欠佳的我，对于博客撰写还是稍有抵触态度的，只是在CSDN上慢慢开始了尝试，逐渐发现在<strong>AI大模型</strong>语言润色写作的支持下，或许并不困难。甚至这种<strong>将知识咀嚼在二次消化的“反刍”过程</strong>，使我内心产生了巨大的<strong>成就感</strong>！</p>\n<p>这里引用一下我的这位同学博客里的原话：</p>\n<div class=\"note note-info\">\n            <p>  “无论是解题、写作，还是费曼学习法，其本质都是<strong>通过输出来强化知识</strong>的吸收。当你能够流畅地演绎一道数学题的多种解法，或是将庞杂的知识梳理成清晰的逻辑链条，甚至写成一篇能让读者受益的博客时，你便完成了<strong>从输入到输出</strong>的有效做功。而这一过程，不仅让知识真正内化，更赋予人莫大的成就感。”</p>\n          </div>\n<div class=\"note note-info\">\n            <p>  “然而，写作——尤其是高质量的博客写作——远非简单的文字堆砌。回想高中写议论文时的经历，你是否也曾感到一种“言不尽意”的挫败？<strong>灵感的闪现 ≠ 逻辑的成型 ≠ 语言的表达 ≠ 理想的呈现</strong>。很多时候，我们脑海中的所谓“灵感”，不过是零星的思维火花，距离一篇结构严谨、论证充分、兼具深度与可读性的文章，仍有漫长的路要走。”</p>\n          </div>\n<div class=\"note note-info\">\n            <p>  “而这，正是博客写作的真正挑战，也是它最珍贵的训练价值——<strong>如何将飘忽的灵感锤炼成扎实的文字，在逻辑与专业之间找到平衡，最终实现清晰而有力的表达。</strong>”</p>\n          </div>\n<p>  在CSDN的简单试水中，我收获了莫大的自信，遂趁着期末周刚结束，全身心地投入到Github个人博客的创建中来！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/About%20Me%20and%20My%20Blog/About-Me-and-My-Blog.png?raw=true\" alt=\"截止2025年7月13日CSDN状态图\"></p>\n<h2 id=\"About-Myself\">About Myself</h2>\n <div class=\"note note-primary\">\n            <p>I am <strong>Li Qinxuan (李沁轩)</strong>, a dedicated Computer Science and Technology scholar at <strong>China University of Mining and Technology (中国矿业大学)</strong>. My academic pursuits encompass diverse domains of computing, with specialized expertise and fervent enthusiasm for <strong>computer vision</strong> and <strong>algorithmic design</strong>.</p>\n          </div>\n<div style=\"text-align: center;\">\n  <strong style=\"color: red; font-size: 2em;\">KEEP CODING!!!</strong>\n</div>\n<h3 id=\"Programming-Languages\">Programming Languages</h3>\n<ul>\n<li>C++</li>\n<li>Python</li>\n<li>HTML</li>\n<li>Matlab</li>\n<li>Javascript (still learning)</li>\n</ul>\n<h3 id=\"Tools\">Tools</h3>\n<ul>\n<li>\n<p>Git</p>\n</li>\n<li>\n<p>LaTex</p>\n</li>\n<li>\n<p>Vim</p>\n</li>\n<li>\n<p>Markdown</p>\n</li>\n<li>\n<p>Bash</p>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/cplusplus/cplusplus-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"C++\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Python\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"HTML5\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"JavaScript\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/bash/bash-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Bash\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/git/git-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Git\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/latex/latex-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"LaTeX\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Linux\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/numpy/numpy-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"NumPy\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pytorch/pytorch-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"PyTorch\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/matplotlib/matplotlib-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Matplotlib\"/>\n<img src=\"https://cdn.jsdelivr.net/gh/devicons/devicon/icons/pandas/pandas-original.svg\" style=\"height:40px;width:auto;max-width:40px;\" alt=\"Pandas\"/>\n</li>\n</ul>\n<h3 id=\"Currently-Learning\">Currently Learning</h3>\n<ul>\n<li>Full-Stack Development</li>\n<li>Python for Data Analysis and Visualization</li>\n<li>Probability and Statistics</li>\n</ul>\n<h3 id=\"Contact-With-Me\">Contact With Me</h3>\n<ul>\n<li><a href=\"mailto:lqx3222482537@qq.com\">lqx3222482537@qq.com</a></li>\n<li><a href=\"mailto:richardli.11.02.06@gmail.com\">richardli.11.02.06@gmail.com</a></li>\n<li><a href=\"mailto:08241120@cumt.edu.cn\">08241120@cumt.edu.cn</a></li>\n</ul>\n<h3 id=\"My-Blog-in-CSDN\">My Blog in CSDN</h3>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪的CSDN博客账号</a></p>\n<h3 id=\"GitHub-Stats\">GitHub Stats:</h3>\n<p><strong>I am always an active commiter! Love Coding Everyday!</strong> 🫡😍</p>\n<p><a href=\"https://github.com/Richard110206\">Richard’s Github</a></p>\n<p><a href=\"https://git.io/streak-stats\"><img src=\"https://streak-stats.demolab.com/?user=Richard110206&amp;theme=radical\" alt=\"GitHub Streak\"></a></p>\n<img src=\"https://ghchart.rshah.org/Richard110206\" alt=\"Li Qinxuan's Github Contributions\" />\n<h3 id=\"Photos\">Photos</h3>\n<ul>\n<li>图片多从YouTube和<a href=\"https://unsplash.com/\">unsplash</a>上获取</li>\n<li>使用<a href=\"https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\">PicGo插件</a>和Github实现<strong>图床</strong>功能</li>\n</ul>\n<p>可以参考这篇博客：<a href=\"https://richard110206.github.io/2025/08/21/Tutorial/Offload-Your-Hexo-Images/\">Offload Your Hexo Images</a></p>\n<hr>\n<p>网站使用Github Pages 和 Hexo静态部署，fluid主题，相关链接地址如下：</p>\n<ul>\n<li><a href=\"https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97\">Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://github.com/fluid-dev/hexo-theme-fluid\">fluid-dev for hexo theme</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/\">开始使用 | Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/guide/\">配置指南 | Hexo Fluid 用户手册</a></li>\n</ul>\n<p>如果大家有任何疑问，欢迎提issue，也欢迎通过邮箱联系我，我们一起进步！</p>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=GWGbOjlJDkU\">Who are you?</a></p>\n"},{"title":"Digital Circuits and Logic Design","date":"2025-09-04T04:58:09.000Z","archive":true,"_content":"\n## 数制与编码\n### 整数十进制转换：除X倒取余法\n十进制整数 N 可表示为 X 进制的幂次和形式：\n$$N = a_{n} \\times X^n + a_{n-1} \\times X^{n-1} + ... + a_{1} \\times X^1 + a_{0} \\times X^0$$通过 “除 X 取余”，可依次求出最低位，再 “倒取余” 得到最终结果。\n### 小数十进制转换：乘X顺取整法\n十进制小数 M（0<M<1）可表示为 X 进制的负幂次和形式：\n$$M = b_{-1} \\times X^{-1} + b_{-2} \\times X^{-2} + ... + b_{-k} \\times X^{-k} + ...$$通过 “乘 X 取整”，可依次求出小数点后第一位，再 “顺取整” 得到 X 进制小数。\n### 原码\n在最高位补0或1表示正负，0为正，1为负。\n### 反码\n- 对于正数，反码与原码相同\n- 对于负数，反码为原码**除符号位外按位取反**\n{%note info%}\n在反码表示法中，0的表示方法不是唯一的\n{%endnote%}\n反码表示法的优点是在进行加减运算时**不需要判断两数的符号是否相同**，只要先求出两数的反码然后相加即可（**符号位也参与运算**，当符号位产生进位时，需要**循环进位**，即把符号位的进位加到和的最低位上去），比原码运算要简单的多。\n### 补码\n- 对于正数，补码与原码相同\n- 对于负数，补码为原码**除符号位外按位取反**，再在**最低位加一**（**补码+1**）\n{%note info%}\n补码的补码是原码\n{%endnote%}\n补码进行运算时，符号位参与运算，而且**符号位的进位会丢弃**（区别于反码）\n\n## 逻辑代数基础\n[相关电路符号图](https://www.cnblogs.com/icmaxwell/p/17374702.html)\n### 三种基本逻辑运算：\n1. 与：串联`·`\n```\n0·0=0\n0·1=0\n1·0=0\n1·1=1\n```\n2. 或：并联`+`\n```\n0+0=0\n0+1=0\n1+0=0\n1=1=1\n```\n3. 非：取反`-`\n\n```\nA·A=A\nA+A=A\n```\n### 复合逻辑运算\n1. 与非：$F=\\overline{A·B·C}$\n2. 或非: $F=\\overline{A+B+C}$\n3. 与或非：$F=\\overline{AB+CD}$\n4. 异或：$ F=A\\oplus B =\\overline{A}B+A\\overline{B}$ **相异为 1，相同为 0**\n5. 同或：$ F=A\\odot B=AB+\\overline{A}\\overline{B}$  **相同为 1，相异为 0**\n\n![基本逻辑门电路图形符号1](https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable1.png?raw=true)\n![基本逻辑门电路图形符号2](https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable2.png?raw=true)\n\n\n### 逻辑函数表示方法的相互转换\n\n1. 真值表法\n2. 表达式法\n3. 逻辑图法\n4. 波形图\n\n- 真值表:arrow_forward::arrow_forward:逻辑式\n\n1. 从真值表中**找出使得F=1的那些变量取值**\n2. 把每一组变量取值写成对应的乘积项, **0 --> 1，1不变**\n3. 将**乘积相加**得到逻辑式\n\n### 波形图\n1. 输入波形要**穷举所用可能的输入**\n2. 输出波形与输入波形**一一对应**\n\n\n### 反演规则\n求反函数\n1. **长非号不变**\n2. 运算的**优先顺序不变**（**要加括号**）\n\n- 摩根定律\n$$\\overline{A + B} = \\overline{A} \\cdot \\overline{B}$$\n\n$$\\overline{A \\cdot B} = \\overline{A} + \\overline{B}$$\n\n- 吸收律\n$$A + A \\cdot B = A$$\n\n\n$$A \\cdot (A + B) = A$$\n\n\n$$A + \\overline{A} \\cdot B = A + B$$\n\n\n$$A \\cdot (\\overline{A} + B) = A \\cdot B$$\n\n- 包含律\n$$A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C$$\n\n$$(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)$$\n\n- 尾部变换\n$$A \\cdot \\overline{B} = A \\cdot \\overline{A \\cdot B}$$\n\n$$A \\cdot \\overline{A \\cdot B} = A \\cdot (\\overline{A} + \\overline{B}) = A \\cdot \\overline{A} + A \\cdot \\overline{B} = A \\cdot \\overline{B}$$\n\n常用的化简方法\n\n1. 并项法$$AB+A\\overline{B}=A$$\n2. 吸收法$$A+AB=A$$\n3. 消去法$$A+\\overline{A}B=A+B$$\n\n$m_0$下标编号规则：原变量取1，反变量取0\n\nn变量的最小项有n个相邻项：\n相邻项：只有一个变量不同，一对相邻项可以消去一个变量\n\n### 卡诺图\n卡诺图表示按照格雷码（任意两个相邻的编码，仅有 1 位二进制数不同）进行标识，使得相邻变量的组合中只有一个变量不同。\n卡诺图排列顺序：00->01->11->10\n#### 卡诺图的绘制：\n- 最小项在方格中填1\n- 最大项在方格中填0\n#### 卡诺图的化简\n卡诺圈内小方格数N必须是$2^n$，相邻两个小方格中只有一个变量不同，可以合并为一项，消去一个互非的变量。\n1.\t卡诺圈越大越好\n2.\t卡诺圈越少越好\n3.\t每一个卡诺圈都要有新的成分\n4.\t先圈大圈，后圈小圈\n","source":"_posts/Review/Digital-Circuits-and-Logic-Design.md","raw":"---\ntitle: Digital Circuits and Logic Design\ndate: 2025-09-04 12:58:09\ntags:\narchive: true\n---\n\n## 数制与编码\n### 整数十进制转换：除X倒取余法\n十进制整数 N 可表示为 X 进制的幂次和形式：\n$$N = a_{n} \\times X^n + a_{n-1} \\times X^{n-1} + ... + a_{1} \\times X^1 + a_{0} \\times X^0$$通过 “除 X 取余”，可依次求出最低位，再 “倒取余” 得到最终结果。\n### 小数十进制转换：乘X顺取整法\n十进制小数 M（0<M<1）可表示为 X 进制的负幂次和形式：\n$$M = b_{-1} \\times X^{-1} + b_{-2} \\times X^{-2} + ... + b_{-k} \\times X^{-k} + ...$$通过 “乘 X 取整”，可依次求出小数点后第一位，再 “顺取整” 得到 X 进制小数。\n### 原码\n在最高位补0或1表示正负，0为正，1为负。\n### 反码\n- 对于正数，反码与原码相同\n- 对于负数，反码为原码**除符号位外按位取反**\n{%note info%}\n在反码表示法中，0的表示方法不是唯一的\n{%endnote%}\n反码表示法的优点是在进行加减运算时**不需要判断两数的符号是否相同**，只要先求出两数的反码然后相加即可（**符号位也参与运算**，当符号位产生进位时，需要**循环进位**，即把符号位的进位加到和的最低位上去），比原码运算要简单的多。\n### 补码\n- 对于正数，补码与原码相同\n- 对于负数，补码为原码**除符号位外按位取反**，再在**最低位加一**（**补码+1**）\n{%note info%}\n补码的补码是原码\n{%endnote%}\n补码进行运算时，符号位参与运算，而且**符号位的进位会丢弃**（区别于反码）\n\n## 逻辑代数基础\n[相关电路符号图](https://www.cnblogs.com/icmaxwell/p/17374702.html)\n### 三种基本逻辑运算：\n1. 与：串联`·`\n```\n0·0=0\n0·1=0\n1·0=0\n1·1=1\n```\n2. 或：并联`+`\n```\n0+0=0\n0+1=0\n1+0=0\n1=1=1\n```\n3. 非：取反`-`\n\n```\nA·A=A\nA+A=A\n```\n### 复合逻辑运算\n1. 与非：$F=\\overline{A·B·C}$\n2. 或非: $F=\\overline{A+B+C}$\n3. 与或非：$F=\\overline{AB+CD}$\n4. 异或：$ F=A\\oplus B =\\overline{A}B+A\\overline{B}$ **相异为 1，相同为 0**\n5. 同或：$ F=A\\odot B=AB+\\overline{A}\\overline{B}$  **相同为 1，相异为 0**\n\n![基本逻辑门电路图形符号1](https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable1.png?raw=true)\n![基本逻辑门电路图形符号2](https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable2.png?raw=true)\n\n\n### 逻辑函数表示方法的相互转换\n\n1. 真值表法\n2. 表达式法\n3. 逻辑图法\n4. 波形图\n\n- 真值表:arrow_forward::arrow_forward:逻辑式\n\n1. 从真值表中**找出使得F=1的那些变量取值**\n2. 把每一组变量取值写成对应的乘积项, **0 --> 1，1不变**\n3. 将**乘积相加**得到逻辑式\n\n### 波形图\n1. 输入波形要**穷举所用可能的输入**\n2. 输出波形与输入波形**一一对应**\n\n\n### 反演规则\n求反函数\n1. **长非号不变**\n2. 运算的**优先顺序不变**（**要加括号**）\n\n- 摩根定律\n$$\\overline{A + B} = \\overline{A} \\cdot \\overline{B}$$\n\n$$\\overline{A \\cdot B} = \\overline{A} + \\overline{B}$$\n\n- 吸收律\n$$A + A \\cdot B = A$$\n\n\n$$A \\cdot (A + B) = A$$\n\n\n$$A + \\overline{A} \\cdot B = A + B$$\n\n\n$$A \\cdot (\\overline{A} + B) = A \\cdot B$$\n\n- 包含律\n$$A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C$$\n\n$$(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)$$\n\n- 尾部变换\n$$A \\cdot \\overline{B} = A \\cdot \\overline{A \\cdot B}$$\n\n$$A \\cdot \\overline{A \\cdot B} = A \\cdot (\\overline{A} + \\overline{B}) = A \\cdot \\overline{A} + A \\cdot \\overline{B} = A \\cdot \\overline{B}$$\n\n常用的化简方法\n\n1. 并项法$$AB+A\\overline{B}=A$$\n2. 吸收法$$A+AB=A$$\n3. 消去法$$A+\\overline{A}B=A+B$$\n\n$m_0$下标编号规则：原变量取1，反变量取0\n\nn变量的最小项有n个相邻项：\n相邻项：只有一个变量不同，一对相邻项可以消去一个变量\n\n### 卡诺图\n卡诺图表示按照格雷码（任意两个相邻的编码，仅有 1 位二进制数不同）进行标识，使得相邻变量的组合中只有一个变量不同。\n卡诺图排列顺序：00->01->11->10\n#### 卡诺图的绘制：\n- 最小项在方格中填1\n- 最大项在方格中填0\n#### 卡诺图的化简\n卡诺圈内小方格数N必须是$2^n$，相邻两个小方格中只有一个变量不同，可以合并为一项，消去一个互非的变量。\n1.\t卡诺圈越大越好\n2.\t卡诺圈越少越好\n3.\t每一个卡诺圈都要有新的成分\n4.\t先圈大圈，后圈小圈\n","slug":"Review/Digital-Circuits-and-Logic-Design","published":1,"updated":"2025-09-11T13:17:13.402Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcs001z40w36fp5bvt6","content":"<h2 id=\"数制与编码\">数制与编码</h2>\n<h3 id=\"整数十进制转换：除X倒取余法\">整数十进制转换：除X倒取余法</h3>\n<p>十进制整数 N 可表示为 X 进制的幂次和形式：<br>\n$$N = a_{n} \\times X^n + a_{n-1} \\times X^{n-1} + … + a_{1} \\times X^1 + a_{0} \\times X^0$$通过 “除 X 取余”，可依次求出最低位，再 “倒取余” 得到最终结果。</p>\n<h3 id=\"小数十进制转换：乘X顺取整法\">小数十进制转换：乘X顺取整法</h3>\n<p>十进制小数 M（0&lt;M&lt;1）可表示为 X 进制的负幂次和形式：<br>\n$$M = b_{-1} \\times X^{-1} + b_{-2} \\times X^{-2} + … + b_{-k} \\times X^{-k} + …$$通过 “乘 X 取整”，可依次求出小数点后第一位，再 “顺取整” 得到 X 进制小数。</p>\n<h3 id=\"原码\">原码</h3>\n<p>在最高位补0或1表示正负，0为正，1为负。</p>\n<h3 id=\"反码\">反码</h3>\n<ul>\n<li>对于正数，反码与原码相同</li>\n<li>对于负数，反码为原码<strong>除符号位外按位取反</strong></li>\n</ul>\n<div class=\"note note-info\">\n            <p>在反码表示法中，0的表示方法不是唯一的</p>\n          </div>\n<p>反码表示法的优点是在进行加减运算时<strong>不需要判断两数的符号是否相同</strong>，只要先求出两数的反码然后相加即可（<strong>符号位也参与运算</strong>，当符号位产生进位时，需要<strong>循环进位</strong>，即把符号位的进位加到和的最低位上去），比原码运算要简单的多。</p>\n<h3 id=\"补码\">补码</h3>\n<ul>\n<li>对于正数，补码与原码相同</li>\n<li>对于负数，补码为原码<strong>除符号位外按位取反</strong>，再在<strong>最低位加一</strong>（<strong>补码+1</strong>）</li>\n</ul>\n<div class=\"note note-info\">\n            <p>补码的补码是原码</p>\n          </div>\n<p>补码进行运算时，符号位参与运算，而且<strong>符号位的进位会丢弃</strong>（区别于反码）</p>\n<h2 id=\"逻辑代数基础\">逻辑代数基础</h2>\n<p><a href=\"https://www.cnblogs.com/icmaxwell/p/17374702.html\">相关电路符号图</a></p>\n<h3 id=\"三种基本逻辑运算：\">三种基本逻辑运算：</h3>\n<ol>\n<li>与：串联<code>·</code></li>\n</ol>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">0</span>·<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">0</span>·<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>·<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>·<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"2\">\n<li>或：并联<code>+</code></li>\n</ol>\n<figure class=\"highlight apache\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">0</span>+<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">0</span>+<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>+<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>=<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"3\">\n<li>非：取反<code>-</code></li>\n</ol>\n<figure class=\"highlight dns\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-keyword\">A</span>·<span class=\"hljs-keyword\">A</span>=<span class=\"hljs-keyword\">A</span><br><span class=\"hljs-keyword\">A</span>+<span class=\"hljs-keyword\">A</span>=<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"复合逻辑运算\">复合逻辑运算</h3>\n<ol>\n<li>与非：$F=\\overline{A·B·C}$</li>\n<li>或非: $F=\\overline{A+B+C}$</li>\n<li>与或非：$F=\\overline{AB+CD}$</li>\n<li>异或：$ F=A\\oplus B =\\overline{A}B+A\\overline{B}$ <strong>相异为 1，相同为 0</strong></li>\n<li>同或：$ F=A\\odot B=AB+\\overline{A}\\overline{B}$  <strong>相同为 1，相异为 0</strong></li>\n</ol>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable1.png?raw=true\" alt=\"基本逻辑门电路图形符号1\"><br>\n<img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable2.png?raw=true\" alt=\"基本逻辑门电路图形符号2\"></p>\n<h3 id=\"逻辑函数表示方法的相互转换\">逻辑函数表示方法的相互转换</h3>\n<ol>\n<li>真值表法</li>\n<li>表达式法</li>\n<li>逻辑图法</li>\n<li>波形图</li>\n</ol>\n<ul>\n<li>真值表▶️▶️逻辑式</li>\n</ul>\n<ol>\n<li>从真值表中<strong>找出使得F=1的那些变量取值</strong></li>\n<li>把每一组变量取值写成对应的乘积项, <strong>0 --&gt; 1，1不变</strong></li>\n<li>将<strong>乘积相加</strong>得到逻辑式</li>\n</ol>\n<h3 id=\"波形图\">波形图</h3>\n<ol>\n<li>输入波形要<strong>穷举所用可能的输入</strong></li>\n<li>输出波形与输入波形<strong>一一对应</strong></li>\n</ol>\n<h3 id=\"反演规则\">反演规则</h3>\n<p>求反函数</p>\n<ol>\n<li><strong>长非号不变</strong></li>\n<li>运算的<strong>优先顺序不变</strong>（<strong>要加括号</strong>）</li>\n</ol>\n<ul>\n<li>摩根定律<br>\n$$\\overline{A + B} = \\overline{A} \\cdot \\overline{B}$$</li>\n</ul>\n<p>$$\\overline{A \\cdot B} = \\overline{A} + \\overline{B}$$</p>\n<ul>\n<li>吸收律<br>\n$$A + A \\cdot B = A$$</li>\n</ul>\n<p>$$A \\cdot (A + B) = A$$</p>\n<p>$$A + \\overline{A} \\cdot B = A + B$$</p>\n<p>$$A \\cdot (\\overline{A} + B) = A \\cdot B$$</p>\n<ul>\n<li>包含律<br>\n$$A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C$$</li>\n</ul>\n<p>$$(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)$$</p>\n<ul>\n<li>尾部变换<br>\n$$A \\cdot \\overline{B} = A \\cdot \\overline{A \\cdot B}$$</li>\n</ul>\n<p>$$A \\cdot \\overline{A \\cdot B} = A \\cdot (\\overline{A} + \\overline{B}) = A \\cdot \\overline{A} + A \\cdot \\overline{B} = A \\cdot \\overline{B}$$</p>\n<p>常用的化简方法</p>\n<ol>\n<li>并项法$$AB+A\\overline{B}=A$$</li>\n<li>吸收法$$A+AB=A$$</li>\n<li>消去法$$A+\\overline{A}B=A+B$$</li>\n</ol>\n<p>$m_0$下标编号规则：原变量取1，反变量取0</p>\n<p>n变量的最小项有n个相邻项：<br>\n相邻项：只有一个变量不同，一对相邻项可以消去一个变量</p>\n<h3 id=\"卡诺图\">卡诺图</h3>\n<p>卡诺图表示按照格雷码（任意两个相邻的编码，仅有 1 位二进制数不同）进行标识，使得相邻变量的组合中只有一个变量不同。<br>\n卡诺图排列顺序：00-&gt;01-&gt;11-&gt;10</p>\n<h4 id=\"卡诺图的绘制：\">卡诺图的绘制：</h4>\n<ul>\n<li>最小项在方格中填1</li>\n<li>最大项在方格中填0</li>\n</ul>\n<h4 id=\"卡诺图的化简\">卡诺图的化简</h4>\n<p>卡诺圈内小方格数N必须是$2^n$，相邻两个小方格中只有一个变量不同，可以合并为一项，消去一个互非的变量。</p>\n<ol>\n<li>卡诺圈越大越好</li>\n<li>卡诺圈越少越好</li>\n<li>每一个卡诺圈都要有新的成分</li>\n<li>先圈大圈，后圈小圈</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"数制与编码\">数制与编码</h2>\n<h3 id=\"整数十进制转换：除X倒取余法\">整数十进制转换：除X倒取余法</h3>\n<p>十进制整数 N 可表示为 X 进制的幂次和形式：<br>\n$$N = a_{n} \\times X^n + a_{n-1} \\times X^{n-1} + … + a_{1} \\times X^1 + a_{0} \\times X^0$$通过 “除 X 取余”，可依次求出最低位，再 “倒取余” 得到最终结果。</p>\n<h3 id=\"小数十进制转换：乘X顺取整法\">小数十进制转换：乘X顺取整法</h3>\n<p>十进制小数 M（0&lt;M&lt;1）可表示为 X 进制的负幂次和形式：<br>\n$$M = b_{-1} \\times X^{-1} + b_{-2} \\times X^{-2} + … + b_{-k} \\times X^{-k} + …$$通过 “乘 X 取整”，可依次求出小数点后第一位，再 “顺取整” 得到 X 进制小数。</p>\n<h3 id=\"原码\">原码</h3>\n<p>在最高位补0或1表示正负，0为正，1为负。</p>\n<h3 id=\"反码\">反码</h3>\n<ul>\n<li>对于正数，反码与原码相同</li>\n<li>对于负数，反码为原码<strong>除符号位外按位取反</strong></li>\n</ul>\n<div class=\"note note-info\">\n            <p>在反码表示法中，0的表示方法不是唯一的</p>\n          </div>\n<p>反码表示法的优点是在进行加减运算时<strong>不需要判断两数的符号是否相同</strong>，只要先求出两数的反码然后相加即可（<strong>符号位也参与运算</strong>，当符号位产生进位时，需要<strong>循环进位</strong>，即把符号位的进位加到和的最低位上去），比原码运算要简单的多。</p>\n<h3 id=\"补码\">补码</h3>\n<ul>\n<li>对于正数，补码与原码相同</li>\n<li>对于负数，补码为原码<strong>除符号位外按位取反</strong>，再在<strong>最低位加一</strong>（<strong>补码+1</strong>）</li>\n</ul>\n<div class=\"note note-info\">\n            <p>补码的补码是原码</p>\n          </div>\n<p>补码进行运算时，符号位参与运算，而且<strong>符号位的进位会丢弃</strong>（区别于反码）</p>\n<h2 id=\"逻辑代数基础\">逻辑代数基础</h2>\n<p><a href=\"https://www.cnblogs.com/icmaxwell/p/17374702.html\">相关电路符号图</a></p>\n<h3 id=\"三种基本逻辑运算：\">三种基本逻辑运算：</h3>\n<ol>\n<li>与：串联<code>·</code></li>\n</ol>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">0</span>·<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">0</span>·<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>·<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>·<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>或：并联<code>+</code></li>\n</ol>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">0</span>+<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">0</span>+<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>+<span class=\"hljs-number\">0</span>=<span class=\"hljs-number\">0</span><br><span class=\"hljs-attribute\">1</span>=<span class=\"hljs-number\">1</span>=<span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>非：取反<code>-</code></li>\n</ol>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\"><span class=\"hljs-keyword\">A</span>·<span class=\"hljs-keyword\">A</span>=<span class=\"hljs-keyword\">A</span><br><span class=\"hljs-keyword\">A</span>+<span class=\"hljs-keyword\">A</span>=<span class=\"hljs-keyword\">A</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"复合逻辑运算\">复合逻辑运算</h3>\n<ol>\n<li>与非：$F=\\overline{A·B·C}$</li>\n<li>或非: $F=\\overline{A+B+C}$</li>\n<li>与或非：$F=\\overline{AB+CD}$</li>\n<li>异或：$ F=A\\oplus B =\\overline{A}B+A\\overline{B}$ <strong>相异为 1，相同为 0</strong></li>\n<li>同或：$ F=A\\odot B=AB+\\overline{A}\\overline{B}$  <strong>相同为 1，相异为 0</strong></li>\n</ol>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable1.png?raw=true\" alt=\"基本逻辑门电路图形符号1\"><br>\n<img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Review/DigitalCircuits/circuitsymboltable2.png?raw=true\" alt=\"基本逻辑门电路图形符号2\"></p>\n<h3 id=\"逻辑函数表示方法的相互转换\">逻辑函数表示方法的相互转换</h3>\n<ol>\n<li>真值表法</li>\n<li>表达式法</li>\n<li>逻辑图法</li>\n<li>波形图</li>\n</ol>\n<ul>\n<li>真值表▶️▶️逻辑式</li>\n</ul>\n<ol>\n<li>从真值表中<strong>找出使得F=1的那些变量取值</strong></li>\n<li>把每一组变量取值写成对应的乘积项, <strong>0 --&gt; 1，1不变</strong></li>\n<li>将<strong>乘积相加</strong>得到逻辑式</li>\n</ol>\n<h3 id=\"波形图\">波形图</h3>\n<ol>\n<li>输入波形要<strong>穷举所用可能的输入</strong></li>\n<li>输出波形与输入波形<strong>一一对应</strong></li>\n</ol>\n<h3 id=\"反演规则\">反演规则</h3>\n<p>求反函数</p>\n<ol>\n<li><strong>长非号不变</strong></li>\n<li>运算的<strong>优先顺序不变</strong>（<strong>要加括号</strong>）</li>\n</ol>\n<ul>\n<li>摩根定律<br>\n$$\\overline{A + B} = \\overline{A} \\cdot \\overline{B}$$</li>\n</ul>\n<p>$$\\overline{A \\cdot B} = \\overline{A} + \\overline{B}$$</p>\n<ul>\n<li>吸收律<br>\n$$A + A \\cdot B = A$$</li>\n</ul>\n<p>$$A \\cdot (A + B) = A$$</p>\n<p>$$A + \\overline{A} \\cdot B = A + B$$</p>\n<p>$$A \\cdot (\\overline{A} + B) = A \\cdot B$$</p>\n<ul>\n<li>包含律<br>\n$$A \\cdot B + \\overline{A} \\cdot C + B \\cdot C = A \\cdot B + \\overline{A} \\cdot C$$</li>\n</ul>\n<p>$$(A + B) \\cdot (\\overline{A} + C) \\cdot (B + C) = (A + B) \\cdot (\\overline{A} + C)$$</p>\n<ul>\n<li>尾部变换<br>\n$$A \\cdot \\overline{B} = A \\cdot \\overline{A \\cdot B}$$</li>\n</ul>\n<p>$$A \\cdot \\overline{A \\cdot B} = A \\cdot (\\overline{A} + \\overline{B}) = A \\cdot \\overline{A} + A \\cdot \\overline{B} = A \\cdot \\overline{B}$$</p>\n<p>常用的化简方法</p>\n<ol>\n<li>并项法$$AB+A\\overline{B}=A$$</li>\n<li>吸收法$$A+AB=A$$</li>\n<li>消去法$$A+\\overline{A}B=A+B$$</li>\n</ol>\n<p>$m_0$下标编号规则：原变量取1，反变量取0</p>\n<p>n变量的最小项有n个相邻项：<br>\n相邻项：只有一个变量不同，一对相邻项可以消去一个变量</p>\n<h3 id=\"卡诺图\">卡诺图</h3>\n<p>卡诺图表示按照格雷码（任意两个相邻的编码，仅有 1 位二进制数不同）进行标识，使得相邻变量的组合中只有一个变量不同。<br>\n卡诺图排列顺序：00-&gt;01-&gt;11-&gt;10</p>\n<h4 id=\"卡诺图的绘制：\">卡诺图的绘制：</h4>\n<ul>\n<li>最小项在方格中填1</li>\n<li>最大项在方格中填0</li>\n</ul>\n<h4 id=\"卡诺图的化简\">卡诺图的化简</h4>\n<p>卡诺圈内小方格数N必须是$2^n$，相邻两个小方格中只有一个变量不同，可以合并为一项，消去一个互非的变量。</p>\n<ol>\n<li>卡诺圈越大越好</li>\n<li>卡诺圈越少越好</li>\n<li>每一个卡诺圈都要有新的成分</li>\n<li>先圈大圈，后圈小圈</li>\n</ol>\n"},{"title":"Casual Chronicles","date":"2025-08-13T14:25:15.000Z","archive":true,"_content":"\n# Casual Chronicles （生活杂谈）\n记录对学习、生活、社会的**一点想法**，或是一些看到的**有意思的内容**！\n\n# 2025\n\n## 7.25\n&emsp;&emsp;听了UC Berkeley的CS61A 感觉US的CS课程比国内超前太多了！图文并茂、简洁利索、一目了然的！他们注重**编程思想的培养**，和**项目实战**，在实践中感受编程的魅力！而我们的老师总是长篇累牍的教授语法知识，煞是枯燥无味！\n\n## 8.12\n&emsp;&emsp;在AI高速发展的当下，我们计算机专业的学习也应该与时俱进，从前我总是习惯于看书学习，从最基础的点开始将知识吸收，往往还没做出什么成果，学习的热情就被消耗殆尽，感叹一句“真难啊”！但是现在有了AI的帮助，我们的学习或许可以不那么注重细节，可以**自顶向下的**，**得“意”忘“形”的**，我们只需先了解其大致框架、工作原理，再利用AI在框架中缝缝补补，哪里有问题去学哪里，这样不仅可以短时间内做出一定成果提升成就感，同时也避免的花费大量时间摄入无用或极少使用的知识！\n\n## 8.15\n&emsp;&emsp;今天和高中同学聚餐，聊完心里挺多感触的——不同学校的教材、教学进度和深度，差别真的太大了。\n&emsp;&emsp;之前刷手机看到BUAA的学生，大一上学期专业课的期末大作业，那难度望而生畏；饭桌上也听同学说，他们课堂上在学用MATLAB做人脸识别，可我们现在还在跟基本语法死磕。\n&emsp;&emsp;回头想想自己的进度，才更真切地感受到学校层次带来的差异。好学校的学生和老师要求本就更紧迫，反观自己，如果没有这种外界的推力，恐怕真会像温水煮青蛙，在不知不觉中就被环境带着，慢慢落后于时代，也落后于那些本来就走在前面的同学。\n&emsp;&emsp;尤其佩服一位在top3的同学，大一学年不仅保持rank1的高绩点，还能从零开始，一年里啃下那么多CS基础知识，跟着导师做各种项目。\n&emsp;&emsp;我也知道**不能好高骛远**，但还是得时时抬头看看更高的山。不用急着跟别人比，但得给自己找些“**自驱力**”，别停下往前走的脚步。\n\n## 8.16\n&emsp;&emsp;看到同学学习进度之快、掌握之扎实，瞠目结舌！\n&emsp;&emsp;确实之前不应该焦急的广泛学习各种语言，c++、Python、MATLAB，现在发现其实仅仅需要学明白c++，其他语言的学习都是以天可以进行速通的，AI时代纠结于底层语法更是没有什么必要的，“AI能完成的 都不需要我们进行学习”，这意味着我们可以更高效的进行项目的学习和开发，速度与效率大大提升！\n\n## 8.18\n&emsp;&emsp;看到[老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化](https://waylau.com/)\n&emsp;&emsp;从2009-2025年，**持续不断的进行博客创作**，从开始的`Github`教程，这一步步见证了**从小白到大佬的蜕变之路**，也更加坚定了我持续学习进行博客创作的动力！\n\n## 8.22\n&emsp;&emsp;开会区up主太精辟了！[暑假，越来越形同虚设了](https://www.bilibili.com/video/BV1Y6uFztEgS/?spm_id_from=333.1387.homepage.video_card.click&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n{%note info%}\n“不要在迷茫的时候，盲目堆积工作量来麻痹自己”\n{%endnote%}\n\n","source":"_posts/other/Casual-Chronicles.md","raw":"---\ntitle: Casual Chronicles\ndate: 2025-08-13 22:25:15\ntags: [updating]\narchive: true\n---\n\n# Casual Chronicles （生活杂谈）\n记录对学习、生活、社会的**一点想法**，或是一些看到的**有意思的内容**！\n\n# 2025\n\n## 7.25\n&emsp;&emsp;听了UC Berkeley的CS61A 感觉US的CS课程比国内超前太多了！图文并茂、简洁利索、一目了然的！他们注重**编程思想的培养**，和**项目实战**，在实践中感受编程的魅力！而我们的老师总是长篇累牍的教授语法知识，煞是枯燥无味！\n\n## 8.12\n&emsp;&emsp;在AI高速发展的当下，我们计算机专业的学习也应该与时俱进，从前我总是习惯于看书学习，从最基础的点开始将知识吸收，往往还没做出什么成果，学习的热情就被消耗殆尽，感叹一句“真难啊”！但是现在有了AI的帮助，我们的学习或许可以不那么注重细节，可以**自顶向下的**，**得“意”忘“形”的**，我们只需先了解其大致框架、工作原理，再利用AI在框架中缝缝补补，哪里有问题去学哪里，这样不仅可以短时间内做出一定成果提升成就感，同时也避免的花费大量时间摄入无用或极少使用的知识！\n\n## 8.15\n&emsp;&emsp;今天和高中同学聚餐，聊完心里挺多感触的——不同学校的教材、教学进度和深度，差别真的太大了。\n&emsp;&emsp;之前刷手机看到BUAA的学生，大一上学期专业课的期末大作业，那难度望而生畏；饭桌上也听同学说，他们课堂上在学用MATLAB做人脸识别，可我们现在还在跟基本语法死磕。\n&emsp;&emsp;回头想想自己的进度，才更真切地感受到学校层次带来的差异。好学校的学生和老师要求本就更紧迫，反观自己，如果没有这种外界的推力，恐怕真会像温水煮青蛙，在不知不觉中就被环境带着，慢慢落后于时代，也落后于那些本来就走在前面的同学。\n&emsp;&emsp;尤其佩服一位在top3的同学，大一学年不仅保持rank1的高绩点，还能从零开始，一年里啃下那么多CS基础知识，跟着导师做各种项目。\n&emsp;&emsp;我也知道**不能好高骛远**，但还是得时时抬头看看更高的山。不用急着跟别人比，但得给自己找些“**自驱力**”，别停下往前走的脚步。\n\n## 8.16\n&emsp;&emsp;看到同学学习进度之快、掌握之扎实，瞠目结舌！\n&emsp;&emsp;确实之前不应该焦急的广泛学习各种语言，c++、Python、MATLAB，现在发现其实仅仅需要学明白c++，其他语言的学习都是以天可以进行速通的，AI时代纠结于底层语法更是没有什么必要的，“AI能完成的 都不需要我们进行学习”，这意味着我们可以更高效的进行项目的学习和开发，速度与效率大大提升！\n\n## 8.18\n&emsp;&emsp;看到[老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化](https://waylau.com/)\n&emsp;&emsp;从2009-2025年，**持续不断的进行博客创作**，从开始的`Github`教程，这一步步见证了**从小白到大佬的蜕变之路**，也更加坚定了我持续学习进行博客创作的动力！\n\n## 8.22\n&emsp;&emsp;开会区up主太精辟了！[暑假，越来越形同虚设了](https://www.bilibili.com/video/BV1Y6uFztEgS/?spm_id_from=333.1387.homepage.video_card.click&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n{%note info%}\n“不要在迷茫的时候，盲目堆积工作量来麻痹自己”\n{%endnote%}\n\n","slug":"other/Casual-Chronicles","published":1,"updated":"2025-09-02T02:36:00.443Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcs002040w3cjos6kbx","content":"<h1>Casual Chronicles （生活杂谈）</h1>\n<p>记录对学习、生活、社会的<strong>一点想法</strong>，或是一些看到的<strong>有意思的内容</strong>！</p>\n<h1>2025</h1>\n<h2 id=\"7-25\">7.25</h2>\n<p>  听了UC Berkeley的CS61A 感觉US的CS课程比国内超前太多了！图文并茂、简洁利索、一目了然的！他们注重<strong>编程思想的培养</strong>，和<strong>项目实战</strong>，在实践中感受编程的魅力！而我们的老师总是长篇累牍的教授语法知识，煞是枯燥无味！</p>\n<h2 id=\"8-12\">8.12</h2>\n<p>  在AI高速发展的当下，我们计算机专业的学习也应该与时俱进，从前我总是习惯于看书学习，从最基础的点开始将知识吸收，往往还没做出什么成果，学习的热情就被消耗殆尽，感叹一句“真难啊”！但是现在有了AI的帮助，我们的学习或许可以不那么注重细节，可以<strong>自顶向下的</strong>，<strong>得“意”忘“形”的</strong>，我们只需先了解其大致框架、工作原理，再利用AI在框架中缝缝补补，哪里有问题去学哪里，这样不仅可以短时间内做出一定成果提升成就感，同时也避免的花费大量时间摄入无用或极少使用的知识！</p>\n<h2 id=\"8-15\">8.15</h2>\n<p>  今天和高中同学聚餐，聊完心里挺多感触的——不同学校的教材、教学进度和深度，差别真的太大了。<br>\n  之前刷手机看到BUAA的学生，大一上学期专业课的期末大作业，那难度望而生畏；饭桌上也听同学说，他们课堂上在学用MATLAB做人脸识别，可我们现在还在跟基本语法死磕。<br>\n  回头想想自己的进度，才更真切地感受到学校层次带来的差异。好学校的学生和老师要求本就更紧迫，反观自己，如果没有这种外界的推力，恐怕真会像温水煮青蛙，在不知不觉中就被环境带着，慢慢落后于时代，也落后于那些本来就走在前面的同学。<br>\n  尤其佩服一位在top3的同学，大一学年不仅保持rank1的高绩点，还能从零开始，一年里啃下那么多CS基础知识，跟着导师做各种项目。<br>\n  我也知道<strong>不能好高骛远</strong>，但还是得时时抬头看看更高的山。不用急着跟别人比，但得给自己找些“<strong>自驱力</strong>”，别停下往前走的脚步。</p>\n<h2 id=\"8-16\">8.16</h2>\n<p>  看到同学学习进度之快、掌握之扎实，瞠目结舌！<br>\n  确实之前不应该焦急的广泛学习各种语言，c++、Python、MATLAB，现在发现其实仅仅需要学明白c++，其他语言的学习都是以天可以进行速通的，AI时代纠结于底层语法更是没有什么必要的，“AI能完成的 都不需要我们进行学习”，这意味着我们可以更高效的进行项目的学习和开发，速度与效率大大提升！</p>\n<h2 id=\"8-18\">8.18</h2>\n<p>  看到<a href=\"https://waylau.com/\">老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化</a><br>\n  从2009-2025年，<strong>持续不断的进行博客创作</strong>，从开始的<code>Github</code>教程，这一步步见证了<strong>从小白到大佬的蜕变之路</strong>，也更加坚定了我持续学习进行博客创作的动力！</p>\n<h2 id=\"8-22\">8.22</h2>\n<p>  开会区up主太精辟了！<a href=\"https://www.bilibili.com/video/BV1Y6uFztEgS/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">暑假，越来越形同虚设了</a></p>\n<div class=\"note note-info\">\n            <p>“不要在迷茫的时候，盲目堆积工作量来麻痹自己”</p>\n          </div>\n","excerpt":"","more":"<h1>Casual Chronicles （生活杂谈）</h1>\n<p>记录对学习、生活、社会的<strong>一点想法</strong>，或是一些看到的<strong>有意思的内容</strong>！</p>\n<h1>2025</h1>\n<h2 id=\"7-25\">7.25</h2>\n<p>  听了UC Berkeley的CS61A 感觉US的CS课程比国内超前太多了！图文并茂、简洁利索、一目了然的！他们注重<strong>编程思想的培养</strong>，和<strong>项目实战</strong>，在实践中感受编程的魅力！而我们的老师总是长篇累牍的教授语法知识，煞是枯燥无味！</p>\n<h2 id=\"8-12\">8.12</h2>\n<p>  在AI高速发展的当下，我们计算机专业的学习也应该与时俱进，从前我总是习惯于看书学习，从最基础的点开始将知识吸收，往往还没做出什么成果，学习的热情就被消耗殆尽，感叹一句“真难啊”！但是现在有了AI的帮助，我们的学习或许可以不那么注重细节，可以<strong>自顶向下的</strong>，<strong>得“意”忘“形”的</strong>，我们只需先了解其大致框架、工作原理，再利用AI在框架中缝缝补补，哪里有问题去学哪里，这样不仅可以短时间内做出一定成果提升成就感，同时也避免的花费大量时间摄入无用或极少使用的知识！</p>\n<h2 id=\"8-15\">8.15</h2>\n<p>  今天和高中同学聚餐，聊完心里挺多感触的——不同学校的教材、教学进度和深度，差别真的太大了。<br>\n  之前刷手机看到BUAA的学生，大一上学期专业课的期末大作业，那难度望而生畏；饭桌上也听同学说，他们课堂上在学用MATLAB做人脸识别，可我们现在还在跟基本语法死磕。<br>\n  回头想想自己的进度，才更真切地感受到学校层次带来的差异。好学校的学生和老师要求本就更紧迫，反观自己，如果没有这种外界的推力，恐怕真会像温水煮青蛙，在不知不觉中就被环境带着，慢慢落后于时代，也落后于那些本来就走在前面的同学。<br>\n  尤其佩服一位在top3的同学，大一学年不仅保持rank1的高绩点，还能从零开始，一年里啃下那么多CS基础知识，跟着导师做各种项目。<br>\n  我也知道<strong>不能好高骛远</strong>，但还是得时时抬头看看更高的山。不用急着跟别人比，但得给自己找些“<strong>自驱力</strong>”，别停下往前走的脚步。</p>\n<h2 id=\"8-16\">8.16</h2>\n<p>  看到同学学习进度之快、掌握之扎实，瞠目结舌！<br>\n  确实之前不应该焦急的广泛学习各种语言，c++、Python、MATLAB，现在发现其实仅仅需要学明白c++，其他语言的学习都是以天可以进行速通的，AI时代纠结于底层语法更是没有什么必要的，“AI能完成的 都不需要我们进行学习”，这意味着我们可以更高效的进行项目的学习和开发，速度与效率大大提升！</p>\n<h2 id=\"8-18\">8.18</h2>\n<p>  看到<a href=\"https://waylau.com/\">老卫（柳伟卫）的博客 - 关注编程、系统架构、性能优化</a><br>\n  从2009-2025年，<strong>持续不断的进行博客创作</strong>，从开始的<code>Github</code>教程，这一步步见证了<strong>从小白到大佬的蜕变之路</strong>，也更加坚定了我持续学习进行博客创作的动力！</p>\n<h2 id=\"8-22\">8.22</h2>\n<p>  开会区up主太精辟了！<a href=\"https://www.bilibili.com/video/BV1Y6uFztEgS/?spm_id_from=333.1387.homepage.video_card.click&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">暑假，越来越形同虚设了</a></p>\n<div class=\"note note-info\">\n            <p>“不要在迷茫的时候，盲目堆积工作量来麻痹自己”</p>\n          </div>\n"},{"title":"Leetcode Mistake Collection 1","date":"2025-08-26T02:26:06.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/Leetcode-Mistake-Collection.png?raw=true","category_bar":true,"description":"The article is intended to systematically document the errors I encountered while solving LeetCode problems, along with the corresponding corrective strategies.","_content":"\n\n由于cpp基础并不扎实，因而打算分类刷题，在此过程中对基本语法与STL修修补补!\n\n## Reference:\n\n[CS-Notes](https://github.com/CyC2018/CS-Notes)\n\n[LeetCode 刷题顺序，按标签分类，科学刷题！](https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?fromshare=blogdetail&sharetype=blogdetail&sharerId=125099023&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)\n\n[LeetCode Cookbook](https://books.halfrost.com/leetcode/)\n\n\n\n## Leetcode 628.三个数的最大乘积\n\n[原题链接](https://leetcode.cn/problems/maximum-product-of-three-numbers/solutions/567309/san-ge-shu-de-zui-da-cheng-ji-by-leetcod-t9sb/)\n\n{%fold into @ Time Error Version :x:%}\n一开始无脑遍历所有组合，显然时间复杂度是$O(n^3)$，会超时！\n```cpp\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        int n=nums.size();\n        int max=INT_MIN;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                for(int k=j+1;k<n;k++){\n                    int mul=nums[i]*nums[j]*nums[k];\n                    if(mul>max){\n                        max=mul;\n                    }\n                }\n            }\n        }\n        return max;\n    }\n};\n```\n{%endfold%}\n\n我们这里考虑使用数学方法：\n\n- 数组**均为正数**，乘积最大即为**最大三个正数相乘**\n- 数组**均为负数**，乘积最大即为**最大三个负数相乘**\n- 数组**有正有负**\n  - **两个负数与一个正数相乘**\n  - **三个最大正数相乘**\n\n我们可以先将数组**排序**，然后分情况讨论：\n- 1、2、4都取最大的三个数\n- 3取最小的两个负数（数组首端）与最大的一个正数（数组尾端）\n\n```cpp\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        return max(nums[0]*nums[1]*nums[n-1],nums[n-3]*nums[n-2]*nums[n-1]);\n    }\n};\n```\n\n## Leetcode 645.错误的集合\n[原题链接](https://leetcode.cn/problems/set-mismatch)\n\n{%fold into @ Error Version :x:%}\n需要注意题目要求的数组中数字的**顺序**，若是使用`if`，则先找到谁会先输出谁！\n```cpp\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<int>& nums) {\n        int n=nums.size();\n        vector <int> vec;\n        unordered_map <int,int> error;\n        for(auto it:nums){\n            error[it]++;\n        }\n        for(int i=1;i<=n;i++){\n            int count=error[i];\n            if(count==2){\n                vec.push_back(i);\n            } else if(count==0){\n                vec.push_back(i);\n            }\n        }\n        return vec;\n    }\n```\n{%endfold%}\n\n这里采用**哈希表法**\n- **重复的数字**在数组中出现**2次**\n- **丢失的数字**在数组中出现**0次**\n- 其余的每个数字在数组中出现**1次**\n  \n因此可以使用**哈希表**记录每个元素在数组中出现的次数，然后遍历从1到n的每个数字，分别找到出现2次和出现0次的数字，即为重复的数字和丢失的数字。\n```cpp\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<int>& nums) {\n        int n=nums.size();\n        vector <int> vec(2);\n        unordered_map <int,int> error;\n        for(auto it:nums){\n            error[it]++;\n        }\n        for(int i=1;i<=n;i++){\n            int count=error[i];\n            if(count==2){\n                vec[0]=i;\n            } else if(count==0){\n                 vec[1]=i;\n            }\n        }\n        return vec;\n    }\n};\n```\n\n访问一个尚未在 map 中的键：\n\n1. 在 map 中**创建**一个键为 it 的新元素。\n2. 对这个新元素的值进行**值初始化**。对于 int 类型，值初始化就是将其初始化为 0。\n3. 然后对这个**新初始化的值**执行操作。\n\n## Leetcode 448.找到数组中消失的数字\n\n[原题链接](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array)\n\n{%fold into @ Error Version :x:%}\n企图使用键key和值val相配对的方式**找到缺失数字**，但是又包含**重复数字**，意图使用键值大小比较，另设`extra`进行**偏移量调整**，但是使用`auto`迭代器，**索引无法完成补偿**，且代码过于冗余，遂放弃！\n```cpp\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        unordered_map <int,int> arr;\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        for(int i=1;i<=n;i++){\n            arr[i]=nums[i-1];\n        }\n        vector <int> vec;\n        int extra=0;\n        for(auto it:arr){\n            if((it+extra).first>it.second){\n                extra--;\n            }\n            else if((it+extra).first<it.second){\n                extra++;\n                vec.push_back((--it.second)\n            }\n        }\n        return vec;\n    }\n};\n```\n{%endfold%}\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        unordered_map <int,bool> arr;\n        vector <int> vec;\n        int n=nums.size();\n        for(auto it:nums){\n            arr[it]=true;\n        }\n        for(int i=1;i<=n;i++){\n            if(arr.find(i)==arr.end()){\n                vec.push_back(i);\n            }\n        }\n        return vec;\n    }\n};\n```\n采用哈希表`<int,bool>`，对**数组进行遍历**\n- **整型记录数字**（索引）\n- **布尔型记录数字是否出现**\n\n\n## Leetcode 274.H指数\n\n[原题链接](https://leetcode.cn/problems/h-index)\n\n{%fold into @ Error Version :x:%}\n想先排序，再按照`citations[i]`的值与`index`**数组索引值**（计算>的至少有多少篇），但未考虑到若是`4、4、4`这样分布，H指数未必是数组中的数字。\n```cpp\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int n=citations.size();\n        sort(citations.begin(),citations.end());\n        int index;\n        for(int i=0;i<n;i++){\n            if(n-i>=citations[i]){\n                index=citations[i];\n            }\n        }\n        return index;\n    }\n};\n```\n{%endfold%}\n考虑到H指数的指标是固定不变的，因而排序后我们采用**从大到小的遍历方式**。\n```cpp\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int n=citations.size();\n        sort(citations.begin(),citations.end());\n        int h=0,i=citations.size()-1;\n        while(i>=0 && citations[i]>h){\n            i--;\n            h++;\n        }\n        return h;\n    }\n};\n```\n\n## Leetcode 283.移动零\n\n[原题链接](https://leetcode.cn/problems/move-zeroes)\n\n{%fold into @ Error Version :x:%}\n未考虑**连续0**的情况\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int n=nums.size();\n        int count=0;\n        for(int i=0;i<n-1;i++){\n            if(nums[i]==0){\n                count++;\n                for(int j=i;j<n-1;j++){\n                    nums[j]=nums[j+1];\n                }\n            }\n        }\n        for(int i=n-count;i<n;i++){\n            nums[i]=0;\n        }\n    }\n};\n```\n{%endfold%}\n### 双指针\n- **左指针**：指向**已处理好的序列的末端**\n- **右指针**：指向**未处理的序列的起始位置**\n\n1. 右指针左边到左指针之间均为0\n2. 左指针**左侧均为非零数**\n\n左右指针均从`index`索引**0位置出发**：\n- 若为0，右指针右移，左指针不动（相当于标记0位置）\n- 若不为0，**交换**左右指针指向的元素，均向右移动\n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int right=0,left=0;\n        int n=nums.size();\n        while(right<n){\n            if(nums[right]){\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n```\n\n## Leetcode 118.杨辉三角 + 119.杨辉三角ii\n[原题链接](https://leetcode.cn/problems/pascals-triangle)\n[原题链接](https://leetcode.cn/problems/pascals-triangle-ii)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> vec(numRows);//初始化杨辉三角行数\n        for(int i=0;i<numRows;i++){\n            vec[i].resize(i+1);//初始化杨辉三角每列元素个数 第i行有i+1个元素\n            vec[i][0]=1;//初始化杨辉三角每列第一个元素为1\n            vec[i][i]=1;//初始化杨辉三角每列最后一个元素为1\n            for(int j=1;j<i;j++){\n                vec[i][j]=vec[i-1][j-1]+vec[i-1][j];\n            }\n        }\n        return vec;\n    }\n};\n```\n### 优化一：滚动数组\n当我们只需要求杨辉三角的`rowIndex`行时，发现对第`i+1`行的计算仅用到了第`i`行的数据,因而可以通过**滚动数组只保留当前行和上一行**的元素，而不需要**更早的元素**。\n```cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector <int> pre,cur;\n        for(int i=0;i<=rowIndex;i++){\n            cur.resize(i+1);\n            cur[0]=cur[i]=1;\n            for(int j=1;j<i;j++){\n                cur[j]=pre[j-1]+pre[j];\n            }\n            pre=cur;\n        }\n        return pre;\n    }\n};\n```\n### 优化二：单一数组逆序更新\n滚动数组的优化，将**当前行**的元素**逆序更新**到**上一行**，从而**不需要保存当前行**，原本的**两数相加**在**同一数组**中每次仅需要加一次即可！。\n```cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector <int> row(rowIndex+1);\n        for(int i=0;i<=rowIndex;i++){\n            row[0]=1;\n            for(int j=i;j>0;j--){\n                row[j]+=row[j-1];\n            }\n        }\n        return row;\n    }\n};\n```\n\n## Leetcode 14.最长公共前缀\n[原题链接](https://leetcode.cn/problems/longest-common-prefix)\n\n### 方法一：横向扫描\n1. 获取数组中第一个字符串作为**最长公共前缀**\n2. **遍历数组**中的每个字符串，与**最长公共前缀**进行**公共前缀**的比较，更新**最长公共前缀**\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n=strs.size();\n        string prefix=strs[0];\n        for(int i=1;i<n;i++){\n            prefix=CommonPrefix(prefix,strs[i]);\n        }\n        return prefix;\n    }\n    string CommonPrefix(string s1,string s2){\n        int index=0;\n        for(int i=0;i<min(s1.size(),s2.size());i++){\n            if(s1[i]!=s2[i]){\n                break;\n            }\n            index++;\n        }\n        return s1.substr(0,index);\n    }\n};\n```\n\n### 方法二：纵向扫描\n1. **遍历数组**，**依次比较**每个字符串第1、2、3...个字符\n2. 返回最长前缀：\n- 若有字符串的第`i`个字符不同，则**最长公共前缀**的长度为`i-1`\n- 若字符串的长度小于`i`，则**最长公共前缀**的长度为`i`\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n=strs.size();\n        int count=strs[0].size();\n        int i=0;\n        for(i=0;i<count;i++){\n            for(int j=1;j<n;j++){\n                if( i==strs[j].size() || strs[j][i]!=strs[0][i]){\n                    return strs[0].substr(0,i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};\n```\n### 方法三：分治\n### 方法四：二分查找\n\n\n## Leetcode 470.用 Rand7() 实现 Rand10()\n[原题链接](https://leetcode.cn/problems/implement-rand10-using-rand7)\n{%fold into @ Error Version :x:%}\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int first,second;\n        while(first=rand7()>6);\n        while(second=rand7()>5);\n        return (first&1)==1? second:5+second;\n}\n```\n该答案第5、6行缺失括号而导致错误！\n#### 第一种错误版本\n```cpp\nwhile(first=rand7()>6);\nwhile(second=rand7()>5);\n```\n这里由于运算符优先级（比较运算符 > 高于赋值运算符 =），实际执行顺序是：\n- 先计算`rand7()>6`的布尔结果（`true` 或 `false`，即 1 或 0）\n- 将这个布尔结果赋值给 `first` 变量\n- 循环条件永远是 1 或 0，导致逻辑错误\n  \n#### 第二种正确版本\n```cpp\nwhile((first=rand7())>6);\nwhile((second=rand7())>5);\n```\n- 调用 `rand7 ()` 生成随机数\n- 将结果赋值给 `first` 变量\n- 检查该值是否大于 6\n{%endfold%}\n\n这道题的目的是使用`rand7()`产生10个不同但**概率相等**的数\n### 方法一：拒绝采样\n1. 首先**生成1-49的均匀随机数**：:exclamation:`(rand7()-1)*7 + rand7()`:exclamation:\n2. 拒绝41-49的样本（保持1-40的**均匀分布**）\n3. 对结果取模+1，得到1-10的**均匀随机数**\n{%fold into @ 为什么这样生成采样样本？%}\n1.`rand7()-1`生成 0~6\n2.`(rand7()-1)*7`生成 0、7、14、21、28、35、42\n3.`(rand7()-1)*7 + rand7()`生成 1~49\n**无重复数字**，每个数字出现的**概率均相同**是1/49\n{%endfold%}\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int num;\n        while((num=(rand7()-1)*7+rand7())>40);\n        return num%10+1;\n    }\n};\n```\n\n### 方法二：古典概型\n1. 第一次`rand7`限定[1,6]，**判断奇偶性**，概率是1/2\n2. 第二次`rand7`限定[1,5]，概率是1/5\n3. 二者结合可以得出10种概率相同的结果\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int first,second;\n        while((first=rand7())>6);\n        while((second=rand7())>5);\n        return (first&1)==1? second:5+second;\n}\n```\n\n#### 位运算符\n- **按位与（&）**：对两个操作数的每一位进行比较，只有当两位都为 1 时结果对应位才为 1，否则为 0。\n示例：3 & 5（二进制 011 & 101）结果为 1（二进制 001）。\n```cpp\nbool isOdd(int x) {\n    return x & 1; // 结果为1则奇数，0则偶数\n}\n```\n- **按位或（|）**：对两个操作数的每一位进行比较，只要其中一位为 1，结果对应位就为 1，否则为 0。\n示例：3 | 5（二进制 011 | 101）结果为 7（二进制 111）。\n- **按位异或（^）**：对两个操作数的每一位进行比较，当两位不同时结果为 1，相同时为 0。\n示例：3 ^ 5（二进制 011 ^ 101）结果为 6（二进制 110）。\n```cpp\nvoid swap(int& a, int& b) {\n    if (a != b) { // 避免a和b同地址时出错\n        a = a ^ b; // a现在是a^b\n        b = a ^ b; // b = (a^b)^b = a\n        a = a ^ b; // a = (a^b)^a = b\n    }\n}\n```\n- **按位非（~）**：对单个操作数的**每一位取反**（0 变 1，1 变 0），是一元运算符。\n示例：~3（二进制 ~011）在 32 位系统中结果为 -4（二进制补码表示）。\n- **左移（<<）**：将左操作数的**二进制位向左移动指定的位数**，右侧空位补 0。\n示例：3 << 1（二进制 011 << 1）结果为 6（二进制 110），相当于**乘以 2 的 n 次方**（n 为移动位数）。\n- **右移（>>）**：将左操作数的**二进制位向右移动指定的位数**，左侧空位补符号位（正数补 0，负数补 1）。\n示例：6 >> 1（二进制 110 >> 1）结果为 3（二进制 011），相当于**除以 2 的 n 次方**（向下取整）。","source":"_posts/Leetcode-Collection/Leetcode-Mistake-Collection-1.md","raw":"---\ntitle: Leetcode Mistake Collection 1\ndate: 2025-08-26 10:26:06\ntags: [Leetcode,updating]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/Leetcode-Mistake-Collection.png?raw=true\ncategory: Leetcode Mistake Collection\ncategory_bar: true\ndescription: The article is intended to systematically document the errors I encountered while solving LeetCode problems, along with the corresponding corrective strategies.\n---\n\n\n由于cpp基础并不扎实，因而打算分类刷题，在此过程中对基本语法与STL修修补补!\n\n## Reference:\n\n[CS-Notes](https://github.com/CyC2018/CS-Notes)\n\n[LeetCode 刷题顺序，按标签分类，科学刷题！](https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?fromshare=blogdetail&sharetype=blogdetail&sharerId=125099023&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)\n\n[LeetCode Cookbook](https://books.halfrost.com/leetcode/)\n\n\n\n## Leetcode 628.三个数的最大乘积\n\n[原题链接](https://leetcode.cn/problems/maximum-product-of-three-numbers/solutions/567309/san-ge-shu-de-zui-da-cheng-ji-by-leetcod-t9sb/)\n\n{%fold into @ Time Error Version :x:%}\n一开始无脑遍历所有组合，显然时间复杂度是$O(n^3)$，会超时！\n```cpp\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        int n=nums.size();\n        int max=INT_MIN;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                for(int k=j+1;k<n;k++){\n                    int mul=nums[i]*nums[j]*nums[k];\n                    if(mul>max){\n                        max=mul;\n                    }\n                }\n            }\n        }\n        return max;\n    }\n};\n```\n{%endfold%}\n\n我们这里考虑使用数学方法：\n\n- 数组**均为正数**，乘积最大即为**最大三个正数相乘**\n- 数组**均为负数**，乘积最大即为**最大三个负数相乘**\n- 数组**有正有负**\n  - **两个负数与一个正数相乘**\n  - **三个最大正数相乘**\n\n我们可以先将数组**排序**，然后分情况讨论：\n- 1、2、4都取最大的三个数\n- 3取最小的两个负数（数组首端）与最大的一个正数（数组尾端）\n\n```cpp\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        return max(nums[0]*nums[1]*nums[n-1],nums[n-3]*nums[n-2]*nums[n-1]);\n    }\n};\n```\n\n## Leetcode 645.错误的集合\n[原题链接](https://leetcode.cn/problems/set-mismatch)\n\n{%fold into @ Error Version :x:%}\n需要注意题目要求的数组中数字的**顺序**，若是使用`if`，则先找到谁会先输出谁！\n```cpp\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<int>& nums) {\n        int n=nums.size();\n        vector <int> vec;\n        unordered_map <int,int> error;\n        for(auto it:nums){\n            error[it]++;\n        }\n        for(int i=1;i<=n;i++){\n            int count=error[i];\n            if(count==2){\n                vec.push_back(i);\n            } else if(count==0){\n                vec.push_back(i);\n            }\n        }\n        return vec;\n    }\n```\n{%endfold%}\n\n这里采用**哈希表法**\n- **重复的数字**在数组中出现**2次**\n- **丢失的数字**在数组中出现**0次**\n- 其余的每个数字在数组中出现**1次**\n  \n因此可以使用**哈希表**记录每个元素在数组中出现的次数，然后遍历从1到n的每个数字，分别找到出现2次和出现0次的数字，即为重复的数字和丢失的数字。\n```cpp\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<int>& nums) {\n        int n=nums.size();\n        vector <int> vec(2);\n        unordered_map <int,int> error;\n        for(auto it:nums){\n            error[it]++;\n        }\n        for(int i=1;i<=n;i++){\n            int count=error[i];\n            if(count==2){\n                vec[0]=i;\n            } else if(count==0){\n                 vec[1]=i;\n            }\n        }\n        return vec;\n    }\n};\n```\n\n访问一个尚未在 map 中的键：\n\n1. 在 map 中**创建**一个键为 it 的新元素。\n2. 对这个新元素的值进行**值初始化**。对于 int 类型，值初始化就是将其初始化为 0。\n3. 然后对这个**新初始化的值**执行操作。\n\n## Leetcode 448.找到数组中消失的数字\n\n[原题链接](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array)\n\n{%fold into @ Error Version :x:%}\n企图使用键key和值val相配对的方式**找到缺失数字**，但是又包含**重复数字**，意图使用键值大小比较，另设`extra`进行**偏移量调整**，但是使用`auto`迭代器，**索引无法完成补偿**，且代码过于冗余，遂放弃！\n```cpp\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        unordered_map <int,int> arr;\n        sort(nums.begin(),nums.end());\n        int n=nums.size();\n        for(int i=1;i<=n;i++){\n            arr[i]=nums[i-1];\n        }\n        vector <int> vec;\n        int extra=0;\n        for(auto it:arr){\n            if((it+extra).first>it.second){\n                extra--;\n            }\n            else if((it+extra).first<it.second){\n                extra++;\n                vec.push_back((--it.second)\n            }\n        }\n        return vec;\n    }\n};\n```\n{%endfold%}\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        unordered_map <int,bool> arr;\n        vector <int> vec;\n        int n=nums.size();\n        for(auto it:nums){\n            arr[it]=true;\n        }\n        for(int i=1;i<=n;i++){\n            if(arr.find(i)==arr.end()){\n                vec.push_back(i);\n            }\n        }\n        return vec;\n    }\n};\n```\n采用哈希表`<int,bool>`，对**数组进行遍历**\n- **整型记录数字**（索引）\n- **布尔型记录数字是否出现**\n\n\n## Leetcode 274.H指数\n\n[原题链接](https://leetcode.cn/problems/h-index)\n\n{%fold into @ Error Version :x:%}\n想先排序，再按照`citations[i]`的值与`index`**数组索引值**（计算>的至少有多少篇），但未考虑到若是`4、4、4`这样分布，H指数未必是数组中的数字。\n```cpp\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int n=citations.size();\n        sort(citations.begin(),citations.end());\n        int index;\n        for(int i=0;i<n;i++){\n            if(n-i>=citations[i]){\n                index=citations[i];\n            }\n        }\n        return index;\n    }\n};\n```\n{%endfold%}\n考虑到H指数的指标是固定不变的，因而排序后我们采用**从大到小的遍历方式**。\n```cpp\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        int n=citations.size();\n        sort(citations.begin(),citations.end());\n        int h=0,i=citations.size()-1;\n        while(i>=0 && citations[i]>h){\n            i--;\n            h++;\n        }\n        return h;\n    }\n};\n```\n\n## Leetcode 283.移动零\n\n[原题链接](https://leetcode.cn/problems/move-zeroes)\n\n{%fold into @ Error Version :x:%}\n未考虑**连续0**的情况\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int n=nums.size();\n        int count=0;\n        for(int i=0;i<n-1;i++){\n            if(nums[i]==0){\n                count++;\n                for(int j=i;j<n-1;j++){\n                    nums[j]=nums[j+1];\n                }\n            }\n        }\n        for(int i=n-count;i<n;i++){\n            nums[i]=0;\n        }\n    }\n};\n```\n{%endfold%}\n### 双指针\n- **左指针**：指向**已处理好的序列的末端**\n- **右指针**：指向**未处理的序列的起始位置**\n\n1. 右指针左边到左指针之间均为0\n2. 左指针**左侧均为非零数**\n\n左右指针均从`index`索引**0位置出发**：\n- 若为0，右指针右移，左指针不动（相当于标记0位置）\n- 若不为0，**交换**左右指针指向的元素，均向右移动\n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int right=0,left=0;\n        int n=nums.size();\n        while(right<n){\n            if(nums[right]){\n                swap(nums[left],nums[right]);\n                left++;\n            }\n            right++;\n        }\n    }\n};\n```\n\n## Leetcode 118.杨辉三角 + 119.杨辉三角ii\n[原题链接](https://leetcode.cn/problems/pascals-triangle)\n[原题链接](https://leetcode.cn/problems/pascals-triangle-ii)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> vec(numRows);//初始化杨辉三角行数\n        for(int i=0;i<numRows;i++){\n            vec[i].resize(i+1);//初始化杨辉三角每列元素个数 第i行有i+1个元素\n            vec[i][0]=1;//初始化杨辉三角每列第一个元素为1\n            vec[i][i]=1;//初始化杨辉三角每列最后一个元素为1\n            for(int j=1;j<i;j++){\n                vec[i][j]=vec[i-1][j-1]+vec[i-1][j];\n            }\n        }\n        return vec;\n    }\n};\n```\n### 优化一：滚动数组\n当我们只需要求杨辉三角的`rowIndex`行时，发现对第`i+1`行的计算仅用到了第`i`行的数据,因而可以通过**滚动数组只保留当前行和上一行**的元素，而不需要**更早的元素**。\n```cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector <int> pre,cur;\n        for(int i=0;i<=rowIndex;i++){\n            cur.resize(i+1);\n            cur[0]=cur[i]=1;\n            for(int j=1;j<i;j++){\n                cur[j]=pre[j-1]+pre[j];\n            }\n            pre=cur;\n        }\n        return pre;\n    }\n};\n```\n### 优化二：单一数组逆序更新\n滚动数组的优化，将**当前行**的元素**逆序更新**到**上一行**，从而**不需要保存当前行**，原本的**两数相加**在**同一数组**中每次仅需要加一次即可！。\n```cpp\nclass Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector <int> row(rowIndex+1);\n        for(int i=0;i<=rowIndex;i++){\n            row[0]=1;\n            for(int j=i;j>0;j--){\n                row[j]+=row[j-1];\n            }\n        }\n        return row;\n    }\n};\n```\n\n## Leetcode 14.最长公共前缀\n[原题链接](https://leetcode.cn/problems/longest-common-prefix)\n\n### 方法一：横向扫描\n1. 获取数组中第一个字符串作为**最长公共前缀**\n2. **遍历数组**中的每个字符串，与**最长公共前缀**进行**公共前缀**的比较，更新**最长公共前缀**\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n=strs.size();\n        string prefix=strs[0];\n        for(int i=1;i<n;i++){\n            prefix=CommonPrefix(prefix,strs[i]);\n        }\n        return prefix;\n    }\n    string CommonPrefix(string s1,string s2){\n        int index=0;\n        for(int i=0;i<min(s1.size(),s2.size());i++){\n            if(s1[i]!=s2[i]){\n                break;\n            }\n            index++;\n        }\n        return s1.substr(0,index);\n    }\n};\n```\n\n### 方法二：纵向扫描\n1. **遍历数组**，**依次比较**每个字符串第1、2、3...个字符\n2. 返回最长前缀：\n- 若有字符串的第`i`个字符不同，则**最长公共前缀**的长度为`i-1`\n- 若字符串的长度小于`i`，则**最长公共前缀**的长度为`i`\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n=strs.size();\n        int count=strs[0].size();\n        int i=0;\n        for(i=0;i<count;i++){\n            for(int j=1;j<n;j++){\n                if( i==strs[j].size() || strs[j][i]!=strs[0][i]){\n                    return strs[0].substr(0,i);\n                }\n            }\n        }\n        return strs[0];\n    }\n};\n```\n### 方法三：分治\n### 方法四：二分查找\n\n\n## Leetcode 470.用 Rand7() 实现 Rand10()\n[原题链接](https://leetcode.cn/problems/implement-rand10-using-rand7)\n{%fold into @ Error Version :x:%}\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int first,second;\n        while(first=rand7()>6);\n        while(second=rand7()>5);\n        return (first&1)==1? second:5+second;\n}\n```\n该答案第5、6行缺失括号而导致错误！\n#### 第一种错误版本\n```cpp\nwhile(first=rand7()>6);\nwhile(second=rand7()>5);\n```\n这里由于运算符优先级（比较运算符 > 高于赋值运算符 =），实际执行顺序是：\n- 先计算`rand7()>6`的布尔结果（`true` 或 `false`，即 1 或 0）\n- 将这个布尔结果赋值给 `first` 变量\n- 循环条件永远是 1 或 0，导致逻辑错误\n  \n#### 第二种正确版本\n```cpp\nwhile((first=rand7())>6);\nwhile((second=rand7())>5);\n```\n- 调用 `rand7 ()` 生成随机数\n- 将结果赋值给 `first` 变量\n- 检查该值是否大于 6\n{%endfold%}\n\n这道题的目的是使用`rand7()`产生10个不同但**概率相等**的数\n### 方法一：拒绝采样\n1. 首先**生成1-49的均匀随机数**：:exclamation:`(rand7()-1)*7 + rand7()`:exclamation:\n2. 拒绝41-49的样本（保持1-40的**均匀分布**）\n3. 对结果取模+1，得到1-10的**均匀随机数**\n{%fold into @ 为什么这样生成采样样本？%}\n1.`rand7()-1`生成 0~6\n2.`(rand7()-1)*7`生成 0、7、14、21、28、35、42\n3.`(rand7()-1)*7 + rand7()`生成 1~49\n**无重复数字**，每个数字出现的**概率均相同**是1/49\n{%endfold%}\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int num;\n        while((num=(rand7()-1)*7+rand7())>40);\n        return num%10+1;\n    }\n};\n```\n\n### 方法二：古典概型\n1. 第一次`rand7`限定[1,6]，**判断奇偶性**，概率是1/2\n2. 第二次`rand7`限定[1,5]，概率是1/5\n3. 二者结合可以得出10种概率相同的结果\n```cpp\nclass Solution {\npublic:\n    int rand10() {\n        int first,second;\n        while((first=rand7())>6);\n        while((second=rand7())>5);\n        return (first&1)==1? second:5+second;\n}\n```\n\n#### 位运算符\n- **按位与（&）**：对两个操作数的每一位进行比较，只有当两位都为 1 时结果对应位才为 1，否则为 0。\n示例：3 & 5（二进制 011 & 101）结果为 1（二进制 001）。\n```cpp\nbool isOdd(int x) {\n    return x & 1; // 结果为1则奇数，0则偶数\n}\n```\n- **按位或（|）**：对两个操作数的每一位进行比较，只要其中一位为 1，结果对应位就为 1，否则为 0。\n示例：3 | 5（二进制 011 | 101）结果为 7（二进制 111）。\n- **按位异或（^）**：对两个操作数的每一位进行比较，当两位不同时结果为 1，相同时为 0。\n示例：3 ^ 5（二进制 011 ^ 101）结果为 6（二进制 110）。\n```cpp\nvoid swap(int& a, int& b) {\n    if (a != b) { // 避免a和b同地址时出错\n        a = a ^ b; // a现在是a^b\n        b = a ^ b; // b = (a^b)^b = a\n        a = a ^ b; // a = (a^b)^a = b\n    }\n}\n```\n- **按位非（~）**：对单个操作数的**每一位取反**（0 变 1，1 变 0），是一元运算符。\n示例：~3（二进制 ~011）在 32 位系统中结果为 -4（二进制补码表示）。\n- **左移（<<）**：将左操作数的**二进制位向左移动指定的位数**，右侧空位补 0。\n示例：3 << 1（二进制 011 << 1）结果为 6（二进制 110），相当于**乘以 2 的 n 次方**（n 为移动位数）。\n- **右移（>>）**：将左操作数的**二进制位向右移动指定的位数**，左侧空位补符号位（正数补 0，负数补 1）。\n示例：6 >> 1（二进制 110 >> 1）结果为 3（二进制 011），相当于**除以 2 的 n 次方**（向下取整）。","slug":"Leetcode-Collection/Leetcode-Mistake-Collection-1","published":1,"updated":"2025-08-31T08:55:54.261Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hct002540w3d6yk0h6f","content":"<p>由于cpp基础并不扎实，因而打算分类刷题，在此过程中对基本语法与STL修修补补!</p>\n<h2 id=\"Reference\">Reference:</h2>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">CS-Notes</a></p>\n<p><a href=\"https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=125099023&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">LeetCode 刷题顺序，按标签分类，科学刷题！</a></p>\n<p><a href=\"https://books.halfrost.com/leetcode/\">LeetCode Cookbook</a></p>\n<h2 id=\"Leetcode-628-三个数的最大乘积\">Leetcode 628.三个数的最大乘积</h2>\n<p><a href=\"https://leetcode.cn/problems/maximum-product-of-three-numbers/solutions/567309/san-ge-shu-de-zui-da-cheng-ji-by-leetcod-t9sb/\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-c2f87d95\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-c2f87d95\">\n        <div class=\"fold-arrow\">▶</div> Time Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-c2f87d95\">\n        <div class=\"fold-content\">\n          <p>一开始无脑遍历所有组合，显然时间复杂度是$O(n^3)$，会超时！</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maximumProduct</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> max=INT_MIN;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++){<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i<span class=\"hljs-number\">+1</span>;j&lt;n;j++){<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> k=j<span class=\"hljs-number\">+1</span>;k&lt;n;k++){<br>                    <span class=\"hljs-type\">int</span> mul=nums[i]*nums[j]*nums[k];<br>                    <span class=\"hljs-keyword\">if</span>(mul&gt;max){<br>                        max=mul;<br>                    }<br>                }<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> max;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<p>我们这里考虑使用数学方法：</p>\n<ul>\n<li>数组<strong>均为正数</strong>，乘积最大即为<strong>最大三个正数相乘</strong></li>\n<li>数组<strong>均为负数</strong>，乘积最大即为<strong>最大三个负数相乘</strong></li>\n<li>数组<strong>有正有负</strong>\n<ul>\n<li><strong>两个负数与一个正数相乘</strong></li>\n<li><strong>三个最大正数相乘</strong></li>\n</ul>\n</li>\n</ul>\n<p>我们可以先将数组<strong>排序</strong>，然后分情况讨论：</p>\n<ul>\n<li>1、2、4都取最大的三个数</li>\n<li>3取最小的两个负数（数组首端）与最大的一个正数（数组尾端）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maximumProduct</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(nums[<span class=\"hljs-number\">0</span>]*nums[<span class=\"hljs-number\">1</span>]*nums[n<span class=\"hljs-number\">-1</span>],nums[n<span class=\"hljs-number\">-3</span>]*nums[n<span class=\"hljs-number\">-2</span>]*nums[n<span class=\"hljs-number\">-1</span>]);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Leetcode-645-错误的集合\">Leetcode 645.错误的集合</h2>\n<p><a href=\"https://leetcode.cn/problems/set-mismatch\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-af06c644\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-af06c644\">\n        <div class=\"fold-arrow\">▶</div> Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-af06c644\">\n        <div class=\"fold-content\">\n          <p>需要注意题目要求的数组中数字的<strong>顺序</strong>，若是使用<code>if</code>，则先找到谁会先输出谁！</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findErrorNums</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; error;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums){<br>            error[it]++;<br>        }<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++){<br>            <span class=\"hljs-type\">int</span> count=error[i];<br>            <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">2</span>){<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>){<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    }<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<p>这里采用<strong>哈希表法</strong></p>\n<ul>\n<li><strong>重复的数字</strong>在数组中出现<strong>2次</strong></li>\n<li><strong>丢失的数字</strong>在数组中出现<strong>0次</strong></li>\n<li>其余的每个数字在数组中出现<strong>1次</strong></li>\n</ul>\n<p>因此可以使用<strong>哈希表</strong>记录每个元素在数组中出现的次数，然后遍历从1到n的每个数字，分别找到出现2次和出现0次的数字，即为重复的数字和丢失的数字。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findErrorNums</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">vec</span>(<span class=\"hljs-number\">2</span>);<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; error;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums){<br>            error[it]++;<br>        }<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++){<br>            <span class=\"hljs-type\">int</span> count=error[i];<br>            <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">2</span>){<br>                vec[<span class=\"hljs-number\">0</span>]=i;<br>            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>){<br>                 vec[<span class=\"hljs-number\">1</span>]=i;<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<p>访问一个尚未在 map 中的键：</p>\n<ol>\n<li>在 map 中<strong>创建</strong>一个键为 it 的新元素。</li>\n<li>对这个新元素的值进行<strong>值初始化</strong>。对于 int 类型，值初始化就是将其初始化为 0。</li>\n<li>然后对这个<strong>新初始化的值</strong>执行操作。</li>\n</ol>\n<h2 id=\"Leetcode-448-找到数组中消失的数字\">Leetcode 448.找到数组中消失的数字</h2>\n<p><a href=\"https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-cbd6109f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-cbd6109f\">\n        <div class=\"fold-arrow\">▶</div> Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-cbd6109f\">\n        <div class=\"fold-content\">\n          <p>企图使用键key和值val相配对的方式<strong>找到缺失数字</strong>，但是又包含<strong>重复数字</strong>，意图使用键值大小比较，另设<code>extra</code>进行<strong>偏移量调整</strong>，但是使用<code>auto</code>迭代器，<strong>索引无法完成补偿</strong>，且代码过于冗余，遂放弃！</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findDisappearedNumbers</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; arr;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++){<br>            arr[i]=nums[i<span class=\"hljs-number\">-1</span>];<br>        }<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        <span class=\"hljs-type\">int</span> extra=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:arr){<br>            <span class=\"hljs-keyword\">if</span>((it+extra).first&gt;it.second){<br>                extra--;<br>            }<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>((it+extra).first&lt;it.second){<br>                extra++;<br>                vec.<span class=\"hljs-built_in\">push_back</span>((--it.second)<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findDisappearedNumbers</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">bool</span>&gt; arr;<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums){<br>            arr[it]=<span class=\"hljs-literal\">true</span>;<br>        }<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++){<br>            <span class=\"hljs-keyword\">if</span>(arr.<span class=\"hljs-built_in\">find</span>(i)==arr.<span class=\"hljs-built_in\">end</span>()){<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<p>采用哈希表<code>&lt;int,bool&gt;</code>，对<strong>数组进行遍历</strong></p>\n<ul>\n<li><strong>整型记录数字</strong>（索引）</li>\n<li><strong>布尔型记录数字是否出现</strong></li>\n</ul>\n<h2 id=\"Leetcode-274-H指数\">Leetcode 274.H指数</h2>\n<p><a href=\"https://leetcode.cn/problems/h-index\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-0927e85d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-0927e85d\">\n        <div class=\"fold-arrow\">▶</div> Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-0927e85d\">\n        <div class=\"fold-content\">\n          <p>想先排序，再按照<code>citations[i]</code>的值与<code>index</code><strong>数组索引值</strong>（计算&gt;的至少有多少篇），但未考虑到若是<code>4、4、4</code>这样分布，H指数未必是数组中的数字。</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; citations)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=citations.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-built_in\">sort</span>(citations.<span class=\"hljs-built_in\">begin</span>(),citations.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> index;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++){<br>            <span class=\"hljs-keyword\">if</span>(n-i&gt;=citations[i]){<br>                index=citations[i];<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> index;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<p>考虑到H指数的指标是固定不变的，因而排序后我们采用<strong>从大到小的遍历方式</strong>。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; citations)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=citations.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-built_in\">sort</span>(citations.<span class=\"hljs-built_in\">begin</span>(),citations.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> h=<span class=\"hljs-number\">0</span>,i=citations.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(i&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; citations[i]&gt;h){<br>            i--;<br>            h++;<br>        }<br>        <span class=\"hljs-keyword\">return</span> h;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Leetcode-283-移动零\">Leetcode 283.移动零</h2>\n<p><a href=\"https://leetcode.cn/problems/move-zeroes\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b977da26\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b977da26\">\n        <div class=\"fold-arrow\">▶</div> Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b977da26\">\n        <div class=\"fold-content\">\n          <p>未考虑<strong>连续0</strong>的情况</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">moveZeroes</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i++){<br>            <span class=\"hljs-keyword\">if</span>(nums[i]==<span class=\"hljs-number\">0</span>){<br>                count++;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;n<span class=\"hljs-number\">-1</span>;j++){<br>                    nums[j]=nums[j<span class=\"hljs-number\">+1</span>];<br>                }<br>            }<br>        }<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=n-count;i&lt;n;i++){<br>            nums[i]=<span class=\"hljs-number\">0</span>;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"双指针\">双指针</h3>\n<ul>\n<li><strong>左指针</strong>：指向<strong>已处理好的序列的末端</strong></li>\n<li><strong>右指针</strong>：指向<strong>未处理的序列的起始位置</strong></li>\n</ul>\n<ol>\n<li>右指针左边到左指针之间均为0</li>\n<li>左指针<strong>左侧均为非零数</strong></li>\n</ol>\n<p>左右指针均从<code>index</code>索引<strong>0位置出发</strong>：</p>\n<ul>\n<li>若为0，右指针右移，左指针不动（相当于标记0位置）</li>\n<li>若不为0，<strong>交换</strong>左右指针指向的元素，均向右移动</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">moveZeroes</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> right=<span class=\"hljs-number\">0</span>,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(right&lt;n){<br>            <span class=\"hljs-keyword\">if</span>(nums[right]){<br>                <span class=\"hljs-built_in\">swap</span>(nums[left],nums[right]);<br>                left++;<br>            }<br>            right++;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Leetcode-118-杨辉三角-119-杨辉三角ii\">Leetcode 118.杨辉三角 + 119.杨辉三角ii</h2>\n<p><a href=\"https://leetcode.cn/problems/pascals-triangle\">原题链接</a><br>\n<a href=\"https://leetcode.cn/problems/pascals-triangle-ii\">原题链接</a></p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">generate</span>(<span class=\"hljs-type\">int</span> numRows) {<br>        vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">vec</span>(numRows);<span class=\"hljs-comment\">//初始化杨辉三角行数</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;numRows;i++){<br>            vec[i].<span class=\"hljs-built_in\">resize</span>(i<span class=\"hljs-number\">+1</span>);<span class=\"hljs-comment\">//初始化杨辉三角每列元素个数 第i行有i+1个元素</span><br>            vec[i][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始化杨辉三角每列第一个元素为1</span><br>            vec[i][i]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始化杨辉三角每列最后一个元素为1</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;i;j++){<br>                vec[i][j]=vec[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+vec[i<span class=\"hljs-number\">-1</span>][j];<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"优化一：滚动数组\">优化一：滚动数组</h3>\n<p>当我们只需要求杨辉三角的<code>rowIndex</code>行时，发现对第<code>i+1</code>行的计算仅用到了第<code>i</code>行的数据,因而可以通过<strong>滚动数组只保留当前行和上一行</strong>的元素，而不需要<strong>更早的元素</strong>。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">getRow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> rowIndex)</span> </span>{<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; pre,cur;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=rowIndex;i++){<br>            cur.<span class=\"hljs-built_in\">resize</span>(i<span class=\"hljs-number\">+1</span>);<br>            cur[<span class=\"hljs-number\">0</span>]=cur[i]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;i;j++){<br>                cur[j]=pre[j<span class=\"hljs-number\">-1</span>]+pre[j];<br>            }<br>            pre=cur;<br>        }<br>        <span class=\"hljs-keyword\">return</span> pre;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"优化二：单一数组逆序更新\">优化二：单一数组逆序更新</h3>\n<p>滚动数组的优化，将<strong>当前行</strong>的元素<strong>逆序更新</strong>到<strong>上一行</strong>，从而<strong>不需要保存当前行</strong>，原本的<strong>两数相加</strong>在<strong>同一数组</strong>中每次仅需要加一次即可！。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">getRow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> rowIndex)</span> </span>{<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">row</span>(rowIndex<span class=\"hljs-number\">+1</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=rowIndex;i++){<br>            row[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&gt;<span class=\"hljs-number\">0</span>;j--){<br>                row[j]+=row[j<span class=\"hljs-number\">-1</span>];<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> row;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"Leetcode-14-最长公共前缀\">Leetcode 14.最长公共前缀</h2>\n<p><a href=\"https://leetcode.cn/problems/longest-common-prefix\">原题链接</a></p>\n<h3 id=\"方法一：横向扫描\">方法一：横向扫描</h3>\n<ol>\n<li>获取数组中第一个字符串作为<strong>最长公共前缀</strong></li>\n<li><strong>遍历数组</strong>中的每个字符串，与<strong>最长公共前缀</strong>进行<strong>公共前缀</strong>的比较，更新<strong>最长公共前缀</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">longestCommonPrefix</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; strs)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=strs.<span class=\"hljs-built_in\">size</span>();<br>        string prefix=strs[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++){<br>            prefix=<span class=\"hljs-built_in\">CommonPrefix</span>(prefix,strs[i]);<br>        }<br>        <span class=\"hljs-keyword\">return</span> prefix;<br>    }<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">CommonPrefix</span><span class=\"hljs-params\">(string s1,string s2)</span></span>{<br>        <span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-built_in\">min</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());i++){<br>            <span class=\"hljs-keyword\">if</span>(s1[i]!=s2[i]){<br>                <span class=\"hljs-keyword\">break</span>;<br>            }<br>            index++;<br>        }<br>        <span class=\"hljs-keyword\">return</span> s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,index);<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"方法二：纵向扫描\">方法二：纵向扫描</h3>\n<ol>\n<li><strong>遍历数组</strong>，<strong>依次比较</strong>每个字符串第1、2、3…个字符</li>\n<li>返回最长前缀：</li>\n</ol>\n<ul>\n<li>若有字符串的第<code>i</code>个字符不同，则<strong>最长公共前缀</strong>的长度为<code>i-1</code></li>\n<li>若字符串的长度小于<code>i</code>，则<strong>最长公共前缀</strong>的长度为<code>i</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">longestCommonPrefix</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; strs)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=strs.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> count=strs[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;count;i++){<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;n;j++){<br>                <span class=\"hljs-keyword\">if</span>( i==strs[j].<span class=\"hljs-built_in\">size</span>() || strs[j][i]!=strs[<span class=\"hljs-number\">0</span>][i]){<br>                    <span class=\"hljs-keyword\">return</span> strs[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,i);<br>                }<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> strs[<span class=\"hljs-number\">0</span>];<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"方法三：分治\">方法三：分治</h3>\n<h3 id=\"方法四：二分查找\">方法四：二分查找</h3>\n<h2 id=\"Leetcode-470-用-Rand7-实现-Rand10\">Leetcode 470.用 Rand7() 实现 Rand10()</h2>\n<p><a href=\"https://leetcode.cn/problems/implement-rand10-using-rand7\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e2498296\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e2498296\">\n        <div class=\"fold-arrow\">▶</div> Error Version <span class=\"github-emoji\"><span>❌</span><img src=\"https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8\" aria-hidden=\"true\" onerror=\"this.parent.classList.add('github-emoji-fallback')\"></span>\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e2498296\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> first,second;<br>        <span class=\"hljs-keyword\">while</span>(first=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">6</span>);<br>        <span class=\"hljs-keyword\">while</span>(second=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">5</span>);<br>        <span class=\"hljs-keyword\">return</span> (first&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>? second:<span class=\"hljs-number\">5</span>+second;<br>}<br></code></pre></td></tr></tbody></table></figure><p>该答案第5、6行缺失括号而导致错误！</p><h4 id=\"第一种错误版本\">第一种错误版本</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span>(first=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">6</span>);<br><span class=\"hljs-keyword\">while</span>(second=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></tbody></table></figure><p>这里由于运算符优先级（比较运算符 &gt; 高于赋值运算符 =），实际执行顺序是：</p><ul><li>先计算<code>rand7()&gt;6</code>的布尔结果（<code>true</code> 或 <code>false</code>，即 1 或 0）</li><li>将这个布尔结果赋值给 <code>first</code> 变量</li><li>循环条件永远是 1 或 0，导致逻辑错误</li></ul><h4 id=\"第二种正确版本\">第二种正确版本</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span>((first=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">6</span>);<br><span class=\"hljs-keyword\">while</span>((second=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></tbody></table></figure><ul><li>调用 <code>rand7 ()</code> 生成随机数</li><li>将结果赋值给 <code>first</code> 变量</li><li>检查该值是否大于 6</li></ul>\n        </div>\n      </div>\n    </div>\n<p>这道题的目的是使用<code>rand7()</code>产生10个不同但<strong>概率相等</strong>的数</p>\n<h3 id=\"方法一：拒绝采样\">方法一：拒绝采样</h3>\n<ol>\n<li>首先<strong>生成1-49的均匀随机数</strong>：❗<code>(rand7()-1)*7 + rand7()</code>❗</li>\n<li>拒绝41-49的样本（保持1-40的<strong>均匀分布</strong>）</li>\n<li>对结果取模+1，得到1-10的<strong>均匀随机数</strong></li>\n</ol>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e761341d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e761341d\">\n        <div class=\"fold-arrow\">▶</div> 为什么这样生成采样样本？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e761341d\">\n        <div class=\"fold-content\">\n          <p>1.<code>rand7()-1</code>生成 0~6<br>2.<code>(rand7()-1)*7</code>生成 0、7、14、21、28、35、42<br>3.<code>(rand7()-1)*7 + rand7()</code>生成 1~49<br><strong>无重复数字</strong>，每个数字出现的<strong>概率均相同</strong>是1/49</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> num;<br>        <span class=\"hljs-keyword\">while</span>((num=(<span class=\"hljs-built_in\">rand7</span>()<span class=\"hljs-number\">-1</span>)*<span class=\"hljs-number\">7</span>+<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">40</span>);<br>        <span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">10</span><span class=\"hljs-number\">+1</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"方法二：古典概型\">方法二：古典概型</h3>\n<ol>\n<li>第一次<code>rand7</code>限定[1,6]，<strong>判断奇偶性</strong>，概率是1/2</li>\n<li>第二次<code>rand7</code>限定[1,5]，概率是1/5</li>\n<li>二者结合可以得出10种概率相同的结果</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>{<br>        <span class=\"hljs-type\">int</span> first,second;<br>        <span class=\"hljs-keyword\">while</span>((first=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">6</span>);<br>        <span class=\"hljs-keyword\">while</span>((second=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">5</span>);<br>        <span class=\"hljs-keyword\">return</span> (first&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>? second:<span class=\"hljs-number\">5</span>+second;<br>}<br></code></pre></td></tr></tbody></table></figure>\n<h4 id=\"位运算符\">位运算符</h4>\n<ul>\n<li><strong>按位与（&amp;）</strong>：对两个操作数的每一位进行比较，只有当两位都为 1 时结果对应位才为 1，否则为 0。<br>\n示例：3 &amp; 5（二进制 011 &amp; 101）结果为 1（二进制 001）。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>{<br>    <span class=\"hljs-keyword\">return</span> x &amp; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 结果为1则奇数，0则偶数</span><br>}<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><strong>按位或（|）</strong>：对两个操作数的每一位进行比较，只要其中一位为 1，结果对应位就为 1，否则为 0。<br>\n示例：3 | 5（二进制 011 | 101）结果为 7（二进制 111）。</li>\n<li><strong>按位异或（^）</strong>：对两个操作数的每一位进行比较，当两位不同时结果为 1，相同时为 0。<br>\n示例：3 ^ 5（二进制 011 ^ 101）结果为 6（二进制 110）。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; a, <span class=\"hljs-type\">int</span>&amp; b)</span> </span>{<br>    <span class=\"hljs-keyword\">if</span> (a != b) { <span class=\"hljs-comment\">// 避免a和b同地址时出错</span><br>        a = a ^ b; <span class=\"hljs-comment\">// a现在是a^b</span><br>        b = a ^ b; <span class=\"hljs-comment\">// b = (a^b)^b = a</span><br>        a = a ^ b; <span class=\"hljs-comment\">// a = (a^b)^a = b</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><strong>按位非（~）</strong>：对单个操作数的<strong>每一位取反</strong>（0 变 1，1 变 0），是一元运算符。<br>\n示例：~3（二进制 ~011）在 32 位系统中结果为 -4（二进制补码表示）。</li>\n<li><strong>左移（&lt;&lt;）</strong>：将左操作数的<strong>二进制位向左移动指定的位数</strong>，右侧空位补 0。<br>\n示例：3 &lt;&lt; 1（二进制 011 &lt;&lt; 1）结果为 6（二进制 110），相当于<strong>乘以 2 的 n 次方</strong>（n 为移动位数）。</li>\n<li><strong>右移（&gt;&gt;）</strong>：将左操作数的<strong>二进制位向右移动指定的位数</strong>，左侧空位补符号位（正数补 0，负数补 1）。<br>\n示例：6 &gt;&gt; 1（二进制 110 &gt;&gt; 1）结果为 3（二进制 011），相当于<strong>除以 2 的 n 次方</strong>（向下取整）。</li>\n</ul>\n","excerpt":"","more":"<p>由于cpp基础并不扎实，因而打算分类刷题，在此过程中对基本语法与STL修修补补!</p>\n<h2 id=\"Reference\">Reference:</h2>\n<p><a href=\"https://github.com/CyC2018/CS-Notes\">CS-Notes</a></p>\n<p><a href=\"https://blog.csdn.net/fengyuyeguirenenen/article/details/125099023?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=125099023&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">LeetCode 刷题顺序，按标签分类，科学刷题！</a></p>\n<p><a href=\"https://books.halfrost.com/leetcode/\">LeetCode Cookbook</a></p>\n<h2 id=\"Leetcode-628-三个数的最大乘积\">Leetcode 628.三个数的最大乘积</h2>\n<p><a href=\"https://leetcode.cn/problems/maximum-product-of-three-numbers/solutions/567309/san-ge-shu-de-zui-da-cheng-ji-by-leetcod-t9sb/\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-c2f87d95\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-c2f87d95\">\n        <div class=\"fold-arrow\">▶</div> Time Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-c2f87d95\">\n        <div class=\"fold-content\">\n          <p>一开始无脑遍历所有组合，显然时间复杂度是$O(n^3)$，会超时！</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maximumProduct</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> max=INT_MIN;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i<span class=\"hljs-number\">+1</span>;j&lt;n;j++)&#123;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> k=j<span class=\"hljs-number\">+1</span>;k&lt;n;k++)&#123;<br>                    <span class=\"hljs-type\">int</span> mul=nums[i]*nums[j]*nums[k];<br>                    <span class=\"hljs-keyword\">if</span>(mul&gt;max)&#123;<br>                        max=mul;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<p>我们这里考虑使用数学方法：</p>\n<ul>\n<li>数组<strong>均为正数</strong>，乘积最大即为<strong>最大三个正数相乘</strong></li>\n<li>数组<strong>均为负数</strong>，乘积最大即为<strong>最大三个负数相乘</strong></li>\n<li>数组<strong>有正有负</strong>\n<ul>\n<li><strong>两个负数与一个正数相乘</strong></li>\n<li><strong>三个最大正数相乘</strong></li>\n</ul>\n</li>\n</ul>\n<p>我们可以先将数组<strong>排序</strong>，然后分情况讨论：</p>\n<ul>\n<li>1、2、4都取最大的三个数</li>\n<li>3取最小的两个负数（数组首端）与最大的一个正数（数组尾端）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maximumProduct</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(nums[<span class=\"hljs-number\">0</span>]*nums[<span class=\"hljs-number\">1</span>]*nums[n<span class=\"hljs-number\">-1</span>],nums[n<span class=\"hljs-number\">-3</span>]*nums[n<span class=\"hljs-number\">-2</span>]*nums[n<span class=\"hljs-number\">-1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Leetcode-645-错误的集合\">Leetcode 645.错误的集合</h2>\n<p><a href=\"https://leetcode.cn/problems/set-mismatch\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-af06c644\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-af06c644\">\n        <div class=\"fold-arrow\">▶</div> Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-af06c644\">\n        <div class=\"fold-content\">\n          <p>需要注意题目要求的数组中数字的<strong>顺序</strong>，若是使用<code>if</code>，则先找到谁会先输出谁！</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findErrorNums</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; error;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums)&#123;<br>            error[it]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>            <span class=\"hljs-type\">int</span> count=error[i];<br>            <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">2</span>)&#123;<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    &#125;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<p>这里采用<strong>哈希表法</strong></p>\n<ul>\n<li><strong>重复的数字</strong>在数组中出现<strong>2次</strong></li>\n<li><strong>丢失的数字</strong>在数组中出现<strong>0次</strong></li>\n<li>其余的每个数字在数组中出现<strong>1次</strong></li>\n</ul>\n<p>因此可以使用<strong>哈希表</strong>记录每个元素在数组中出现的次数，然后遍历从1到n的每个数字，分别找到出现2次和出现0次的数字，即为重复的数字和丢失的数字。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findErrorNums</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">vec</span>(<span class=\"hljs-number\">2</span>);<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; error;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums)&#123;<br>            error[it]++;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>            <span class=\"hljs-type\">int</span> count=error[i];<br>            <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">2</span>)&#123;<br>                vec[<span class=\"hljs-number\">0</span>]=i;<br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(count==<span class=\"hljs-number\">0</span>)&#123;<br>                 vec[<span class=\"hljs-number\">1</span>]=i;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>访问一个尚未在 map 中的键：</p>\n<ol>\n<li>在 map 中<strong>创建</strong>一个键为 it 的新元素。</li>\n<li>对这个新元素的值进行<strong>值初始化</strong>。对于 int 类型，值初始化就是将其初始化为 0。</li>\n<li>然后对这个<strong>新初始化的值</strong>执行操作。</li>\n</ol>\n<h2 id=\"Leetcode-448-找到数组中消失的数字\">Leetcode 448.找到数组中消失的数字</h2>\n<p><a href=\"https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-cbd6109f\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-cbd6109f\">\n        <div class=\"fold-arrow\">▶</div> Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-cbd6109f\">\n        <div class=\"fold-content\">\n          <p>企图使用键key和值val相配对的方式<strong>找到缺失数字</strong>，但是又包含<strong>重复数字</strong>，意图使用键值大小比较，另设<code>extra</code>进行<strong>偏移量调整</strong>，但是使用<code>auto</code>迭代器，<strong>索引无法完成补偿</strong>，且代码过于冗余，遂放弃！</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findDisappearedNumbers</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">int</span>&gt; arr;<br>        <span class=\"hljs-built_in\">sort</span>(nums.<span class=\"hljs-built_in\">begin</span>(),nums.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>            arr[i]=nums[i<span class=\"hljs-number\">-1</span>];<br>        &#125;<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        <span class=\"hljs-type\">int</span> extra=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:arr)&#123;<br>            <span class=\"hljs-keyword\">if</span>((it+extra).first&gt;it.second)&#123;<br>                extra--;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>((it+extra).first&lt;it.second)&#123;<br>                extra++;<br>                vec.<span class=\"hljs-built_in\">push_back</span>((--it.second)<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">findDisappearedNumbers</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map &lt;<span class=\"hljs-type\">int</span>,<span class=\"hljs-type\">bool</span>&gt; arr;<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; vec;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> it:nums)&#123;<br>            arr[it]=<span class=\"hljs-literal\">true</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;=n;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(arr.<span class=\"hljs-built_in\">find</span>(i)==arr.<span class=\"hljs-built_in\">end</span>())&#123;<br>                vec.<span class=\"hljs-built_in\">push_back</span>(i);<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>采用哈希表<code>&lt;int,bool&gt;</code>，对<strong>数组进行遍历</strong></p>\n<ul>\n<li><strong>整型记录数字</strong>（索引）</li>\n<li><strong>布尔型记录数字是否出现</strong></li>\n</ul>\n<h2 id=\"Leetcode-274-H指数\">Leetcode 274.H指数</h2>\n<p><a href=\"https://leetcode.cn/problems/h-index\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-0927e85d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-0927e85d\">\n        <div class=\"fold-arrow\">▶</div> Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-0927e85d\">\n        <div class=\"fold-content\">\n          <p>想先排序，再按照<code>citations[i]</code>的值与<code>index</code><strong>数组索引值</strong>（计算&gt;的至少有多少篇），但未考虑到若是<code>4、4、4</code>这样分布，H指数未必是数组中的数字。</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=citations.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-built_in\">sort</span>(citations.<span class=\"hljs-built_in\">begin</span>(),citations.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> index;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(n-i&gt;=citations[i])&#123;<br>                index=citations[i];<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<p>考虑到H指数的指标是固定不变的，因而排序后我们采用<strong>从大到小的遍历方式</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">hIndex</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; citations)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=citations.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-built_in\">sort</span>(citations.<span class=\"hljs-built_in\">begin</span>(),citations.<span class=\"hljs-built_in\">end</span>());<br>        <span class=\"hljs-type\">int</span> h=<span class=\"hljs-number\">0</span>,i=citations.<span class=\"hljs-built_in\">size</span>()<span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">while</span>(i&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; citations[i]&gt;h)&#123;<br>            i--;<br>            h++;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> h;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Leetcode-283-移动零\">Leetcode 283.移动零</h2>\n<p><a href=\"https://leetcode.cn/problems/move-zeroes\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-b977da26\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-b977da26\">\n        <div class=\"fold-arrow\">▶</div> Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-b977da26\">\n        <div class=\"fold-content\">\n          <p>未考虑<strong>连续0</strong>的情况</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">moveZeroes</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> count=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n<span class=\"hljs-number\">-1</span>;i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[i]==<span class=\"hljs-number\">0</span>)&#123;<br>                count++;<br>                <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;n<span class=\"hljs-number\">-1</span>;j++)&#123;<br>                    nums[j]=nums[j<span class=\"hljs-number\">+1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=n-count;i&lt;n;i++)&#123;<br>            nums[i]=<span class=\"hljs-number\">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"双指针\">双指针</h3>\n<ul>\n<li><strong>左指针</strong>：指向<strong>已处理好的序列的末端</strong></li>\n<li><strong>右指针</strong>：指向<strong>未处理的序列的起始位置</strong></li>\n</ul>\n<ol>\n<li>右指针左边到左指针之间均为0</li>\n<li>左指针<strong>左侧均为非零数</strong></li>\n</ol>\n<p>左右指针均从<code>index</code>索引<strong>0位置出发</strong>：</p>\n<ul>\n<li>若为0，右指针右移，左指针不动（相当于标记0位置）</li>\n<li>若不为0，<strong>交换</strong>左右指针指向的元素，均向右移动</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">moveZeroes</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> right=<span class=\"hljs-number\">0</span>,left=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">while</span>(right&lt;n)&#123;<br>            <span class=\"hljs-keyword\">if</span>(nums[right])&#123;<br>                <span class=\"hljs-built_in\">swap</span>(nums[left],nums[right]);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Leetcode-118-杨辉三角-119-杨辉三角ii\">Leetcode 118.杨辉三角 + 119.杨辉三角ii</h2>\n<p><a href=\"https://leetcode.cn/problems/pascals-triangle\">原题链接</a><br>\n<a href=\"https://leetcode.cn/problems/pascals-triangle-ii\">原题链接</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">generate</span>(<span class=\"hljs-type\">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; <span class=\"hljs-built_in\">vec</span>(numRows);<span class=\"hljs-comment\">//初始化杨辉三角行数</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;numRows;i++)&#123;<br>            vec[i].<span class=\"hljs-built_in\">resize</span>(i<span class=\"hljs-number\">+1</span>);<span class=\"hljs-comment\">//初始化杨辉三角每列元素个数 第i行有i+1个元素</span><br>            vec[i][<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始化杨辉三角每列第一个元素为1</span><br>            vec[i][i]=<span class=\"hljs-number\">1</span>;<span class=\"hljs-comment\">//初始化杨辉三角每列最后一个元素为1</span><br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;i;j++)&#123;<br>                vec[i][j]=vec[i<span class=\"hljs-number\">-1</span>][j<span class=\"hljs-number\">-1</span>]+vec[i<span class=\"hljs-number\">-1</span>][j];<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> vec;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"优化一：滚动数组\">优化一：滚动数组</h3>\n<p>当我们只需要求杨辉三角的<code>rowIndex</code>行时，发现对第<code>i+1</code>行的计算仅用到了第<code>i</code>行的数据,因而可以通过<strong>滚动数组只保留当前行和上一行</strong>的元素，而不需要<strong>更早的元素</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">getRow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> rowIndex)</span> </span>&#123;<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; pre,cur;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=rowIndex;i++)&#123;<br>            cur.<span class=\"hljs-built_in\">resize</span>(i<span class=\"hljs-number\">+1</span>);<br>            cur[<span class=\"hljs-number\">0</span>]=cur[i]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;i;j++)&#123;<br>                cur[j]=pre[j<span class=\"hljs-number\">-1</span>]+pre[j];<br>            &#125;<br>            pre=cur;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"优化二：单一数组逆序更新\">优化二：单一数组逆序更新</h3>\n<p>滚动数组的优化，将<strong>当前行</strong>的元素<strong>逆序更新</strong>到<strong>上一行</strong>，从而<strong>不需要保存当前行</strong>，原本的<strong>两数相加</strong>在<strong>同一数组</strong>中每次仅需要加一次即可！。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">getRow</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> rowIndex)</span> </span>&#123;<br>        vector &lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-built_in\">row</span>(rowIndex<span class=\"hljs-number\">+1</span>);<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;=rowIndex;i++)&#123;<br>            row[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">1</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&gt;<span class=\"hljs-number\">0</span>;j--)&#123;<br>                row[j]+=row[j<span class=\"hljs-number\">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> row;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Leetcode-14-最长公共前缀\">Leetcode 14.最长公共前缀</h2>\n<p><a href=\"https://leetcode.cn/problems/longest-common-prefix\">原题链接</a></p>\n<h3 id=\"方法一：横向扫描\">方法一：横向扫描</h3>\n<ol>\n<li>获取数组中第一个字符串作为<strong>最长公共前缀</strong></li>\n<li><strong>遍历数组</strong>中的每个字符串，与<strong>最长公共前缀</strong>进行<strong>公共前缀</strong>的比较，更新<strong>最长公共前缀</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">longestCommonPrefix</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=strs.<span class=\"hljs-built_in\">size</span>();<br>        string prefix=strs[<span class=\"hljs-number\">0</span>];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">1</span>;i&lt;n;i++)&#123;<br>            prefix=<span class=\"hljs-built_in\">CommonPrefix</span>(prefix,strs[i]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> prefix;<br>    &#125;<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">CommonPrefix</span><span class=\"hljs-params\">(string s1,string s2)</span></span>&#123;<br>        <span class=\"hljs-type\">int</span> index=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-built_in\">min</span>(s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">size</span>(),s<span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">size</span>());i++)&#123;<br>            <span class=\"hljs-keyword\">if</span>(s1[i]!=s2[i])&#123;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            index++;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> s<span class=\"hljs-number\">1.</span><span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,index);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"方法二：纵向扫描\">方法二：纵向扫描</h3>\n<ol>\n<li><strong>遍历数组</strong>，<strong>依次比较</strong>每个字符串第1、2、3…个字符</li>\n<li>返回最长前缀：</li>\n</ol>\n<ul>\n<li>若有字符串的第<code>i</code>个字符不同，则<strong>最长公共前缀</strong>的长度为<code>i-1</code></li>\n<li>若字符串的长度小于<code>i</code>，则<strong>最长公共前缀</strong>的长度为<code>i</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">longestCommonPrefix</span><span class=\"hljs-params\">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=strs.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> count=strs[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;count;i++)&#123;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=<span class=\"hljs-number\">1</span>;j&lt;n;j++)&#123;<br>                <span class=\"hljs-keyword\">if</span>( i==strs[j].<span class=\"hljs-built_in\">size</span>() || strs[j][i]!=strs[<span class=\"hljs-number\">0</span>][i])&#123;<br>                    <span class=\"hljs-keyword\">return</span> strs[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">substr</span>(<span class=\"hljs-number\">0</span>,i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> strs[<span class=\"hljs-number\">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"方法三：分治\">方法三：分治</h3>\n<h3 id=\"方法四：二分查找\">方法四：二分查找</h3>\n<h2 id=\"Leetcode-470-用-Rand7-实现-Rand10\">Leetcode 470.用 Rand7() 实现 Rand10()</h2>\n<p><a href=\"https://leetcode.cn/problems/implement-rand10-using-rand7\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e2498296\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e2498296\">\n        <div class=\"fold-arrow\">▶</div> Error Version :x:\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e2498296\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> first,second;<br>        <span class=\"hljs-keyword\">while</span>(first=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">6</span>);<br>        <span class=\"hljs-keyword\">while</span>(second=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">5</span>);<br>        <span class=\"hljs-keyword\">return</span> (first&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>? second:<span class=\"hljs-number\">5</span>+second;<br>&#125;<br></code></pre></td></tr></table></figure><p>该答案第5、6行缺失括号而导致错误！</p><h4 id=\"第一种错误版本\">第一种错误版本</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span>(first=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">6</span>);<br><span class=\"hljs-keyword\">while</span>(second=<span class=\"hljs-built_in\">rand7</span>()&gt;<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure><p>这里由于运算符优先级（比较运算符 &gt; 高于赋值运算符 =），实际执行顺序是：</p><ul><li>先计算<code>rand7()&gt;6</code>的布尔结果（<code>true</code> 或 <code>false</code>，即 1 或 0）</li><li>将这个布尔结果赋值给 <code>first</code> 变量</li><li>循环条件永远是 1 或 0，导致逻辑错误</li></ul><h4 id=\"第二种正确版本\">第二种正确版本</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span>((first=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">6</span>);<br><span class=\"hljs-keyword\">while</span>((second=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">5</span>);<br></code></pre></td></tr></table></figure><ul><li>调用 <code>rand7 ()</code> 生成随机数</li><li>将结果赋值给 <code>first</code> 变量</li><li>检查该值是否大于 6</li></ul>\n        </div>\n      </div>\n    </div>\n<p>这道题的目的是使用<code>rand7()</code>产生10个不同但<strong>概率相等</strong>的数</p>\n<h3 id=\"方法一：拒绝采样\">方法一：拒绝采样</h3>\n<ol>\n<li>首先<strong>生成1-49的均匀随机数</strong>：❗<code>(rand7()-1)*7 + rand7()</code>❗</li>\n<li>拒绝41-49的样本（保持1-40的<strong>均匀分布</strong>）</li>\n<li>对结果取模+1，得到1-10的<strong>均匀随机数</strong></li>\n</ol>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-e761341d\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-e761341d\">\n        <div class=\"fold-arrow\">▶</div> 为什么这样生成采样样本？\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-e761341d\">\n        <div class=\"fold-content\">\n          <p>1.<code>rand7()-1</code>生成 0~6<br>2.<code>(rand7()-1)*7</code>生成 0、7、14、21、28、35、42<br>3.<code>(rand7()-1)*7 + rand7()</code>生成 1~49<br><strong>无重复数字</strong>，每个数字出现的<strong>概率均相同</strong>是1/49</p>\n        </div>\n      </div>\n    </div>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> num;<br>        <span class=\"hljs-keyword\">while</span>((num=(<span class=\"hljs-built_in\">rand7</span>()<span class=\"hljs-number\">-1</span>)*<span class=\"hljs-number\">7</span>+<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">40</span>);<br>        <span class=\"hljs-keyword\">return</span> num%<span class=\"hljs-number\">10</span><span class=\"hljs-number\">+1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"方法二：古典概型\">方法二：古典概型</h3>\n<ol>\n<li>第一次<code>rand7</code>限定[1,6]，<strong>判断奇偶性</strong>，概率是1/2</li>\n<li>第二次<code>rand7</code>限定[1,5]，概率是1/5</li>\n<li>二者结合可以得出10种概率相同的结果</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rand10</span><span class=\"hljs-params\">()</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> first,second;<br>        <span class=\"hljs-keyword\">while</span>((first=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">6</span>);<br>        <span class=\"hljs-keyword\">while</span>((second=<span class=\"hljs-built_in\">rand7</span>())&gt;<span class=\"hljs-number\">5</span>);<br>        <span class=\"hljs-keyword\">return</span> (first&amp;<span class=\"hljs-number\">1</span>)==<span class=\"hljs-number\">1</span>? second:<span class=\"hljs-number\">5</span>+second;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h4 id=\"位运算符\">位运算符</h4>\n<ul>\n<li><strong>按位与（&amp;）</strong>：对两个操作数的每一位进行比较，只有当两位都为 1 时结果对应位才为 1，否则为 0。<br>\n示例：3 &amp; 5（二进制 011 &amp; 101）结果为 1（二进制 001）。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">isOdd</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> x &amp; <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 结果为1则奇数，0则偶数</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>按位或（|）</strong>：对两个操作数的每一位进行比较，只要其中一位为 1，结果对应位就为 1，否则为 0。<br>\n示例：3 | 5（二进制 011 | 101）结果为 7（二进制 111）。</li>\n<li><strong>按位异或（^）</strong>：对两个操作数的每一位进行比较，当两位不同时结果为 1，相同时为 0。<br>\n示例：3 ^ 5（二进制 011 ^ 101）结果为 6（二进制 110）。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">swap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>&amp; a, <span class=\"hljs-type\">int</span>&amp; b)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (a != b) &#123; <span class=\"hljs-comment\">// 避免a和b同地址时出错</span><br>        a = a ^ b; <span class=\"hljs-comment\">// a现在是a^b</span><br>        b = a ^ b; <span class=\"hljs-comment\">// b = (a^b)^b = a</span><br>        a = a ^ b; <span class=\"hljs-comment\">// a = (a^b)^a = b</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>按位非（~）</strong>：对单个操作数的<strong>每一位取反</strong>（0 变 1，1 变 0），是一元运算符。<br>\n示例：~3（二进制 ~011）在 32 位系统中结果为 -4（二进制补码表示）。</li>\n<li><strong>左移（&lt;&lt;）</strong>：将左操作数的<strong>二进制位向左移动指定的位数</strong>，右侧空位补 0。<br>\n示例：3 &lt;&lt; 1（二进制 011 &lt;&lt; 1）结果为 6（二进制 110），相当于<strong>乘以 2 的 n 次方</strong>（n 为移动位数）。</li>\n<li><strong>右移（&gt;&gt;）</strong>：将左操作数的<strong>二进制位向右移动指定的位数</strong>，左侧空位补符号位（正数补 0，负数补 1）。<br>\n示例：6 &gt;&gt; 1（二进制 110 &gt;&gt; 1）结果为 3（二进制 011），相当于<strong>除以 2 的 n 次方</strong>（向下取整）。</li>\n</ul>\n"},{"title":"Leetcode Mistake Collection 2","date":"2025-09-10T04:47:08.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/Leetcode-Mistake-Collection.png?raw=true","category_bar":true,"description":"The article is intended to systematically document the errors I encountered while solving LeetCode problems, along with the corresponding corrective strategies.","math":true,"_content":"\n## Leetcode 160. 相交链表\n\n[原题链接](https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&envId=hash-table)\n\n\n### 方法一：哈希表\n\n遍历ListNodeA，用哈希表存**储链表节点**，再遍历ListNodeB，如果ListNodeB的节点在哈希表中，则返回该节点。\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set <ListNode *> set;\n        while(headA!=nullptr){\n            set.insert(headA);\n            headA=headA->next;\n        }\n        while(headB!=nullptr){\n            if(set.find(headB)!=set.end()){\n                return headB;\n            }\n            headB=headB->next;\n        }\n        return nullptr;\n    }\n};\n```\n### 方法二：双指针\n\n定义两个指针分别指向头节点，同时遍历向后进行遍历，若遍历为nullptr，则将指针指向另一条链表的头节点，直至两指针相遇，或者两个指针都为nullptr。\n\n- 若两链表**相交**\n$$length.A=a+m$$$$length.B=b+m$$\n\n其中a、b分别为**相交前分别独有长度**，m为**两链表相交的长度**对于指针A、B遍历的长度相等：$$a+m+b=b+m+a$$\n\n此时两指针**恰好相遇于两链表交点**\n\n- 若两链表**不相交**\n则两指针将AB均遍历结束，同时指向nullptr。\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA=headA, *pB=headB;\n        while(pA!=pB){\n            pA=pA==nullptr?headB:pA->next;\n            pB=pB==nullptr?headA:pB->next;\n        }\n        return pA;\n    }\n};\n```\n***\n## Leetcode 21. 合并两个有序链表\n\n[原题链接](https://leetcode.cn/problems/merge-two-sorted-lists)\n{%fold into @基础解法 %}\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *dummy=new ListNode(0);\n        ListNode * curr=dummy;\n        ListNode *p1=list1,*p2=list2;\n        while(p1!=nullptr && p2!=nullptr){\n            if(p1->val<=p2->val){\n                curr->next=p1;\n                p1=p1->next;\n            }\n            else{\n                curr->next=p2;\n                p2=p2->next;\n            }\n            curr=curr->next;\n        }\n        if(p1==nullptr){\n            curr->next=p2;\n        }\n        else curr->next=p1;\n        return dummy->next;\n    }\n};\n```\n### Tips : 哑结点\n在链表操作中，很多操作都依赖于**当前节点的前驱节点**来完成，而头节点没有前驱节点，因此需要特殊处理。\n\n{%note info%}\n以删除一个节点为例：\n- 对于非头节点：只需找到它的前驱节点`prev`，执行`prev->next = prev->next->next`即可。\n- 对于头节点：由于没有前驱，只能直接修改头指针（`head = head->next`）。\n\n当我们尝试使用对头节点和普通节点**统一逻辑**进行删除：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    ListNode* current = head;\n    \n    while (current != nullptr) {\n        // 尝试用统一逻辑：检查下一个节点\n        if (current->next != nullptr && current->next->val == val) {\n            current->next = current->next->next; // 删除下一个节点\n        } else {\n            current = current->next;\n        }\n    }\n    return head; // 问题：如果头节点要被删除，这里无法处理！\n}\n```\n#### 方法一：常规方法\n采用头节点特殊的显式处理：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    // 特别处理1：先处理所有需要删除的头节点\n    while (head != nullptr && head->val == val) {\n        head = head->next; // 直接移动头指针\n    }\n    \n    // 特别处理2：如果链表为空，直接返回\n    if (head == nullptr) return nullptr;\n    \n    // 然后用统一逻辑处理后续节点\n    ListNode* current = head;\n    while (current->next != nullptr) {\n        if (current->next->val == val) {\n            current->next = current->next->next;\n        } else {\n            current = current->next;\n        }\n    }\n    \n    return head;\n}\n```\n#### 方法二：使用哨兵节点（统一逻辑）：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    // 创建哨兵节点，让头节点也有\"前驱\"\n    ListNode* dummy = new ListNode(0);\n    dummy->next = head;\n    \n    ListNode* current = dummy;\n    \n    // 现在可以用统一逻辑处理所有节点\n    while (current->next != nullptr) {\n        if (current->next->val == val) {\n            current->next = current->next->next;\n        } else {\n            current = current->next;\n        }\n    }\n    \n    return dummy->next; // 返回新的头节点\n}\n```\n{%endnote%}\n\n这时我们就可以采用**哑结点**来简化边界情况的处理，哑结点是一个不存储实际数据的**特殊节点**，通常作为链表的\"**虚拟头节点**\" 存在，它的**next指针指向真正的头节点**：\n\n```cpp\nListNode *dummy=new ListNode(0);  //这里初始化取值无意义\ndummy->next=head;\n ListNode* result = dummy->next;\ndelete dummy; // 释放哑节点的内存\nreturn result;\n```\n{%note danger%}\n:warning: 注意事项:\n- 哑结点是**临时的辅助节点**，最后需要**释放内存**（避免内存泄漏）\n- 操作完成后，**真正的头节点**是`dummy->next`    \n{%endnote%}\n\n{%endfold%}\n\n### 方法一：递归\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if(list1==nullptr){\n            return list2;\n        }\n        else if(list2==nullptr){\n            return list1;\n        }\n        else if(list1->val<list2->val){\n            list1->next=mergeTwoLists(list1->next,list2);\n            return list1;\n        }\n        else{\n            list2->next=mergeTwoLists(list1,list2->next);\n            return list2;\n        }\n    }\n};\n```\n### 方法二：迭代（本质是常规解法）\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *prehead=new ListNode(-1);\n        ListNode *pre=prehead;\n        while(list1!=nullptr && list2!=nullptr){\n            if(list1->val<=list2->val){\n                pre->next=list1;\n                list1=list1->next;\n            }\n            else {\n                pre->next=list2;\n                list2=list2->next;\n            }\n            pre=pre->next;\n        }\n        pre->next=list1==nullptr?list2:list1;\n        return prehead->next;\n    }\n};\n```\n\n***\n## Leetcode 53. 最大子数组和\n[原题链接](https://leetcode.cn/problems/maximum-subarray)\n{%fold into @常规解法Time Error %}\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n=nums.size();\n        int max=-100000;\n        for(int i=0;i<n;i++){\n            int sum=0;\n            for(int j=i;j<n;j++){\n                sum+=nums[j];\n                if(sum>max){\n                    max=sum;\n                }\n            }\n        }\n        return max;\n    }\n};\n```\n{%endfold%}\n\n### 方法一：动态规划\n我们维护一个函数`f(i)`，表示以第`i`个数结尾的**最大子数组和**，那么显然我们就是要求`f(i)`的最大值：\n$$max_{i=1}^n f(i)$$\n\n而`f(i)`仅仅与`f(i-1)`有关，取`f(i-1)+nums[i]`和`nums[i]`中的最大值，写出动态规划状态转移方程，即：\n$$f(i)=max(f(i-1)+nums[i],nums[i])$$\n\n然而还可以进行优化，我们无需显式的表示出`f(i)`，采用“滚动数组”的思想，只需要用一个变量`pre`来维护前`i-1`个`f(x)`的最大值即可。\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxAns=nums[0],pre=0;\n        for(const auto& it:nums){\n            pre=max(pre+it,it);\n            maxAns=max(maxAns,pre);\n        }\n        return maxAns;\n    }\n};\n```\n","source":"_posts/Leetcode-Collection/Leetcode-Mistake-Collection-2.md","raw":"---\ntitle: Leetcode Mistake Collection 2\ndate: 2025-09-10 12:47:08\ntags: [Leetcode,updating]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/Leetcode-Mistake-Collection.png?raw=true\ncategory: Leetcode Mistake Collection\ncategory_bar: true\ndescription: The article is intended to systematically document the errors I encountered while solving LeetCode problems, along with the corresponding corrective strategies.\nmath: true\n---\n\n## Leetcode 160. 相交链表\n\n[原题链接](https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&envId=hash-table)\n\n\n### 方法一：哈希表\n\n遍历ListNodeA，用哈希表存**储链表节点**，再遍历ListNodeB，如果ListNodeB的节点在哈希表中，则返回该节点。\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        unordered_set <ListNode *> set;\n        while(headA!=nullptr){\n            set.insert(headA);\n            headA=headA->next;\n        }\n        while(headB!=nullptr){\n            if(set.find(headB)!=set.end()){\n                return headB;\n            }\n            headB=headB->next;\n        }\n        return nullptr;\n    }\n};\n```\n### 方法二：双指针\n\n定义两个指针分别指向头节点，同时遍历向后进行遍历，若遍历为nullptr，则将指针指向另一条链表的头节点，直至两指针相遇，或者两个指针都为nullptr。\n\n- 若两链表**相交**\n$$length.A=a+m$$$$length.B=b+m$$\n\n其中a、b分别为**相交前分别独有长度**，m为**两链表相交的长度**对于指针A、B遍历的长度相等：$$a+m+b=b+m+a$$\n\n此时两指针**恰好相遇于两链表交点**\n\n- 若两链表**不相交**\n则两指针将AB均遍历结束，同时指向nullptr。\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA=headA, *pB=headB;\n        while(pA!=pB){\n            pA=pA==nullptr?headB:pA->next;\n            pB=pB==nullptr?headA:pB->next;\n        }\n        return pA;\n    }\n};\n```\n***\n## Leetcode 21. 合并两个有序链表\n\n[原题链接](https://leetcode.cn/problems/merge-two-sorted-lists)\n{%fold into @基础解法 %}\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *dummy=new ListNode(0);\n        ListNode * curr=dummy;\n        ListNode *p1=list1,*p2=list2;\n        while(p1!=nullptr && p2!=nullptr){\n            if(p1->val<=p2->val){\n                curr->next=p1;\n                p1=p1->next;\n            }\n            else{\n                curr->next=p2;\n                p2=p2->next;\n            }\n            curr=curr->next;\n        }\n        if(p1==nullptr){\n            curr->next=p2;\n        }\n        else curr->next=p1;\n        return dummy->next;\n    }\n};\n```\n### Tips : 哑结点\n在链表操作中，很多操作都依赖于**当前节点的前驱节点**来完成，而头节点没有前驱节点，因此需要特殊处理。\n\n{%note info%}\n以删除一个节点为例：\n- 对于非头节点：只需找到它的前驱节点`prev`，执行`prev->next = prev->next->next`即可。\n- 对于头节点：由于没有前驱，只能直接修改头指针（`head = head->next`）。\n\n当我们尝试使用对头节点和普通节点**统一逻辑**进行删除：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    ListNode* current = head;\n    \n    while (current != nullptr) {\n        // 尝试用统一逻辑：检查下一个节点\n        if (current->next != nullptr && current->next->val == val) {\n            current->next = current->next->next; // 删除下一个节点\n        } else {\n            current = current->next;\n        }\n    }\n    return head; // 问题：如果头节点要被删除，这里无法处理！\n}\n```\n#### 方法一：常规方法\n采用头节点特殊的显式处理：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    // 特别处理1：先处理所有需要删除的头节点\n    while (head != nullptr && head->val == val) {\n        head = head->next; // 直接移动头指针\n    }\n    \n    // 特别处理2：如果链表为空，直接返回\n    if (head == nullptr) return nullptr;\n    \n    // 然后用统一逻辑处理后续节点\n    ListNode* current = head;\n    while (current->next != nullptr) {\n        if (current->next->val == val) {\n            current->next = current->next->next;\n        } else {\n            current = current->next;\n        }\n    }\n    \n    return head;\n}\n```\n#### 方法二：使用哨兵节点（统一逻辑）：\n```cpp\nListNode* removeElements(ListNode* head, int val) {\n    // 创建哨兵节点，让头节点也有\"前驱\"\n    ListNode* dummy = new ListNode(0);\n    dummy->next = head;\n    \n    ListNode* current = dummy;\n    \n    // 现在可以用统一逻辑处理所有节点\n    while (current->next != nullptr) {\n        if (current->next->val == val) {\n            current->next = current->next->next;\n        } else {\n            current = current->next;\n        }\n    }\n    \n    return dummy->next; // 返回新的头节点\n}\n```\n{%endnote%}\n\n这时我们就可以采用**哑结点**来简化边界情况的处理，哑结点是一个不存储实际数据的**特殊节点**，通常作为链表的\"**虚拟头节点**\" 存在，它的**next指针指向真正的头节点**：\n\n```cpp\nListNode *dummy=new ListNode(0);  //这里初始化取值无意义\ndummy->next=head;\n ListNode* result = dummy->next;\ndelete dummy; // 释放哑节点的内存\nreturn result;\n```\n{%note danger%}\n:warning: 注意事项:\n- 哑结点是**临时的辅助节点**，最后需要**释放内存**（避免内存泄漏）\n- 操作完成后，**真正的头节点**是`dummy->next`    \n{%endnote%}\n\n{%endfold%}\n\n### 方法一：递归\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if(list1==nullptr){\n            return list2;\n        }\n        else if(list2==nullptr){\n            return list1;\n        }\n        else if(list1->val<list2->val){\n            list1->next=mergeTwoLists(list1->next,list2);\n            return list1;\n        }\n        else{\n            list2->next=mergeTwoLists(list1,list2->next);\n            return list2;\n        }\n    }\n};\n```\n### 方法二：迭代（本质是常规解法）\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *prehead=new ListNode(-1);\n        ListNode *pre=prehead;\n        while(list1!=nullptr && list2!=nullptr){\n            if(list1->val<=list2->val){\n                pre->next=list1;\n                list1=list1->next;\n            }\n            else {\n                pre->next=list2;\n                list2=list2->next;\n            }\n            pre=pre->next;\n        }\n        pre->next=list1==nullptr?list2:list1;\n        return prehead->next;\n    }\n};\n```\n\n***\n## Leetcode 53. 最大子数组和\n[原题链接](https://leetcode.cn/problems/maximum-subarray)\n{%fold into @常规解法Time Error %}\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n=nums.size();\n        int max=-100000;\n        for(int i=0;i<n;i++){\n            int sum=0;\n            for(int j=i;j<n;j++){\n                sum+=nums[j];\n                if(sum>max){\n                    max=sum;\n                }\n            }\n        }\n        return max;\n    }\n};\n```\n{%endfold%}\n\n### 方法一：动态规划\n我们维护一个函数`f(i)`，表示以第`i`个数结尾的**最大子数组和**，那么显然我们就是要求`f(i)`的最大值：\n$$max_{i=1}^n f(i)$$\n\n而`f(i)`仅仅与`f(i-1)`有关，取`f(i-1)+nums[i]`和`nums[i]`中的最大值，写出动态规划状态转移方程，即：\n$$f(i)=max(f(i-1)+nums[i],nums[i])$$\n\n然而还可以进行优化，我们无需显式的表示出`f(i)`，采用“滚动数组”的思想，只需要用一个变量`pre`来维护前`i-1`个`f(x)`的最大值即可。\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int maxAns=nums[0],pre=0;\n        for(const auto& it:nums){\n            pre=max(pre+it,it);\n            maxAns=max(maxAns,pre);\n        }\n        return maxAns;\n    }\n};\n```\n","slug":"Leetcode-Collection/Leetcode-Mistake-Collection-2","published":1,"updated":"2025-09-13T08:37:11.465Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hct002740w3448wesxq","content":"<h2 id=\"Leetcode-160-相交链表\">Leetcode 160. 相交链表</h2>\n<p><a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&amp;envId=hash-table\">原题链接</a></p>\n<h3 id=\"方法一：哈希表\">方法一：哈希表</h3>\n<p>遍历ListNodeA，用哈希表存<strong>储链表节点</strong>，再遍历ListNodeB，如果ListNodeB的节点在哈希表中，则返回该节点。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode *<span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(ListNode *headA, ListNode *headB)</span> </span>{<br>        unordered_set &lt;ListNode *&gt; set;<br>        <span class=\"hljs-keyword\">while</span>(headA!=<span class=\"hljs-literal\">nullptr</span>){<br>            set.<span class=\"hljs-built_in\">insert</span>(headA);<br>            headA=headA-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">while</span>(headB!=<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">if</span>(set.<span class=\"hljs-built_in\">find</span>(headB)!=set.<span class=\"hljs-built_in\">end</span>()){<br>                <span class=\"hljs-keyword\">return</span> headB;<br>            }<br>            headB=headB-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"方法二：双指针\">方法二：双指针</h3>\n<p>定义两个指针分别指向头节点，同时遍历向后进行遍历，若遍历为nullptr，则将指针指向另一条链表的头节点，直至两指针相遇，或者两个指针都为nullptr。</p>\n<ul>\n<li>若两链表<strong>相交</strong><br>\n$$length.A=a+m$$$$length.B=b+m$$</li>\n</ul>\n<p>其中a、b分别为<strong>相交前分别独有长度</strong>，m为<strong>两链表相交的长度</strong>对于指针A、B遍历的长度相等：$$a+m+b=b+m+a$$</p>\n<p>此时两指针<strong>恰好相遇于两链表交点</strong></p>\n<ul>\n<li>若两链表<strong>不相交</strong><br>\n则两指针将AB均遍历结束，同时指向nullptr。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode *<span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(ListNode *headA, ListNode *headB)</span> </span>{<br>        ListNode *pA=headA, *pB=headB;<br>        <span class=\"hljs-keyword\">while</span>(pA!=pB){<br>            pA=pA==<span class=\"hljs-literal\">nullptr</span>?headB:pA-&gt;next;<br>            pB=pB==<span class=\"hljs-literal\">nullptr</span>?headA:pB-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">return</span> pA;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h2 id=\"Leetcode-21-合并两个有序链表\">Leetcode 21. 合并两个有序链表</h2>\n<p><a href=\"https://leetcode.cn/problems/merge-two-sorted-lists\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-3b7ab7e6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-3b7ab7e6\">\n        <div class=\"fold-arrow\">▶</div>基础解法\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-3b7ab7e6\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>{<br>        ListNode *dummy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);<br>        ListNode * curr=dummy;<br>        ListNode *p1=list1,*p2=list2;<br>        <span class=\"hljs-keyword\">while</span>(p1!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; p2!=<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">if</span>(p1-&gt;val&lt;=p2-&gt;val){<br>                curr-&gt;next=p1;<br>                p1=p1-&gt;next;<br>            }<br>            <span class=\"hljs-keyword\">else</span>{<br>                curr-&gt;next=p2;<br>                p2=p2-&gt;next;<br>            }<br>            curr=curr-&gt;next;<br>        }<br>        <span class=\"hljs-keyword\">if</span>(p1==<span class=\"hljs-literal\">nullptr</span>){<br>            curr-&gt;next=p2;<br>        }<br>        <span class=\"hljs-keyword\">else</span> curr-&gt;next=p1;<br>        <span class=\"hljs-keyword\">return</span> dummy-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure><h3 id=\"Tips-哑结点\">Tips : 哑结点</h3><p>在链表操作中，很多操作都依赖于<strong>当前节点的前驱节点</strong>来完成，而头节点没有前驱节点，因此需要特殊处理。</p><div class=\"note note-info\">            <p>以删除一个节点为例：</p><ul><li>对于非头节点：只需找到它的前驱节点<code>prev</code>，执行<code>prev-&gt;next = prev-&gt;next-&gt;next</code>即可。</li><li>对于头节点：由于没有前驱，只能直接修改头指针（<code>head = head-&gt;next</code>）。</li></ul><p>当我们尝试使用对头节点和普通节点<strong>统一逻辑</strong>进行删除：</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>{<br>    ListNode* current = head;<br>    <br>    <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">nullptr</span>) {<br>        <span class=\"hljs-comment\">// 尝试用统一逻辑：检查下一个节点</span><br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; current-&gt;next-&gt;val == val) {<br>            current-&gt;next = current-&gt;next-&gt;next; <span class=\"hljs-comment\">// 删除下一个节点</span><br>        } <span class=\"hljs-keyword\">else</span> {<br>            current = current-&gt;next;<br>        }<br>    }<br>    <span class=\"hljs-keyword\">return</span> head; <span class=\"hljs-comment\">// 问题：如果头节点要被删除，这里无法处理！</span><br>}<br></code></pre></td></tr></tbody></table></figure><h4 id=\"方法一：常规方法\">方法一：常规方法</h4><p>采用头节点特殊的显式处理：</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>{<br>    <span class=\"hljs-comment\">// 特别处理1：先处理所有需要删除的头节点</span><br>    <span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; head-&gt;val == val) {<br>        head = head-&gt;next; <span class=\"hljs-comment\">// 直接移动头指针</span><br>    }<br>    <br>    <span class=\"hljs-comment\">// 特别处理2：如果链表为空，直接返回</span><br>    <span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    <br>    <span class=\"hljs-comment\">// 然后用统一逻辑处理后续节点</span><br>    ListNode* current = head;<br>    <span class=\"hljs-keyword\">while</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span>) {<br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next-&gt;val == val) {<br>            current-&gt;next = current-&gt;next-&gt;next;<br>        } <span class=\"hljs-keyword\">else</span> {<br>            current = current-&gt;next;<br>        }<br>    }<br>    <br>    <span class=\"hljs-keyword\">return</span> head;<br>}<br></code></pre></td></tr></tbody></table></figure><h4 id=\"方法二：使用哨兵节点（统一逻辑）：\">方法二：使用哨兵节点（统一逻辑）：</h4><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>{<br>    <span class=\"hljs-comment\">// 创建哨兵节点，让头节点也有\"前驱\"</span><br>    ListNode* dummy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);<br>    dummy-&gt;next = head;<br>    <br>    ListNode* current = dummy;<br>    <br>    <span class=\"hljs-comment\">// 现在可以用统一逻辑处理所有节点</span><br>    <span class=\"hljs-keyword\">while</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span>) {<br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next-&gt;val == val) {<br>            current-&gt;next = current-&gt;next-&gt;next;<br>        } <span class=\"hljs-keyword\">else</span> {<br>            current = current-&gt;next;<br>        }<br>    }<br>    <br>    <span class=\"hljs-keyword\">return</span> dummy-&gt;next; <span class=\"hljs-comment\">// 返回新的头节点</span><br>}<br></code></pre></td></tr></tbody></table></figure>          </div><p>这时我们就可以采用<strong>哑结点</strong>来简化边界情况的处理，哑结点是一个不存储实际数据的<strong>特殊节点</strong>，通常作为链表的\"<strong>虚拟头节点</strong>\" 存在，它的<strong>next指针指向真正的头节点</strong>：</p><figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ListNode *dummy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">//这里初始化取值无意义</span><br>dummy-&gt;next=head;<br> ListNode* result = dummy-&gt;next;<br><span class=\"hljs-keyword\">delete</span> dummy; <span class=\"hljs-comment\">// 释放哑节点的内存</span><br><span class=\"hljs-keyword\">return</span> result;<br></code></pre></td></tr></tbody></table></figure><div class=\"note note-danger\">            <p>⚠️ 注意事项:</p><ul><li>哑结点是<strong>临时的辅助节点</strong>，最后需要<strong>释放内存</strong>（避免内存泄漏）</li><li>操作完成后，<strong>真正的头节点</strong>是<code>dummy-&gt;next</code></li></ul>          </div>\n        </div>\n      </div>\n    </div>\n<h3 id=\"方法一：递归\">方法一：递归</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>{<br>        <span class=\"hljs-keyword\">if</span>(list1==<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">return</span> list2;<br>        }<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(list2==<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">return</span> list1;<br>        }<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(list1-&gt;val&lt;list2-&gt;val){<br>            list1-&gt;next=<span class=\"hljs-built_in\">mergeTwoLists</span>(list1-&gt;next,list2);<br>            <span class=\"hljs-keyword\">return</span> list1;<br>        }<br>        <span class=\"hljs-keyword\">else</span>{<br>            list2-&gt;next=<span class=\"hljs-built_in\">mergeTwoLists</span>(list1,list2-&gt;next);<br>            <span class=\"hljs-keyword\">return</span> list2;<br>        }<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"方法二：迭代（本质是常规解法）\">方法二：迭代（本质是常规解法）</h3>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>{<br>        ListNode *prehead=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">-1</span>);<br>        ListNode *pre=prehead;<br>        <span class=\"hljs-keyword\">while</span>(list1!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; list2!=<span class=\"hljs-literal\">nullptr</span>){<br>            <span class=\"hljs-keyword\">if</span>(list1-&gt;val&lt;=list2-&gt;val){<br>                pre-&gt;next=list1;<br>                list1=list1-&gt;next;<br>            }<br>            <span class=\"hljs-keyword\">else</span> {<br>                pre-&gt;next=list2;<br>                list2=list2-&gt;next;<br>            }<br>            pre=pre-&gt;next;<br>        }<br>        pre-&gt;next=list1==<span class=\"hljs-literal\">nullptr</span>?list2:list1;<br>        <span class=\"hljs-keyword\">return</span> prehead-&gt;next;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n<hr>\n<h2 id=\"Leetcode-53-最大子数组和\">Leetcode 53. 最大子数组和</h2>\n<p><a href=\"https://leetcode.cn/problems/maximum-subarray\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8bbf6858\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8bbf6858\">\n        <div class=\"fold-arrow\">▶</div>常规解法Time Error\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8bbf6858\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> max=<span class=\"hljs-number\">-100000</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++){<br>            <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;n;j++){<br>                sum+=nums[j];<br>                <span class=\"hljs-keyword\">if</span>(sum&gt;max){<br>                    max=sum;<br>                }<br>            }<br>        }<br>        <span class=\"hljs-keyword\">return</span> max;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"方法一：动态规划\">方法一：动态规划</h3>\n<p>我们维护一个函数<code>f(i)</code>，表示以第<code>i</code>个数结尾的<strong>最大子数组和</strong>，那么显然我们就是要求<code>f(i)</code>的最大值：<br>\n$$max_{i=1}^n f(i)$$</p>\n<p>而<code>f(i)</code>仅仅与<code>f(i-1)</code>有关，取<code>f(i-1)+nums[i]</code>和<code>nums[i]</code>中的最大值，写出动态规划状态转移方程，即：<br>\n$$f(i)=max(f(i-1)+nums[i],nums[i])$$</p>\n<p>然而还可以进行优化，我们无需显式的表示出<code>f(i)</code>，采用“滚动数组”的思想，只需要用一个变量<code>pre</code>来维护前<code>i-1</code>个<code>f(x)</code>的最大值即可。</p>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> {<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>{<br>        <span class=\"hljs-type\">int</span> maxAns=nums[<span class=\"hljs-number\">0</span>],pre=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; it:nums){<br>            pre=<span class=\"hljs-built_in\">max</span>(pre+it,it);<br>            maxAns=<span class=\"hljs-built_in\">max</span>(maxAns,pre);<br>        }<br>        <span class=\"hljs-keyword\">return</span> maxAns;<br>    }<br>};<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<h2 id=\"Leetcode-160-相交链表\">Leetcode 160. 相交链表</h2>\n<p><a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&amp;envId=hash-table\">原题链接</a></p>\n<h3 id=\"方法一：哈希表\">方法一：哈希表</h3>\n<p>遍历ListNodeA，用哈希表存<strong>储链表节点</strong>，再遍历ListNodeB，如果ListNodeB的节点在哈希表中，则返回该节点。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode *<span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        unordered_set &lt;ListNode *&gt; set;<br>        <span class=\"hljs-keyword\">while</span>(headA!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            set.<span class=\"hljs-built_in\">insert</span>(headA);<br>            headA=headA-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">while</span>(headB!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(set.<span class=\"hljs-built_in\">find</span>(headB)!=set.<span class=\"hljs-built_in\">end</span>())&#123;<br>                <span class=\"hljs-keyword\">return</span> headB;<br>            &#125;<br>            headB=headB-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"方法二：双指针\">方法二：双指针</h3>\n<p>定义两个指针分别指向头节点，同时遍历向后进行遍历，若遍历为nullptr，则将指针指向另一条链表的头节点，直至两指针相遇，或者两个指针都为nullptr。</p>\n<ul>\n<li>若两链表<strong>相交</strong><br>\n$$length.A=a+m$$$$length.B=b+m$$</li>\n</ul>\n<p>其中a、b分别为<strong>相交前分别独有长度</strong>，m为<strong>两链表相交的长度</strong>对于指针A、B遍历的长度相等：$$a+m+b=b+m+a$$</p>\n<p>此时两指针<strong>恰好相遇于两链表交点</strong></p>\n<ul>\n<li>若两链表<strong>不相交</strong><br>\n则两指针将AB均遍历结束，同时指向nullptr。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode *<span class=\"hljs-title\">getIntersectionNode</span><span class=\"hljs-params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode *pA=headA, *pB=headB;<br>        <span class=\"hljs-keyword\">while</span>(pA!=pB)&#123;<br>            pA=pA==<span class=\"hljs-literal\">nullptr</span>?headB:pA-&gt;next;<br>            pB=pB==<span class=\"hljs-literal\">nullptr</span>?headA:pB-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"Leetcode-21-合并两个有序链表\">Leetcode 21. 合并两个有序链表</h2>\n<p><a href=\"https://leetcode.cn/problems/merge-two-sorted-lists\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-3b7ab7e6\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-3b7ab7e6\">\n        <div class=\"fold-arrow\">▶</div>基础解法\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-3b7ab7e6\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *dummy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);<br>        ListNode * curr=dummy;<br>        ListNode *p1=list1,*p2=list2;<br>        <span class=\"hljs-keyword\">while</span>(p1!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; p2!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(p1-&gt;val&lt;=p2-&gt;val)&#123;<br>                curr-&gt;next=p1;<br>                p1=p1-&gt;next;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span>&#123;<br>                curr-&gt;next=p2;<br>                p2=p2-&gt;next;<br>            &#125;<br>            curr=curr-&gt;next;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span>(p1==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            curr-&gt;next=p2;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> curr-&gt;next=p1;<br>        <span class=\"hljs-keyword\">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id=\"Tips-哑结点\">Tips : 哑结点</h3><p>在链表操作中，很多操作都依赖于<strong>当前节点的前驱节点</strong>来完成，而头节点没有前驱节点，因此需要特殊处理。</p><div class=\"note note-info\">            <p>以删除一个节点为例：</p><ul><li>对于非头节点：只需找到它的前驱节点<code>prev</code>，执行<code>prev-&gt;next = prev-&gt;next-&gt;next</code>即可。</li><li>对于头节点：由于没有前驱，只能直接修改头指针（<code>head = head-&gt;next</code>）。</li></ul><p>当我们尝试使用对头节点和普通节点<strong>统一逻辑</strong>进行删除：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>    ListNode* current = head;<br>    <br>    <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-comment\">// 尝试用统一逻辑：检查下一个节点</span><br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; current-&gt;next-&gt;val == val) &#123;<br>            current-&gt;next = current-&gt;next-&gt;next; <span class=\"hljs-comment\">// 删除下一个节点</span><br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            current = current-&gt;next;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> head; <span class=\"hljs-comment\">// 问题：如果头节点要被删除，这里无法处理！</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id=\"方法一：常规方法\">方法一：常规方法</h4><p>采用头节点特殊的显式处理：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 特别处理1：先处理所有需要删除的头节点</span><br>    <span class=\"hljs-keyword\">while</span> (head != <span class=\"hljs-literal\">nullptr</span> &amp;&amp; head-&gt;val == val) &#123;<br>        head = head-&gt;next; <span class=\"hljs-comment\">// 直接移动头指针</span><br>    &#125;<br>    <br>    <span class=\"hljs-comment\">// 特别处理2：如果链表为空，直接返回</span><br>    <span class=\"hljs-keyword\">if</span> (head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    <br>    <span class=\"hljs-comment\">// 然后用统一逻辑处理后续节点</span><br>    ListNode* current = head;<br>    <span class=\"hljs-keyword\">while</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next-&gt;val == val) &#123;<br>            current-&gt;next = current-&gt;next-&gt;next;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            current = current-&gt;next;<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=\"方法二：使用哨兵节点（统一逻辑）：\">方法二：使用哨兵节点（统一逻辑）：</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">removeElements</span><span class=\"hljs-params\">(ListNode* head, <span class=\"hljs-type\">int</span> val)</span> </span>&#123;<br>    <span class=\"hljs-comment\">// 创建哨兵节点，让头节点也有&quot;前驱&quot;</span><br>    ListNode* dummy = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);<br>    dummy-&gt;next = head;<br>    <br>    ListNode* current = dummy;<br>    <br>    <span class=\"hljs-comment\">// 现在可以用统一逻辑处理所有节点</span><br>    <span class=\"hljs-keyword\">while</span> (current-&gt;next != <span class=\"hljs-literal\">nullptr</span>) &#123;<br>        <span class=\"hljs-keyword\">if</span> (current-&gt;next-&gt;val == val) &#123;<br>            current-&gt;next = current-&gt;next-&gt;next;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            current = current-&gt;next;<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> dummy-&gt;next; <span class=\"hljs-comment\">// 返回新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure>          </div><p>这时我们就可以采用<strong>哑结点</strong>来简化边界情况的处理，哑结点是一个不存储实际数据的<strong>特殊节点</strong>，通常作为链表的&quot;<strong>虚拟头节点</strong>&quot; 存在，它的<strong>next指针指向真正的头节点</strong>：</p><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\">ListNode *dummy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">//这里初始化取值无意义</span><br>dummy-&gt;next=head;<br> ListNode* result = dummy-&gt;next;<br><span class=\"hljs-keyword\">delete</span> dummy; <span class=\"hljs-comment\">// 释放哑节点的内存</span><br><span class=\"hljs-keyword\">return</span> result;<br></code></pre></td></tr></table></figure><div class=\"note note-danger\">            <p>⚠️ 注意事项:</p><ul><li>哑结点是<strong>临时的辅助节点</strong>，最后需要<strong>释放内存</strong>（避免内存泄漏）</li><li>操作完成后，<strong>真正的头节点</strong>是<code>dummy-&gt;next</code></li></ul>          </div>\n        </div>\n      </div>\n    </div>\n<h3 id=\"方法一：递归\">方法一：递归</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(list1==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> list2;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(list2==<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> list1;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(list1-&gt;val&lt;list2-&gt;val)&#123;<br>            list1-&gt;next=<span class=\"hljs-built_in\">mergeTwoLists</span>(list1-&gt;next,list2);<br>            <span class=\"hljs-keyword\">return</span> list1;<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>            list2-&gt;next=<span class=\"hljs-built_in\">mergeTwoLists</span>(list1,list2-&gt;next);<br>            <span class=\"hljs-keyword\">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"方法二：迭代（本质是常规解法）\">方法二：迭代（本质是常规解法）</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\">ListNode* <span class=\"hljs-title\">mergeTwoLists</span><span class=\"hljs-params\">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode *prehead=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ListNode</span>(<span class=\"hljs-number\">-1</span>);<br>        ListNode *pre=prehead;<br>        <span class=\"hljs-keyword\">while</span>(list1!=<span class=\"hljs-literal\">nullptr</span> &amp;&amp; list2!=<span class=\"hljs-literal\">nullptr</span>)&#123;<br>            <span class=\"hljs-keyword\">if</span>(list1-&gt;val&lt;=list2-&gt;val)&#123;<br>                pre-&gt;next=list1;<br>                list1=list1-&gt;next;<br>            &#125;<br>            <span class=\"hljs-keyword\">else</span> &#123;<br>                pre-&gt;next=list2;<br>                list2=list2-&gt;next;<br>            &#125;<br>            pre=pre-&gt;next;<br>        &#125;<br>        pre-&gt;next=list1==<span class=\"hljs-literal\">nullptr</span>?list2:list1;<br>        <span class=\"hljs-keyword\">return</span> prehead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"Leetcode-53-最大子数组和\">Leetcode 53. 最大子数组和</h2>\n<p><a href=\"https://leetcode.cn/problems/maximum-subarray\">原题链接</a></p>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-8bbf6858\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-8bbf6858\">\n        <div class=\"fold-arrow\">▶</div>常规解法Time Error\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-8bbf6858\">\n        <div class=\"fold-content\">\n          <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> n=nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-type\">int</span> max=<span class=\"hljs-number\">-100000</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;n;i++)&#123;<br>            <span class=\"hljs-type\">int</span> sum=<span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j=i;j&lt;n;j++)&#123;<br>                sum+=nums[j];<br>                <span class=\"hljs-keyword\">if</span>(sum&gt;max)&#123;<br>                    max=sum;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n        </div>\n      </div>\n    </div>\n<h3 id=\"方法一：动态规划\">方法一：动态规划</h3>\n<p>我们维护一个函数<code>f(i)</code>，表示以第<code>i</code>个数结尾的<strong>最大子数组和</strong>，那么显然我们就是要求<code>f(i)</code>的最大值：<br>\n$$max_{i=1}^n f(i)$$</p>\n<p>而<code>f(i)</code>仅仅与<code>f(i-1)</code>有关，取<code>f(i-1)+nums[i]</code>和<code>nums[i]</code>中的最大值，写出动态规划状态转移方程，即：<br>\n$$f(i)=max(f(i-1)+nums[i],nums[i])$$</p>\n<p>然而还可以进行优化，我们无需显式的表示出<code>f(i)</code>，采用“滚动数组”的思想，只需要用一个变量<code>pre</code>来维护前<code>i-1</code>个<code>f(x)</code>的最大值即可。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">maxSubArray</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class=\"hljs-type\">int</span> maxAns=nums[<span class=\"hljs-number\">0</span>],pre=<span class=\"hljs-number\">0</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">auto</span>&amp; it:nums)&#123;<br>            pre=<span class=\"hljs-built_in\">max</span>(pre+it,it);<br>            maxAns=<span class=\"hljs-built_in\">max</span>(maxAns,pre);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> maxAns;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n"},{"title":"From OpenCV to YOLOv5","date":"2025-07-09T10:33:26.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice.png","category_bar":true,"description":"This article systematically examines the evolution of object detection technologies from traditional methods to deep learning.","_content":"\n \n # From OpenCV to YOLOv5: Object Detection from Theory to Practice\n{% note primary %}**摘要**：本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，重点对比分析了 **OpenCV级联分类器** 与 **YOLOv5** 的核心原理、技术特点及适用场景。通过深入研究**Haar特征** 与 **卷积神经网络** 的特征提取机制，揭示了两种方法在检测精度、计算效率等方面的本质差异。在实践层面，详细探讨了使用**Labelme**进行**数据标注**的方法论，以及如何利用 **Roboflow** 等平台获取和优化训练数据集。基于上述理论研究，我们将YOLOv5模型部署至 **树莓派嵌入式平台** ，实现了垃圾分类目标检测系统的工程化应用。本研究不仅梳理了目标检测技术的发展脉络，更通过完整的 **\"理论-数据-训练-部署\"** 闭环验证了深度学习人工智能在资源受限设备上的实用价值。{% endnote %}\n\n\n{% note primary %}\n**关键词**：**OpenCV；YOLOv5；目标检测；树莓派**\n{% endnote %}\n\n{% note primary %}\n**引言**：每天清晨，当我们拿起智能手机解锁时，人脸识别功能会瞬间完成身份验证；走进机场安检区，摄像头会自动标记旅客的面部位置；甚至社交软件中的“美颜滤镜”，也需要先精准定位五官。这些看似简单的功能，其实背后都依赖于图像处理的目标检测技术！\n{% endnote %}\n\n&emsp;&emsp;而在早期，这类技术并非基于复杂的深度学习，而是通过OpenCV的级联检测器（如Haar级联）实现的。\n\n### 一、OpenCV中Python 环境搭建\n&emsp;&emsp;Python 环境搭建是实现目标检测的前提基础，而其环境也并不复杂，仅仅是在Python解释器的基础上添加诸如numpy、matplotlib等库即可。\n\n![图1 OpenCV环境搭建所需要的软件包示例](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%871.png)\n\n### 二、OpenCV的级联分类器\n&emsp;&emsp;Haar分类器是一种基于机器学习的目标检测算法，它使用Haar特征描述图像中的目标。Haar特征是基于图像亮度的局部差异计算得出的，可以用来描述目标的边缘、角落和线条等特征。\n&emsp;&emsp;将一系列简单的分类器按照一定的顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。OpenCV提供一些已经训练好的级联分类器，有人脸检测、身形检测、车牌检测等，如下图所示。想要实现哪一种图像检测，在程序启动时加载对应的级联分类器即可。\n\n![图2 OpenCV自带的级联分类器XML文件](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%872.png)\n\n```python\nimport cv2\nimport numpy as np\ndef face_detection(frame):\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\n    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.05, minNeighbors=9, minSize=(30, 30))\n    for (x, y, w, h) in faces:\n        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)\n        cv2.putText(frame, \"Face\", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)\n    return frame\ncap = cv2.VideoCapture(0)\nwhile True:\n    ret, frame = cap.read()\n    result = face_detection(frame)\n    cv2.imshow(\"Face Detection\", result)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 三、调用级联分类器实现检测\n&emsp;&emsp;作为传统机器视觉的AI方法，人脸级联分类器采用提取眼睛区域（上暗下亮）、鼻梁区域（两侧暗中间亮）、嘴巴区域（上唇暗下唇亮）、面部轮廓（与背景的明暗对比）等多个特征的方法进行检测，效果图如下图所示。\n\n![图4 使用OpenCV人脸级联分类器进行人脸检测效果图](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%873.png)\n\n&emsp;&emsp;尽管Haar级联在早期表现出色，但是随着场景扩展，传统方法OpenCV图像处理的弊端逐渐开始显现，级联的方法遇到了瓶颈，其局限性在复杂场景中暴露无遗：\n(1)光照敏感：强光下人脸过曝时，特征对比度消失，导致漏检。\n(2)姿态与遮挡：侧脸或戴口罩时，矩形特征失效，误检率飙升。\n(3)多目标处理困难：需手动调整参数适应不同目标（如猫脸检测需重新训练）。\nHaar级联的失败案例：背光导致检测失败：树叶被误检测为人脸。\n\n&emsp;&emsp;从“人工规则”到“智能学习”，随着OpenCV传统图像处理方法的失宠，一种运用前沿AI——深度学习算法的新目标检测方法应运而生：YOLO算法！YOLOv5的诞生标志着目标检测从人工设计规则转向数据驱动学习，他们有着诸多的不同：\n(1)特征提取的自动化：Haar级联依赖工程师设计的黑白矩形块，而YOLOv5通过训练自动提取更复杂的特征（例如纹理、轮廓、语义信息）。\n(2)全局理解图像：传统方法需滑动窗口逐区域扫描，YOLOv5将图像划分为网格，单次预测所有目标的位置和类别，效率提升百倍。\n### 四、YOLOv5运行环境的搭建\n&emsp;&emsp;这个的步骤可能略显复杂，主要是安装anaconda，为YOLOv5的运行创建虚拟环境，安装cuda，再根据电脑具体配置是否有GPU选择pytorch的版本。\n\n### 五、YOLOv5的运行\n\n![图 5 PC成功调用GPU进行YOLOv5 目标检测](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%875.png)\n\n![图 6 YOLOv5 默认图像的处理结果（1）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%876.png)\n\n![图 7 YOLOv5 默认图像的处理结果（2）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%877.png)\n\n&emsp;&emsp;从OpenCV的“人工经验”到YOLOv5的“数据智能”，目标检测技术实现了质的飞跃。然而，YOLOv5的强大性能离不开高质量的数据支撑，但是现实生活中我们的需求是多样化的，此时我们不满足于仅仅使用YOLOv5默认的数据集进行目标检测，这时我们将深入探讨如何构建专属数据集：\n### 六、用labelme进行数据集的标注[4]\n\n![图 8 使用labelme手动进行数据集标注](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%878.png)\n\n&emsp;&emsp;Labelme确实能够适应特定需求进行数据集的划分了，但是一次的训练需要成百上千张图片，每做一次数据集就需要手动划分这么多，显然效率较低，难以大规模推广使用，于是我们可以通过下载网络平台上的各种标注好数据集进行训练实验。\n### 七、用roboflow下载数据集[5]\n\n![图 9 在Roboflow中寻找合适的数据集](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%879.png)\n\n### 八、对数据集进行训练和测试\n\n![图 10 对数据集进行训练](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8710.png)\n\n![图 11 获取训练好的特征权重文件](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8711.png)\n\n![在图 12 训练所得混淆矩阵](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8712.png)\n\n&emsp;&emsp;列代表预测的类别，行代表实际的类别。其对角线上的值表示预测正确的数量比例，非对角线元素则是预测错误的部分。混淆矩阵的对角线值越高越好，这表明许多预测是正确的。\n\n![图13 训练所得labels](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8713.png)\n\n![图14 训练所得准确率与置信度](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8714.png)\n\n![图15 训练所得](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8715.png)\n\n![图16 个人“手势”数据集测试（1）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8716.png)\n\n![图17 个人“手势”数据集测试（2）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8717.png)\n\n&emsp;&emsp;为了将目标检测技术从理论转化为实际应用，我们决定将YOLOv5模型部署到嵌入式设备中，打造具有实用价值的智能终端。考虑到深度学习算法对计算性能的较高要求，传统的C51、STM32等单片机难以满足运算需求，因此我们选择了性能更为强大的树莓派作为硬件平台，以确保模型能够高效稳定地运行。这一方案不仅提升了系统的实时处理能力，也为后续的功能扩展提供了充足的计算资源保障。\n\n### 九、部署至树莓派装置进行实战检测\n&emsp;&emsp;在系统实现过程中，我们针对树莓派的硬件特性进行了适配性开发。由于树莓派采用CSI摄像头接口，其图像采集方式与PC端的USB摄像头存在差异，为此我们专门优化了图像采集模块的代码架构。同时，通过设计高效的通信协议，实现了树莓派与主控芯片STM32的协同工作。\n\n![图18 在树莓派中配置anaconda](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8718.png)\n\n![图19 在树莓派中配置vscode](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8719.png)\n\n![图20 对树莓派进行调试](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8720.png)\n\n&emsp;&emsp;历经反复的调试，最终完成了基于YOLOv5的智能垃圾分类系统，在自主构建的数据集支持下，能够准确识别多种垃圾类型，并通过机械执行实现自动分类压缩回收，充分展现了人工智能深度学习技术的实用价值！\n\n### 参考文献\n\n[1]陈之尧.基于OpenCV-Python的图像分割技术的设计与应用研究[J].中国新通信,2018,20(19):89.\n[2]明月科技.《Python OpenCV快速从入门到精通》.\n[3][深度学习目标检测：yolov5环境配置，适合0基础小白，超详细-CSDN博客](https://blog.csdn.net/qq_67105081/article/details/138232424?ops_request_misc=%7B%22request_id%22%3A%22b368614c237378c5bf41ba67bb6c3883%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=b368614c237378c5bf41ba67bb6c3883&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-138232424-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=yolov5%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA&spm=1018.2226.3001.4187)\n[4][labelme制作yolov5模型的数据集_labelme yolo-CSDN博客](https://blog.csdn.net/weixin_45736855/article/details/129583272?ops_request_misc=&request_id=&biz_id=102&utm_term=yolov5%E7%9A%84labelme%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129583272.142%5Ev102%5Epc_search_result_base2&spm=1018.2226.3001.4187)\n[5][下载数据集进行yolov5的训练测试_yolov5数据集下载-CSDN博客](https://blog.csdn.net/2401_86849688/article/details/145814831?spm=1001.2014.3001.5501)\n[6][yolov5-runs文件中对train结果的说明_train box loss-CSDN博客](https://blog.csdn.net/qq_45305490/article/details/125219937?ops_request_misc=%7B%22request_id%22%3A%22d18d63f66eeb3c007e4fab2cfbb532b2%22%2C%22scm%22%3A%2220140713.130102334.pc_all.%22%7D&request_id=d18d63f66eeb3c007e4fab2cfbb532b2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125219937-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=yolov5%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84runs%20train&spm=1018.2226.3001.4187)\n[7][将yolov5运用在树莓派上进行目标检测_树莓派yolo5调用摄像头-CSDN博客](https://blog.csdn.net/2401_86849688/article/details/145858990?spm=1001.2014.3001.5501)\n\n","source":"_posts/other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice.md","raw":"---\ntitle: From OpenCV to YOLOv5\ndate: 2025-07-09 18:33:26\ntags: [opencv,yolov5,object detection]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice.png\ncategory_bar: true\ndescription: This article systematically examines the evolution of object detection technologies from traditional methods to deep learning.\n---\n\n \n # From OpenCV to YOLOv5: Object Detection from Theory to Practice\n{% note primary %}**摘要**：本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，重点对比分析了 **OpenCV级联分类器** 与 **YOLOv5** 的核心原理、技术特点及适用场景。通过深入研究**Haar特征** 与 **卷积神经网络** 的特征提取机制，揭示了两种方法在检测精度、计算效率等方面的本质差异。在实践层面，详细探讨了使用**Labelme**进行**数据标注**的方法论，以及如何利用 **Roboflow** 等平台获取和优化训练数据集。基于上述理论研究，我们将YOLOv5模型部署至 **树莓派嵌入式平台** ，实现了垃圾分类目标检测系统的工程化应用。本研究不仅梳理了目标检测技术的发展脉络，更通过完整的 **\"理论-数据-训练-部署\"** 闭环验证了深度学习人工智能在资源受限设备上的实用价值。{% endnote %}\n\n\n{% note primary %}\n**关键词**：**OpenCV；YOLOv5；目标检测；树莓派**\n{% endnote %}\n\n{% note primary %}\n**引言**：每天清晨，当我们拿起智能手机解锁时，人脸识别功能会瞬间完成身份验证；走进机场安检区，摄像头会自动标记旅客的面部位置；甚至社交软件中的“美颜滤镜”，也需要先精准定位五官。这些看似简单的功能，其实背后都依赖于图像处理的目标检测技术！\n{% endnote %}\n\n&emsp;&emsp;而在早期，这类技术并非基于复杂的深度学习，而是通过OpenCV的级联检测器（如Haar级联）实现的。\n\n### 一、OpenCV中Python 环境搭建\n&emsp;&emsp;Python 环境搭建是实现目标检测的前提基础，而其环境也并不复杂，仅仅是在Python解释器的基础上添加诸如numpy、matplotlib等库即可。\n\n![图1 OpenCV环境搭建所需要的软件包示例](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%871.png)\n\n### 二、OpenCV的级联分类器\n&emsp;&emsp;Haar分类器是一种基于机器学习的目标检测算法，它使用Haar特征描述图像中的目标。Haar特征是基于图像亮度的局部差异计算得出的，可以用来描述目标的边缘、角落和线条等特征。\n&emsp;&emsp;将一系列简单的分类器按照一定的顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。OpenCV提供一些已经训练好的级联分类器，有人脸检测、身形检测、车牌检测等，如下图所示。想要实现哪一种图像检测，在程序启动时加载对应的级联分类器即可。\n\n![图2 OpenCV自带的级联分类器XML文件](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%872.png)\n\n```python\nimport cv2\nimport numpy as np\ndef face_detection(frame):\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')\n    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.05, minNeighbors=9, minSize=(30, 30))\n    for (x, y, w, h) in faces:\n        cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)\n        cv2.putText(frame, \"Face\", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)\n    return frame\ncap = cv2.VideoCapture(0)\nwhile True:\n    ret, frame = cap.read()\n    result = face_detection(frame)\n    cv2.imshow(\"Face Detection\", result)\n    if cv2.waitKey(1) & 0xFF == ord('q'):\n        break\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### 三、调用级联分类器实现检测\n&emsp;&emsp;作为传统机器视觉的AI方法，人脸级联分类器采用提取眼睛区域（上暗下亮）、鼻梁区域（两侧暗中间亮）、嘴巴区域（上唇暗下唇亮）、面部轮廓（与背景的明暗对比）等多个特征的方法进行检测，效果图如下图所示。\n\n![图4 使用OpenCV人脸级联分类器进行人脸检测效果图](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%873.png)\n\n&emsp;&emsp;尽管Haar级联在早期表现出色，但是随着场景扩展，传统方法OpenCV图像处理的弊端逐渐开始显现，级联的方法遇到了瓶颈，其局限性在复杂场景中暴露无遗：\n(1)光照敏感：强光下人脸过曝时，特征对比度消失，导致漏检。\n(2)姿态与遮挡：侧脸或戴口罩时，矩形特征失效，误检率飙升。\n(3)多目标处理困难：需手动调整参数适应不同目标（如猫脸检测需重新训练）。\nHaar级联的失败案例：背光导致检测失败：树叶被误检测为人脸。\n\n&emsp;&emsp;从“人工规则”到“智能学习”，随着OpenCV传统图像处理方法的失宠，一种运用前沿AI——深度学习算法的新目标检测方法应运而生：YOLO算法！YOLOv5的诞生标志着目标检测从人工设计规则转向数据驱动学习，他们有着诸多的不同：\n(1)特征提取的自动化：Haar级联依赖工程师设计的黑白矩形块，而YOLOv5通过训练自动提取更复杂的特征（例如纹理、轮廓、语义信息）。\n(2)全局理解图像：传统方法需滑动窗口逐区域扫描，YOLOv5将图像划分为网格，单次预测所有目标的位置和类别，效率提升百倍。\n### 四、YOLOv5运行环境的搭建\n&emsp;&emsp;这个的步骤可能略显复杂，主要是安装anaconda，为YOLOv5的运行创建虚拟环境，安装cuda，再根据电脑具体配置是否有GPU选择pytorch的版本。\n\n### 五、YOLOv5的运行\n\n![图 5 PC成功调用GPU进行YOLOv5 目标检测](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%875.png)\n\n![图 6 YOLOv5 默认图像的处理结果（1）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%876.png)\n\n![图 7 YOLOv5 默认图像的处理结果（2）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%877.png)\n\n&emsp;&emsp;从OpenCV的“人工经验”到YOLOv5的“数据智能”，目标检测技术实现了质的飞跃。然而，YOLOv5的强大性能离不开高质量的数据支撑，但是现实生活中我们的需求是多样化的，此时我们不满足于仅仅使用YOLOv5默认的数据集进行目标检测，这时我们将深入探讨如何构建专属数据集：\n### 六、用labelme进行数据集的标注[4]\n\n![图 8 使用labelme手动进行数据集标注](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%878.png)\n\n&emsp;&emsp;Labelme确实能够适应特定需求进行数据集的划分了，但是一次的训练需要成百上千张图片，每做一次数据集就需要手动划分这么多，显然效率较低，难以大规模推广使用，于是我们可以通过下载网络平台上的各种标注好数据集进行训练实验。\n### 七、用roboflow下载数据集[5]\n\n![图 9 在Roboflow中寻找合适的数据集](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%879.png)\n\n### 八、对数据集进行训练和测试\n\n![图 10 对数据集进行训练](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8710.png)\n\n![图 11 获取训练好的特征权重文件](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8711.png)\n\n![在图 12 训练所得混淆矩阵](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8712.png)\n\n&emsp;&emsp;列代表预测的类别，行代表实际的类别。其对角线上的值表示预测正确的数量比例，非对角线元素则是预测错误的部分。混淆矩阵的对角线值越高越好，这表明许多预测是正确的。\n\n![图13 训练所得labels](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8713.png)\n\n![图14 训练所得准确率与置信度](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8714.png)\n\n![图15 训练所得](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8715.png)\n\n![图16 个人“手势”数据集测试（1）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8716.png)\n\n![图17 个人“手势”数据集测试（2）](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8717.png)\n\n&emsp;&emsp;为了将目标检测技术从理论转化为实际应用，我们决定将YOLOv5模型部署到嵌入式设备中，打造具有实用价值的智能终端。考虑到深度学习算法对计算性能的较高要求，传统的C51、STM32等单片机难以满足运算需求，因此我们选择了性能更为强大的树莓派作为硬件平台，以确保模型能够高效稳定地运行。这一方案不仅提升了系统的实时处理能力，也为后续的功能扩展提供了充足的计算资源保障。\n\n### 九、部署至树莓派装置进行实战检测\n&emsp;&emsp;在系统实现过程中，我们针对树莓派的硬件特性进行了适配性开发。由于树莓派采用CSI摄像头接口，其图像采集方式与PC端的USB摄像头存在差异，为此我们专门优化了图像采集模块的代码架构。同时，通过设计高效的通信协议，实现了树莓派与主控芯片STM32的协同工作。\n\n![图18 在树莓派中配置anaconda](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8718.png)\n\n![图19 在树莓派中配置vscode](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8719.png)\n\n![图20 对树莓派进行调试](https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8720.png)\n\n&emsp;&emsp;历经反复的调试，最终完成了基于YOLOv5的智能垃圾分类系统，在自主构建的数据集支持下，能够准确识别多种垃圾类型，并通过机械执行实现自动分类压缩回收，充分展现了人工智能深度学习技术的实用价值！\n\n### 参考文献\n\n[1]陈之尧.基于OpenCV-Python的图像分割技术的设计与应用研究[J].中国新通信,2018,20(19):89.\n[2]明月科技.《Python OpenCV快速从入门到精通》.\n[3][深度学习目标检测：yolov5环境配置，适合0基础小白，超详细-CSDN博客](https://blog.csdn.net/qq_67105081/article/details/138232424?ops_request_misc=%7B%22request_id%22%3A%22b368614c237378c5bf41ba67bb6c3883%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=b368614c237378c5bf41ba67bb6c3883&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-138232424-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=yolov5%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA&spm=1018.2226.3001.4187)\n[4][labelme制作yolov5模型的数据集_labelme yolo-CSDN博客](https://blog.csdn.net/weixin_45736855/article/details/129583272?ops_request_misc=&request_id=&biz_id=102&utm_term=yolov5%E7%9A%84labelme%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129583272.142%5Ev102%5Epc_search_result_base2&spm=1018.2226.3001.4187)\n[5][下载数据集进行yolov5的训练测试_yolov5数据集下载-CSDN博客](https://blog.csdn.net/2401_86849688/article/details/145814831?spm=1001.2014.3001.5501)\n[6][yolov5-runs文件中对train结果的说明_train box loss-CSDN博客](https://blog.csdn.net/qq_45305490/article/details/125219937?ops_request_misc=%7B%22request_id%22%3A%22d18d63f66eeb3c007e4fab2cfbb532b2%22%2C%22scm%22%3A%2220140713.130102334.pc_all.%22%7D&request_id=d18d63f66eeb3c007e4fab2cfbb532b2&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125219937-null-null.142%5Ev102%5Epc_search_result_base2&utm_term=yolov5%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84runs%20train&spm=1018.2226.3001.4187)\n[7][将yolov5运用在树莓派上进行目标检测_树莓派yolo5调用摄像头-CSDN博客](https://blog.csdn.net/2401_86849688/article/details/145858990?spm=1001.2014.3001.5501)\n\n","slug":"other/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice","published":1,"updated":"2025-09-03T06:31:20.169Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hct002c40w306u44mq4","content":"<h1>From OpenCV to YOLOv5: Object Detection from Theory to Practice</h1>\n<div class=\"note note-primary\">\n            <p><strong>摘要</strong>：本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，重点对比分析了 <strong>OpenCV级联分类器</strong> 与 <strong>YOLOv5</strong> 的核心原理、技术特点及适用场景。通过深入研究<strong>Haar特征</strong> 与 <strong>卷积神经网络</strong> 的特征提取机制，揭示了两种方法在检测精度、计算效率等方面的本质差异。在实践层面，详细探讨了使用<strong>Labelme</strong>进行<strong>数据标注</strong>的方法论，以及如何利用 <strong>Roboflow</strong> 等平台获取和优化训练数据集。基于上述理论研究，我们将YOLOv5模型部署至 <strong>树莓派嵌入式平台</strong> ，实现了垃圾分类目标检测系统的工程化应用。本研究不仅梳理了目标检测技术的发展脉络，更通过完整的 <strong>“理论-数据-训练-部署”</strong> 闭环验证了深度学习人工智能在资源受限设备上的实用价值。</p>\n          </div>\n<div class=\"note note-primary\">\n            <p><strong>关键词</strong>：<strong>OpenCV；YOLOv5；目标检测；树莓派</strong></p>\n          </div>\n<div class=\"note note-primary\">\n            <p><strong>引言</strong>：每天清晨，当我们拿起智能手机解锁时，人脸识别功能会瞬间完成身份验证；走进机场安检区，摄像头会自动标记旅客的面部位置；甚至社交软件中的“美颜滤镜”，也需要先精准定位五官。这些看似简单的功能，其实背后都依赖于图像处理的目标检测技术！</p>\n          </div>\n<p>  而在早期，这类技术并非基于复杂的深度学习，而是通过OpenCV的级联检测器（如Haar级联）实现的。</p>\n<h3 id=\"一、OpenCV中Python-环境搭建\">一、OpenCV中Python 环境搭建</h3>\n<p>  Python 环境搭建是实现目标检测的前提基础，而其环境也并不复杂，仅仅是在Python解释器的基础上添加诸如numpy、matplotlib等库即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%871.png\" alt=\"图1 OpenCV环境搭建所需要的软件包示例\"></p>\n<h3 id=\"二、OpenCV的级联分类器\">二、OpenCV的级联分类器</h3>\n<p>  Haar分类器是一种基于机器学习的目标检测算法，它使用Haar特征描述图像中的目标。Haar特征是基于图像亮度的局部差异计算得出的，可以用来描述目标的边缘、角落和线条等特征。<br>\n  将一系列简单的分类器按照一定的顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。OpenCV提供一些已经训练好的级联分类器，有人脸检测、身形检测、车牌检测等，如下图所示。想要实现哪一种图像检测，在程序启动时加载对应的级联分类器即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%872.png\" alt=\"图2 OpenCV自带的级联分类器XML文件\"></p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> cv2<br><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">face_detection</span>(<span class=\"hljs-params\">frame</span>):<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class=\"hljs-string\">'haarcascade_frontalface_default.xml'</span>)<br>    faces = face_cascade.detectMultiScale(gray, scaleFactor=<span class=\"hljs-number\">1.05</span>, minNeighbors=<span class=\"hljs-number\">9</span>, minSize=(<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">30</span>))<br>    <span class=\"hljs-keyword\">for</span> (x, y, w, h) <span class=\"hljs-keyword\">in</span> faces:<br>        cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)<br>        cv2.putText(frame, <span class=\"hljs-string\">\"Face\"</span>, (x, y - <span class=\"hljs-number\">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class=\"hljs-number\">0.9</span>, (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)<br>    <span class=\"hljs-keyword\">return</span> frame<br>cap = cv2.VideoCapture(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:<br>    ret, frame = cap.read()<br>    result = face_detection(frame)<br>    cv2.imshow(<span class=\"hljs-string\">\"Face Detection\"</span>, result)<br>    <span class=\"hljs-keyword\">if</span> cv2.waitKey(<span class=\"hljs-number\">1</span>) &amp; <span class=\"hljs-number\">0xFF</span> == <span class=\"hljs-built_in\">ord</span>(<span class=\"hljs-string\">'q'</span>):<br>        <span class=\"hljs-keyword\">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"三、调用级联分类器实现检测\">三、调用级联分类器实现检测</h3>\n<p>  作为传统机器视觉的AI方法，人脸级联分类器采用提取眼睛区域（上暗下亮）、鼻梁区域（两侧暗中间亮）、嘴巴区域（上唇暗下唇亮）、面部轮廓（与背景的明暗对比）等多个特征的方法进行检测，效果图如下图所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%873.png\" alt=\"图4 使用OpenCV人脸级联分类器进行人脸检测效果图\"></p>\n<p>  尽管Haar级联在早期表现出色，但是随着场景扩展，传统方法OpenCV图像处理的弊端逐渐开始显现，级联的方法遇到了瓶颈，其局限性在复杂场景中暴露无遗：<br>\n(1)光照敏感：强光下人脸过曝时，特征对比度消失，导致漏检。<br>\n(2)姿态与遮挡：侧脸或戴口罩时，矩形特征失效，误检率飙升。<br>\n(3)多目标处理困难：需手动调整参数适应不同目标（如猫脸检测需重新训练）。<br>\nHaar级联的失败案例：背光导致检测失败：树叶被误检测为人脸。</p>\n<p>  从“人工规则”到“智能学习”，随着OpenCV传统图像处理方法的失宠，一种运用前沿AI——深度学习算法的新目标检测方法应运而生：YOLO算法！YOLOv5的诞生标志着目标检测从人工设计规则转向数据驱动学习，他们有着诸多的不同：<br>\n(1)特征提取的自动化：Haar级联依赖工程师设计的黑白矩形块，而YOLOv5通过训练自动提取更复杂的特征（例如纹理、轮廓、语义信息）。<br>\n(2)全局理解图像：传统方法需滑动窗口逐区域扫描，YOLOv5将图像划分为网格，单次预测所有目标的位置和类别，效率提升百倍。</p>\n<h3 id=\"四、YOLOv5运行环境的搭建\">四、YOLOv5运行环境的搭建</h3>\n<p>  这个的步骤可能略显复杂，主要是安装anaconda，为YOLOv5的运行创建虚拟环境，安装cuda，再根据电脑具体配置是否有GPU选择pytorch的版本。</p>\n<h3 id=\"五、YOLOv5的运行\">五、YOLOv5的运行</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%875.png\" alt=\"图 5 PC成功调用GPU进行YOLOv5 目标检测\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%876.png\" alt=\"图 6 YOLOv5 默认图像的处理结果（1）\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%877.png\" alt=\"图 7 YOLOv5 默认图像的处理结果（2）\"></p>\n<p>  从OpenCV的“人工经验”到YOLOv5的“数据智能”，目标检测技术实现了质的飞跃。然而，YOLOv5的强大性能离不开高质量的数据支撑，但是现实生活中我们的需求是多样化的，此时我们不满足于仅仅使用YOLOv5默认的数据集进行目标检测，这时我们将深入探讨如何构建专属数据集：</p>\n<h3 id=\"六、用labelme进行数据集的标注-4\">六、用labelme进行数据集的标注[4]</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%878.png\" alt=\"图 8 使用labelme手动进行数据集标注\"></p>\n<p>  Labelme确实能够适应特定需求进行数据集的划分了，但是一次的训练需要成百上千张图片，每做一次数据集就需要手动划分这么多，显然效率较低，难以大规模推广使用，于是我们可以通过下载网络平台上的各种标注好数据集进行训练实验。</p>\n<h3 id=\"七、用roboflow下载数据集-5\">七、用roboflow下载数据集[5]</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%879.png\" alt=\"图 9 在Roboflow中寻找合适的数据集\"></p>\n<h3 id=\"八、对数据集进行训练和测试\">八、对数据集进行训练和测试</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8710.png\" alt=\"图 10 对数据集进行训练\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8711.png\" alt=\"图 11 获取训练好的特征权重文件\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8712.png\" alt=\"在图 12 训练所得混淆矩阵\"></p>\n<p>  列代表预测的类别，行代表实际的类别。其对角线上的值表示预测正确的数量比例，非对角线元素则是预测错误的部分。混淆矩阵的对角线值越高越好，这表明许多预测是正确的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8713.png\" alt=\"图13 训练所得labels\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8714.png\" alt=\"图14 训练所得准确率与置信度\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8715.png\" alt=\"图15 训练所得\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8716.png\" alt=\"图16 个人“手势”数据集测试（1）\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8717.png\" alt=\"图17 个人“手势”数据集测试（2）\"></p>\n<p>  为了将目标检测技术从理论转化为实际应用，我们决定将YOLOv5模型部署到嵌入式设备中，打造具有实用价值的智能终端。考虑到深度学习算法对计算性能的较高要求，传统的C51、STM32等单片机难以满足运算需求，因此我们选择了性能更为强大的树莓派作为硬件平台，以确保模型能够高效稳定地运行。这一方案不仅提升了系统的实时处理能力，也为后续的功能扩展提供了充足的计算资源保障。</p>\n<h3 id=\"九、部署至树莓派装置进行实战检测\">九、部署至树莓派装置进行实战检测</h3>\n<p>  在系统实现过程中，我们针对树莓派的硬件特性进行了适配性开发。由于树莓派采用CSI摄像头接口，其图像采集方式与PC端的USB摄像头存在差异，为此我们专门优化了图像采集模块的代码架构。同时，通过设计高效的通信协议，实现了树莓派与主控芯片STM32的协同工作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8718.png\" alt=\"图18 在树莓派中配置anaconda\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8719.png\" alt=\"图19 在树莓派中配置vscode\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8720.png\" alt=\"图20 对树莓派进行调试\"></p>\n<p>  历经反复的调试，最终完成了基于YOLOv5的智能垃圾分类系统，在自主构建的数据集支持下，能够准确识别多种垃圾类型，并通过机械执行实现自动分类压缩回收，充分展现了人工智能深度学习技术的实用价值！</p>\n<h3 id=\"参考文献\">参考文献</h3>\n<p>[1]陈之尧.基于OpenCV-Python的图像分割技术的设计与应用研究[J].中国新通信,2018,20(19):89.<br>\n[2]明月科技.《Python OpenCV快速从入门到精通》.<br>\n[3]<a href=\"https://blog.csdn.net/qq_67105081/article/details/138232424?ops_request_misc=%7B%22request_id%22%3A%22b368614c237378c5bf41ba67bb6c3883%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=b368614c237378c5bf41ba67bb6c3883&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-138232424-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4187\">深度学习目标检测：yolov5环境配置，适合0基础小白，超详细-CSDN博客</a><br>\n[4]<a href=\"https://blog.csdn.net/weixin_45736855/article/details/129583272?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolov5%E7%9A%84labelme%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129583272.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">labelme制作yolov5模型的数据集_labelme yolo-CSDN博客</a><br>\n[5]<a href=\"https://blog.csdn.net/2401_86849688/article/details/145814831?spm=1001.2014.3001.5501\">下载数据集进行yolov5的训练测试_yolov5数据集下载-CSDN博客</a><br>\n[6]<a href=\"https://blog.csdn.net/qq_45305490/article/details/125219937?ops_request_misc=%7B%22request_id%22%3A%22d18d63f66eeb3c007e4fab2cfbb532b2%22%2C%22scm%22%3A%2220140713.130102334.pc_all.%22%7D&amp;request_id=d18d63f66eeb3c007e4fab2cfbb532b2&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125219937-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84runs%20train&amp;spm=1018.2226.3001.4187\">yolov5-runs文件中对train结果的说明_train box loss-CSDN博客</a><br>\n[7]<a href=\"https://blog.csdn.net/2401_86849688/article/details/145858990?spm=1001.2014.3001.5501\">将yolov5运用在树莓派上进行目标检测_树莓派yolo5调用摄像头-CSDN博客</a></p>\n","excerpt":"","more":"<h1>From OpenCV to YOLOv5: Object Detection from Theory to Practice</h1>\n<div class=\"note note-primary\">\n            <p><strong>摘要</strong>：本文系统性地研究了目标检测技术从传统方法到深度学习的演进过程，重点对比分析了 <strong>OpenCV级联分类器</strong> 与 <strong>YOLOv5</strong> 的核心原理、技术特点及适用场景。通过深入研究<strong>Haar特征</strong> 与 <strong>卷积神经网络</strong> 的特征提取机制，揭示了两种方法在检测精度、计算效率等方面的本质差异。在实践层面，详细探讨了使用<strong>Labelme</strong>进行<strong>数据标注</strong>的方法论，以及如何利用 <strong>Roboflow</strong> 等平台获取和优化训练数据集。基于上述理论研究，我们将YOLOv5模型部署至 <strong>树莓派嵌入式平台</strong> ，实现了垃圾分类目标检测系统的工程化应用。本研究不仅梳理了目标检测技术的发展脉络，更通过完整的 <strong>“理论-数据-训练-部署”</strong> 闭环验证了深度学习人工智能在资源受限设备上的实用价值。</p>\n          </div>\n<div class=\"note note-primary\">\n            <p><strong>关键词</strong>：<strong>OpenCV；YOLOv5；目标检测；树莓派</strong></p>\n          </div>\n<div class=\"note note-primary\">\n            <p><strong>引言</strong>：每天清晨，当我们拿起智能手机解锁时，人脸识别功能会瞬间完成身份验证；走进机场安检区，摄像头会自动标记旅客的面部位置；甚至社交软件中的“美颜滤镜”，也需要先精准定位五官。这些看似简单的功能，其实背后都依赖于图像处理的目标检测技术！</p>\n          </div>\n<p>  而在早期，这类技术并非基于复杂的深度学习，而是通过OpenCV的级联检测器（如Haar级联）实现的。</p>\n<h3 id=\"一、OpenCV中Python-环境搭建\">一、OpenCV中Python 环境搭建</h3>\n<p>  Python 环境搭建是实现目标检测的前提基础，而其环境也并不复杂，仅仅是在Python解释器的基础上添加诸如numpy、matplotlib等库即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%871.png\" alt=\"图1 OpenCV环境搭建所需要的软件包示例\"></p>\n<h3 id=\"二、OpenCV的级联分类器\">二、OpenCV的级联分类器</h3>\n<p>  Haar分类器是一种基于机器学习的目标检测算法，它使用Haar特征描述图像中的目标。Haar特征是基于图像亮度的局部差异计算得出的，可以用来描述目标的边缘、角落和线条等特征。<br>\n  将一系列简单的分类器按照一定的顺序级联到一起就构成了级联分类器，使用级联分类器的程序可以通过一系列简单的判断来对样本进行识别。OpenCV提供一些已经训练好的级联分类器，有人脸检测、身形检测、车牌检测等，如下图所示。想要实现哪一种图像检测，在程序启动时加载对应的级联分类器即可。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%872.png\" alt=\"图2 OpenCV自带的级联分类器XML文件\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> cv2<br><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np<br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">face_detection</span>(<span class=\"hljs-params\">frame</span>):<br>    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + <span class=\"hljs-string\">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)<br>    faces = face_cascade.detectMultiScale(gray, scaleFactor=<span class=\"hljs-number\">1.05</span>, minNeighbors=<span class=\"hljs-number\">9</span>, minSize=(<span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">30</span>))<br>    <span class=\"hljs-keyword\">for</span> (x, y, w, h) <span class=\"hljs-keyword\">in</span> faces:<br>        cv2.rectangle(frame, (x, y), (x + w, y + h), (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)<br>        cv2.putText(frame, <span class=\"hljs-string\">&quot;Face&quot;</span>, (x, y - <span class=\"hljs-number\">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class=\"hljs-number\">0.9</span>, (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)<br>    <span class=\"hljs-keyword\">return</span> frame<br>cap = cv2.VideoCapture(<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:<br>    ret, frame = cap.read()<br>    result = face_detection(frame)<br>    cv2.imshow(<span class=\"hljs-string\">&quot;Face Detection&quot;</span>, result)<br>    <span class=\"hljs-keyword\">if</span> cv2.waitKey(<span class=\"hljs-number\">1</span>) &amp; <span class=\"hljs-number\">0xFF</span> == <span class=\"hljs-built_in\">ord</span>(<span class=\"hljs-string\">&#x27;q&#x27;</span>):<br>        <span class=\"hljs-keyword\">break</span><br>cap.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure>\n<h3 id=\"三、调用级联分类器实现检测\">三、调用级联分类器实现检测</h3>\n<p>  作为传统机器视觉的AI方法，人脸级联分类器采用提取眼睛区域（上暗下亮）、鼻梁区域（两侧暗中间亮）、嘴巴区域（上唇暗下唇亮）、面部轮廓（与背景的明暗对比）等多个特征的方法进行检测，效果图如下图所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%873.png\" alt=\"图4 使用OpenCV人脸级联分类器进行人脸检测效果图\"></p>\n<p>  尽管Haar级联在早期表现出色，但是随着场景扩展，传统方法OpenCV图像处理的弊端逐渐开始显现，级联的方法遇到了瓶颈，其局限性在复杂场景中暴露无遗：<br>\n(1)光照敏感：强光下人脸过曝时，特征对比度消失，导致漏检。<br>\n(2)姿态与遮挡：侧脸或戴口罩时，矩形特征失效，误检率飙升。<br>\n(3)多目标处理困难：需手动调整参数适应不同目标（如猫脸检测需重新训练）。<br>\nHaar级联的失败案例：背光导致检测失败：树叶被误检测为人脸。</p>\n<p>  从“人工规则”到“智能学习”，随着OpenCV传统图像处理方法的失宠，一种运用前沿AI——深度学习算法的新目标检测方法应运而生：YOLO算法！YOLOv5的诞生标志着目标检测从人工设计规则转向数据驱动学习，他们有着诸多的不同：<br>\n(1)特征提取的自动化：Haar级联依赖工程师设计的黑白矩形块，而YOLOv5通过训练自动提取更复杂的特征（例如纹理、轮廓、语义信息）。<br>\n(2)全局理解图像：传统方法需滑动窗口逐区域扫描，YOLOv5将图像划分为网格，单次预测所有目标的位置和类别，效率提升百倍。</p>\n<h3 id=\"四、YOLOv5运行环境的搭建\">四、YOLOv5运行环境的搭建</h3>\n<p>  这个的步骤可能略显复杂，主要是安装anaconda，为YOLOv5的运行创建虚拟环境，安装cuda，再根据电脑具体配置是否有GPU选择pytorch的版本。</p>\n<h3 id=\"五、YOLOv5的运行\">五、YOLOv5的运行</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%875.png\" alt=\"图 5 PC成功调用GPU进行YOLOv5 目标检测\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%876.png\" alt=\"图 6 YOLOv5 默认图像的处理结果（1）\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%877.png\" alt=\"图 7 YOLOv5 默认图像的处理结果（2）\"></p>\n<p>  从OpenCV的“人工经验”到YOLOv5的“数据智能”，目标检测技术实现了质的飞跃。然而，YOLOv5的强大性能离不开高质量的数据支撑，但是现实生活中我们的需求是多样化的，此时我们不满足于仅仅使用YOLOv5默认的数据集进行目标检测，这时我们将深入探讨如何构建专属数据集：</p>\n<h3 id=\"六、用labelme进行数据集的标注-4\">六、用labelme进行数据集的标注[4]</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%878.png\" alt=\"图 8 使用labelme手动进行数据集标注\"></p>\n<p>  Labelme确实能够适应特定需求进行数据集的划分了，但是一次的训练需要成百上千张图片，每做一次数据集就需要手动划分这么多，显然效率较低，难以大规模推广使用，于是我们可以通过下载网络平台上的各种标注好数据集进行训练实验。</p>\n<h3 id=\"七、用roboflow下载数据集-5\">七、用roboflow下载数据集[5]</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%879.png\" alt=\"图 9 在Roboflow中寻找合适的数据集\"></p>\n<h3 id=\"八、对数据集进行训练和测试\">八、对数据集进行训练和测试</h3>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8710.png\" alt=\"图 10 对数据集进行训练\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8711.png\" alt=\"图 11 获取训练好的特征权重文件\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8712.png\" alt=\"在图 12 训练所得混淆矩阵\"></p>\n<p>  列代表预测的类别，行代表实际的类别。其对角线上的值表示预测正确的数量比例，非对角线元素则是预测错误的部分。混淆矩阵的对角线值越高越好，这表明许多预测是正确的。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8713.png\" alt=\"图13 训练所得labels\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8714.png\" alt=\"图14 训练所得准确率与置信度\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8715.png\" alt=\"图15 训练所得\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8716.png\" alt=\"图16 个人“手势”数据集测试（1）\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8717.png\" alt=\"图17 个人“手势”数据集测试（2）\"></p>\n<p>  为了将目标检测技术从理论转化为实际应用，我们决定将YOLOv5模型部署到嵌入式设备中，打造具有实用价值的智能终端。考虑到深度学习算法对计算性能的较高要求，传统的C51、STM32等单片机难以满足运算需求，因此我们选择了性能更为强大的树莓派作为硬件平台，以确保模型能够高效稳定地运行。这一方案不仅提升了系统的实时处理能力，也为后续的功能扩展提供了充足的计算资源保障。</p>\n<h3 id=\"九、部署至树莓派装置进行实战检测\">九、部署至树莓派装置进行实战检测</h3>\n<p>  在系统实现过程中，我们针对树莓派的硬件特性进行了适配性开发。由于树莓派采用CSI摄像头接口，其图像采集方式与PC端的USB摄像头存在差异，为此我们专门优化了图像采集模块的代码架构。同时，通过设计高效的通信协议，实现了树莓派与主控芯片STM32的协同工作。</p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8718.png\" alt=\"图18 在树莓派中配置anaconda\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8719.png\" alt=\"图19 在树莓派中配置vscode\"></p>\n<p><img src=\"https://raw.githubusercontent.com/Richard110206/Blog-image/main/article/From-OpenCV-to-YOLOv5-Object-Detection-from-Theory-to-Practice/%E5%9B%BE%E7%89%8720.png\" alt=\"图20 对树莓派进行调试\"></p>\n<p>  历经反复的调试，最终完成了基于YOLOv5的智能垃圾分类系统，在自主构建的数据集支持下，能够准确识别多种垃圾类型，并通过机械执行实现自动分类压缩回收，充分展现了人工智能深度学习技术的实用价值！</p>\n<h3 id=\"参考文献\">参考文献</h3>\n<p>[1]陈之尧.基于OpenCV-Python的图像分割技术的设计与应用研究[J].中国新通信,2018,20(19):89.<br>\n[2]明月科技.《Python OpenCV快速从入门到精通》.<br>\n[3]<a href=\"https://blog.csdn.net/qq_67105081/article/details/138232424?ops_request_misc=%7B%22request_id%22%3A%22b368614c237378c5bf41ba67bb6c3883%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=b368614c237378c5bf41ba67bb6c3883&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-138232424-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA&amp;spm=1018.2226.3001.4187\">深度学习目标检测：yolov5环境配置，适合0基础小白，超详细-CSDN博客</a><br>\n[4]<a href=\"https://blog.csdn.net/weixin_45736855/article/details/129583272?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=yolov5%E7%9A%84labelme%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-129583272.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">labelme制作yolov5模型的数据集_labelme yolo-CSDN博客</a><br>\n[5]<a href=\"https://blog.csdn.net/2401_86849688/article/details/145814831?spm=1001.2014.3001.5501\">下载数据集进行yolov5的训练测试_yolov5数据集下载-CSDN博客</a><br>\n[6]<a href=\"https://blog.csdn.net/qq_45305490/article/details/125219937?ops_request_misc=%7B%22request_id%22%3A%22d18d63f66eeb3c007e4fab2cfbb532b2%22%2C%22scm%22%3A%2220140713.130102334.pc_all.%22%7D&amp;request_id=d18d63f66eeb3c007e4fab2cfbb532b2&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-125219937-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=yolov5%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84runs%20train&amp;spm=1018.2226.3001.4187\">yolov5-runs文件中对train结果的说明_train box loss-CSDN博客</a><br>\n[7]<a href=\"https://blog.csdn.net/2401_86849688/article/details/145858990?spm=1001.2014.3001.5501\">将yolov5运用在树莓派上进行目标检测_树莓派yolo5调用摄像头-CSDN博客</a></p>\n"},{"title":"Life-musings","date":"2025-07-14T15:34:51.000Z","archive":true,"_content":"\n# Life-musings（精进日记）\n\n记录每天的**学习内容** && 博客未来**更新方向**！\n保持更新的节奏！\n\n## 2025\n\n{%fold into @ Summer Vacation %}\n#### 7.14\n梦开始的地方！\n**cool！**\n\n#### 7.16\nTurtle in Python 大win特win！\n\n#### 7.17\n昨晚备课到两点...\n逐渐适应老师的身份！\n制作课件的过程中也顺便二次学习Python语法！\n\n#### 7.18\n成功给 blog 添加 category 功能！\n\n#### 7.22\n上知网阅读相关论文，**着手准备26大创pre**！\n在roboflow上找到几个感觉适配的**数据集**！\n但是还是感觉有些缺失，需要自己想办法解决...\n\n#### 7.23\n参考数据结构教材，重新梳理了几种常见的**排序算法的核心思路**！\n自己敲了敲各种排序算法的代码，interesting！\n\n#### 7.24\n试图给博客添加vercel进行**自动化部署**，\n似乎不是很成功 :cry:\n\n#### 7.25\nUC Berkeley的CS61A！\n\n#### 7.26\nThe Missing Semester of Your CS Education！\n`shell`篇，受益匪浅！\n\n#### 7.27\n先是赛车，再是足球！忙活一天！\n回来总算是吧`shell`篇的博客写完了！\n还顺带配置了博客 emoji :smile:\n以后终于不再是文文并茂了:cry:\n\n#### 7.28\n继续[missing semster]，学完了`vim`篇！\n\n#### 7.29\n完善`Git`篇！\n捣鼓我的 mac！\n\n#### 7.30\n终于在 macbook 上成功配置博客环境！\n单人多设备假装自己是多人协作开发大项目:smile:\n\n#### 7.31\nmac 中尝试在`vim`写、编译运行`c++`！\n**skilled programmer** 既视感:smile:\n\n#### 8.1\n入门**dynamic programming**！\n祝好运:wink:\n\n\n#### 8.7\n**LaTex**简单入门，优雅，太优雅了！:blush:\n果然学习才是**祛魅**的最好方式！\n**overleaf**在线共享编辑，真是个好东西！:smile:\n\n#### 8.8\nLaTex 太灾难了:cry:\n还是更喜欢**WYSWYG**:blush:\n\n#### 8.9\nLaTex 还得是在**实战中学习**！\n但感觉花大量时间学习性价比不太高:cry:\nAI辅助 LaTex就很舒服:grinning:\n\n#### 8.10\n终于整完了，呼~~\n要投身算法学习哩！\n不能再依靠 life-musings 栏目苟延残喘更新速度了:rage:\n\n#### 8.11\nsummer vacation assignment:rage:\n\n#### 8.13\n有点绷不住了:angry:\n搞了一上午才将**图床**弄好\n然后下午进行**图片的迁移**和博客照片中路径的修改~\n对整个博客内容**缝缝补补**（其实是女娲补天:grinning:）\n将原来`生活随想录`栏目进行了拆分：\n- 精进日记 :arrow_right::arrow_right: 偏学业\n- 生活杂谈 :arrow_right::arrow_right: 偏生活\n  \n![2025年8月13日23点10分Github截图](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/20250813.png?raw=true)\n\n#### 8.14\n进行更新HTML&&CSS的部分\n\n#### 8.16\n刷知乎看到一篇很好的帖子：\n[大一计算机新生怎么合理利用github？ - 知乎](https://www.zhihu.com/question/11379810074)\n后续努力方向！\n\n完善Github主页readme文件\n尝试使用开源代码丰富界面\n\n再三尝试**Vercel部署**失败:cry:\n能不能让我赢一次:cry:\n\n#### 8.17\n完善 HTML && CSS 表单部分\nyysy 感觉越写越多，CSS都要单开一栏目了:grinning:\n学习《Github从入门到实践》\n丰富有关`Git`项目管理的笔记内容:smile:\n\n#### 8.18\n新开章节CSS！\n\n#### 8.19\n第一次尝试**PR**！\n学习`flex`布局！\n\n#### 8.20\n无所事事！\n这看看那看看的\n一会儿看看 github 一会儿又去 leetcode\n还没刷上题又去看 data analyse:cry:\n\n#### 8.21\n经提醒，发现CSDN博客上的图片转存失败，紧急进行修复！\n顺便写了一篇关于PicGo插件配置Github图床的博客！\n并计划回顾往期博客，完善格式，修复语病！\n使用**pandoc实行文档转换**输出数学公式！\n![成功给博客配置数学公式结算画面](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/mathematical.png?raw=true)\n\n#### 8.22\n新语法Get！给hexo增加**折叠块**的内容！\n经常在YouTube上刷到动画风质感很好的封面：\n![Ghibli画风](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/Ghibli.jpeg?raw=true)\n今天才知道原来是**吉卜力工作室的宫崎骏画风**！\n（不知道为啥在国内不是很火:fire: 难道是版权问题🫤）\n其实一开始看着就有点像AI改的，但是据我浅薄的了解：\n这种文字程度的又不太像AI生成的（或许是我没用过更好的大模型吧）\n用豆包试了试,感觉还不错,但跟想象略有出入:cry:\n```textinfo\n以这张图为基础，转化为吉卜力风格插画。采用吉卜力经典的高饱和度且自然和谐的色彩体系，像宫崎骏作品中常见的清新绿、湛蓝天空色等。画面笔触要细腻且有手绘质感，就如同吉卜力动画中一帧帧精心绘制的场景。保留所有的人物、建筑物等，营造出吉卜力式的奇幻氛围 ，光影柔和，突出主体，整体呈现出温暖治愈的感觉 。\n```\n\n```textinfo\n将此图重绘为吉卜力风格。保留原图主体动作与大致构图，色调调整为吉卜力偏好的明快且温馨的色调，比如用柔和的暖黄色光模拟夕阳洒下的效果。背景细节按照吉卜力风格丰富化，若有建筑，添加木质纹理与精致的装饰；若有自然场景，细化植物的形态与层次。线条干净流畅，具有明显的手绘痕迹，使整幅图宛如出自吉卜力工作室 。\n```\n\n```textinfo\n参照此图，创作吉卜力风格画面。保留原图核心元素，将画面氛围塑造为吉卜力式的宁静而充满生机。色彩以清新淡雅为主，偶尔用鲜艳色彩作为点缀突出重点。绘制手法上，以干净利落的线条勾勒轮廓，再用细腻的色彩填充，展现出吉卜力动画那种精致的画面效果。光影处理成既有明亮的主光源，又有柔和的环境光，让整个场景看起来自然且生动 。保留人物物体的一致性。\n```\n\n下午开新坑！回顾数据结构！\n\n华数杯“优秀奖”，:cry:呜呜呜......\n第一次在博客中引入pdf文件！\n\n#### 8.23\n继续复习栈和队列，未来会尝试将**每种数据结构都实现一遍**！\n\n新博客栏目的**宫崎骏画风封面**感觉还不错！\n就是显示文字依然乱码，十分费劲！\n那大抵是要**开ChatGPT会员**罢！\n\n密码的，吃完饭回来电脑竟然**死机了**:cry:\n大概是开太多程序又长时间没有关机的缘故（多学学人家Mac 几周不关机也没事）\n然后一通乱按又把键盘弄失灵了:cry:\n弄俩小时才发现是误触 要`Fn`+`T`**切换到有线模式**才行 太折磨了！\n\n#### 8.24\n开刷leetcode！\n有种高中写圆锥曲线和导数大题的感觉:grinning:\n又折磨又兴奋 又菜又爱学没跑了:cry:\n\n#### 8.25\nc++修修补补 \n学习lambda表达式和auto用法\n\nChatGPT果然还是更胜一筹\n“**贵的东西的缺点只有贵**”\n\n#### 8.26\nHashtable Review!\n\n**Sora绘图**效果令人惊喜，可惜每日三次:cry:\n\n![ChatGPT Warning!](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/ChatGPT-Warning.png?raw=true)\n猜的很对了，这下看懂了:grinning:\n\n**Update the published blog post!**\n- 为了**方便阅读**，给**OJ题目设置了折叠块**\n- 为了**格式重点突出**，给问题解答、分析板块增加不同颜色的**标签note插件**\n\n#### 8.27\ndebug——**ssh**突然网络连接失败（CSDN:white_check_mark:）\n\n**Sora绘图**不知道为啥又**无限制**了:grinning:\n吸取之前被限制的教训，这次表达相当**委婉**\n**prompt**详细一点，生图风格就相当**awesome**！\n\n#### 8.28\n学习**结构化绑定**\n\n依然Leetcode刷题，查漏补缺！\n\n#### 8.29\n**Leetcode**！杨辉三角+优化\n妙实在是妙！\n\n将博客切换`en`英文版面\n\n#### 8.31\n双指针依然不能稳定AC嘛~\n\n&emsp;&emsp;8月暑假悄悄从指间溜走了~ 回顾整个暑假，从刚放假看国外公开课，学习一些简单的Tools，比如Github、Git、 Vim、Shell等，充实基础知识，作为科班生的底气了；旅游归来复习几个基本的数据结构，开刷leetcode，同时更新`Leetcode Mistake Collection`！时隔一年再次享受到到刷题的乐趣，无情的算法题会将你的思维+代码的bug暴露无遗，但绿意盎然的“通过”则会将你从苦海中拯救！真是痛并快乐着！\n\n开学了后续大概会更新：\n\n- 部分学科的学习笔记（概率论和大物、计组等）\n- 简单的cpp项目\n- 每天一道leetcode\n- 全栈\n- 一些基本工具的巩固\n- 入门Linux\n\n我们未来见！:wave:\n\n{%endfold%}\n\n\n- 9.1\n  - 数电：概论，智能系统=算法+软件+**硬件**，复习信概**进制转换**等内容\n  - 概率论：概论，基本**集合符号使用**（与离散数学相似）\n  - 网球：概论，学校体育建设史（网球）\n  - JavaScript：以 cpp 基础速通基本语法\n- 9.2\n  - 大英：BBC 精听:arrow_forward::arrow_forward:饮食改善\n  - 大物：理想气体状态方程\n  - 毛中特：“教义是不谈条件的 方法是谈条件的”\n  - 数学文化：24春晚魔术:arrow_forward::arrow_forward:约瑟夫环\n  - 博客：完善Shell篇博客，增加示例代码\n- 9.3\n  -  程序设计综合实践取消，观看大阅兵\n  -  博客：将blog-img-article进行文件归类整理，提升未来图片管理效率\n  -  Github：新建仓库\"Hexo-Source\"，将博客源码进行迁移，便于mac/windows切换撰写博客\n- 9.4\n  -  数电：基本逻辑运算符\n  -  概率论：大数定律，条件概率\n  -  leetcode：侮辱人的每日一题:grinning: \n- 9.5\n  - 大物：理想气体自由度、动能、\n  - 数模：Q3创新点提出\n- 9.6\n  - 数模：完成Q1与Q2、Q3建模过程，Q4起头\n- 9.7\n  - 数模：仅仅生成md5码 未进行提交 参赛失败 功亏一篑\n- 9.8\n  - 数电：逻辑表达式的化简\n  - 概率论：全概率公式、贝叶斯公式\n- 9.9\n  - 大物（线上）：气体分子不同温度下速率分布\n  - 毛中特：毛泽东思想 && 毛泽东“的”思想 毛泽东思想的历史地位、活的灵魂\n- 9.10\n  - CSP:课程简介，须刷leetcode，课设项目\n- 9.11\n  - 数电：卡诺图化简\n  - 概率论：二项分布，伯努利实验、\n  - 物理实验：太阳能电池特性研究，接线较为简单\n  - 毛中特：“半殖民地”、“半封建”的价值评判\n- 9.12\n  - 大物：热学章节 等压等容等温变化\n  - leetcode 每日一题：再涉动态规划，对状态转移方程有点感觉了\n  - 博客：mac/windows 切换更新出 bug 似乎是mac的gitignore全局配置文件，导致无法部署（标签无法识别），无奈进行回滚，git果然还得是在慢慢debug的时候才能“精通”\n- 9.13\n  - 四史：87 顺利通过，主要是第几次会议混淆记不清楚\n  - Python：初涉Matplotlib\n  - leetcode：刷了昨天的[每日一题](https://leetcode.cn/problems/vowels-game-in-a-string?envType=daily-question&envId=2025-09-12)，感觉有点子抽象:grinning:\n\n","source":"_posts/other/life-musings.md","raw":"---\ntitle: Life-musings\ndate: 2025-07-14 23:34:51\ntags: [updating]\narchive: true\n---\n\n# Life-musings（精进日记）\n\n记录每天的**学习内容** && 博客未来**更新方向**！\n保持更新的节奏！\n\n## 2025\n\n{%fold into @ Summer Vacation %}\n#### 7.14\n梦开始的地方！\n**cool！**\n\n#### 7.16\nTurtle in Python 大win特win！\n\n#### 7.17\n昨晚备课到两点...\n逐渐适应老师的身份！\n制作课件的过程中也顺便二次学习Python语法！\n\n#### 7.18\n成功给 blog 添加 category 功能！\n\n#### 7.22\n上知网阅读相关论文，**着手准备26大创pre**！\n在roboflow上找到几个感觉适配的**数据集**！\n但是还是感觉有些缺失，需要自己想办法解决...\n\n#### 7.23\n参考数据结构教材，重新梳理了几种常见的**排序算法的核心思路**！\n自己敲了敲各种排序算法的代码，interesting！\n\n#### 7.24\n试图给博客添加vercel进行**自动化部署**，\n似乎不是很成功 :cry:\n\n#### 7.25\nUC Berkeley的CS61A！\n\n#### 7.26\nThe Missing Semester of Your CS Education！\n`shell`篇，受益匪浅！\n\n#### 7.27\n先是赛车，再是足球！忙活一天！\n回来总算是吧`shell`篇的博客写完了！\n还顺带配置了博客 emoji :smile:\n以后终于不再是文文并茂了:cry:\n\n#### 7.28\n继续[missing semster]，学完了`vim`篇！\n\n#### 7.29\n完善`Git`篇！\n捣鼓我的 mac！\n\n#### 7.30\n终于在 macbook 上成功配置博客环境！\n单人多设备假装自己是多人协作开发大项目:smile:\n\n#### 7.31\nmac 中尝试在`vim`写、编译运行`c++`！\n**skilled programmer** 既视感:smile:\n\n#### 8.1\n入门**dynamic programming**！\n祝好运:wink:\n\n\n#### 8.7\n**LaTex**简单入门，优雅，太优雅了！:blush:\n果然学习才是**祛魅**的最好方式！\n**overleaf**在线共享编辑，真是个好东西！:smile:\n\n#### 8.8\nLaTex 太灾难了:cry:\n还是更喜欢**WYSWYG**:blush:\n\n#### 8.9\nLaTex 还得是在**实战中学习**！\n但感觉花大量时间学习性价比不太高:cry:\nAI辅助 LaTex就很舒服:grinning:\n\n#### 8.10\n终于整完了，呼~~\n要投身算法学习哩！\n不能再依靠 life-musings 栏目苟延残喘更新速度了:rage:\n\n#### 8.11\nsummer vacation assignment:rage:\n\n#### 8.13\n有点绷不住了:angry:\n搞了一上午才将**图床**弄好\n然后下午进行**图片的迁移**和博客照片中路径的修改~\n对整个博客内容**缝缝补补**（其实是女娲补天:grinning:）\n将原来`生活随想录`栏目进行了拆分：\n- 精进日记 :arrow_right::arrow_right: 偏学业\n- 生活杂谈 :arrow_right::arrow_right: 偏生活\n  \n![2025年8月13日23点10分Github截图](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/20250813.png?raw=true)\n\n#### 8.14\n进行更新HTML&&CSS的部分\n\n#### 8.16\n刷知乎看到一篇很好的帖子：\n[大一计算机新生怎么合理利用github？ - 知乎](https://www.zhihu.com/question/11379810074)\n后续努力方向！\n\n完善Github主页readme文件\n尝试使用开源代码丰富界面\n\n再三尝试**Vercel部署**失败:cry:\n能不能让我赢一次:cry:\n\n#### 8.17\n完善 HTML && CSS 表单部分\nyysy 感觉越写越多，CSS都要单开一栏目了:grinning:\n学习《Github从入门到实践》\n丰富有关`Git`项目管理的笔记内容:smile:\n\n#### 8.18\n新开章节CSS！\n\n#### 8.19\n第一次尝试**PR**！\n学习`flex`布局！\n\n#### 8.20\n无所事事！\n这看看那看看的\n一会儿看看 github 一会儿又去 leetcode\n还没刷上题又去看 data analyse:cry:\n\n#### 8.21\n经提醒，发现CSDN博客上的图片转存失败，紧急进行修复！\n顺便写了一篇关于PicGo插件配置Github图床的博客！\n并计划回顾往期博客，完善格式，修复语病！\n使用**pandoc实行文档转换**输出数学公式！\n![成功给博客配置数学公式结算画面](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/mathematical.png?raw=true)\n\n#### 8.22\n新语法Get！给hexo增加**折叠块**的内容！\n经常在YouTube上刷到动画风质感很好的封面：\n![Ghibli画风](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/Ghibli.jpeg?raw=true)\n今天才知道原来是**吉卜力工作室的宫崎骏画风**！\n（不知道为啥在国内不是很火:fire: 难道是版权问题🫤）\n其实一开始看着就有点像AI改的，但是据我浅薄的了解：\n这种文字程度的又不太像AI生成的（或许是我没用过更好的大模型吧）\n用豆包试了试,感觉还不错,但跟想象略有出入:cry:\n```textinfo\n以这张图为基础，转化为吉卜力风格插画。采用吉卜力经典的高饱和度且自然和谐的色彩体系，像宫崎骏作品中常见的清新绿、湛蓝天空色等。画面笔触要细腻且有手绘质感，就如同吉卜力动画中一帧帧精心绘制的场景。保留所有的人物、建筑物等，营造出吉卜力式的奇幻氛围 ，光影柔和，突出主体，整体呈现出温暖治愈的感觉 。\n```\n\n```textinfo\n将此图重绘为吉卜力风格。保留原图主体动作与大致构图，色调调整为吉卜力偏好的明快且温馨的色调，比如用柔和的暖黄色光模拟夕阳洒下的效果。背景细节按照吉卜力风格丰富化，若有建筑，添加木质纹理与精致的装饰；若有自然场景，细化植物的形态与层次。线条干净流畅，具有明显的手绘痕迹，使整幅图宛如出自吉卜力工作室 。\n```\n\n```textinfo\n参照此图，创作吉卜力风格画面。保留原图核心元素，将画面氛围塑造为吉卜力式的宁静而充满生机。色彩以清新淡雅为主，偶尔用鲜艳色彩作为点缀突出重点。绘制手法上，以干净利落的线条勾勒轮廓，再用细腻的色彩填充，展现出吉卜力动画那种精致的画面效果。光影处理成既有明亮的主光源，又有柔和的环境光，让整个场景看起来自然且生动 。保留人物物体的一致性。\n```\n\n下午开新坑！回顾数据结构！\n\n华数杯“优秀奖”，:cry:呜呜呜......\n第一次在博客中引入pdf文件！\n\n#### 8.23\n继续复习栈和队列，未来会尝试将**每种数据结构都实现一遍**！\n\n新博客栏目的**宫崎骏画风封面**感觉还不错！\n就是显示文字依然乱码，十分费劲！\n那大抵是要**开ChatGPT会员**罢！\n\n密码的，吃完饭回来电脑竟然**死机了**:cry:\n大概是开太多程序又长时间没有关机的缘故（多学学人家Mac 几周不关机也没事）\n然后一通乱按又把键盘弄失灵了:cry:\n弄俩小时才发现是误触 要`Fn`+`T`**切换到有线模式**才行 太折磨了！\n\n#### 8.24\n开刷leetcode！\n有种高中写圆锥曲线和导数大题的感觉:grinning:\n又折磨又兴奋 又菜又爱学没跑了:cry:\n\n#### 8.25\nc++修修补补 \n学习lambda表达式和auto用法\n\nChatGPT果然还是更胜一筹\n“**贵的东西的缺点只有贵**”\n\n#### 8.26\nHashtable Review!\n\n**Sora绘图**效果令人惊喜，可惜每日三次:cry:\n\n![ChatGPT Warning!](https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/ChatGPT-Warning.png?raw=true)\n猜的很对了，这下看懂了:grinning:\n\n**Update the published blog post!**\n- 为了**方便阅读**，给**OJ题目设置了折叠块**\n- 为了**格式重点突出**，给问题解答、分析板块增加不同颜色的**标签note插件**\n\n#### 8.27\ndebug——**ssh**突然网络连接失败（CSDN:white_check_mark:）\n\n**Sora绘图**不知道为啥又**无限制**了:grinning:\n吸取之前被限制的教训，这次表达相当**委婉**\n**prompt**详细一点，生图风格就相当**awesome**！\n\n#### 8.28\n学习**结构化绑定**\n\n依然Leetcode刷题，查漏补缺！\n\n#### 8.29\n**Leetcode**！杨辉三角+优化\n妙实在是妙！\n\n将博客切换`en`英文版面\n\n#### 8.31\n双指针依然不能稳定AC嘛~\n\n&emsp;&emsp;8月暑假悄悄从指间溜走了~ 回顾整个暑假，从刚放假看国外公开课，学习一些简单的Tools，比如Github、Git、 Vim、Shell等，充实基础知识，作为科班生的底气了；旅游归来复习几个基本的数据结构，开刷leetcode，同时更新`Leetcode Mistake Collection`！时隔一年再次享受到到刷题的乐趣，无情的算法题会将你的思维+代码的bug暴露无遗，但绿意盎然的“通过”则会将你从苦海中拯救！真是痛并快乐着！\n\n开学了后续大概会更新：\n\n- 部分学科的学习笔记（概率论和大物、计组等）\n- 简单的cpp项目\n- 每天一道leetcode\n- 全栈\n- 一些基本工具的巩固\n- 入门Linux\n\n我们未来见！:wave:\n\n{%endfold%}\n\n\n- 9.1\n  - 数电：概论，智能系统=算法+软件+**硬件**，复习信概**进制转换**等内容\n  - 概率论：概论，基本**集合符号使用**（与离散数学相似）\n  - 网球：概论，学校体育建设史（网球）\n  - JavaScript：以 cpp 基础速通基本语法\n- 9.2\n  - 大英：BBC 精听:arrow_forward::arrow_forward:饮食改善\n  - 大物：理想气体状态方程\n  - 毛中特：“教义是不谈条件的 方法是谈条件的”\n  - 数学文化：24春晚魔术:arrow_forward::arrow_forward:约瑟夫环\n  - 博客：完善Shell篇博客，增加示例代码\n- 9.3\n  -  程序设计综合实践取消，观看大阅兵\n  -  博客：将blog-img-article进行文件归类整理，提升未来图片管理效率\n  -  Github：新建仓库\"Hexo-Source\"，将博客源码进行迁移，便于mac/windows切换撰写博客\n- 9.4\n  -  数电：基本逻辑运算符\n  -  概率论：大数定律，条件概率\n  -  leetcode：侮辱人的每日一题:grinning: \n- 9.5\n  - 大物：理想气体自由度、动能、\n  - 数模：Q3创新点提出\n- 9.6\n  - 数模：完成Q1与Q2、Q3建模过程，Q4起头\n- 9.7\n  - 数模：仅仅生成md5码 未进行提交 参赛失败 功亏一篑\n- 9.8\n  - 数电：逻辑表达式的化简\n  - 概率论：全概率公式、贝叶斯公式\n- 9.9\n  - 大物（线上）：气体分子不同温度下速率分布\n  - 毛中特：毛泽东思想 && 毛泽东“的”思想 毛泽东思想的历史地位、活的灵魂\n- 9.10\n  - CSP:课程简介，须刷leetcode，课设项目\n- 9.11\n  - 数电：卡诺图化简\n  - 概率论：二项分布，伯努利实验、\n  - 物理实验：太阳能电池特性研究，接线较为简单\n  - 毛中特：“半殖民地”、“半封建”的价值评判\n- 9.12\n  - 大物：热学章节 等压等容等温变化\n  - leetcode 每日一题：再涉动态规划，对状态转移方程有点感觉了\n  - 博客：mac/windows 切换更新出 bug 似乎是mac的gitignore全局配置文件，导致无法部署（标签无法识别），无奈进行回滚，git果然还得是在慢慢debug的时候才能“精通”\n- 9.13\n  - 四史：87 顺利通过，主要是第几次会议混淆记不清楚\n  - Python：初涉Matplotlib\n  - leetcode：刷了昨天的[每日一题](https://leetcode.cn/problems/vowels-game-in-a-string?envType=daily-question&envId=2025-09-12)，感觉有点子抽象:grinning:\n\n","slug":"other/life-musings","published":1,"updated":"2025-09-13T06:28:50.501Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hct002d40w39hf00ckc","content":"<h1>Life-musings（精进日记）</h1>\n<p>记录每天的<strong>学习内容</strong> &amp;&amp; 博客未来<strong>更新方向</strong>！<br>\n保持更新的节奏！</p>\n<h2 id=\"2025\">2025</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-fb1ce71c\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-fb1ce71c\">\n        <div class=\"fold-arrow\">▶</div> Summer Vacation\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-fb1ce71c\">\n        <div class=\"fold-content\">\n          <h4 id=\"7-14\">7.14</h4><p>梦开始的地方！<br><strong>cool！</strong></p><h4 id=\"7-16\">7.16</h4><p>Turtle in Python 大win特win！</p><h4 id=\"7-17\">7.17</h4><p>昨晚备课到两点…<br>逐渐适应老师的身份！<br>制作课件的过程中也顺便二次学习Python语法！</p><h4 id=\"7-18\">7.18</h4><p>成功给 blog 添加 category 功能！</p><h4 id=\"7-22\">7.22</h4><p>上知网阅读相关论文，<strong>着手准备26大创pre</strong>！<br>在roboflow上找到几个感觉适配的<strong>数据集</strong>！<br>但是还是感觉有些缺失，需要自己想办法解决…</p><h4 id=\"7-23\">7.23</h4><p>参考数据结构教材，重新梳理了几种常见的<strong>排序算法的核心思路</strong>！<br>自己敲了敲各种排序算法的代码，interesting！</p><h4 id=\"7-24\">7.24</h4><p>试图给博客添加vercel进行<strong>自动化部署</strong>，<br>似乎不是很成功 😢</p><h4 id=\"7-25\">7.25</h4><p>UC Berkeley的CS61A！</p><h4 id=\"7-26\">7.26</h4><p>The Missing Semester of Your CS Education！<br><code>shell</code>篇，受益匪浅！</p><h4 id=\"7-27\">7.27</h4><p>先是赛车，再是足球！忙活一天！<br>回来总算是吧<code>shell</code>篇的博客写完了！<br>还顺带配置了博客 emoji 😄<br>以后终于不再是文文并茂了😢</p><h4 id=\"7-28\">7.28</h4><p>继续[missing semster]，学完了<code>vim</code>篇！</p><h4 id=\"7-29\">7.29</h4><p>完善<code>Git</code>篇！<br>捣鼓我的 mac！</p><h4 id=\"7-30\">7.30</h4><p>终于在 macbook 上成功配置博客环境！<br>单人多设备假装自己是多人协作开发大项目😄</p><h4 id=\"7-31\">7.31</h4><p>mac 中尝试在<code>vim</code>写、编译运行<code>c++</code>！<br><strong>skilled programmer</strong> 既视感😄</p><h4 id=\"8-1\">8.1</h4><p>入门<strong>dynamic programming</strong>！<br>祝好运😉</p><h4 id=\"8-7\">8.7</h4><p><strong>LaTex</strong>简单入门，优雅，太优雅了！😊<br>果然学习才是<strong>祛魅</strong>的最好方式！<br><strong>overleaf</strong>在线共享编辑，真是个好东西！😄</p><h4 id=\"8-8\">8.8</h4><p>LaTex 太灾难了😢<br>还是更喜欢<strong>WYSWYG</strong>😊</p><h4 id=\"8-9\">8.9</h4><p>LaTex 还得是在<strong>实战中学习</strong>！<br>但感觉花大量时间学习性价比不太高😢<br>AI辅助 LaTex就很舒服😀</p><h4 id=\"8-10\">8.10</h4><p>终于整完了，呼~~<br>要投身算法学习哩！<br>不能再依靠 life-musings 栏目苟延残喘更新速度了😡</p><h4 id=\"8-11\">8.11</h4><p>summer vacation assignment😡</p><h4 id=\"8-13\">8.13</h4><p>有点绷不住了😠<br>搞了一上午才将<strong>图床</strong>弄好<br>然后下午进行<strong>图片的迁移</strong>和博客照片中路径的修改~<br>对整个博客内容<strong>缝缝补补</strong>（其实是女娲补天😀）<br>将原来<code>生活随想录</code>栏目进行了拆分：</p><ul><li>精进日记 ➡️➡️ 偏学业</li><li>生活杂谈 ➡️➡️ 偏生活</li></ul><p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/20250813.png?raw=true\" alt=\"2025年8月13日23点10分Github截图\"></p><h4 id=\"8-14\">8.14</h4><p>进行更新HTML&amp;&amp;CSS的部分</p><h4 id=\"8-16\">8.16</h4><p>刷知乎看到一篇很好的帖子：<br><a href=\"https://www.zhihu.com/question/11379810074\">大一计算机新生怎么合理利用github？ - 知乎</a><br>后续努力方向！</p><p>完善Github主页readme文件<br>尝试使用开源代码丰富界面</p><p>再三尝试<strong>Vercel部署</strong>失败😢<br>能不能让我赢一次😢</p><h4 id=\"8-17\">8.17</h4><p>完善 HTML &amp;&amp; CSS 表单部分<br>yysy 感觉越写越多，CSS都要单开一栏目了😀<br>学习《Github从入门到实践》<br>丰富有关<code>Git</code>项目管理的笔记内容😄</p><h4 id=\"8-18\">8.18</h4><p>新开章节CSS！</p><h4 id=\"8-19\">8.19</h4><p>第一次尝试<strong>PR</strong>！<br>学习<code>flex</code>布局！</p><h4 id=\"8-20\">8.20</h4><p>无所事事！<br>这看看那看看的<br>一会儿看看 github 一会儿又去 leetcode<br>还没刷上题又去看 data analyse😢</p><h4 id=\"8-21\">8.21</h4><p>经提醒，发现CSDN博客上的图片转存失败，紧急进行修复！<br>顺便写了一篇关于PicGo插件配置Github图床的博客！<br>并计划回顾往期博客，完善格式，修复语病！<br>使用<strong>pandoc实行文档转换</strong>输出数学公式！<br><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/mathematical.png?raw=true\" alt=\"成功给博客配置数学公式结算画面\"></p><h4 id=\"8-22\">8.22</h4><p>新语法Get！给hexo增加<strong>折叠块</strong>的内容！<br>经常在YouTube上刷到动画风质感很好的封面：<br><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/Ghibli.jpeg?raw=true\" alt=\"Ghibli画风\"><br>今天才知道原来是<strong>吉卜力工作室的宫崎骏画风</strong>！<br>（不知道为啥在国内不是很火🔥 难道是版权问题🫤）<br>其实一开始看着就有点像AI改的，但是据我浅薄的了解：<br>这种文字程度的又不太像AI生成的（或许是我没用过更好的大模型吧）<br>用豆包试了试,感觉还不错,但跟想象略有出入😢</p><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">以这张图为基础，转化为吉卜力风格插画。采用吉卜力经典的高饱和度且自然和谐的色彩体系，像宫崎骏作品中常见的清新绿、湛蓝天空色等。画面笔触要细腻且有手绘质感，就如同吉卜力动画中一帧帧精心绘制的场景。保留所有的人物、建筑物等，营造出吉卜力式的奇幻氛围 ，光影柔和，突出主体，整体呈现出温暖治愈的感觉 。<br></code></pre></td></tr></tbody></table></figure><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">将此图重绘为吉卜力风格。保留原图主体动作与大致构图，色调调整为吉卜力偏好的明快且温馨的色调，比如用柔和的暖黄色光模拟夕阳洒下的效果。背景细节按照吉卜力风格丰富化，若有建筑，添加木质纹理与精致的装饰；若有自然场景，细化植物的形态与层次。线条干净流畅，具有明显的手绘痕迹，使整幅图宛如出自吉卜力工作室 。<br></code></pre></td></tr></tbody></table></figure><figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">参照此图，创作吉卜力风格画面。保留原图核心元素，将画面氛围塑造为吉卜力式的宁静而充满生机。色彩以清新淡雅为主，偶尔用鲜艳色彩作为点缀突出重点。绘制手法上，以干净利落的线条勾勒轮廓，再用细腻的色彩填充，展现出吉卜力动画那种精致的画面效果。光影处理成既有明亮的主光源，又有柔和的环境光，让整个场景看起来自然且生动 。保留人物物体的一致性。<br></code></pre></td></tr></tbody></table></figure><p>下午开新坑！回顾数据结构！</p><p>华数杯“优秀奖”，😢呜呜呜…<br>第一次在博客中引入pdf文件！</p><h4 id=\"8-23\">8.23</h4><p>继续复习栈和队列，未来会尝试将<strong>每种数据结构都实现一遍</strong>！</p><p>新博客栏目的<strong>宫崎骏画风封面</strong>感觉还不错！<br>就是显示文字依然乱码，十分费劲！<br>那大抵是要<strong>开ChatGPT会员</strong>罢！</p><p>密码的，吃完饭回来电脑竟然<strong>死机了</strong>😢<br>大概是开太多程序又长时间没有关机的缘故（多学学人家Mac 几周不关机也没事）<br>然后一通乱按又把键盘弄失灵了😢<br>弄俩小时才发现是误触 要<code>Fn</code>+<code>T</code><strong>切换到有线模式</strong>才行 太折磨了！</p><h4 id=\"8-24\">8.24</h4><p>开刷leetcode！<br>有种高中写圆锥曲线和导数大题的感觉😀<br>又折磨又兴奋 又菜又爱学没跑了😢</p><h4 id=\"8-25\">8.25</h4><p>c++修修补补<br>学习lambda表达式和auto用法</p><p>ChatGPT果然还是更胜一筹<br>“<strong>贵的东西的缺点只有贵</strong>”</p><h4 id=\"8-26\">8.26</h4><p>Hashtable Review!</p><p><strong>Sora绘图</strong>效果令人惊喜，可惜每日三次😢</p><p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/ChatGPT-Warning.png?raw=true\" alt=\"ChatGPT Warning!\"><br>猜的很对了，这下看懂了😀</p><p><strong>Update the published blog post!</strong></p><ul><li>为了<strong>方便阅读</strong>，给<strong>OJ题目设置了折叠块</strong></li><li>为了<strong>格式重点突出</strong>，给问题解答、分析板块增加不同颜色的<strong>标签note插件</strong></li></ul><h4 id=\"8-27\">8.27</h4><p>debug——<strong>ssh</strong>突然网络连接失败（CSDN✅）</p><p><strong>Sora绘图</strong>不知道为啥又<strong>无限制</strong>了😀<br>吸取之前被限制的教训，这次表达相当<strong>委婉</strong><br><strong>prompt</strong>详细一点，生图风格就相当<strong>awesome</strong>！</p><h4 id=\"8-28\">8.28</h4><p>学习<strong>结构化绑定</strong></p><p>依然Leetcode刷题，查漏补缺！</p><h4 id=\"8-29\">8.29</h4><p><strong>Leetcode</strong>！杨辉三角+优化<br>妙实在是妙！</p><p>将博客切换<code>en</code>英文版面</p><h4 id=\"8-31\">8.31</h4><p>双指针依然不能稳定AC嘛~</p><p>  8月暑假悄悄从指间溜走了~ 回顾整个暑假，从刚放假看国外公开课，学习一些简单的Tools，比如Github、Git、 Vim、Shell等，充实基础知识，作为科班生的底气了；旅游归来复习几个基本的数据结构，开刷leetcode，同时更新<code>Leetcode Mistake Collection</code>！时隔一年再次享受到到刷题的乐趣，无情的算法题会将你的思维+代码的bug暴露无遗，但绿意盎然的“通过”则会将你从苦海中拯救！真是痛并快乐着！</p><p>开学了后续大概会更新：</p><ul><li>部分学科的学习笔记（概率论和大物、计组等）</li><li>简单的cpp项目</li><li>每天一道leetcode</li><li>全栈</li><li>一些基本工具的巩固</li><li>入门Linux</li></ul><p>我们未来见！👋</p>\n        </div>\n      </div>\n    </div>\n<ul>\n<li>9.1\n<ul>\n<li>数电：概论，智能系统=算法+软件+<strong>硬件</strong>，复习信概<strong>进制转换</strong>等内容</li>\n<li>概率论：概论，基本<strong>集合符号使用</strong>（与离散数学相似）</li>\n<li>网球：概论，学校体育建设史（网球）</li>\n<li>JavaScript：以 cpp 基础速通基本语法</li>\n</ul>\n</li>\n<li>9.2\n<ul>\n<li>大英：BBC 精听▶️▶️饮食改善</li>\n<li>大物：理想气体状态方程</li>\n<li>毛中特：“教义是不谈条件的 方法是谈条件的”</li>\n<li>数学文化：24春晚魔术▶️▶️约瑟夫环</li>\n<li>博客：完善Shell篇博客，增加示例代码</li>\n</ul>\n</li>\n<li>9.3\n<ul>\n<li>程序设计综合实践取消，观看大阅兵</li>\n<li>博客：将blog-img-article进行文件归类整理，提升未来图片管理效率</li>\n<li>Github：新建仓库\"Hexo-Source\"，将博客源码进行迁移，便于mac/windows切换撰写博客</li>\n</ul>\n</li>\n<li>9.4\n<ul>\n<li>数电：基本逻辑运算符</li>\n<li>概率论：大数定律，条件概率</li>\n<li>leetcode：侮辱人的每日一题😀</li>\n</ul>\n</li>\n<li>9.5\n<ul>\n<li>大物：理想气体自由度、动能、</li>\n<li>数模：Q3创新点提出</li>\n</ul>\n</li>\n<li>9.6\n<ul>\n<li>数模：完成Q1与Q2、Q3建模过程，Q4起头</li>\n</ul>\n</li>\n<li>9.7\n<ul>\n<li>数模：仅仅生成md5码 未进行提交 参赛失败 功亏一篑</li>\n</ul>\n</li>\n<li>9.8\n<ul>\n<li>数电：逻辑表达式的化简</li>\n<li>概率论：全概率公式、贝叶斯公式</li>\n</ul>\n</li>\n<li>9.9\n<ul>\n<li>大物（线上）：气体分子不同温度下速率分布</li>\n<li>毛中特：毛泽东思想 &amp;&amp; 毛泽东“的”思想 毛泽东思想的历史地位、活的灵魂</li>\n</ul>\n</li>\n<li>9.10\n<ul>\n<li>CSP:课程简介，须刷leetcode，课设项目</li>\n</ul>\n</li>\n<li>9.11\n<ul>\n<li>数电：卡诺图化简</li>\n<li>概率论：二项分布，伯努利实验、</li>\n<li>物理实验：太阳能电池特性研究，接线较为简单</li>\n<li>毛中特：“半殖民地”、“半封建”的价值评判</li>\n</ul>\n</li>\n<li>9.12\n<ul>\n<li>大物：热学章节 等压等容等温变化</li>\n<li>leetcode 每日一题：再涉动态规划，对状态转移方程有点感觉了</li>\n<li>博客：mac/windows 切换更新出 bug 似乎是mac的gitignore全局配置文件，导致无法部署（标签无法识别），无奈进行回滚，git果然还得是在慢慢debug的时候才能“精通”</li>\n</ul>\n</li>\n<li>9.13\n<ul>\n<li>四史：87 顺利通过，主要是第几次会议混淆记不清楚</li>\n<li>Python：初涉Matplotlib</li>\n<li>leetcode：刷了昨天的<a href=\"https://leetcode.cn/problems/vowels-game-in-a-string?envType=daily-question&amp;envId=2025-09-12\">每日一题</a>，感觉有点子抽象😀</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1>Life-musings（精进日记）</h1>\n<p>记录每天的<strong>学习内容</strong> &amp;&amp; 博客未来<strong>更新方向</strong>！<br>\n保持更新的节奏！</p>\n<h2 id=\"2025\">2025</h2>\n\n    <div class=\"fold\">\n      <div class=\"fold-title fold-into collapsed\" data-toggle=\"collapse\" href=\"#collapse-fb1ce71c\" role=\"button\" aria-expanded=\"false\" aria-controls=\"collapse-fb1ce71c\">\n        <div class=\"fold-arrow\">▶</div> Summer Vacation\n      </div>\n      <div class=\"fold-collapse collapse\" id=\"collapse-fb1ce71c\">\n        <div class=\"fold-content\">\n          <h4 id=\"7-14\">7.14</h4><p>梦开始的地方！<br><strong>cool！</strong></p><h4 id=\"7-16\">7.16</h4><p>Turtle in Python 大win特win！</p><h4 id=\"7-17\">7.17</h4><p>昨晚备课到两点…<br>逐渐适应老师的身份！<br>制作课件的过程中也顺便二次学习Python语法！</p><h4 id=\"7-18\">7.18</h4><p>成功给 blog 添加 category 功能！</p><h4 id=\"7-22\">7.22</h4><p>上知网阅读相关论文，<strong>着手准备26大创pre</strong>！<br>在roboflow上找到几个感觉适配的<strong>数据集</strong>！<br>但是还是感觉有些缺失，需要自己想办法解决…</p><h4 id=\"7-23\">7.23</h4><p>参考数据结构教材，重新梳理了几种常见的<strong>排序算法的核心思路</strong>！<br>自己敲了敲各种排序算法的代码，interesting！</p><h4 id=\"7-24\">7.24</h4><p>试图给博客添加vercel进行<strong>自动化部署</strong>，<br>似乎不是很成功 😢</p><h4 id=\"7-25\">7.25</h4><p>UC Berkeley的CS61A！</p><h4 id=\"7-26\">7.26</h4><p>The Missing Semester of Your CS Education！<br><code>shell</code>篇，受益匪浅！</p><h4 id=\"7-27\">7.27</h4><p>先是赛车，再是足球！忙活一天！<br>回来总算是吧<code>shell</code>篇的博客写完了！<br>还顺带配置了博客 emoji 😄<br>以后终于不再是文文并茂了😢</p><h4 id=\"7-28\">7.28</h4><p>继续[missing semster]，学完了<code>vim</code>篇！</p><h4 id=\"7-29\">7.29</h4><p>完善<code>Git</code>篇！<br>捣鼓我的 mac！</p><h4 id=\"7-30\">7.30</h4><p>终于在 macbook 上成功配置博客环境！<br>单人多设备假装自己是多人协作开发大项目😄</p><h4 id=\"7-31\">7.31</h4><p>mac 中尝试在<code>vim</code>写、编译运行<code>c++</code>！<br><strong>skilled programmer</strong> 既视感😄</p><h4 id=\"8-1\">8.1</h4><p>入门<strong>dynamic programming</strong>！<br>祝好运😉</p><h4 id=\"8-7\">8.7</h4><p><strong>LaTex</strong>简单入门，优雅，太优雅了！😊<br>果然学习才是<strong>祛魅</strong>的最好方式！<br><strong>overleaf</strong>在线共享编辑，真是个好东西！😄</p><h4 id=\"8-8\">8.8</h4><p>LaTex 太灾难了😢<br>还是更喜欢<strong>WYSWYG</strong>😊</p><h4 id=\"8-9\">8.9</h4><p>LaTex 还得是在<strong>实战中学习</strong>！<br>但感觉花大量时间学习性价比不太高😢<br>AI辅助 LaTex就很舒服😀</p><h4 id=\"8-10\">8.10</h4><p>终于整完了，呼~~<br>要投身算法学习哩！<br>不能再依靠 life-musings 栏目苟延残喘更新速度了😡</p><h4 id=\"8-11\">8.11</h4><p>summer vacation assignment😡</p><h4 id=\"8-13\">8.13</h4><p>有点绷不住了😠<br>搞了一上午才将<strong>图床</strong>弄好<br>然后下午进行<strong>图片的迁移</strong>和博客照片中路径的修改~<br>对整个博客内容<strong>缝缝补补</strong>（其实是女娲补天😀）<br>将原来<code>生活随想录</code>栏目进行了拆分：</p><ul><li>精进日记 ➡️➡️ 偏学业</li><li>生活杂谈 ➡️➡️ 偏生活</li></ul><p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/20250813.png?raw=true\" alt=\"2025年8月13日23点10分Github截图\"></p><h4 id=\"8-14\">8.14</h4><p>进行更新HTML&amp;&amp;CSS的部分</p><h4 id=\"8-16\">8.16</h4><p>刷知乎看到一篇很好的帖子：<br><a href=\"https://www.zhihu.com/question/11379810074\">大一计算机新生怎么合理利用github？ - 知乎</a><br>后续努力方向！</p><p>完善Github主页readme文件<br>尝试使用开源代码丰富界面</p><p>再三尝试<strong>Vercel部署</strong>失败😢<br>能不能让我赢一次😢</p><h4 id=\"8-17\">8.17</h4><p>完善 HTML &amp;&amp; CSS 表单部分<br>yysy 感觉越写越多，CSS都要单开一栏目了😀<br>学习《Github从入门到实践》<br>丰富有关<code>Git</code>项目管理的笔记内容😄</p><h4 id=\"8-18\">8.18</h4><p>新开章节CSS！</p><h4 id=\"8-19\">8.19</h4><p>第一次尝试<strong>PR</strong>！<br>学习<code>flex</code>布局！</p><h4 id=\"8-20\">8.20</h4><p>无所事事！<br>这看看那看看的<br>一会儿看看 github 一会儿又去 leetcode<br>还没刷上题又去看 data analyse😢</p><h4 id=\"8-21\">8.21</h4><p>经提醒，发现CSDN博客上的图片转存失败，紧急进行修复！<br>顺便写了一篇关于PicGo插件配置Github图床的博客！<br>并计划回顾往期博客，完善格式，修复语病！<br>使用<strong>pandoc实行文档转换</strong>输出数学公式！<br><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/mathematical.png?raw=true\" alt=\"成功给博客配置数学公式结算画面\"></p><h4 id=\"8-22\">8.22</h4><p>新语法Get！给hexo增加<strong>折叠块</strong>的内容！<br>经常在YouTube上刷到动画风质感很好的封面：<br><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/Ghibli.jpeg?raw=true\" alt=\"Ghibli画风\"><br>今天才知道原来是<strong>吉卜力工作室的宫崎骏画风</strong>！<br>（不知道为啥在国内不是很火🔥 难道是版权问题🫤）<br>其实一开始看着就有点像AI改的，但是据我浅薄的了解：<br>这种文字程度的又不太像AI生成的（或许是我没用过更好的大模型吧）<br>用豆包试了试,感觉还不错,但跟想象略有出入😢</p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">以这张图为基础，转化为吉卜力风格插画。采用吉卜力经典的高饱和度且自然和谐的色彩体系，像宫崎骏作品中常见的清新绿、湛蓝天空色等。画面笔触要细腻且有手绘质感，就如同吉卜力动画中一帧帧精心绘制的场景。保留所有的人物、建筑物等，营造出吉卜力式的奇幻氛围 ，光影柔和，突出主体，整体呈现出温暖治愈的感觉 。<br></code></pre></td></tr></table></figure><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">将此图重绘为吉卜力风格。保留原图主体动作与大致构图，色调调整为吉卜力偏好的明快且温馨的色调，比如用柔和的暖黄色光模拟夕阳洒下的效果。背景细节按照吉卜力风格丰富化，若有建筑，添加木质纹理与精致的装饰；若有自然场景，细化植物的形态与层次。线条干净流畅，具有明显的手绘痕迹，使整幅图宛如出自吉卜力工作室 。<br></code></pre></td></tr></table></figure><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs textinfo\">参照此图，创作吉卜力风格画面。保留原图核心元素，将画面氛围塑造为吉卜力式的宁静而充满生机。色彩以清新淡雅为主，偶尔用鲜艳色彩作为点缀突出重点。绘制手法上，以干净利落的线条勾勒轮廓，再用细腻的色彩填充，展现出吉卜力动画那种精致的画面效果。光影处理成既有明亮的主光源，又有柔和的环境光，让整个场景看起来自然且生动 。保留人物物体的一致性。<br></code></pre></td></tr></table></figure><p>下午开新坑！回顾数据结构！</p><p>华数杯“优秀奖”，😢呜呜呜…<br>第一次在博客中引入pdf文件！</p><h4 id=\"8-23\">8.23</h4><p>继续复习栈和队列，未来会尝试将<strong>每种数据结构都实现一遍</strong>！</p><p>新博客栏目的<strong>宫崎骏画风封面</strong>感觉还不错！<br>就是显示文字依然乱码，十分费劲！<br>那大抵是要<strong>开ChatGPT会员</strong>罢！</p><p>密码的，吃完饭回来电脑竟然<strong>死机了</strong>😢<br>大概是开太多程序又长时间没有关机的缘故（多学学人家Mac 几周不关机也没事）<br>然后一通乱按又把键盘弄失灵了😢<br>弄俩小时才发现是误触 要<code>Fn</code>+<code>T</code><strong>切换到有线模式</strong>才行 太折磨了！</p><h4 id=\"8-24\">8.24</h4><p>开刷leetcode！<br>有种高中写圆锥曲线和导数大题的感觉😀<br>又折磨又兴奋 又菜又爱学没跑了😢</p><h4 id=\"8-25\">8.25</h4><p>c++修修补补<br>学习lambda表达式和auto用法</p><p>ChatGPT果然还是更胜一筹<br>“<strong>贵的东西的缺点只有贵</strong>”</p><h4 id=\"8-26\">8.26</h4><p>Hashtable Review!</p><p><strong>Sora绘图</strong>效果令人惊喜，可惜每日三次😢</p><p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/General/life-musings/ChatGPT-Warning.png?raw=true\" alt=\"ChatGPT Warning!\"><br>猜的很对了，这下看懂了😀</p><p><strong>Update the published blog post!</strong></p><ul><li>为了<strong>方便阅读</strong>，给<strong>OJ题目设置了折叠块</strong></li><li>为了<strong>格式重点突出</strong>，给问题解答、分析板块增加不同颜色的<strong>标签note插件</strong></li></ul><h4 id=\"8-27\">8.27</h4><p>debug——<strong>ssh</strong>突然网络连接失败（CSDN✅）</p><p><strong>Sora绘图</strong>不知道为啥又<strong>无限制</strong>了😀<br>吸取之前被限制的教训，这次表达相当<strong>委婉</strong><br><strong>prompt</strong>详细一点，生图风格就相当<strong>awesome</strong>！</p><h4 id=\"8-28\">8.28</h4><p>学习<strong>结构化绑定</strong></p><p>依然Leetcode刷题，查漏补缺！</p><h4 id=\"8-29\">8.29</h4><p><strong>Leetcode</strong>！杨辉三角+优化<br>妙实在是妙！</p><p>将博客切换<code>en</code>英文版面</p><h4 id=\"8-31\">8.31</h4><p>双指针依然不能稳定AC嘛~</p><p>  8月暑假悄悄从指间溜走了~ 回顾整个暑假，从刚放假看国外公开课，学习一些简单的Tools，比如Github、Git、 Vim、Shell等，充实基础知识，作为科班生的底气了；旅游归来复习几个基本的数据结构，开刷leetcode，同时更新<code>Leetcode Mistake Collection</code>！时隔一年再次享受到到刷题的乐趣，无情的算法题会将你的思维+代码的bug暴露无遗，但绿意盎然的“通过”则会将你从苦海中拯救！真是痛并快乐着！</p><p>开学了后续大概会更新：</p><ul><li>部分学科的学习笔记（概率论和大物、计组等）</li><li>简单的cpp项目</li><li>每天一道leetcode</li><li>全栈</li><li>一些基本工具的巩固</li><li>入门Linux</li></ul><p>我们未来见！👋</p>\n        </div>\n      </div>\n    </div>\n<ul>\n<li>9.1\n<ul>\n<li>数电：概论，智能系统=算法+软件+<strong>硬件</strong>，复习信概<strong>进制转换</strong>等内容</li>\n<li>概率论：概论，基本<strong>集合符号使用</strong>（与离散数学相似）</li>\n<li>网球：概论，学校体育建设史（网球）</li>\n<li>JavaScript：以 cpp 基础速通基本语法</li>\n</ul>\n</li>\n<li>9.2\n<ul>\n<li>大英：BBC 精听▶️▶️饮食改善</li>\n<li>大物：理想气体状态方程</li>\n<li>毛中特：“教义是不谈条件的 方法是谈条件的”</li>\n<li>数学文化：24春晚魔术▶️▶️约瑟夫环</li>\n<li>博客：完善Shell篇博客，增加示例代码</li>\n</ul>\n</li>\n<li>9.3\n<ul>\n<li>程序设计综合实践取消，观看大阅兵</li>\n<li>博客：将blog-img-article进行文件归类整理，提升未来图片管理效率</li>\n<li>Github：新建仓库&quot;Hexo-Source&quot;，将博客源码进行迁移，便于mac/windows切换撰写博客</li>\n</ul>\n</li>\n<li>9.4\n<ul>\n<li>数电：基本逻辑运算符</li>\n<li>概率论：大数定律，条件概率</li>\n<li>leetcode：侮辱人的每日一题😀</li>\n</ul>\n</li>\n<li>9.5\n<ul>\n<li>大物：理想气体自由度、动能、</li>\n<li>数模：Q3创新点提出</li>\n</ul>\n</li>\n<li>9.6\n<ul>\n<li>数模：完成Q1与Q2、Q3建模过程，Q4起头</li>\n</ul>\n</li>\n<li>9.7\n<ul>\n<li>数模：仅仅生成md5码 未进行提交 参赛失败 功亏一篑</li>\n</ul>\n</li>\n<li>9.8\n<ul>\n<li>数电：逻辑表达式的化简</li>\n<li>概率论：全概率公式、贝叶斯公式</li>\n</ul>\n</li>\n<li>9.9\n<ul>\n<li>大物（线上）：气体分子不同温度下速率分布</li>\n<li>毛中特：毛泽东思想 &amp;&amp; 毛泽东“的”思想 毛泽东思想的历史地位、活的灵魂</li>\n</ul>\n</li>\n<li>9.10\n<ul>\n<li>CSP:课程简介，须刷leetcode，课设项目</li>\n</ul>\n</li>\n<li>9.11\n<ul>\n<li>数电：卡诺图化简</li>\n<li>概率论：二项分布，伯努利实验、</li>\n<li>物理实验：太阳能电池特性研究，接线较为简单</li>\n<li>毛中特：“半殖民地”、“半封建”的价值评判</li>\n</ul>\n</li>\n<li>9.12\n<ul>\n<li>大物：热学章节 等压等容等温变化</li>\n<li>leetcode 每日一题：再涉动态规划，对状态转移方程有点感觉了</li>\n<li>博客：mac/windows 切换更新出 bug 似乎是mac的gitignore全局配置文件，导致无法部署（标签无法识别），无奈进行回滚，git果然还得是在慢慢debug的时候才能“精通”</li>\n</ul>\n</li>\n<li>9.13\n<ul>\n<li>四史：87 顺利通过，主要是第几次会议混淆记不清楚</li>\n<li>Python：初涉Matplotlib</li>\n<li>leetcode：刷了昨天的<a href=\"https://leetcode.cn/problems/vowels-game-in-a-string?envType=daily-question&amp;envId=2025-09-12\">每日一题</a>，感觉有点子抽象😀</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Hello World！","date":"2025-04-30T16:00:00.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/hello-world.png","description":"My First Blogging Experience, A Complete Guide to Writing and Updating Posts!","_content":"\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post(创建新文章)\n\n``` bash\nhexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server(启动本地服务器)\n\n``` bash\nhexo server\n```\n会出现\n```bash\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop\n```\n这样就可以在本地服务器上进行测试了！\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Wipe cache partition(清理缓存)\n\n``` bash\nhexo clean\n```\n\n### Generate static files(生成静态文件)\n\n``` bash\nhexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites(部署到github远程站点)\n\n``` bash\nhexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### Integrate (将上述步骤简化为一个命令行操作)\n``` bash\nhexo clean && hexo g && hexo d\n```\n``` bash\nhexo clean && hexo g && hexo s\n```\n封面来源：[Alan Walker & Torine - Hello World (Official Music Video)](https://www.youtube.com/watch?v=u7JMhVI7taQ&list=RDu7JMhVI7taQ&start_radio=1)","source":"_posts/other/hello-world.md","raw":"---\ntitle: Hello World！\ndate: 2025-05-01 00:00:00\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/hello-world.png\ndescription: My First Blogging Experience, A Complete Guide to Writing and Updating Posts!\n---\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post(创建新文章)\n\n``` bash\nhexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server(启动本地服务器)\n\n``` bash\nhexo server\n```\n会出现\n```bash\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop\n```\n这样就可以在本地服务器上进行测试了！\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Wipe cache partition(清理缓存)\n\n``` bash\nhexo clean\n```\n\n### Generate static files(生成静态文件)\n\n``` bash\nhexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites(部署到github远程站点)\n\n``` bash\nhexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### Integrate (将上述步骤简化为一个命令行操作)\n``` bash\nhexo clean && hexo g && hexo d\n```\n``` bash\nhexo clean && hexo g && hexo s\n```\n封面来源：[Alan Walker & Torine - Hello World (Official Music Video)](https://www.youtube.com/watch?v=u7JMhVI7taQ&list=RDu7JMhVI7taQ&start_radio=1)","slug":"other/hello-world","published":1,"updated":"2025-08-21T13:02:26.691Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcu002h40w3c7sa7t26","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post-创建新文章\">Create a new post(创建新文章)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo new <span class=\"hljs-string\">\"My New Post\"</span><br></code></pre></td></tr></tbody></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server-启动本地服务器\">Run server(启动本地服务器)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo server<br></code></pre></td></tr></tbody></table></figure>\n<p>会出现</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop<br></code></pre></td></tr></tbody></table></figure>\n<p>这样就可以在本地服务器上进行测试了！</p>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Wipe-cache-partition-清理缓存\">Wipe cache partition(清理缓存)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"Generate-static-files-生成静态文件\">Generate static files(生成静态文件)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></tbody></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-部署到github远程站点\">Deploy to remote sites(部署到github远程站点)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo deploy<br></code></pre></td></tr></tbody></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"Integrate-将上述步骤简化为一个命令行操作\">Integrate (将上述步骤简化为一个命令行操作)</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=u7JMhVI7taQ&amp;list=RDu7JMhVI7taQ&amp;start_radio=1\">Alan Walker &amp; Torine - Hello World (Official Music Video)</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\">Quick Start</h2>\n<h3 id=\"Create-a-new-post-创建新文章\">Create a new post(创建新文章)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server-启动本地服务器\">Run server(启动本地服务器)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo server<br></code></pre></td></tr></table></figure>\n<p>会出现</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop<br></code></pre></td></tr></table></figure>\n<p>这样就可以在本地服务器上进行测试了！</p>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Wipe-cache-partition-清理缓存\">Wipe cache partition(清理缓存)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean<br></code></pre></td></tr></table></figure>\n<h3 id=\"Generate-static-files-生成静态文件\">Generate static files(生成静态文件)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites-部署到github远程站点\">Deploy to remote sites(部署到github远程站点)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo deploy<br></code></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"Integrate-将上述步骤简化为一个命令行操作\">Integrate (将上述步骤简化为一个命令行操作)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=u7JMhVI7taQ&amp;list=RDu7JMhVI7taQ&amp;start_radio=1\">Alan Walker &amp; Torine - Hello World (Official Music Video)</a></p>\n"},{"title":"GitHub Connection Deep Dive","date":"2025-08-27T06:25:40.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/GithubConnection.png?raw=true","category_bar":true,"description":"Triggered by an SSH connection failure to GitHub, this article explores and explains the methods for connecting to GitHub—including via HTTPS and SSH.","_content":"\n今天在将hexo博客进行部署的时候突然发生以下报错：\n\n```bash\nssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html\nError: Spawn failed\n    at ChildProcess.<anonymous> (E:\\Hexo-backup\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:51:21)\n    at ChildProcess.emit (node:events:518:28)\n    at cp.emit (E:\\Hexo-backup\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)\n    at ChildProcess._handle.onexit (node:internal/child_process:293:12)\n```\n\n在CSDN找到相应问题文档，才成功解决！[git报错ssh: connect to host github.com port 22: Connection timed out](https://blog.csdn.net/nightwishh/article/details/99647545?fromshare=blogdetail&sharetype=blogdetail&sharerId=99647545&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)\n\n## HTTPS\n## SSH\n","source":"_posts/Tutorial/GitHub-Connection-Deep-Dive.md","raw":"---\ntitle: GitHub Connection Deep Dive\ndate: 2025-08-27 14:25:40\ntags: [Github,updating]\nindex_img: https://github.com/Richard110206/Blog-image/blob/main/cover/GithubConnection.png?raw=true\ncategory: Tutorial\ncategory_bar: true\ndescription: Triggered by an SSH connection failure to GitHub, this article explores and explains the methods for connecting to GitHub—including via HTTPS and SSH.\n---\n\n今天在将hexo博客进行部署的时候突然发生以下报错：\n\n```bash\nssh: connect to host github.com port 22: Connection timed out\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\nFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html\nError: Spawn failed\n    at ChildProcess.<anonymous> (E:\\Hexo-backup\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:51:21)\n    at ChildProcess.emit (node:events:518:28)\n    at cp.emit (E:\\Hexo-backup\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)\n    at ChildProcess._handle.onexit (node:internal/child_process:293:12)\n```\n\n在CSDN找到相应问题文档，才成功解决！[git报错ssh: connect to host github.com port 22: Connection timed out](https://blog.csdn.net/nightwishh/article/details/99647545?fromshare=blogdetail&sharetype=blogdetail&sharerId=99647545&sharerefer=PC&sharesource=m0_53058983&sharefrom=from_link)\n\n## HTTPS\n## SSH\n","slug":"Tutorial/GitHub-Connection-Deep-Dive","published":1,"updated":"2025-08-27T08:34:47.598Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcu002j40w37mg722nr","content":"<p>今天在将hexo博客进行部署的时候突然发生以下报错：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh: connect to host github.com port 22: Connection timed out<br>fatal: Could not <span class=\"hljs-built_in\">read</span> from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something<span class=\"hljs-string\">'s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class=\"hljs-string\">Error: Spawn failed</span><br><span class=\"hljs-string\">    at ChildProcess.&lt;anonymous&gt; (E:\\Hexo-backup\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:51:21)</span><br><span class=\"hljs-string\">    at ChildProcess.emit (node:events:518:28)</span><br><span class=\"hljs-string\">    at cp.emit (E:\\Hexo-backup\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)</span><br><span class=\"hljs-string\">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span><br></code></pre></td></tr></tbody></table></figure>\n<p>在CSDN找到相应问题文档，才成功解决！<a href=\"https://blog.csdn.net/nightwishh/article/details/99647545?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=99647545&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">git报错ssh: connect to host github.com port 22: Connection timed out</a></p>\n<h2 id=\"HTTPS\">HTTPS</h2>\n<h2 id=\"SSH\">SSH</h2>\n","excerpt":"","more":"<p>今天在将hexo博客进行部署的时候突然发生以下报错：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ssh: connect to host github.com port 22: Connection timed out<br>fatal: Could not <span class=\"hljs-built_in\">read</span> from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something<span class=\"hljs-string\">&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class=\"hljs-string\">Error: Spawn failed</span><br><span class=\"hljs-string\">    at ChildProcess.&lt;anonymous&gt; (E:\\Hexo-backup\\node_modules\\hexo-deployer-git\\node_modules\\hexo-util\\lib\\spawn.js:51:21)</span><br><span class=\"hljs-string\">    at ChildProcess.emit (node:events:518:28)</span><br><span class=\"hljs-string\">    at cp.emit (E:\\Hexo-backup\\node_modules\\cross-spawn\\lib\\enoent.js:34:29)</span><br><span class=\"hljs-string\">    at ChildProcess._handle.onexit (node:internal/child_process:293:12)</span><br></code></pre></td></tr></table></figure>\n<p>在CSDN找到相应问题文档，才成功解决！<a href=\"https://blog.csdn.net/nightwishh/article/details/99647545?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=99647545&amp;sharerefer=PC&amp;sharesource=m0_53058983&amp;sharefrom=from_link\">git报错ssh: connect to host github.com port 22: Connection timed out</a></p>\n<h2 id=\"HTTPS\">HTTPS</h2>\n<h2 id=\"SSH\">SSH</h2>\n"},{"title":"Hexo,Unleash Your Blogging Magic","date":"2025-07-12T14:15:10.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover//Hexo-Hacks-Unleash-Your-Blogging-Magic.png","category_bar":true,"description":"This article briefly introduces the various ways to enrich your personal blog built with Hexo and the adaptation differences when writing blogs on different platforms.","_content":"\n\n## 一、玩转`Hexo`\n不同主题的Hexo主题博客，大致特点如下：\n| 主题       | 特点                          | \n|------------|-------------------------------|\n| **Fluid**  | 加载速度快，有简单的动态效果，移动端适配佳   | \n| **Butterfly** | 功能全面，社区活跃，高度可定制 |  |\n| **Landscape** | 默认主题，轻量级，简洁易上手（有较多限制）  | \n\n博主尝试了这几种后对`fluid`追一见钟情，遂使用此主题。\n### （一）更换主题\n**1. 安装 `Fluid` 主题**\n\n在 Hexo 博客根目录（`/HexoData`）运行：\n```bash\nnpm install --save hexo-theme-fluid\n```\n**2. 修改 `Hexo` 主配置**\n\n打开`_config.yml`（位于博客根目录），找到`theme`字段，修改为：\n\n```yaml\ntheme: fluid\n```\n如需要可以将 `language` 设置为中文：\n\n```yaml\nlanguage: zh-CN\n```\n**3. 创建 Fluid 的配置文件**\n\n`Fluid`主题的配置需要额外文件：\n在博客根目录下创建` _config.fluid.yml `文件：\n\n```bash\ncp node_modules/hexo-theme-fluid/_config.yml _config.fluid.yml\n```\n编辑` _config.fluid.yml `来自定义主题（如菜单、颜色、字体等）。\n\n**4. 迁移 Landscape 的内容（可选）**\n\n自定义样式/脚本：将 `Landscape` 的 `source/css` 或 `source/js` 文件复制到 `Fluid` 的 `source` 目录。\n文章/页面：`_posts` 和` _pages` 内容无需迁移，`Hexo` 会自动读取。\n\n**5. 清理并重新生成**\n```bash\nhexo clean && hexo g && hexo s\n```\n访问 <http://localhost:4000> 查看效果。\n### （二）添加评论系统\n[Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)](https://blog.csdn.net/Neter_Leon/article/details/107064603?ops_request_misc=&request_id=&biz_id=102&utm_term=hexo%E7%9A%84fulid%E4%B8%8D%E5%90%8C%E7%8E%A9%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107064603.142^v102^pc_search_result_base2&spm=1018.2226.3001.4187)\n注意`comments`在(`\\themes\\你的主题名\\_config.yml`)文件中，Hexo 主配置文件(`_config.yml`)通常用于全局配置（如博客标题、作者等），添加评论系统的配置不在这个文件中。将`appid`和`appkey`填入，同时记得根据选择的插件修改博客评论系统的`type`！\n### （三）添加背景音乐\n[Hexo-Fluid主题添加音乐页面](https://blog.csdn.net/weixin_43471926/article/details/109798928?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224db07d60e8ad014b04fcc3b6dc2a5cdf%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=4db07d60e8ad014b04fcc3b6dc2a5cdf&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109798928-null-null.142^v102^pc_search_result_base2&utm_term=hexo%20fluid%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90&spm=1018.2226.3001.4187)\n### （四）给每篇博客添加封面/背景\n在`source`文件夹下新建`medias`文件夹用于存放图片，在每篇博客文章` front-matter `的区域添加：\n**背景图片：**\n```markdown\nbanner_img: 图片路径（/medias/图片文件名）\n```\n**封面图片预览：**\n```markdown\nindex_img: 图片路径（/medias/图片文件名）\n```\n\n其他丰富玩法参考官方文档：\n- [开始使用 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/start/)\n- [配置指南 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/guide/)\n\n## 二、CSDN与Hexo撰写差异\n\n**1. 插入图片**\n插入图片的语法如下：`![插入图片的注释](插入图片的连接或本地路径)`\n&emsp;&emsp;CSDN 不支持本地图片链接：如果你在 CSDN 写博客时插入本地图片路径，其他用户无法访问你的本地文件。\n&emsp;&emsp;使用Hexo进行博客撰写时，图片可以放在`source/images/ 文件夹（可以自行创建）`使用相对路径，避免文件迁移后路径找不到而导致问题，建议一篇博客单独创建一个文件夹进行图片的存储便于管理。\n&emsp;&emsp;CSDN中的图片注释无法显示，必须通过在图片下添加`<center>添加图片注释</font</center>`的方式进行注释。\n><center>添加图片注释</font</center>\n\n&emsp;&emsp;网上其他博主也有推荐使用[七牛云存储](https://portal.qiniu.com/signin?redirect=%2Fhome)的，将图片从本地上传到七牛云存储仓库。得到一个外链地址，将外链地址作为图片的URL地址写进文章。\n\n**2.数学公式**\nCSDN中默认`latex`的格式是可以进行渲染的，而在`Hexo`中需要在全局配置文件中进行修改：\n```markdown\n  # 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式\n  # Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math\n  math:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`\n    # If you want to use math on the custom page, you need to set `math: true` in Front-matter\n    enable: true\n\n    # 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math\n    specific: false\n```\n\n封面来源：[如何使用Hexo+Github Pages 搭建个人博客，手把手最新教程](https://www.youtube.com/watch?v=XiMVwkxu3hU)\n\n\n","source":"_posts/Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic.md","raw":"---\ntitle: Hexo,Unleash Your Blogging Magic\ndate: 2025-07-12 22:15:10\ntags: [Hexo, Blogging]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover//Hexo-Hacks-Unleash-Your-Blogging-Magic.png\ncategory: Tutorial\ncategory_bar: true\ndescription: This article briefly introduces the various ways to enrich your personal blog built with Hexo and the adaptation differences when writing blogs on different platforms.\n---\n\n\n## 一、玩转`Hexo`\n不同主题的Hexo主题博客，大致特点如下：\n| 主题       | 特点                          | \n|------------|-------------------------------|\n| **Fluid**  | 加载速度快，有简单的动态效果，移动端适配佳   | \n| **Butterfly** | 功能全面，社区活跃，高度可定制 |  |\n| **Landscape** | 默认主题，轻量级，简洁易上手（有较多限制）  | \n\n博主尝试了这几种后对`fluid`追一见钟情，遂使用此主题。\n### （一）更换主题\n**1. 安装 `Fluid` 主题**\n\n在 Hexo 博客根目录（`/HexoData`）运行：\n```bash\nnpm install --save hexo-theme-fluid\n```\n**2. 修改 `Hexo` 主配置**\n\n打开`_config.yml`（位于博客根目录），找到`theme`字段，修改为：\n\n```yaml\ntheme: fluid\n```\n如需要可以将 `language` 设置为中文：\n\n```yaml\nlanguage: zh-CN\n```\n**3. 创建 Fluid 的配置文件**\n\n`Fluid`主题的配置需要额外文件：\n在博客根目录下创建` _config.fluid.yml `文件：\n\n```bash\ncp node_modules/hexo-theme-fluid/_config.yml _config.fluid.yml\n```\n编辑` _config.fluid.yml `来自定义主题（如菜单、颜色、字体等）。\n\n**4. 迁移 Landscape 的内容（可选）**\n\n自定义样式/脚本：将 `Landscape` 的 `source/css` 或 `source/js` 文件复制到 `Fluid` 的 `source` 目录。\n文章/页面：`_posts` 和` _pages` 内容无需迁移，`Hexo` 会自动读取。\n\n**5. 清理并重新生成**\n```bash\nhexo clean && hexo g && hexo s\n```\n访问 <http://localhost:4000> 查看效果。\n### （二）添加评论系统\n[Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)](https://blog.csdn.net/Neter_Leon/article/details/107064603?ops_request_misc=&request_id=&biz_id=102&utm_term=hexo%E7%9A%84fulid%E4%B8%8D%E5%90%8C%E7%8E%A9%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107064603.142^v102^pc_search_result_base2&spm=1018.2226.3001.4187)\n注意`comments`在(`\\themes\\你的主题名\\_config.yml`)文件中，Hexo 主配置文件(`_config.yml`)通常用于全局配置（如博客标题、作者等），添加评论系统的配置不在这个文件中。将`appid`和`appkey`填入，同时记得根据选择的插件修改博客评论系统的`type`！\n### （三）添加背景音乐\n[Hexo-Fluid主题添加音乐页面](https://blog.csdn.net/weixin_43471926/article/details/109798928?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224db07d60e8ad014b04fcc3b6dc2a5cdf%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=4db07d60e8ad014b04fcc3b6dc2a5cdf&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109798928-null-null.142^v102^pc_search_result_base2&utm_term=hexo%20fluid%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90&spm=1018.2226.3001.4187)\n### （四）给每篇博客添加封面/背景\n在`source`文件夹下新建`medias`文件夹用于存放图片，在每篇博客文章` front-matter `的区域添加：\n**背景图片：**\n```markdown\nbanner_img: 图片路径（/medias/图片文件名）\n```\n**封面图片预览：**\n```markdown\nindex_img: 图片路径（/medias/图片文件名）\n```\n\n其他丰富玩法参考官方文档：\n- [开始使用 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/start/)\n- [配置指南 | Hexo Fluid 用户手册](https://fluid-dev.github.io/hexo-fluid-docs/guide/)\n\n## 二、CSDN与Hexo撰写差异\n\n**1. 插入图片**\n插入图片的语法如下：`![插入图片的注释](插入图片的连接或本地路径)`\n&emsp;&emsp;CSDN 不支持本地图片链接：如果你在 CSDN 写博客时插入本地图片路径，其他用户无法访问你的本地文件。\n&emsp;&emsp;使用Hexo进行博客撰写时，图片可以放在`source/images/ 文件夹（可以自行创建）`使用相对路径，避免文件迁移后路径找不到而导致问题，建议一篇博客单独创建一个文件夹进行图片的存储便于管理。\n&emsp;&emsp;CSDN中的图片注释无法显示，必须通过在图片下添加`<center>添加图片注释</font</center>`的方式进行注释。\n><center>添加图片注释</font</center>\n\n&emsp;&emsp;网上其他博主也有推荐使用[七牛云存储](https://portal.qiniu.com/signin?redirect=%2Fhome)的，将图片从本地上传到七牛云存储仓库。得到一个外链地址，将外链地址作为图片的URL地址写进文章。\n\n**2.数学公式**\nCSDN中默认`latex`的格式是可以进行渲染的，而在`Hexo`中需要在全局配置文件中进行修改：\n```markdown\n  # 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式\n  # Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math\n  math:\n    # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`\n    # If you want to use math on the custom page, you need to set `math: true` in Front-matter\n    enable: true\n\n    # 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度\n    # If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math\n    specific: false\n```\n\n封面来源：[如何使用Hexo+Github Pages 搭建个人博客，手把手最新教程](https://www.youtube.com/watch?v=XiMVwkxu3hU)\n\n\n","slug":"Tutorial/Hexo-Hacks-Unleash-Your-Blogging-Magic","published":1,"updated":"2025-08-21T09:48:26.720Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcv002o40w3bdd0bzd2","content":"<h2 id=\"一、玩转Hexo\">一、玩转<code>Hexo</code></h2>\n<p>不同主题的Hexo主题博客，大致特点如下：</p>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Fluid</strong></td>\n<td>加载速度快，有简单的动态效果，移动端适配佳</td>\n</tr>\n<tr>\n<td><strong>Butterfly</strong></td>\n<td>功能全面，社区活跃，高度可定制</td>\n</tr>\n<tr>\n<td><strong>Landscape</strong></td>\n<td>默认主题，轻量级，简洁易上手（有较多限制）</td>\n</tr>\n</tbody>\n</table>\n<p>博主尝试了这几种后对<code>fluid</code>追一见钟情，遂使用此主题。</p>\n<h3 id=\"（一）更换主题\">（一）更换主题</h3>\n<p><strong>1. 安装 <code>Fluid</code> 主题</strong></p>\n<p>在 Hexo 博客根目录（<code>/HexoData</code>）运行：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></tbody></table></figure>\n<p><strong>2. 修改 <code>Hexo</code> 主配置</strong></p>\n<p>打开<code>_config.yml</code>（位于博客根目录），找到<code>theme</code>字段，修改为：</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></tbody></table></figure>\n<p>如需要可以将 <code>language</code> 设置为中文：</p>\n<figure class=\"highlight yaml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>3. 创建 Fluid 的配置文件</strong></p>\n<p><code>Fluid</code>主题的配置需要额外文件：<br>\n在博客根目录下创建<code>_config.fluid.yml</code>文件：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cp</span> node_modules/hexo-theme-fluid/_config.yml _config.fluid.yml<br></code></pre></td></tr></tbody></table></figure>\n<p>编辑<code>_config.fluid.yml</code>来自定义主题（如菜单、颜色、字体等）。</p>\n<p><strong>4. 迁移 Landscape 的内容（可选）</strong></p>\n<p>自定义样式/脚本：将 <code>Landscape</code> 的 <code>source/css</code> 或 <code>source/js</code> 文件复制到 <code>Fluid</code> 的 <code>source</code> 目录。<br>\n文章/页面：<code>_posts</code> 和<code> _pages</code> 内容无需迁移，<code>Hexo</code> 会自动读取。</p>\n<p><strong>5. 清理并重新生成</strong></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></tbody></table></figure>\n<p>访问 <a href=\"http://localhost:4000\">http://localhost:4000</a> 查看效果。</p>\n<h3 id=\"（二）添加评论系统\">（二）添加评论系统</h3>\n<p><a href=\"https://blog.csdn.net/Neter_Leon/article/details/107064603?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%E7%9A%84fulid%E4%B8%8D%E5%90%8C%E7%8E%A9%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107064603.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)</a><br>\n注意<code>comments</code>在(<code>\\themes\\你的主题名\\_config.yml</code>)文件中，Hexo 主配置文件(<code>_config.yml</code>)通常用于全局配置（如博客标题、作者等），添加评论系统的配置不在这个文件中。将<code>appid</code>和<code>appkey</code>填入，同时记得根据选择的插件修改博客评论系统的<code>type</code>！</p>\n<h3 id=\"（三）添加背景音乐\">（三）添加背景音乐</h3>\n<p><a href=\"https://blog.csdn.net/weixin_43471926/article/details/109798928?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224db07d60e8ad014b04fcc3b6dc2a5cdf%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=4db07d60e8ad014b04fcc3b6dc2a5cdf&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109798928-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=hexo%20fluid%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90&amp;spm=1018.2226.3001.4187\">Hexo-Fluid主题添加音乐页面</a></p>\n<h3 id=\"（四）给每篇博客添加封面-背景\">（四）给每篇博客添加封面/背景</h3>\n<p>在<code>source</code>文件夹下新建<code>medias</code>文件夹用于存放图片，在每篇博客文章<code>front-matter</code>的区域添加：<br>\n<strong>背景图片：</strong></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">banner<span class=\"hljs-emphasis\">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>封面图片预览：</strong></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">index<span class=\"hljs-emphasis\">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></tbody></table></figure>\n<p>其他丰富玩法参考官方文档：</p>\n<ul>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/\">开始使用 | Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/guide/\">配置指南 | Hexo Fluid 用户手册</a></li>\n</ul>\n<h2 id=\"二、CSDN与Hexo撰写差异\">二、CSDN与Hexo撰写差异</h2>\n<p><strong>1. 插入图片</strong><br>\n插入图片的语法如下：<code>![插入图片的注释](插入图片的连接或本地路径)</code><br>\n  CSDN 不支持本地图片链接：如果你在 CSDN 写博客时插入本地图片路径，其他用户无法访问你的本地文件。<br>\n  使用Hexo进行博客撰写时，图片可以放在<code>source/images/ 文件夹（可以自行创建）</code>使用相对路径，避免文件迁移后路径找不到而导致问题，建议一篇博客单独创建一个文件夹进行图片的存储便于管理。<br>\n  CSDN中的图片注释无法显示，必须通过在图片下添加<code>&lt;center&gt;添加图片注释&lt;/font&lt;/center&gt;</code>的方式进行注释。</p>\n<blockquote>\n<center>添加图片注释\n</center></blockquote>\n<p>  网上其他博主也有推荐使用<a href=\"https://portal.qiniu.com/signin?redirect=%2Fhome\">七牛云存储</a>的，将图片从本地上传到七牛云存储仓库。得到一个外链地址，将外链地址作为图片的URL地址写进文章。</p>\n<p><strong>2.数学公式</strong><br>\nCSDN中默认<code>latex</code>的格式是可以进行渲染的，而在<code>Hexo</code>中需要在全局配置文件中进行修改：</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br><span class=\"hljs-section\"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>math:<br>  # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 <span class=\"hljs-code\">`math: true`</span><br>  # If you want to use math on the custom page, you need to set <span class=\"hljs-code\">`math: true`</span> in Front-matter<br>  enable: true<br><br>  # 开启后，只有在文章 Front-matter 里指定 <span class=\"hljs-code\">`math: true`</span> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度<br>  # If true, only set <span class=\"hljs-code\">`math: true`</span> in Front-matter will enable math, to load faster when the page does not contain math<br>  specific: false<br></code></pre></td></tr></tbody></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=XiMVwkxu3hU\">如何使用Hexo+Github Pages 搭建个人博客，手把手最新教程</a></p>\n","excerpt":"","more":"<h2 id=\"一、玩转Hexo\">一、玩转<code>Hexo</code></h2>\n<p>不同主题的Hexo主题博客，大致特点如下：</p>\n<table>\n<thead>\n<tr>\n<th>主题</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Fluid</strong></td>\n<td>加载速度快，有简单的动态效果，移动端适配佳</td>\n</tr>\n<tr>\n<td><strong>Butterfly</strong></td>\n<td>功能全面，社区活跃，高度可定制</td>\n</tr>\n<tr>\n<td><strong>Landscape</strong></td>\n<td>默认主题，轻量级，简洁易上手（有较多限制）</td>\n</tr>\n</tbody>\n</table>\n<p>博主尝试了这几种后对<code>fluid</code>追一见钟情，遂使用此主题。</p>\n<h3 id=\"（一）更换主题\">（一）更换主题</h3>\n<p><strong>1. 安装 <code>Fluid</code> 主题</strong></p>\n<p>在 Hexo 博客根目录（<code>/HexoData</code>）运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure>\n<p><strong>2. 修改 <code>Hexo</code> 主配置</strong></p>\n<p>打开<code>_config.yml</code>（位于博客根目录），找到<code>theme</code>字段，修改为：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">theme:</span> <span class=\"hljs-string\">fluid</span><br></code></pre></td></tr></table></figure>\n<p>如需要可以将 <code>language</code> 设置为中文：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">language:</span> <span class=\"hljs-string\">zh-CN</span><br></code></pre></td></tr></table></figure>\n<p><strong>3. 创建 Fluid 的配置文件</strong></p>\n<p><code>Fluid</code>主题的配置需要额外文件：<br>\n在博客根目录下创建<code>_config.fluid.yml</code>文件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">cp</span> node_modules/hexo-theme-fluid/_config.yml _config.fluid.yml<br></code></pre></td></tr></table></figure>\n<p>编辑<code>_config.fluid.yml</code>来自定义主题（如菜单、颜色、字体等）。</p>\n<p><strong>4. 迁移 Landscape 的内容（可选）</strong></p>\n<p>自定义样式/脚本：将 <code>Landscape</code> 的 <code>source/css</code> 或 <code>source/js</code> 文件复制到 <code>Fluid</code> 的 <code>source</code> 目录。<br>\n文章/页面：<code>_posts</code> 和<code> _pages</code> 内容无需迁移，<code>Hexo</code> 会自动读取。</p>\n<p><strong>5. 清理并重新生成</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br></code></pre></td></tr></table></figure>\n<p>访问 <a href=\"http://localhost:4000\">http://localhost:4000</a> 查看效果。</p>\n<h3 id=\"（二）添加评论系统\">（二）添加评论系统</h3>\n<p><a href=\"https://blog.csdn.net/Neter_Leon/article/details/107064603?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%E7%9A%84fulid%E4%B8%8D%E5%90%8C%E7%8E%A9%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-107064603.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">Hexo快速构建个人小站-Fulid主题下添加Valine评论系统(三)</a><br>\n注意<code>comments</code>在(<code>\\themes\\你的主题名\\_config.yml</code>)文件中，Hexo 主配置文件(<code>_config.yml</code>)通常用于全局配置（如博客标题、作者等），添加评论系统的配置不在这个文件中。将<code>appid</code>和<code>appkey</code>填入，同时记得根据选择的插件修改博客评论系统的<code>type</code>！</p>\n<h3 id=\"（三）添加背景音乐\">（三）添加背景音乐</h3>\n<p><a href=\"https://blog.csdn.net/weixin_43471926/article/details/109798928?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224db07d60e8ad014b04fcc3b6dc2a5cdf%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=4db07d60e8ad014b04fcc3b6dc2a5cdf&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-109798928-null-null.142%5Ev102%5Epc_search_result_base2&amp;utm_term=hexo%20fluid%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%9F%B3%E4%B9%90&amp;spm=1018.2226.3001.4187\">Hexo-Fluid主题添加音乐页面</a></p>\n<h3 id=\"（四）给每篇博客添加封面-背景\">（四）给每篇博客添加封面/背景</h3>\n<p>在<code>source</code>文件夹下新建<code>medias</code>文件夹用于存放图片，在每篇博客文章<code>front-matter</code>的区域添加：<br>\n<strong>背景图片：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">banner<span class=\"hljs-emphasis\">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></table></figure>\n<p><strong>封面图片预览：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">index<span class=\"hljs-emphasis\">_img: 图片路径（/medias/图片文件名）</span><br></code></pre></td></tr></table></figure>\n<p>其他丰富玩法参考官方文档：</p>\n<ul>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/start/\">开始使用 | Hexo Fluid 用户手册</a></li>\n<li><a href=\"https://fluid-dev.github.io/hexo-fluid-docs/guide/\">配置指南 | Hexo Fluid 用户手册</a></li>\n</ul>\n<h2 id=\"二、CSDN与Hexo撰写差异\">二、CSDN与Hexo撰写差异</h2>\n<p><strong>1. 插入图片</strong><br>\n插入图片的语法如下：<code>![插入图片的注释](插入图片的连接或本地路径)</code><br>\n  CSDN 不支持本地图片链接：如果你在 CSDN 写博客时插入本地图片路径，其他用户无法访问你的本地文件。<br>\n  使用Hexo进行博客撰写时，图片可以放在<code>source/images/ 文件夹（可以自行创建）</code>使用相对路径，避免文件迁移后路径找不到而导致问题，建议一篇博客单独创建一个文件夹进行图片的存储便于管理。<br>\n  CSDN中的图片注释无法显示，必须通过在图片下添加<code>&lt;center&gt;添加图片注释&lt;/font&lt;/center&gt;</code>的方式进行注释。</p>\n<blockquote>\n<center>添加图片注释</font</center>\n</blockquote>\n<p>  网上其他博主也有推荐使用<a href=\"https://portal.qiniu.com/signin?redirect=%2Fhome\">七牛云存储</a>的，将图片从本地上传到七牛云存储仓库。得到一个外链地址，将外链地址作为图片的URL地址写进文章。</p>\n<p><strong>2.数学公式</strong><br>\nCSDN中默认<code>latex</code>的格式是可以进行渲染的，而在<code>Hexo</code>中需要在全局配置文件中进行修改：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># 数学公式，开启之前需要更换 Markdown 渲染器，否则复杂公式会有兼容问题，具体请见：https://hexo.fluid-dev.com/docs/guide/##latex-数学公式</span><br><span class=\"hljs-section\"># Mathematical formula. If enable, you need to change the Markdown renderer, see: https://hexo.fluid-dev.com/docs/en/guide/#math</span><br>math:<br>  # 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 <span class=\"hljs-code\">`math: true`</span><br>  # If you want to use math on the custom page, you need to set <span class=\"hljs-code\">`math: true`</span> in Front-matter<br>  enable: true<br><br>  # 开启后，只有在文章 Front-matter 里指定 <span class=\"hljs-code\">`math: true`</span> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度<br>  # If true, only set <span class=\"hljs-code\">`math: true`</span> in Front-matter will enable math, to load faster when the page does not contain math<br>  specific: false<br></code></pre></td></tr></table></figure>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=XiMVwkxu3hU\">如何使用Hexo+Github Pages 搭建个人博客，手把手最新教程</a></p>\n"},{"title":"Practical Guide to Writing Blogs！","date":"2025-05-29T14:32:19.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Markdown，Practical Guide to Writing Blogs！.png","category_bar":true,"description":"A practical guide to writing blogs using markdown.","_content":"\n## 个人博客搭建指南：\n\n\n&emsp;&emsp;正所谓“工欲善其事必先利其器”，博主之前在csdn上写过一些简单，了解也使用过一些简单的markdown语法，但是最近新部署了github博客网站，发现别人的博客网站颜色华丽，排版精美，而我的博客却只有简单的标题、正文、斜体、加粗等简单的界面，煞是寡淡，于是上网学习，发现在markdown中可以添加HTML标签和CSS样式，使得界面变得更加丰富，更加美观，下面是一些markdown的基础语法和进阶玩法，希望对大家有所帮助。\n\n {% note primary%}**前言**： 不知大家是否和博主有着相同的疑惑，为什么别的博主写出来的博客排版工整、优雅美观，而自己的博客却毫无出彩之处。原先博主更多的关注点在技术博客的内容上，markdown语法仅仅靠csdn上的“语法说明”自己瞎琢磨的，现在放暑假正好有时间，再温习一下基础语法和学习一下进阶语法，来丰富自己的博客排版！这篇是我的学习笔记，博采众长，希望也能帮到大家！{% endnote %}\n\n\n&emsp;&emsp;下面分为两个板块进行阐述：**基础语法**和**进阶语法**，板块一可以帮助你简单入门，版块二则是语法的升级！下面我都在代码块中展示markdown的写法，下面是对应的博客展现形式，大家可以根据自己的需求进行选择和学习！\n## 一、基础语法\n#### 1.标题\n输入```#```+```space（空格）```就是不同等级的标题（最多只有六个等级）\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n># 一级标题\n>## 二级标题\n>### 三级标题\n>#### 四级标题\n>##### 五级标题\n>###### 六级标题\n#### 2.文本样式\n\n**斜体**：```*```+```文本内容```+```*```\n```mardown\n*这是一个斜体*\n```\n>*这是一个斜体*\n\n**加粗**：```**```+```文本内容```+```**```\n```mardown\n**这里进行了加粗**\n```\n>**这里进行了加粗**\n\n**斜体加粗**：```***```+```文本内容```+```***```\n```markdown\n***这里是斜体加粗***\n```\n>***这里是斜体加粗***\n\n**删除线**：```~~```+```文本内容```+```~~```\n```markdown\n~~这里是删除线~~\n```\n>~~这里是删除线~~\n\n**分割线**：在一行中用三个以上的星号建立一个分隔线，行内不能有其他内容，也可以在星号中间插入空格。\n```markdown\n* * *\n```\n>* * *\n#### 3.列表\n**无序列表**：```-```或```*```或```+```+```space（空格）```+```文本内容```\n```markdown\n- 无序列表1\n- 无序列表2\n- 无序列表3\n```\n- 无序列表1\n- 无序列表2\n- 无序列表3\n\n**有序列表**：```数字序号```+```.```+```space（空格）```+```文本内容```\n```markdown\n1. 有序列表1\n2. 有序列表2\n3. 有序列表3\n```\n>1. 有序列表1\n>2. 有序列表2\n>3. 有序列表3\n\n**嵌套列表**：\n```-```+```space```+```第一级无序列表1```\n```space*2```+```-```+```第二级无序列表2```\n```markdown\n- 嵌套列表1\n  - 嵌套列表2\n    - 嵌套列表3\n```\n>- 嵌套列表1\n>   - 嵌套列表2\n>     - 嵌套列表3\n\n#### 4.板块\n**表格**：\n```|```+ ```每列的标题```+```|```+```每列的标题```+```|```\n```|```+ ```----| ----```+```|```\n```|```+ ```每列内容```+```|```+```每列内容```+```|```\n```|```+ ```每列内容```+```|```+```每列内容```+```|```\n```markdown\n|语言类型 |输出函数|\n| --- | ----------- |\n|c语言|printf|\n|c++|cout|\n|python|print|\n```\n|语言类型 |输出函数|\n| --- | ----------- |\n|c语言|printf|\n|c++|cout|\n|python|print|\n\n可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。\n>:— 设置内容和标题栏居左对齐。\n>:----: 设置内容和标题栏居中对齐。\n>—: 设置内容和标题栏居右对齐。\n\n**代码块**：前后三个```即可，可自定义选择编程语言\n```python\nprint(\"这是一个代码块\")\nprint(\"这是使用的python语言\")\n```\n```cpp\n#include <iostream>\nusing namespace std;\nint main(){\ncout<<\"这是一个c++的代码块！\"<<endl;\nreturn 0;}\n```\n**链接**：```[```+```超链接显示名```+```]```+```(```+```超链接地址```+```)```\n```markdown\n不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog)\n```\n>不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog)\n\n我们还可以给这个链接添加title，当鼠标悬停在链接上会出现提示。\n```[```+```超链接显示名```+```]```+```(```+```超链接地址```+```space```+```\"链接title\"```+```)```\n```markdown\n不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog \"欢迎来到我的博客！\")\n```\n> 不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog \"欢迎来到我的博客！\")\n\n使用尖括号可以很方便地把URL或者email地址变成可点击的链接：\n```markdown\n<https://blog.csdn.net/2401_86849688?type=blog>\n```\n><https://blog.csdn.net/2401_86849688?type=blog>\n\n要显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \\ \n```markdown\n\\*我想要输出的是两个星号*\n```\n>\\*我想要输出的是两个星号*\n\n## 二、进阶用法\n#### 1.字体与背景\n```<font face=\"字体\">```+```文本内容```+```</font>```\n```markdown\n<font face=\"黑体\">这是黑体</font>\n<font face=\"微软雅黑\">这是微软雅黑</font>\n<font face=\"STCAIYUN\">这是华文彩云</font>\n```\n><font face=\"黑体\">这是黑体</font>\n <font face=\"微软雅黑\">这是微软雅黑</font>\n <font face=\"STCAIYUN\">这是华文彩云</font>\n\n```<font size=字体大小>```+```文本内容```+```</font>```\n```markdown\n<font size=4>字体大小为4的文字</font>\n<font size=3>字体大小为3的文字</font>\n<font size=2>字体大小为2的文字</font>\n<font size=1>字体大小为1的文字</font>\n```\n><font size=4>字体大小为4的文字</font>\n<font size=3>字体大小为3的文字</font>\n<font size=2>字体大小为2的文字</font>\n<font size=1>字体大小为1的文字</font>\n\n```<font color=“color”>```+```文本内容```+```</font>```\n```markdown\n<font color=\"red\">红色的文本内容</font>\n<font color=\"green\">绿色的文本内容</font>\n<font color=\"blue\">蓝色的文本内容</font>\n```\n><font color=\"red\">红色的文本内容</font>\n<font color=\"green\">绿色的文本内容</font>\n<font color=\"blue\">蓝色的文本内容</font>\n\n```<mark>```+```文本内容```+```</mark>```或者```==```+```文本内容```+```==```\n```markdown\n<mark>高亮显示的文本内容</mark>\n==高亮显示的文本内容==\n```\n><mark>高亮显示的文本内容</mark>\n==高亮显示的文本内容==\n\n```<table><tr><td bgcolor=“color”><mark>```+```文本内容```+```</mark></td></tr></table>```\n```markdown\n<table><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n<table><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n```\n><table><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n><table><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</td></tr></table>\n\n```<u>```+```文本内容```+```</u>```\n```markdown\n<u>下划线的文本内容</u>\n```\n><u>下划线的文本内容</u>\n\n```>```+```文本内容```\n```markdown\n>引用的文本内容\n```\n>引用的文本内容\n#### 2.段落缩进\n**首行缩进**：\n- 全角：```&emsp;```或```&#8195;```\n- 半角：```&ensp;```或```&#8194;```\n- 半角之半角：```&nbsp;```或```&#160;```\n```markdown\n&emsp;&emsp;磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！\n```\n>&emsp;&emsp;磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！\n#### 3.公式\n&emsp;&emsp;在markdown中可以使用```$$```来作为公式块，在其中进行Latex类型公式的输入！\n\n```$``` + ```公式``` + ```$```\n\n```markdown\n$x^2-y^2=(x+y)(x-y)$\n$$(x-y)^2=x^2-2xy+y^2$$\n```\n\n>$x^2-y^2=(x+y)(x-y)$\n\n>$$(x-y)^2=x^2-2xy+y^2$$\n#### 4.表情\n我们可以通过键入`emoji shortcodes`来输出表情包：\n`man`:\n| 😄 `:smile:` | 😊 `:blush:` | 😍 `:heart_eyes:` |\n|--------------|--------------|------------------|\n| 😘 `:kissing_heart:` | 😳 `:flushed:` | 😁 `:grin:` |\n| 😉 `:wink:` | 😜 `:tongue_wink:` | 😀 `:grinning:` |\n| 😴 `:sleeping:` | 😟 `:worried:` | 😮 `:open_mouth:` |\n| 😕 `:confused:` | 😑 `:expressionless:` | 😅 `:sweat_smile:` |\n| 😥 `:sad_relieved:` | 😢 `:cry:` | 😭 `:sob:` |\n| 😂 `:joy:` | 😱 `:scream:` | 😠 `:angry:` |\n| 😡 `:rage:` | 😷 `:mask:` | 😎 `:sunglasses:` |\n| 😇 `:innocent:` | ❤️ `:heart:` | 💔 `:broken_heart:` |\n| ✨ `:sparkles:` | 👍 `:thumbsup:` | 👎 `:thumbsdown:` |\n| 👌 `:ok_hand:` | ✊ `:fist:` | ✌️ `:v:` |\n| 👋 `:wave:` | 🙌 `:raised_hands:` | 🙏 `:pray:` |\n| 👏 `:clap:` | 💪 `:muscle:` | 🏃 `:running:` |\n| 👫 `:couple:` | 👪 `:family:` | 💃 `:dancer:` |\n| 🙅 `:no_good:` | 💁 `:info_desk:` | 👶 `:baby:` |\n| 👩 `:woman:` | 👨 `:man:` | 👵 `:grandma:` |\n| 👴 `:grandpa:` | 👮 `:police:` | 😺 `:smile_cat:` |\n| 🙈 `:see_no_evil:` | 💀 `:skull:` | 💋 `:kiss:` |\n| 👀 `:eyes:` | 👄 `:mouth:` | 💬 `:speech_bubble:` |\n\n`nature`:\n| ☀️ `:sunny:` | ☔ `:umbrella:` | ☁️ `:cloud:` |\n|--------------|----------------|-------------|\n| ❄️ `:snowflake:` | ⛄ `:snowman:` | ⚡ `:zap:` |\n| 🌊 `:ocean:` | 🐱 `:cat:` | 🐶 `:dog:` |\n| 🐭 `:mouse:` | 🐰 `:rabbit:` | 🐯 `:tiger:` |\n| 🐨 `:koala:` | 🐻 `:bear:` | 🐷 `:pig:` |\n| 🐮 `:cow:` | 🐵 `:monkey:` | 🐴 `:horse:` |\n| 🐘 `:elephant:` | 🐼 `:panda:` | 🐍 `:snake:` |\n| 🐦 `:bird:` | 🐤 `:chick:` | 🐧 `:penguin:` |\n| 🐢 `:turtle:` | 🐝 `:bee:` | 🐙 `:octopus:` |\n| 🐠 `:fish:` | 🐳 `:whale:` | 🐬 `:dolphin:` |\n| 🌸 `:cherry_blossom:` | 🌹 `:rose:` | 🌻 `:sunflower:` |\n| 🍁 `:maple_leaf:` | 🍄 `:mushroom:` | 🌵 `:cactus:` |\n| 🌴 `:palm_tree:` | 🌲 `:tree:` | 🌞 `:sun_with_face:` |\n| 🌙 `:moon:` | 🌎 `:earth:` | 🌋 `:volcano:` |\n\n`objects`:\n| 🎍 `:bamboo:` | 💝 `:gift_heart:` | 🎒 `:school_satchel:` |\n|--------------|--------------------------|--------------|\n| 🎓 `:mortar_board:` | 🎏 `:flags:` | 🎆 `:fireworks:` |\n| 🎇 `:sparkler:` | 🎃 `:jack_o_lantern:` | 👻 `:ghost:` |\n| 🎅 `:santa:` | 🎄 `:christmas_tree:` | 🎁 `:gift:` |\n| 🔔 `:bell:` | 🎉 `:tada:` | 🎊 `:confetti_ball:` |\n| 🎈 `:balloon:` | 📷 `:camera:` | 🎥 `:movie_camera:` |\n| 💻 `:computer:` | 📺 `:tv:` | 📱 `:iphone:` |\n| ☎️ `:phone:` | 📞 `:telephone_receiver:` | 💡 `:bulb:` |\n| 🔋 `:battery:` | 📧 `:email:` | ✉️ `:envelope:` |\n| 🛀 `:bath:` | 🚿 `:shower:` | 🚽 `:toilet:` |\n| 🔧 `:wrench:` | 🔨 `:hammer:` | 💰 `:moneybag:` |\n| 💵 `:dollar:` | 💳 `:credit_card:` | ✂️ `:scissors:` |\n| 📌 `:pushpin:` | 📎 `:paperclip:` | ✏️ `:pencil2:` |\n| 📕 `:closed_book:` | 📚 `:books:` | 🔖 `:bookmark:` |\n| ⚽ `:soccer:` | 🏀 `:basketball:` | 🎾 `:tennis:` |\n| 🏊 `:swimmer:` | 🎮 `:video_game:` | 🎬 `:clapper:` |\n| 📝 `:memo:` | 🎤 `:microphone:` | 🎧 `:headphones:` |\n| 👞 `:shoe:` | 👠 `:high_heel:` | 💄 `:lipstick:` |\n| 👕 `:tshirt:` | 👖 `:jeans:` | 👙 `:bikini:` |\n| 👑 `:crown:` | 👓 `:eyeglasses:` | ☕ `:coffee:` |\n| 🍵 `:tea:` | 🍺 `:beer:` | 🍕 `:pizza:` |\n| 🍔 `:hamburger:` | 🍟 `:fries:` | 🍣 `:sushi:` |\n| 🍚 `:rice:` | 🍰 `:cake:` | 🍫 `:chocolate_bar:` |\n| 🍎 `:apple:` | 🍌 `:banana:` | 🍅 `:tomato:` |\n\n`place`:\n| 🏠 `:house:` | 🏡 `:house_with_garden:` | 🏫 `:school:` |\n|--------------|--------------------------|--------------|\n| 🏢 `:office:` | 🏣 `:post_office:` | 🏥 `:hospital:` |\n| 🏦 `:bank:` | 🏪 `:convenience_store:` | 🏨 `:hotel:` |\n| 💒 `:wedding:` | ⛪ `:church:` | 🌇 `:city_sunrise:` |\n| 🏯 `:japanese_castle:` | 🏰 `:european_castle:` | ⛺ `:tent:` |\n| 🏭 `:factory:` | 🗼 `:tokyo_tower:` | 🗻 `:mount_fuji:` |\n| 🌄 `:sunrise_over_mountains:` | 🌅 `:sunrise:` | 🌈 `:rainbow:` |\n| 🎡 `:ferris_wheel:` | ⛲ `:fountain:` | 🎢 `:roller_coaster:` |\n| 🚢 `:ship:` | 🚤 `:speedboat:` | ⛵ `:sailboat:` |\n| 🚀 `:rocket:` | ✈️ `:airplane:` | 🚁 `:helicopter:` |\n| 🚂 `:train:` | 🚊 `:tram:` | 🚲 `:bike:` |\n| 🚗 `:car:` | 🚕 `:taxi:` | 🚌 `:bus:` |\n| 🚓 `:police_car:` | 🚑 `:ambulance:` | 🚚 `:truck:` |\n| 🚦 `:traffic_light:` | ⚠️ `:warning:` | 🚧 `:construction:` |\n| 🏧 `:atm:` | 🎫 `:ticket:` | ♨️ `:hotsprings:` |\n\n`number`&& `directions`:\n| 1️⃣ `:one:` | 2️⃣ `:two:` | 3️⃣ `:three:` |\n|------------|------------|-------------|\n| 4️⃣ `:four:` | 5️⃣ `:five:` | 6️⃣ `:six:` |\n| 7️⃣ `:seven:` | 8️⃣ `:eight:` | 9️⃣ `:nine:` |\n| 🔟 `:keycap_ten:` | 0️⃣ `:zero:` | #️⃣ `:hash:` |\n| ◀️ `:arrow_backward:` | ⬇️ `:arrow_down:` | ▶️ `:arrow_forward:` |\n| ⬅️ `:arrow_left:` | ➡️ `:arrow_right:` | ⬆️ `:arrow_up:` |\n| 🔄 `:arrows_counterclockwise:` | ℹ️ `:information_source:` | 🆗 `:ok:` |\n| 🆕 `:new:` | 🆙 `:up:` | 🆒 `:cool:` |\n| 🚻 `:restroom:` | 🚹 `:mens:` | 🚺 `:womens:` |\n| ♿ `:wheelchair:` | 🚇 `:metro:` | 🚫 `:no_entry_sign:` |\n| ⛔ `:no_entry:` | ♻️ `:recycle:` | 🕐 `:clock1:` |\n| ❌ `:x:` | ❗ `:exclamation:` | ⭕ `:o:` |\n| ➕ `:plus:` | ➖ `:minus:` | ✔️ `:check_mark:` |\n| 🔘 `:radio_button:` | 🔗 `:link:` | ✅ `:white_check_mark:` |\n| ⚫ `:black_circle:` | ⚪ `:white_circle:` | 🔴 `:red_circle:` |\n| 🔵 `:blue_circle:` | ©️ `:copyright:` | ®️ `:registered:` |\n| ™️ `:tm:` | 🔶 `:orange_diamond:` | 🔷 `:blue_diamond:` |\n\n#### 5.提示\n\n```markdown\n{%note 参数%} 文字内容 {%endnote%}\n```\n| 参数      | 说明               |\n|-----------|--------------------|\n| `default` | 默认样式（灰色）    | \n| `primary` | 主要样式（蓝色）    | \n| `info`    | 信息提示（浅蓝色）  | \n| `success` | 成功提示（绿色）    |\n| `warning` | 警告提示（黄色）    |\n| `danger`  | 危险/错误（红色）   | \n\n- `default`\n{%note default%} 默认！ {%endnote%}\n- `primary`\n{%note primary%} 主要！ {%endnote%}\n- `info`\n{%note info%} 提示！ {%endnote%}\n- `success`\n{%note success%} 成功！ {%endnote%}\n- `warning`\n{%note warning%} 警告！ {%endnote%}\n- `danger`\n{%note danger%} 危险！ {%endnote%}\n\n\n\n 恭喜！ 看到这里你已经掌握了 Markdown 的核心语法和进阶技巧！\n\n✨ 小建议：\n\n精致排版 + 优质内容 = 王炸组合 💥 清晰的结构和美观的格式会让你的博客更专业、更吸睛！\n\n立刻动手写一篇吧！ 从今天开始，用 Markdown 打造你的技术分享博客，下一个顶尖技术博主就是你！ 🚀\n\n参考文献：\n[Markdown 语法详解大全(超级版)（一）——标题、字体文本式样、颜色、列表、版块区块、缩进、列表项](https://blog.csdn.net/weixin_69553582/article/details/142665344)\n[Markdown 语法详解大全(超级版)（二）——图片、表格、段落、转义字符、内嵌、注释、缩进、公式](https://blog.csdn.net/weixin_69553582/article/details/142711165)\n[Markdown 语法详解大全(超级版)（三）——甘特图语法详解](https://blog.csdn.net/weixin_69553582/article/details/142719257)\n[Markdown 语法详解大全(超级版)（四）——Markdown 使用 Emoji 表情 （附：表情符号简码列表）](https://blog.csdn.net/weixin_69553582/article/details/140277283)\n","source":"_posts/Tutorial/Markdown，Practical Guide to Writing Blogs！.md","raw":"---\ntitle: Practical Guide to Writing Blogs！\ndate: 2025-05-29 22:32:19\ntags: [markdown, blogger]  # 建议至少添加1-2个标签\nindex_img:  https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Markdown，Practical Guide to Writing Blogs！.png\ncategory: Tutorial\ncategory_bar: true\ndescription: A practical guide to writing blogs using markdown.\n---\n\n## 个人博客搭建指南：\n\n\n&emsp;&emsp;正所谓“工欲善其事必先利其器”，博主之前在csdn上写过一些简单，了解也使用过一些简单的markdown语法，但是最近新部署了github博客网站，发现别人的博客网站颜色华丽，排版精美，而我的博客却只有简单的标题、正文、斜体、加粗等简单的界面，煞是寡淡，于是上网学习，发现在markdown中可以添加HTML标签和CSS样式，使得界面变得更加丰富，更加美观，下面是一些markdown的基础语法和进阶玩法，希望对大家有所帮助。\n\n {% note primary%}**前言**： 不知大家是否和博主有着相同的疑惑，为什么别的博主写出来的博客排版工整、优雅美观，而自己的博客却毫无出彩之处。原先博主更多的关注点在技术博客的内容上，markdown语法仅仅靠csdn上的“语法说明”自己瞎琢磨的，现在放暑假正好有时间，再温习一下基础语法和学习一下进阶语法，来丰富自己的博客排版！这篇是我的学习笔记，博采众长，希望也能帮到大家！{% endnote %}\n\n\n&emsp;&emsp;下面分为两个板块进行阐述：**基础语法**和**进阶语法**，板块一可以帮助你简单入门，版块二则是语法的升级！下面我都在代码块中展示markdown的写法，下面是对应的博客展现形式，大家可以根据自己的需求进行选择和学习！\n## 一、基础语法\n#### 1.标题\n输入```#```+```space（空格）```就是不同等级的标题（最多只有六个等级）\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n># 一级标题\n>## 二级标题\n>### 三级标题\n>#### 四级标题\n>##### 五级标题\n>###### 六级标题\n#### 2.文本样式\n\n**斜体**：```*```+```文本内容```+```*```\n```mardown\n*这是一个斜体*\n```\n>*这是一个斜体*\n\n**加粗**：```**```+```文本内容```+```**```\n```mardown\n**这里进行了加粗**\n```\n>**这里进行了加粗**\n\n**斜体加粗**：```***```+```文本内容```+```***```\n```markdown\n***这里是斜体加粗***\n```\n>***这里是斜体加粗***\n\n**删除线**：```~~```+```文本内容```+```~~```\n```markdown\n~~这里是删除线~~\n```\n>~~这里是删除线~~\n\n**分割线**：在一行中用三个以上的星号建立一个分隔线，行内不能有其他内容，也可以在星号中间插入空格。\n```markdown\n* * *\n```\n>* * *\n#### 3.列表\n**无序列表**：```-```或```*```或```+```+```space（空格）```+```文本内容```\n```markdown\n- 无序列表1\n- 无序列表2\n- 无序列表3\n```\n- 无序列表1\n- 无序列表2\n- 无序列表3\n\n**有序列表**：```数字序号```+```.```+```space（空格）```+```文本内容```\n```markdown\n1. 有序列表1\n2. 有序列表2\n3. 有序列表3\n```\n>1. 有序列表1\n>2. 有序列表2\n>3. 有序列表3\n\n**嵌套列表**：\n```-```+```space```+```第一级无序列表1```\n```space*2```+```-```+```第二级无序列表2```\n```markdown\n- 嵌套列表1\n  - 嵌套列表2\n    - 嵌套列表3\n```\n>- 嵌套列表1\n>   - 嵌套列表2\n>     - 嵌套列表3\n\n#### 4.板块\n**表格**：\n```|```+ ```每列的标题```+```|```+```每列的标题```+```|```\n```|```+ ```----| ----```+```|```\n```|```+ ```每列内容```+```|```+```每列内容```+```|```\n```|```+ ```每列内容```+```|```+```每列内容```+```|```\n```markdown\n|语言类型 |输出函数|\n| --- | ----------- |\n|c语言|printf|\n|c++|cout|\n|python|print|\n```\n|语言类型 |输出函数|\n| --- | ----------- |\n|c语言|printf|\n|c++|cout|\n|python|print|\n\n可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。\n>:— 设置内容和标题栏居左对齐。\n>:----: 设置内容和标题栏居中对齐。\n>—: 设置内容和标题栏居右对齐。\n\n**代码块**：前后三个```即可，可自定义选择编程语言\n```python\nprint(\"这是一个代码块\")\nprint(\"这是使用的python语言\")\n```\n```cpp\n#include <iostream>\nusing namespace std;\nint main(){\ncout<<\"这是一个c++的代码块！\"<<endl;\nreturn 0;}\n```\n**链接**：```[```+```超链接显示名```+```]```+```(```+```超链接地址```+```)```\n```markdown\n不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog)\n```\n>不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog)\n\n我们还可以给这个链接添加title，当鼠标悬停在链接上会出现提示。\n```[```+```超链接显示名```+```]```+```(```+```超链接地址```+```space```+```\"链接title\"```+```)```\n```markdown\n不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog \"欢迎来到我的博客！\")\n```\n> 不在了情绪的博客主页：[不在了情绪](https://blog.csdn.net/2401_86849688?type=blog \"欢迎来到我的博客！\")\n\n使用尖括号可以很方便地把URL或者email地址变成可点击的链接：\n```markdown\n<https://blog.csdn.net/2401_86849688?type=blog>\n```\n><https://blog.csdn.net/2401_86849688?type=blog>\n\n要显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \\ \n```markdown\n\\*我想要输出的是两个星号*\n```\n>\\*我想要输出的是两个星号*\n\n## 二、进阶用法\n#### 1.字体与背景\n```<font face=\"字体\">```+```文本内容```+```</font>```\n```markdown\n<font face=\"黑体\">这是黑体</font>\n<font face=\"微软雅黑\">这是微软雅黑</font>\n<font face=\"STCAIYUN\">这是华文彩云</font>\n```\n><font face=\"黑体\">这是黑体</font>\n <font face=\"微软雅黑\">这是微软雅黑</font>\n <font face=\"STCAIYUN\">这是华文彩云</font>\n\n```<font size=字体大小>```+```文本内容```+```</font>```\n```markdown\n<font size=4>字体大小为4的文字</font>\n<font size=3>字体大小为3的文字</font>\n<font size=2>字体大小为2的文字</font>\n<font size=1>字体大小为1的文字</font>\n```\n><font size=4>字体大小为4的文字</font>\n<font size=3>字体大小为3的文字</font>\n<font size=2>字体大小为2的文字</font>\n<font size=1>字体大小为1的文字</font>\n\n```<font color=“color”>```+```文本内容```+```</font>```\n```markdown\n<font color=\"red\">红色的文本内容</font>\n<font color=\"green\">绿色的文本内容</font>\n<font color=\"blue\">蓝色的文本内容</font>\n```\n><font color=\"red\">红色的文本内容</font>\n<font color=\"green\">绿色的文本内容</font>\n<font color=\"blue\">蓝色的文本内容</font>\n\n```<mark>```+```文本内容```+```</mark>```或者```==```+```文本内容```+```==```\n```markdown\n<mark>高亮显示的文本内容</mark>\n==高亮显示的文本内容==\n```\n><mark>高亮显示的文本内容</mark>\n==高亮显示的文本内容==\n\n```<table><tr><td bgcolor=“color”><mark>```+```文本内容```+```</mark></td></tr></table>```\n```markdown\n<table><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n<table><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n```\n><table><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n><table><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</td></tr></table>\n\n```<u>```+```文本内容```+```</u>```\n```markdown\n<u>下划线的文本内容</u>\n```\n><u>下划线的文本内容</u>\n\n```>```+```文本内容```\n```markdown\n>引用的文本内容\n```\n>引用的文本内容\n#### 2.段落缩进\n**首行缩进**：\n- 全角：```&emsp;```或```&#8195;```\n- 半角：```&ensp;```或```&#8194;```\n- 半角之半角：```&nbsp;```或```&#160;```\n```markdown\n&emsp;&emsp;磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！\n```\n>&emsp;&emsp;磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！\n#### 3.公式\n&emsp;&emsp;在markdown中可以使用```$$```来作为公式块，在其中进行Latex类型公式的输入！\n\n```$``` + ```公式``` + ```$```\n\n```markdown\n$x^2-y^2=(x+y)(x-y)$\n$$(x-y)^2=x^2-2xy+y^2$$\n```\n\n>$x^2-y^2=(x+y)(x-y)$\n\n>$$(x-y)^2=x^2-2xy+y^2$$\n#### 4.表情\n我们可以通过键入`emoji shortcodes`来输出表情包：\n`man`:\n| 😄 `:smile:` | 😊 `:blush:` | 😍 `:heart_eyes:` |\n|--------------|--------------|------------------|\n| 😘 `:kissing_heart:` | 😳 `:flushed:` | 😁 `:grin:` |\n| 😉 `:wink:` | 😜 `:tongue_wink:` | 😀 `:grinning:` |\n| 😴 `:sleeping:` | 😟 `:worried:` | 😮 `:open_mouth:` |\n| 😕 `:confused:` | 😑 `:expressionless:` | 😅 `:sweat_smile:` |\n| 😥 `:sad_relieved:` | 😢 `:cry:` | 😭 `:sob:` |\n| 😂 `:joy:` | 😱 `:scream:` | 😠 `:angry:` |\n| 😡 `:rage:` | 😷 `:mask:` | 😎 `:sunglasses:` |\n| 😇 `:innocent:` | ❤️ `:heart:` | 💔 `:broken_heart:` |\n| ✨ `:sparkles:` | 👍 `:thumbsup:` | 👎 `:thumbsdown:` |\n| 👌 `:ok_hand:` | ✊ `:fist:` | ✌️ `:v:` |\n| 👋 `:wave:` | 🙌 `:raised_hands:` | 🙏 `:pray:` |\n| 👏 `:clap:` | 💪 `:muscle:` | 🏃 `:running:` |\n| 👫 `:couple:` | 👪 `:family:` | 💃 `:dancer:` |\n| 🙅 `:no_good:` | 💁 `:info_desk:` | 👶 `:baby:` |\n| 👩 `:woman:` | 👨 `:man:` | 👵 `:grandma:` |\n| 👴 `:grandpa:` | 👮 `:police:` | 😺 `:smile_cat:` |\n| 🙈 `:see_no_evil:` | 💀 `:skull:` | 💋 `:kiss:` |\n| 👀 `:eyes:` | 👄 `:mouth:` | 💬 `:speech_bubble:` |\n\n`nature`:\n| ☀️ `:sunny:` | ☔ `:umbrella:` | ☁️ `:cloud:` |\n|--------------|----------------|-------------|\n| ❄️ `:snowflake:` | ⛄ `:snowman:` | ⚡ `:zap:` |\n| 🌊 `:ocean:` | 🐱 `:cat:` | 🐶 `:dog:` |\n| 🐭 `:mouse:` | 🐰 `:rabbit:` | 🐯 `:tiger:` |\n| 🐨 `:koala:` | 🐻 `:bear:` | 🐷 `:pig:` |\n| 🐮 `:cow:` | 🐵 `:monkey:` | 🐴 `:horse:` |\n| 🐘 `:elephant:` | 🐼 `:panda:` | 🐍 `:snake:` |\n| 🐦 `:bird:` | 🐤 `:chick:` | 🐧 `:penguin:` |\n| 🐢 `:turtle:` | 🐝 `:bee:` | 🐙 `:octopus:` |\n| 🐠 `:fish:` | 🐳 `:whale:` | 🐬 `:dolphin:` |\n| 🌸 `:cherry_blossom:` | 🌹 `:rose:` | 🌻 `:sunflower:` |\n| 🍁 `:maple_leaf:` | 🍄 `:mushroom:` | 🌵 `:cactus:` |\n| 🌴 `:palm_tree:` | 🌲 `:tree:` | 🌞 `:sun_with_face:` |\n| 🌙 `:moon:` | 🌎 `:earth:` | 🌋 `:volcano:` |\n\n`objects`:\n| 🎍 `:bamboo:` | 💝 `:gift_heart:` | 🎒 `:school_satchel:` |\n|--------------|--------------------------|--------------|\n| 🎓 `:mortar_board:` | 🎏 `:flags:` | 🎆 `:fireworks:` |\n| 🎇 `:sparkler:` | 🎃 `:jack_o_lantern:` | 👻 `:ghost:` |\n| 🎅 `:santa:` | 🎄 `:christmas_tree:` | 🎁 `:gift:` |\n| 🔔 `:bell:` | 🎉 `:tada:` | 🎊 `:confetti_ball:` |\n| 🎈 `:balloon:` | 📷 `:camera:` | 🎥 `:movie_camera:` |\n| 💻 `:computer:` | 📺 `:tv:` | 📱 `:iphone:` |\n| ☎️ `:phone:` | 📞 `:telephone_receiver:` | 💡 `:bulb:` |\n| 🔋 `:battery:` | 📧 `:email:` | ✉️ `:envelope:` |\n| 🛀 `:bath:` | 🚿 `:shower:` | 🚽 `:toilet:` |\n| 🔧 `:wrench:` | 🔨 `:hammer:` | 💰 `:moneybag:` |\n| 💵 `:dollar:` | 💳 `:credit_card:` | ✂️ `:scissors:` |\n| 📌 `:pushpin:` | 📎 `:paperclip:` | ✏️ `:pencil2:` |\n| 📕 `:closed_book:` | 📚 `:books:` | 🔖 `:bookmark:` |\n| ⚽ `:soccer:` | 🏀 `:basketball:` | 🎾 `:tennis:` |\n| 🏊 `:swimmer:` | 🎮 `:video_game:` | 🎬 `:clapper:` |\n| 📝 `:memo:` | 🎤 `:microphone:` | 🎧 `:headphones:` |\n| 👞 `:shoe:` | 👠 `:high_heel:` | 💄 `:lipstick:` |\n| 👕 `:tshirt:` | 👖 `:jeans:` | 👙 `:bikini:` |\n| 👑 `:crown:` | 👓 `:eyeglasses:` | ☕ `:coffee:` |\n| 🍵 `:tea:` | 🍺 `:beer:` | 🍕 `:pizza:` |\n| 🍔 `:hamburger:` | 🍟 `:fries:` | 🍣 `:sushi:` |\n| 🍚 `:rice:` | 🍰 `:cake:` | 🍫 `:chocolate_bar:` |\n| 🍎 `:apple:` | 🍌 `:banana:` | 🍅 `:tomato:` |\n\n`place`:\n| 🏠 `:house:` | 🏡 `:house_with_garden:` | 🏫 `:school:` |\n|--------------|--------------------------|--------------|\n| 🏢 `:office:` | 🏣 `:post_office:` | 🏥 `:hospital:` |\n| 🏦 `:bank:` | 🏪 `:convenience_store:` | 🏨 `:hotel:` |\n| 💒 `:wedding:` | ⛪ `:church:` | 🌇 `:city_sunrise:` |\n| 🏯 `:japanese_castle:` | 🏰 `:european_castle:` | ⛺ `:tent:` |\n| 🏭 `:factory:` | 🗼 `:tokyo_tower:` | 🗻 `:mount_fuji:` |\n| 🌄 `:sunrise_over_mountains:` | 🌅 `:sunrise:` | 🌈 `:rainbow:` |\n| 🎡 `:ferris_wheel:` | ⛲ `:fountain:` | 🎢 `:roller_coaster:` |\n| 🚢 `:ship:` | 🚤 `:speedboat:` | ⛵ `:sailboat:` |\n| 🚀 `:rocket:` | ✈️ `:airplane:` | 🚁 `:helicopter:` |\n| 🚂 `:train:` | 🚊 `:tram:` | 🚲 `:bike:` |\n| 🚗 `:car:` | 🚕 `:taxi:` | 🚌 `:bus:` |\n| 🚓 `:police_car:` | 🚑 `:ambulance:` | 🚚 `:truck:` |\n| 🚦 `:traffic_light:` | ⚠️ `:warning:` | 🚧 `:construction:` |\n| 🏧 `:atm:` | 🎫 `:ticket:` | ♨️ `:hotsprings:` |\n\n`number`&& `directions`:\n| 1️⃣ `:one:` | 2️⃣ `:two:` | 3️⃣ `:three:` |\n|------------|------------|-------------|\n| 4️⃣ `:four:` | 5️⃣ `:five:` | 6️⃣ `:six:` |\n| 7️⃣ `:seven:` | 8️⃣ `:eight:` | 9️⃣ `:nine:` |\n| 🔟 `:keycap_ten:` | 0️⃣ `:zero:` | #️⃣ `:hash:` |\n| ◀️ `:arrow_backward:` | ⬇️ `:arrow_down:` | ▶️ `:arrow_forward:` |\n| ⬅️ `:arrow_left:` | ➡️ `:arrow_right:` | ⬆️ `:arrow_up:` |\n| 🔄 `:arrows_counterclockwise:` | ℹ️ `:information_source:` | 🆗 `:ok:` |\n| 🆕 `:new:` | 🆙 `:up:` | 🆒 `:cool:` |\n| 🚻 `:restroom:` | 🚹 `:mens:` | 🚺 `:womens:` |\n| ♿ `:wheelchair:` | 🚇 `:metro:` | 🚫 `:no_entry_sign:` |\n| ⛔ `:no_entry:` | ♻️ `:recycle:` | 🕐 `:clock1:` |\n| ❌ `:x:` | ❗ `:exclamation:` | ⭕ `:o:` |\n| ➕ `:plus:` | ➖ `:minus:` | ✔️ `:check_mark:` |\n| 🔘 `:radio_button:` | 🔗 `:link:` | ✅ `:white_check_mark:` |\n| ⚫ `:black_circle:` | ⚪ `:white_circle:` | 🔴 `:red_circle:` |\n| 🔵 `:blue_circle:` | ©️ `:copyright:` | ®️ `:registered:` |\n| ™️ `:tm:` | 🔶 `:orange_diamond:` | 🔷 `:blue_diamond:` |\n\n#### 5.提示\n\n```markdown\n{%note 参数%} 文字内容 {%endnote%}\n```\n| 参数      | 说明               |\n|-----------|--------------------|\n| `default` | 默认样式（灰色）    | \n| `primary` | 主要样式（蓝色）    | \n| `info`    | 信息提示（浅蓝色）  | \n| `success` | 成功提示（绿色）    |\n| `warning` | 警告提示（黄色）    |\n| `danger`  | 危险/错误（红色）   | \n\n- `default`\n{%note default%} 默认！ {%endnote%}\n- `primary`\n{%note primary%} 主要！ {%endnote%}\n- `info`\n{%note info%} 提示！ {%endnote%}\n- `success`\n{%note success%} 成功！ {%endnote%}\n- `warning`\n{%note warning%} 警告！ {%endnote%}\n- `danger`\n{%note danger%} 危险！ {%endnote%}\n\n\n\n 恭喜！ 看到这里你已经掌握了 Markdown 的核心语法和进阶技巧！\n\n✨ 小建议：\n\n精致排版 + 优质内容 = 王炸组合 💥 清晰的结构和美观的格式会让你的博客更专业、更吸睛！\n\n立刻动手写一篇吧！ 从今天开始，用 Markdown 打造你的技术分享博客，下一个顶尖技术博主就是你！ 🚀\n\n参考文献：\n[Markdown 语法详解大全(超级版)（一）——标题、字体文本式样、颜色、列表、版块区块、缩进、列表项](https://blog.csdn.net/weixin_69553582/article/details/142665344)\n[Markdown 语法详解大全(超级版)（二）——图片、表格、段落、转义字符、内嵌、注释、缩进、公式](https://blog.csdn.net/weixin_69553582/article/details/142711165)\n[Markdown 语法详解大全(超级版)（三）——甘特图语法详解](https://blog.csdn.net/weixin_69553582/article/details/142719257)\n[Markdown 语法详解大全(超级版)（四）——Markdown 使用 Emoji 表情 （附：表情符号简码列表）](https://blog.csdn.net/weixin_69553582/article/details/140277283)\n","slug":"Tutorial/Markdown，Practical Guide to Writing Blogs！","published":1,"updated":"2025-08-21T09:46:31.922Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcv002q40w33m2g0cke","content":"<h2 id=\"个人博客搭建指南：\">个人博客搭建指南：</h2>\n<p>  正所谓“工欲善其事必先利其器”，博主之前在csdn上写过一些简单，了解也使用过一些简单的markdown语法，但是最近新部署了github博客网站，发现别人的博客网站颜色华丽，排版精美，而我的博客却只有简单的标题、正文、斜体、加粗等简单的界面，煞是寡淡，于是上网学习，发现在markdown中可以添加HTML标签和CSS样式，使得界面变得更加丰富，更加美观，下面是一些markdown的基础语法和进阶玩法，希望对大家有所帮助。</p>\n <div class=\"note note-primary\">\n            <p><strong>前言</strong>： 不知大家是否和博主有着相同的疑惑，为什么别的博主写出来的博客排版工整、优雅美观，而自己的博客却毫无出彩之处。原先博主更多的关注点在技术博客的内容上，markdown语法仅仅靠csdn上的“语法说明”自己瞎琢磨的，现在放暑假正好有时间，再温习一下基础语法和学习一下进阶语法，来丰富自己的博客排版！这篇是我的学习笔记，博采众长，希望也能帮到大家！</p>\n          </div>\n<p>  下面分为两个板块进行阐述：<strong>基础语法</strong>和<strong>进阶语法</strong>，板块一可以帮助你简单入门，版块二则是语法的升级！下面我都在代码块中展示markdown的写法，下面是对应的博客展现形式，大家可以根据自己的需求进行选择和学习！</p>\n<h2 id=\"一、基础语法\">一、基础语法</h2>\n<h4 id=\"1-标题\">1.标题</h4>\n<p>输入<code>#</code>+<code>space（空格）</code>就是不同等级的标题（最多只有六个等级）</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># 一级标题</span><br><span class=\"hljs-section\">## 二级标题</span><br><span class=\"hljs-section\">### 三级标题</span><br><span class=\"hljs-section\">#### 四级标题</span><br><span class=\"hljs-section\">##### 五级标题</span><br><span class=\"hljs-section\">###### 六级标题</span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<h1>一级标题</h1>\n<h2 id=\"二级标题\">二级标题</h2>\n<h3 id=\"三级标题\">三级标题</h3>\n<h4 id=\"四级标题\">四级标题</h4>\n<h5 id=\"五级标题\">五级标题</h5>\n<h6 id=\"六级标题\">六级标题</h6>\n</blockquote>\n<h4 id=\"2-文本样式\">2.文本样式</h4>\n<p><strong>斜体</strong>：<code>*</code>+<code>文本内容</code>+<code>*</code></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mardown\">*这是一个斜体*<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><em>这是一个斜体</em></p>\n</blockquote>\n<p><strong>加粗</strong>：<code>**</code>+<code>文本内容</code>+<code>**</code></p>\n<figure class=\"highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mardown\">**这里进行了加粗**<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><strong>这里进行了加粗</strong></p>\n</blockquote>\n<p><strong>斜体加粗</strong>：<code>***</code>+<code>文本内容</code>+<code>***</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*这里是斜体加粗*</span>**</span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><em><strong>这里是斜体加粗</strong></em></p>\n</blockquote>\n<p><strong>删除线</strong>：<code>~~</code>+<code>文本内容</code>+<code>~~</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">~~这里是删除线~~<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><s>这里是删除线</s></p>\n</blockquote>\n<p><strong>分割线</strong>：在一行中用三个以上的星号建立一个分隔线，行内不能有其他内容，也可以在星号中间插入空格。</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">*</span> * <span class=\"hljs-emphasis\">*</span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<hr>\n</blockquote>\n<h4 id=\"3-列表\">3.列表</h4>\n<p><strong>无序列表</strong>：<code>-</code>或<code>*</code>或<code>+</code>+<code>space（空格）</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 无序列表1<br><span class=\"hljs-bullet\">-</span> 无序列表2<br><span class=\"hljs-bullet\">-</span> 无序列表3<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n<li>无序列表3</li>\n</ul>\n<p><strong>有序列表</strong>：<code>数字序号</code>+<code>.</code>+<code>space（空格）</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 有序列表1<br><span class=\"hljs-bullet\">2.</span> 有序列表2<br><span class=\"hljs-bullet\">3.</span> 有序列表3<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n<li>有序列表3</li>\n</ol>\n</blockquote>\n<p><strong>嵌套列表</strong>：<br>\n<code>-</code>+<code>space</code>+<code>第一级无序列表1</code><br>\n<code>space*2</code>+<code>-</code>+<code>第二级无序列表2</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 嵌套列表1<br><span class=\"hljs-bullet\">  -</span> 嵌套列表2<br><span class=\"hljs-bullet\">    -</span> 嵌套列表3<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<ul>\n<li>嵌套列表1\n<ul>\n<li>嵌套列表2\n<ul>\n<li>嵌套列表3</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"4-板块\">4.板块</h4>\n<p><strong>表格</strong>：<br>\n<code>|</code>+ <code>每列的标题</code>+<code>|</code>+<code>每列的标题</code>+<code>|</code><br>\n<code>|</code>+ <code>----| ----</code>+<code>|</code><br>\n<code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code><br>\n<code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">|语言类型 |输出函数|<br>| --- | ----------- |<br>|c语言|printf|<br>|c++|cout|<br>|python|print|<br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>语言类型</th>\n<th>输出函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c语言</td>\n<td>printf</td>\n</tr>\n<tr>\n<td>c++</td>\n<td>cout</td>\n</tr>\n<tr>\n<td>python</td>\n<td>print</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</p>\n<blockquote>\n<p>:— 设置内容和标题栏居左对齐。<br>\n:----: 设置内容和标题栏居中对齐。<br>\n—: 设置内容和标题栏居右对齐。</p>\n</blockquote>\n<p><strong>代码块</strong>：前后三个```即可，可自定义选择编程语言</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"这是一个代码块\"</span>)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"这是使用的python语言\"</span>)<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight cpp\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>{<br>cout&lt;&lt;<span class=\"hljs-string\">\"这是一个c++的代码块！\"</span>&lt;&lt;endl;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;}<br></code></pre></td></tr></tbody></table></figure>\n<p><strong>链接</strong>：<code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>)</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">不在了情绪的博客主页：[<span class=\"hljs-string\">不在了情绪</span>](<span class=\"hljs-link\">https://blog.csdn.net/2401_86849688?type=blog</span>)<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>不在了情绪的博客主页：<a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪</a></p>\n</blockquote>\n<p>我们还可以给这个链接添加title，当鼠标悬停在链接上会出现提示。<br>\n<code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>space</code>+<code>\"链接title\"</code>+<code>)</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">不在了情绪的博客主页：[<span class=\"hljs-string\">不在了情绪</span>](<span class=\"hljs-link\">https://blog.csdn.net/2401_86849688?type=blog \"欢迎来到我的博客！\"</span>)<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>不在了情绪的博客主页：<a href=\"https://blog.csdn.net/2401_86849688?type=blog\" title=\"欢迎来到我的博客！\">不在了情绪</a></p>\n</blockquote>\n<p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接：</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\">&lt;https://blog.csdn.net/2401_86849688?type=blog&gt;</span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">https://blog.csdn.net/2401_86849688?type=blog</a></p>\n</blockquote>\n<p>要显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \\</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">\\<span class=\"hljs-emphasis\">*我想要输出的是两个星号*</span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>*我想要输出的是两个星号*</p>\n</blockquote>\n<h2 id=\"二、进阶用法\">二、进阶用法</h2>\n<h4 id=\"1-字体与背景\">1.字体与背景</h4>\n<p><code>&lt;font face=\"字体\"&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">\"黑体\"</span>&gt;</span></span>这是黑体<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">\"微软雅黑\"</span>&gt;</span></span>这是微软雅黑<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">\"STCAIYUN\"</span>&gt;</span></span>这是华文彩云<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><font face=\"黑体\">这是黑体</font><br>\n<font face=\"微软雅黑\">这是微软雅黑</font><br>\n<font face=\"STCAIYUN\">这是华文彩云</font></p>\n</blockquote>\n<p><code>&lt;font size=字体大小&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">4</span>&gt;</span></span>字体大小为4的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">3</span>&gt;</span></span>字体大小为3的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">2</span>&gt;</span></span>字体大小为2的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">1</span>&gt;</span></span>字体大小为1的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><font size=\"4\">字体大小为4的文字</font><br>\n<font size=\"3\">字体大小为3的文字</font><br>\n<font size=\"2\">字体大小为2的文字</font><br>\n<font size=\"1\">字体大小为1的文字</font></p>\n</blockquote>\n<p><code>&lt;font color=“color”&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"red\"</span>&gt;</span></span>红色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"green\"</span>&gt;</span></span>绿色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"blue\"</span>&gt;</span></span>蓝色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><font color=\"red\">红色的文本内容</font><br>\n<font color=\"green\">绿色的文本内容</font><br>\n<font color=\"blue\">蓝色的文本内容</font></p>\n</blockquote>\n<p><code>&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;</code>或者<code>==</code>+<code>文本内容</code>+<code>==</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>高亮显示的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><br>==高亮显示的文本内容==<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><mark>高亮显示的文本内容</mark><br>\n==高亮显示的文本内容==</p>\n</blockquote>\n<p><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=“color”&gt;&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">\"green\"</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">\"red\"</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<table><tbody><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></tbody></table>\n<table><tbody><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</mark></td></tr></tbody></table>\n</blockquote>\n<p><code>&lt;u&gt;</code>+<code>文本内容</code>+<code>&lt;/u&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">u</span>&gt;</span></span>下划线的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">u</span>&gt;</span></span><br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p><u>下划线的文本内容</u></p>\n</blockquote>\n<p><code>&gt;</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">&gt;引用的文本内容<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>引用的文本内容</p>\n</blockquote>\n<h4 id=\"2-段落缩进\">2.段落缩进</h4>\n<p><strong>首行缩进</strong>：</p>\n<ul>\n<li>全角：<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li>\n<li>半角：<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li>\n<li>半角之半角：<code>&amp;nbsp;</code>或<code>&amp;#160;</code></li>\n</ul>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-literal\">&amp;emsp;</span><span class=\"hljs-literal\">&amp;emsp;</span>磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>  磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！</p>\n</blockquote>\n<h4 id=\"3-公式\">3.公式</h4>\n<p>  在markdown中可以使用<code>$$</code>来作为公式块，在其中进行Latex类型公式的输入！</p>\n<p><code>$</code> + <code>公式</code> + <code>$</code></p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">$x^2-y^2=(x+y)(x-y)$<br>$$(x-y)^2=x^2-2xy+y^2$$<br></code></pre></td></tr></tbody></table></figure>\n<blockquote>\n<p>$x<sup>2-y</sup>2=(x+y)(x-y)$</p>\n</blockquote>\n<blockquote>\n<p>$$(x-y)<sup>2=x</sup>2-2xy+y^2$$</p>\n</blockquote>\n<h4 id=\"4-表情\">4.表情</h4>\n<p>我们可以通过键入<code>emoji shortcodes</code>来输出表情包：<br>\n<code>man</code>:</p>\n<table>\n<thead>\n<tr>\n<th>😄 <code>:smile:</code></th>\n<th>😊 <code>:blush:</code></th>\n<th>😍 <code>:heart_eyes:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>😘 <code>:kissing_heart:</code></td>\n<td>😳 <code>:flushed:</code></td>\n<td>😁 <code>:grin:</code></td>\n</tr>\n<tr>\n<td>😉 <code>:wink:</code></td>\n<td>😜 <code>:tongue_wink:</code></td>\n<td>😀 <code>:grinning:</code></td>\n</tr>\n<tr>\n<td>😴 <code>:sleeping:</code></td>\n<td>😟 <code>:worried:</code></td>\n<td>😮 <code>:open_mouth:</code></td>\n</tr>\n<tr>\n<td>😕 <code>:confused:</code></td>\n<td>😑 <code>:expressionless:</code></td>\n<td>😅 <code>:sweat_smile:</code></td>\n</tr>\n<tr>\n<td>😥 <code>:sad_relieved:</code></td>\n<td>😢 <code>:cry:</code></td>\n<td>😭 <code>:sob:</code></td>\n</tr>\n<tr>\n<td>😂 <code>:joy:</code></td>\n<td>😱 <code>:scream:</code></td>\n<td>😠 <code>:angry:</code></td>\n</tr>\n<tr>\n<td>😡 <code>:rage:</code></td>\n<td>😷 <code>:mask:</code></td>\n<td>😎 <code>:sunglasses:</code></td>\n</tr>\n<tr>\n<td>😇 <code>:innocent:</code></td>\n<td>❤️ <code>:heart:</code></td>\n<td>💔 <code>:broken_heart:</code></td>\n</tr>\n<tr>\n<td>✨ <code>:sparkles:</code></td>\n<td>👍 <code>:thumbsup:</code></td>\n<td>👎 <code>:thumbsdown:</code></td>\n</tr>\n<tr>\n<td>👌 <code>:ok_hand:</code></td>\n<td>✊ <code>:fist:</code></td>\n<td>✌️ <code>:v:</code></td>\n</tr>\n<tr>\n<td>👋 <code>:wave:</code></td>\n<td>🙌 <code>:raised_hands:</code></td>\n<td>🙏 <code>:pray:</code></td>\n</tr>\n<tr>\n<td>👏 <code>:clap:</code></td>\n<td>💪 <code>:muscle:</code></td>\n<td>🏃 <code>:running:</code></td>\n</tr>\n<tr>\n<td>👫 <code>:couple:</code></td>\n<td>👪 <code>:family:</code></td>\n<td>💃 <code>:dancer:</code></td>\n</tr>\n<tr>\n<td>🙅 <code>:no_good:</code></td>\n<td>💁 <code>:info_desk:</code></td>\n<td>👶 <code>:baby:</code></td>\n</tr>\n<tr>\n<td>👩 <code>:woman:</code></td>\n<td>👨 <code>:man:</code></td>\n<td>👵 <code>:grandma:</code></td>\n</tr>\n<tr>\n<td>👴 <code>:grandpa:</code></td>\n<td>👮 <code>:police:</code></td>\n<td>😺 <code>:smile_cat:</code></td>\n</tr>\n<tr>\n<td>🙈 <code>:see_no_evil:</code></td>\n<td>💀 <code>:skull:</code></td>\n<td>💋 <code>:kiss:</code></td>\n</tr>\n<tr>\n<td>👀 <code>:eyes:</code></td>\n<td>👄 <code>:mouth:</code></td>\n<td>💬 <code>:speech_bubble:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>nature</code>:</p>\n<table>\n<thead>\n<tr>\n<th>☀️ <code>:sunny:</code></th>\n<th>☔ <code>:umbrella:</code></th>\n<th>☁️ <code>:cloud:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>❄️ <code>:snowflake:</code></td>\n<td>⛄ <code>:snowman:</code></td>\n<td>⚡ <code>:zap:</code></td>\n</tr>\n<tr>\n<td>🌊 <code>:ocean:</code></td>\n<td>🐱 <code>:cat:</code></td>\n<td>🐶 <code>:dog:</code></td>\n</tr>\n<tr>\n<td>🐭 <code>:mouse:</code></td>\n<td>🐰 <code>:rabbit:</code></td>\n<td>🐯 <code>:tiger:</code></td>\n</tr>\n<tr>\n<td>🐨 <code>:koala:</code></td>\n<td>🐻 <code>:bear:</code></td>\n<td>🐷 <code>:pig:</code></td>\n</tr>\n<tr>\n<td>🐮 <code>:cow:</code></td>\n<td>🐵 <code>:monkey:</code></td>\n<td>🐴 <code>:horse:</code></td>\n</tr>\n<tr>\n<td>🐘 <code>:elephant:</code></td>\n<td>🐼 <code>:panda:</code></td>\n<td>🐍 <code>:snake:</code></td>\n</tr>\n<tr>\n<td>🐦 <code>:bird:</code></td>\n<td>🐤 <code>:chick:</code></td>\n<td>🐧 <code>:penguin:</code></td>\n</tr>\n<tr>\n<td>🐢 <code>:turtle:</code></td>\n<td>🐝 <code>:bee:</code></td>\n<td>🐙 <code>:octopus:</code></td>\n</tr>\n<tr>\n<td>🐠 <code>:fish:</code></td>\n<td>🐳 <code>:whale:</code></td>\n<td>🐬 <code>:dolphin:</code></td>\n</tr>\n<tr>\n<td>🌸 <code>:cherry_blossom:</code></td>\n<td>🌹 <code>:rose:</code></td>\n<td>🌻 <code>:sunflower:</code></td>\n</tr>\n<tr>\n<td>🍁 <code>:maple_leaf:</code></td>\n<td>🍄 <code>:mushroom:</code></td>\n<td>🌵 <code>:cactus:</code></td>\n</tr>\n<tr>\n<td>🌴 <code>:palm_tree:</code></td>\n<td>🌲 <code>:tree:</code></td>\n<td>🌞 <code>:sun_with_face:</code></td>\n</tr>\n<tr>\n<td>🌙 <code>:moon:</code></td>\n<td>🌎 <code>:earth:</code></td>\n<td>🌋 <code>:volcano:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>objects</code>:</p>\n<table>\n<thead>\n<tr>\n<th>🎍 <code>:bamboo:</code></th>\n<th>💝 <code>:gift_heart:</code></th>\n<th>🎒 <code>:school_satchel:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🎓 <code>:mortar_board:</code></td>\n<td>🎏 <code>:flags:</code></td>\n<td>🎆 <code>:fireworks:</code></td>\n</tr>\n<tr>\n<td>🎇 <code>:sparkler:</code></td>\n<td>🎃 <code>:jack_o_lantern:</code></td>\n<td>👻 <code>:ghost:</code></td>\n</tr>\n<tr>\n<td>🎅 <code>:santa:</code></td>\n<td>🎄 <code>:christmas_tree:</code></td>\n<td>🎁 <code>:gift:</code></td>\n</tr>\n<tr>\n<td>🔔 <code>:bell:</code></td>\n<td>🎉 <code>:tada:</code></td>\n<td>🎊 <code>:confetti_ball:</code></td>\n</tr>\n<tr>\n<td>🎈 <code>:balloon:</code></td>\n<td>📷 <code>:camera:</code></td>\n<td>🎥 <code>:movie_camera:</code></td>\n</tr>\n<tr>\n<td>💻 <code>:computer:</code></td>\n<td>📺 <code>:tv:</code></td>\n<td>📱 <code>:iphone:</code></td>\n</tr>\n<tr>\n<td>☎️ <code>:phone:</code></td>\n<td>📞 <code>:telephone_receiver:</code></td>\n<td>💡 <code>:bulb:</code></td>\n</tr>\n<tr>\n<td>🔋 <code>:battery:</code></td>\n<td>📧 <code>:email:</code></td>\n<td>✉️ <code>:envelope:</code></td>\n</tr>\n<tr>\n<td>🛀 <code>:bath:</code></td>\n<td>🚿 <code>:shower:</code></td>\n<td>🚽 <code>:toilet:</code></td>\n</tr>\n<tr>\n<td>🔧 <code>:wrench:</code></td>\n<td>🔨 <code>:hammer:</code></td>\n<td>💰 <code>:moneybag:</code></td>\n</tr>\n<tr>\n<td>💵 <code>:dollar:</code></td>\n<td>💳 <code>:credit_card:</code></td>\n<td>✂️ <code>:scissors:</code></td>\n</tr>\n<tr>\n<td>📌 <code>:pushpin:</code></td>\n<td>📎 <code>:paperclip:</code></td>\n<td>✏️ <code>:pencil2:</code></td>\n</tr>\n<tr>\n<td>📕 <code>:closed_book:</code></td>\n<td>📚 <code>:books:</code></td>\n<td>🔖 <code>:bookmark:</code></td>\n</tr>\n<tr>\n<td>⚽ <code>:soccer:</code></td>\n<td>🏀 <code>:basketball:</code></td>\n<td>🎾 <code>:tennis:</code></td>\n</tr>\n<tr>\n<td>🏊 <code>:swimmer:</code></td>\n<td>🎮 <code>:video_game:</code></td>\n<td>🎬 <code>:clapper:</code></td>\n</tr>\n<tr>\n<td>📝 <code>:memo:</code></td>\n<td>🎤 <code>:microphone:</code></td>\n<td>🎧 <code>:headphones:</code></td>\n</tr>\n<tr>\n<td>👞 <code>:shoe:</code></td>\n<td>👠 <code>:high_heel:</code></td>\n<td>💄 <code>:lipstick:</code></td>\n</tr>\n<tr>\n<td>👕 <code>:tshirt:</code></td>\n<td>👖 <code>:jeans:</code></td>\n<td>👙 <code>:bikini:</code></td>\n</tr>\n<tr>\n<td>👑 <code>:crown:</code></td>\n<td>👓 <code>:eyeglasses:</code></td>\n<td>☕ <code>:coffee:</code></td>\n</tr>\n<tr>\n<td>🍵 <code>:tea:</code></td>\n<td>🍺 <code>:beer:</code></td>\n<td>🍕 <code>:pizza:</code></td>\n</tr>\n<tr>\n<td>🍔 <code>:hamburger:</code></td>\n<td>🍟 <code>:fries:</code></td>\n<td>🍣 <code>:sushi:</code></td>\n</tr>\n<tr>\n<td>🍚 <code>:rice:</code></td>\n<td>🍰 <code>:cake:</code></td>\n<td>🍫 <code>:chocolate_bar:</code></td>\n</tr>\n<tr>\n<td>🍎 <code>:apple:</code></td>\n<td>🍌 <code>:banana:</code></td>\n<td>🍅 <code>:tomato:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>place</code>:</p>\n<table>\n<thead>\n<tr>\n<th>🏠 <code>:house:</code></th>\n<th>🏡 <code>:house_with_garden:</code></th>\n<th>🏫 <code>:school:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🏢 <code>:office:</code></td>\n<td>🏣 <code>:post_office:</code></td>\n<td>🏥 <code>:hospital:</code></td>\n</tr>\n<tr>\n<td>🏦 <code>:bank:</code></td>\n<td>🏪 <code>:convenience_store:</code></td>\n<td>🏨 <code>:hotel:</code></td>\n</tr>\n<tr>\n<td>💒 <code>:wedding:</code></td>\n<td>⛪ <code>:church:</code></td>\n<td>🌇 <code>:city_sunrise:</code></td>\n</tr>\n<tr>\n<td>🏯 <code>:japanese_castle:</code></td>\n<td>🏰 <code>:european_castle:</code></td>\n<td>⛺ <code>:tent:</code></td>\n</tr>\n<tr>\n<td>🏭 <code>:factory:</code></td>\n<td>🗼 <code>:tokyo_tower:</code></td>\n<td>🗻 <code>:mount_fuji:</code></td>\n</tr>\n<tr>\n<td>🌄 <code>:sunrise_over_mountains:</code></td>\n<td>🌅 <code>:sunrise:</code></td>\n<td>🌈 <code>:rainbow:</code></td>\n</tr>\n<tr>\n<td>🎡 <code>:ferris_wheel:</code></td>\n<td>⛲ <code>:fountain:</code></td>\n<td>🎢 <code>:roller_coaster:</code></td>\n</tr>\n<tr>\n<td>🚢 <code>:ship:</code></td>\n<td>🚤 <code>:speedboat:</code></td>\n<td>⛵ <code>:sailboat:</code></td>\n</tr>\n<tr>\n<td>🚀 <code>:rocket:</code></td>\n<td>✈️ <code>:airplane:</code></td>\n<td>🚁 <code>:helicopter:</code></td>\n</tr>\n<tr>\n<td>🚂 <code>:train:</code></td>\n<td>🚊 <code>:tram:</code></td>\n<td>🚲 <code>:bike:</code></td>\n</tr>\n<tr>\n<td>🚗 <code>:car:</code></td>\n<td>🚕 <code>:taxi:</code></td>\n<td>🚌 <code>:bus:</code></td>\n</tr>\n<tr>\n<td>🚓 <code>:police_car:</code></td>\n<td>🚑 <code>:ambulance:</code></td>\n<td>🚚 <code>:truck:</code></td>\n</tr>\n<tr>\n<td>🚦 <code>:traffic_light:</code></td>\n<td>⚠️ <code>:warning:</code></td>\n<td>🚧 <code>:construction:</code></td>\n</tr>\n<tr>\n<td>🏧 <code>:atm:</code></td>\n<td>🎫 <code>:ticket:</code></td>\n<td>♨️ <code>:hotsprings:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>number</code>&amp;&amp; <code>directions</code>:</p>\n<table>\n<thead>\n<tr>\n<th>1️⃣ <code>:one:</code></th>\n<th>2️⃣ <code>:two:</code></th>\n<th>3️⃣ <code>:three:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4️⃣ <code>:four:</code></td>\n<td>5️⃣ <code>:five:</code></td>\n<td>6️⃣ <code>:six:</code></td>\n</tr>\n<tr>\n<td>7️⃣ <code>:seven:</code></td>\n<td>8️⃣ <code>:eight:</code></td>\n<td>9️⃣ <code>:nine:</code></td>\n</tr>\n<tr>\n<td>🔟 <code>:keycap_ten:</code></td>\n<td>0️⃣ <code>:zero:</code></td>\n<td>#️⃣ <code>:hash:</code></td>\n</tr>\n<tr>\n<td>◀️ <code>:arrow_backward:</code></td>\n<td>⬇️ <code>:arrow_down:</code></td>\n<td>▶️ <code>:arrow_forward:</code></td>\n</tr>\n<tr>\n<td>⬅️ <code>:arrow_left:</code></td>\n<td>➡️ <code>:arrow_right:</code></td>\n<td>⬆️ <code>:arrow_up:</code></td>\n</tr>\n<tr>\n<td>🔄 <code>:arrows_counterclockwise:</code></td>\n<td>ℹ️ <code>:information_source:</code></td>\n<td>🆗 <code>:ok:</code></td>\n</tr>\n<tr>\n<td>🆕 <code>:new:</code></td>\n<td>🆙 <code>:up:</code></td>\n<td>🆒 <code>:cool:</code></td>\n</tr>\n<tr>\n<td>🚻 <code>:restroom:</code></td>\n<td>🚹 <code>:mens:</code></td>\n<td>🚺 <code>:womens:</code></td>\n</tr>\n<tr>\n<td>♿ <code>:wheelchair:</code></td>\n<td>🚇 <code>:metro:</code></td>\n<td>🚫 <code>:no_entry_sign:</code></td>\n</tr>\n<tr>\n<td>⛔ <code>:no_entry:</code></td>\n<td>♻️ <code>:recycle:</code></td>\n<td>🕐 <code>:clock1:</code></td>\n</tr>\n<tr>\n<td>❌ <code>:x:</code></td>\n<td>❗ <code>:exclamation:</code></td>\n<td>⭕ <code>:o:</code></td>\n</tr>\n<tr>\n<td>➕ <code>:plus:</code></td>\n<td>➖ <code>:minus:</code></td>\n<td>✔️ <code>:check_mark:</code></td>\n</tr>\n<tr>\n<td>🔘 <code>:radio_button:</code></td>\n<td>🔗 <code>:link:</code></td>\n<td>✅ <code>:white_check_mark:</code></td>\n</tr>\n<tr>\n<td>⚫ <code>:black_circle:</code></td>\n<td>⚪ <code>:white_circle:</code></td>\n<td>🔴 <code>:red_circle:</code></td>\n</tr>\n<tr>\n<td>🔵 <code>:blue_circle:</code></td>\n<td>©️ <code>:copyright:</code></td>\n<td>®️ <code>:registered:</code></td>\n</tr>\n<tr>\n<td>™️ <code>:tm:</code></td>\n<td>🔶 <code>:orange_diamond:</code></td>\n<td>🔷 <code>:blue_diamond:</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-提示\">5.提示</h4>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">{%note 参数%} 文字内容 {%endnote%}<br></code></pre></td></tr></tbody></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default</code></td>\n<td>默认样式（灰色）</td>\n</tr>\n<tr>\n<td><code>primary</code></td>\n<td>主要样式（蓝色）</td>\n</tr>\n<tr>\n<td><code>info</code></td>\n<td>信息提示（浅蓝色）</td>\n</tr>\n<tr>\n<td><code>success</code></td>\n<td>成功提示（绿色）</td>\n</tr>\n<tr>\n<td><code>warning</code></td>\n<td>警告提示（黄色）</td>\n</tr>\n<tr>\n<td><code>danger</code></td>\n<td>危险/错误（红色）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>default</code></li>\n</ul>\n<div class=\"note note-info\">\n            <p>默认！</p>\n          </div>\n<ul>\n<li><code>primary</code></li>\n</ul>\n<div class=\"note note-primary\">\n            <p>主要！</p>\n          </div>\n<ul>\n<li><code>info</code></li>\n</ul>\n<div class=\"note note-info\">\n            <p>提示！</p>\n          </div>\n<ul>\n<li><code>success</code></li>\n</ul>\n<div class=\"note note-success\">\n            <p>成功！</p>\n          </div>\n<ul>\n<li><code>warning</code></li>\n</ul>\n<div class=\"note note-warning\">\n            <p>警告！</p>\n          </div>\n<ul>\n<li><code>danger</code></li>\n</ul>\n<div class=\"note note-danger\">\n            <p>危险！</p>\n          </div>\n<p>恭喜！ 看到这里你已经掌握了 Markdown 的核心语法和进阶技巧！</p>\n<p>✨ 小建议：</p>\n<p>精致排版 + 优质内容 = 王炸组合 💥 清晰的结构和美观的格式会让你的博客更专业、更吸睛！</p>\n<p>立刻动手写一篇吧！ 从今天开始，用 Markdown 打造你的技术分享博客，下一个顶尖技术博主就是你！ 🚀</p>\n<p>参考文献：<br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142665344\">Markdown 语法详解大全(超级版)（一）——标题、字体文本式样、颜色、列表、版块区块、缩进、列表项</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142711165\">Markdown 语法详解大全(超级版)（二）——图片、表格、段落、转义字符、内嵌、注释、缩进、公式</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142719257\">Markdown 语法详解大全(超级版)（三）——甘特图语法详解</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/140277283\">Markdown 语法详解大全(超级版)（四）——Markdown 使用 Emoji 表情 （附：表情符号简码列表）</a></p>\n","excerpt":"","more":"<h2 id=\"个人博客搭建指南：\">个人博客搭建指南：</h2>\n<p>  正所谓“工欲善其事必先利其器”，博主之前在csdn上写过一些简单，了解也使用过一些简单的markdown语法，但是最近新部署了github博客网站，发现别人的博客网站颜色华丽，排版精美，而我的博客却只有简单的标题、正文、斜体、加粗等简单的界面，煞是寡淡，于是上网学习，发现在markdown中可以添加HTML标签和CSS样式，使得界面变得更加丰富，更加美观，下面是一些markdown的基础语法和进阶玩法，希望对大家有所帮助。</p>\n <div class=\"note note-primary\">\n            <p><strong>前言</strong>： 不知大家是否和博主有着相同的疑惑，为什么别的博主写出来的博客排版工整、优雅美观，而自己的博客却毫无出彩之处。原先博主更多的关注点在技术博客的内容上，markdown语法仅仅靠csdn上的“语法说明”自己瞎琢磨的，现在放暑假正好有时间，再温习一下基础语法和学习一下进阶语法，来丰富自己的博客排版！这篇是我的学习笔记，博采众长，希望也能帮到大家！</p>\n          </div>\n<p>  下面分为两个板块进行阐述：<strong>基础语法</strong>和<strong>进阶语法</strong>，板块一可以帮助你简单入门，版块二则是语法的升级！下面我都在代码块中展示markdown的写法，下面是对应的博客展现形式，大家可以根据自己的需求进行选择和学习！</p>\n<h2 id=\"一、基础语法\">一、基础语法</h2>\n<h4 id=\"1-标题\">1.标题</h4>\n<p>输入<code>#</code>+<code>space（空格）</code>就是不同等级的标题（最多只有六个等级）</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-section\"># 一级标题</span><br><span class=\"hljs-section\">## 二级标题</span><br><span class=\"hljs-section\">### 三级标题</span><br><span class=\"hljs-section\">#### 四级标题</span><br><span class=\"hljs-section\">##### 五级标题</span><br><span class=\"hljs-section\">###### 六级标题</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<h1>一级标题</h1>\n<h2 id=\"二级标题\">二级标题</h2>\n<h3 id=\"三级标题\">三级标题</h3>\n<h4 id=\"四级标题\">四级标题</h4>\n<h5 id=\"五级标题\">五级标题</h5>\n<h6 id=\"六级标题\">六级标题</h6>\n</blockquote>\n<h4 id=\"2-文本样式\">2.文本样式</h4>\n<p><strong>斜体</strong>：<code>*</code>+<code>文本内容</code>+<code>*</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mardown\">*这是一个斜体*<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><em>这是一个斜体</em></p>\n</blockquote>\n<p><strong>加粗</strong>：<code>**</code>+<code>文本内容</code>+<code>**</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mardown\">**这里进行了加粗**<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>这里进行了加粗</strong></p>\n</blockquote>\n<p><strong>斜体加粗</strong>：<code>***</code>+<code>文本内容</code>+<code>***</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-strong\">**<span class=\"hljs-emphasis\">*这里是斜体加粗*</span>**</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><em><strong>这里是斜体加粗</strong></em></p>\n</blockquote>\n<p><strong>删除线</strong>：<code>~~</code>+<code>文本内容</code>+<code>~~</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">~~这里是删除线~~<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><s>这里是删除线</s></p>\n</blockquote>\n<p><strong>分割线</strong>：在一行中用三个以上的星号建立一个分隔线，行内不能有其他内容，也可以在星号中间插入空格。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">*</span> * <span class=\"hljs-emphasis\">*</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<hr>\n</blockquote>\n<h4 id=\"3-列表\">3.列表</h4>\n<p><strong>无序列表</strong>：<code>-</code>或<code>*</code>或<code>+</code>+<code>space（空格）</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 无序列表1<br><span class=\"hljs-bullet\">-</span> 无序列表2<br><span class=\"hljs-bullet\">-</span> 无序列表3<br></code></pre></td></tr></table></figure>\n<ul>\n<li>无序列表1</li>\n<li>无序列表2</li>\n<li>无序列表3</li>\n</ul>\n<p><strong>有序列表</strong>：<code>数字序号</code>+<code>.</code>+<code>space（空格）</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">1.</span> 有序列表1<br><span class=\"hljs-bullet\">2.</span> 有序列表2<br><span class=\"hljs-bullet\">3.</span> 有序列表3<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n<li>有序列表3</li>\n</ol>\n</blockquote>\n<p><strong>嵌套列表</strong>：<br>\n<code>-</code>+<code>space</code>+<code>第一级无序列表1</code><br>\n<code>space*2</code>+<code>-</code>+<code>第二级无序列表2</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-bullet\">-</span> 嵌套列表1<br><span class=\"hljs-bullet\">  -</span> 嵌套列表2<br><span class=\"hljs-bullet\">    -</span> 嵌套列表3<br></code></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>嵌套列表1\n<ul>\n<li>嵌套列表2\n<ul>\n<li>嵌套列表3</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"4-板块\">4.板块</h4>\n<p><strong>表格</strong>：<br>\n<code>|</code>+ <code>每列的标题</code>+<code>|</code>+<code>每列的标题</code>+<code>|</code><br>\n<code>|</code>+ <code>----| ----</code>+<code>|</code><br>\n<code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code><br>\n<code>|</code>+ <code>每列内容</code>+<code>|</code>+<code>每列内容</code>+<code>|</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">|语言类型 |输出函数|<br>| --- | ----------- |<br>|c语言|printf|<br>|c++|cout|<br>|python|print|<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>语言类型</th>\n<th>输出函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>c语言</td>\n<td>printf</td>\n</tr>\n<tr>\n<td>c++</td>\n<td>cout</td>\n</tr>\n<tr>\n<td>python</td>\n<td>print</td>\n</tr>\n</tbody>\n</table>\n<p>可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（:），将列中的文本对齐到左侧，右侧或中心。</p>\n<blockquote>\n<p>:— 设置内容和标题栏居左对齐。<br>\n:----: 设置内容和标题栏居中对齐。<br>\n—: 设置内容和标题栏居右对齐。</p>\n</blockquote>\n<p><strong>代码块</strong>：前后三个```即可，可自定义选择编程语言</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;这是一个代码块&quot;</span>)<br><span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;这是使用的python语言&quot;</span>)<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>cout&lt;&lt;<span class=\"hljs-string\">&quot;这是一个c++的代码块！&quot;</span>&lt;&lt;endl;<br><span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;&#125;<br></code></pre></td></tr></table></figure>\n<p><strong>链接</strong>：<code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>)</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">不在了情绪的博客主页：[<span class=\"hljs-string\">不在了情绪</span>](<span class=\"hljs-link\">https://blog.csdn.net/2401_86849688?type=blog</span>)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>不在了情绪的博客主页：<a href=\"https://blog.csdn.net/2401_86849688?type=blog\">不在了情绪</a></p>\n</blockquote>\n<p>我们还可以给这个链接添加title，当鼠标悬停在链接上会出现提示。<br>\n<code>[</code>+<code>超链接显示名</code>+<code>]</code>+<code>(</code>+<code>超链接地址</code>+<code>space</code>+<code>&quot;链接title&quot;</code>+<code>)</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">不在了情绪的博客主页：[<span class=\"hljs-string\">不在了情绪</span>](<span class=\"hljs-link\">https://blog.csdn.net/2401_86849688?type=blog &quot;欢迎来到我的博客！&quot;</span>)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>不在了情绪的博客主页：<a href=\"https://blog.csdn.net/2401_86849688?type=blog\" title=\"欢迎来到我的博客！\">不在了情绪</a></p>\n</blockquote>\n<p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\">&lt;https://blog.csdn.net/2401_86849688?type=blog&gt;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/2401_86849688?type=blog\">https://blog.csdn.net/2401_86849688?type=blog</a></p>\n</blockquote>\n<p>要显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \\</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">\\<span class=\"hljs-emphasis\">*我想要输出的是两个星号*</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>*我想要输出的是两个星号*</p>\n</blockquote>\n<h2 id=\"二、进阶用法\">二、进阶用法</h2>\n<h4 id=\"1-字体与背景\">1.字体与背景</h4>\n<p><code>&lt;font face=&quot;字体&quot;&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">&quot;黑体&quot;</span>&gt;</span></span>这是黑体<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">&quot;微软雅黑&quot;</span>&gt;</span></span>这是微软雅黑<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">face</span>=<span class=\"hljs-string\">&quot;STCAIYUN&quot;</span>&gt;</span></span>这是华文彩云<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><font face=\"黑体\">这是黑体</font><br>\n<font face=\"微软雅黑\">这是微软雅黑</font><br>\n<font face=\"STCAIYUN\">这是华文彩云</font></p>\n</blockquote>\n<p><code>&lt;font size=字体大小&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">4</span>&gt;</span></span>字体大小为4的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">3</span>&gt;</span></span>字体大小为3的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">2</span>&gt;</span></span>字体大小为2的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">size</span>=<span class=\"hljs-string\">1</span>&gt;</span></span>字体大小为1的文字<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><font size=4>字体大小为4的文字</font><br>\n<font size=3>字体大小为3的文字</font><br>\n<font size=2>字体大小为2的文字</font><br>\n<font size=1>字体大小为1的文字</font></p>\n</blockquote>\n<p><code>&lt;font color=“color”&gt;</code>+<code>文本内容</code>+<code>&lt;/font&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">&quot;red&quot;</span>&gt;</span></span>红色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">&quot;green&quot;</span>&gt;</span></span>绿色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">&quot;blue&quot;</span>&gt;</span></span>蓝色的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><font color=\"red\">红色的文本内容</font><br>\n<font color=\"green\">绿色的文本内容</font><br>\n<font color=\"blue\">蓝色的文本内容</font></p>\n</blockquote>\n<p><code>&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;</code>或者<code>==</code>+<code>文本内容</code>+<code>==</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>高亮显示的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><br>==高亮显示的文本内容==<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><mark>高亮显示的文本内容</mark><br>\n==高亮显示的文本内容==</p>\n</blockquote>\n<p><code>&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=“color”&gt;&lt;mark&gt;</code>+<code>文本内容</code>+<code>&lt;/mark&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">&quot;green&quot;</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></span><br><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span> <span class=\"hljs-attr\">bgcolor</span>=<span class=\"hljs-string\">&quot;red&quot;</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mark</span>&gt;</span></span>有背景颜色的高亮文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mark</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span></span><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<table><tr><td bgcolor=\"green\"><mark>有背景颜色的高亮文本内容</mark></td></tr></table>\n<table><tr><td bgcolor=\"red\"><mark>有背景颜色的高亮文本内容</td></tr></table>\n</blockquote>\n<p><code>&lt;u&gt;</code>+<code>文本内容</code>+<code>&lt;/u&gt;</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">u</span>&gt;</span></span>下划线的文本内容<span class=\"language-xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">u</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><u>下划线的文本内容</u></p>\n</blockquote>\n<p><code>&gt;</code>+<code>文本内容</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">&gt;引用的文本内容<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>引用的文本内容</p>\n</blockquote>\n<h4 id=\"2-段落缩进\">2.段落缩进</h4>\n<p><strong>首行缩进</strong>：</p>\n<ul>\n<li>全角：<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li>\n<li>半角：<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li>\n<li>半角之半角：<code>&amp;nbsp;</code>或<code>&amp;#160;</code></li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\"><span class=\"hljs-literal\">&amp;emsp;</span><span class=\"hljs-literal\">&amp;emsp;</span>磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>  磨刀不误砍柴工，好好学习、反复练习markdown语法，才能在日后的博客撰写中手到擒来，手拿把掐！</p>\n</blockquote>\n<h4 id=\"3-公式\">3.公式</h4>\n<p>  在markdown中可以使用<code>$$</code>来作为公式块，在其中进行Latex类型公式的输入！</p>\n<p><code>$</code> + <code>公式</code> + <code>$</code></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">$x^2-y^2=(x+y)(x-y)$<br>$$(x-y)^2=x^2-2xy+y^2$$<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>$x<sup>2-y</sup>2=(x+y)(x-y)$</p>\n</blockquote>\n<blockquote>\n<p>$$(x-y)<sup>2=x</sup>2-2xy+y^2$$</p>\n</blockquote>\n<h4 id=\"4-表情\">4.表情</h4>\n<p>我们可以通过键入<code>emoji shortcodes</code>来输出表情包：<br>\n<code>man</code>:</p>\n<table>\n<thead>\n<tr>\n<th>😄 <code>:smile:</code></th>\n<th>😊 <code>:blush:</code></th>\n<th>😍 <code>:heart_eyes:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>😘 <code>:kissing_heart:</code></td>\n<td>😳 <code>:flushed:</code></td>\n<td>😁 <code>:grin:</code></td>\n</tr>\n<tr>\n<td>😉 <code>:wink:</code></td>\n<td>😜 <code>:tongue_wink:</code></td>\n<td>😀 <code>:grinning:</code></td>\n</tr>\n<tr>\n<td>😴 <code>:sleeping:</code></td>\n<td>😟 <code>:worried:</code></td>\n<td>😮 <code>:open_mouth:</code></td>\n</tr>\n<tr>\n<td>😕 <code>:confused:</code></td>\n<td>😑 <code>:expressionless:</code></td>\n<td>😅 <code>:sweat_smile:</code></td>\n</tr>\n<tr>\n<td>😥 <code>:sad_relieved:</code></td>\n<td>😢 <code>:cry:</code></td>\n<td>😭 <code>:sob:</code></td>\n</tr>\n<tr>\n<td>😂 <code>:joy:</code></td>\n<td>😱 <code>:scream:</code></td>\n<td>😠 <code>:angry:</code></td>\n</tr>\n<tr>\n<td>😡 <code>:rage:</code></td>\n<td>😷 <code>:mask:</code></td>\n<td>😎 <code>:sunglasses:</code></td>\n</tr>\n<tr>\n<td>😇 <code>:innocent:</code></td>\n<td>❤️ <code>:heart:</code></td>\n<td>💔 <code>:broken_heart:</code></td>\n</tr>\n<tr>\n<td>✨ <code>:sparkles:</code></td>\n<td>👍 <code>:thumbsup:</code></td>\n<td>👎 <code>:thumbsdown:</code></td>\n</tr>\n<tr>\n<td>👌 <code>:ok_hand:</code></td>\n<td>✊ <code>:fist:</code></td>\n<td>✌️ <code>:v:</code></td>\n</tr>\n<tr>\n<td>👋 <code>:wave:</code></td>\n<td>🙌 <code>:raised_hands:</code></td>\n<td>🙏 <code>:pray:</code></td>\n</tr>\n<tr>\n<td>👏 <code>:clap:</code></td>\n<td>💪 <code>:muscle:</code></td>\n<td>🏃 <code>:running:</code></td>\n</tr>\n<tr>\n<td>👫 <code>:couple:</code></td>\n<td>👪 <code>:family:</code></td>\n<td>💃 <code>:dancer:</code></td>\n</tr>\n<tr>\n<td>🙅 <code>:no_good:</code></td>\n<td>💁 <code>:info_desk:</code></td>\n<td>👶 <code>:baby:</code></td>\n</tr>\n<tr>\n<td>👩 <code>:woman:</code></td>\n<td>👨 <code>:man:</code></td>\n<td>👵 <code>:grandma:</code></td>\n</tr>\n<tr>\n<td>👴 <code>:grandpa:</code></td>\n<td>👮 <code>:police:</code></td>\n<td>😺 <code>:smile_cat:</code></td>\n</tr>\n<tr>\n<td>🙈 <code>:see_no_evil:</code></td>\n<td>💀 <code>:skull:</code></td>\n<td>💋 <code>:kiss:</code></td>\n</tr>\n<tr>\n<td>👀 <code>:eyes:</code></td>\n<td>👄 <code>:mouth:</code></td>\n<td>💬 <code>:speech_bubble:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>nature</code>:</p>\n<table>\n<thead>\n<tr>\n<th>☀️ <code>:sunny:</code></th>\n<th>☔ <code>:umbrella:</code></th>\n<th>☁️ <code>:cloud:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>❄️ <code>:snowflake:</code></td>\n<td>⛄ <code>:snowman:</code></td>\n<td>⚡ <code>:zap:</code></td>\n</tr>\n<tr>\n<td>🌊 <code>:ocean:</code></td>\n<td>🐱 <code>:cat:</code></td>\n<td>🐶 <code>:dog:</code></td>\n</tr>\n<tr>\n<td>🐭 <code>:mouse:</code></td>\n<td>🐰 <code>:rabbit:</code></td>\n<td>🐯 <code>:tiger:</code></td>\n</tr>\n<tr>\n<td>🐨 <code>:koala:</code></td>\n<td>🐻 <code>:bear:</code></td>\n<td>🐷 <code>:pig:</code></td>\n</tr>\n<tr>\n<td>🐮 <code>:cow:</code></td>\n<td>🐵 <code>:monkey:</code></td>\n<td>🐴 <code>:horse:</code></td>\n</tr>\n<tr>\n<td>🐘 <code>:elephant:</code></td>\n<td>🐼 <code>:panda:</code></td>\n<td>🐍 <code>:snake:</code></td>\n</tr>\n<tr>\n<td>🐦 <code>:bird:</code></td>\n<td>🐤 <code>:chick:</code></td>\n<td>🐧 <code>:penguin:</code></td>\n</tr>\n<tr>\n<td>🐢 <code>:turtle:</code></td>\n<td>🐝 <code>:bee:</code></td>\n<td>🐙 <code>:octopus:</code></td>\n</tr>\n<tr>\n<td>🐠 <code>:fish:</code></td>\n<td>🐳 <code>:whale:</code></td>\n<td>🐬 <code>:dolphin:</code></td>\n</tr>\n<tr>\n<td>🌸 <code>:cherry_blossom:</code></td>\n<td>🌹 <code>:rose:</code></td>\n<td>🌻 <code>:sunflower:</code></td>\n</tr>\n<tr>\n<td>🍁 <code>:maple_leaf:</code></td>\n<td>🍄 <code>:mushroom:</code></td>\n<td>🌵 <code>:cactus:</code></td>\n</tr>\n<tr>\n<td>🌴 <code>:palm_tree:</code></td>\n<td>🌲 <code>:tree:</code></td>\n<td>🌞 <code>:sun_with_face:</code></td>\n</tr>\n<tr>\n<td>🌙 <code>:moon:</code></td>\n<td>🌎 <code>:earth:</code></td>\n<td>🌋 <code>:volcano:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>objects</code>:</p>\n<table>\n<thead>\n<tr>\n<th>🎍 <code>:bamboo:</code></th>\n<th>💝 <code>:gift_heart:</code></th>\n<th>🎒 <code>:school_satchel:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🎓 <code>:mortar_board:</code></td>\n<td>🎏 <code>:flags:</code></td>\n<td>🎆 <code>:fireworks:</code></td>\n</tr>\n<tr>\n<td>🎇 <code>:sparkler:</code></td>\n<td>🎃 <code>:jack_o_lantern:</code></td>\n<td>👻 <code>:ghost:</code></td>\n</tr>\n<tr>\n<td>🎅 <code>:santa:</code></td>\n<td>🎄 <code>:christmas_tree:</code></td>\n<td>🎁 <code>:gift:</code></td>\n</tr>\n<tr>\n<td>🔔 <code>:bell:</code></td>\n<td>🎉 <code>:tada:</code></td>\n<td>🎊 <code>:confetti_ball:</code></td>\n</tr>\n<tr>\n<td>🎈 <code>:balloon:</code></td>\n<td>📷 <code>:camera:</code></td>\n<td>🎥 <code>:movie_camera:</code></td>\n</tr>\n<tr>\n<td>💻 <code>:computer:</code></td>\n<td>📺 <code>:tv:</code></td>\n<td>📱 <code>:iphone:</code></td>\n</tr>\n<tr>\n<td>☎️ <code>:phone:</code></td>\n<td>📞 <code>:telephone_receiver:</code></td>\n<td>💡 <code>:bulb:</code></td>\n</tr>\n<tr>\n<td>🔋 <code>:battery:</code></td>\n<td>📧 <code>:email:</code></td>\n<td>✉️ <code>:envelope:</code></td>\n</tr>\n<tr>\n<td>🛀 <code>:bath:</code></td>\n<td>🚿 <code>:shower:</code></td>\n<td>🚽 <code>:toilet:</code></td>\n</tr>\n<tr>\n<td>🔧 <code>:wrench:</code></td>\n<td>🔨 <code>:hammer:</code></td>\n<td>💰 <code>:moneybag:</code></td>\n</tr>\n<tr>\n<td>💵 <code>:dollar:</code></td>\n<td>💳 <code>:credit_card:</code></td>\n<td>✂️ <code>:scissors:</code></td>\n</tr>\n<tr>\n<td>📌 <code>:pushpin:</code></td>\n<td>📎 <code>:paperclip:</code></td>\n<td>✏️ <code>:pencil2:</code></td>\n</tr>\n<tr>\n<td>📕 <code>:closed_book:</code></td>\n<td>📚 <code>:books:</code></td>\n<td>🔖 <code>:bookmark:</code></td>\n</tr>\n<tr>\n<td>⚽ <code>:soccer:</code></td>\n<td>🏀 <code>:basketball:</code></td>\n<td>🎾 <code>:tennis:</code></td>\n</tr>\n<tr>\n<td>🏊 <code>:swimmer:</code></td>\n<td>🎮 <code>:video_game:</code></td>\n<td>🎬 <code>:clapper:</code></td>\n</tr>\n<tr>\n<td>📝 <code>:memo:</code></td>\n<td>🎤 <code>:microphone:</code></td>\n<td>🎧 <code>:headphones:</code></td>\n</tr>\n<tr>\n<td>👞 <code>:shoe:</code></td>\n<td>👠 <code>:high_heel:</code></td>\n<td>💄 <code>:lipstick:</code></td>\n</tr>\n<tr>\n<td>👕 <code>:tshirt:</code></td>\n<td>👖 <code>:jeans:</code></td>\n<td>👙 <code>:bikini:</code></td>\n</tr>\n<tr>\n<td>👑 <code>:crown:</code></td>\n<td>👓 <code>:eyeglasses:</code></td>\n<td>☕ <code>:coffee:</code></td>\n</tr>\n<tr>\n<td>🍵 <code>:tea:</code></td>\n<td>🍺 <code>:beer:</code></td>\n<td>🍕 <code>:pizza:</code></td>\n</tr>\n<tr>\n<td>🍔 <code>:hamburger:</code></td>\n<td>🍟 <code>:fries:</code></td>\n<td>🍣 <code>:sushi:</code></td>\n</tr>\n<tr>\n<td>🍚 <code>:rice:</code></td>\n<td>🍰 <code>:cake:</code></td>\n<td>🍫 <code>:chocolate_bar:</code></td>\n</tr>\n<tr>\n<td>🍎 <code>:apple:</code></td>\n<td>🍌 <code>:banana:</code></td>\n<td>🍅 <code>:tomato:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>place</code>:</p>\n<table>\n<thead>\n<tr>\n<th>🏠 <code>:house:</code></th>\n<th>🏡 <code>:house_with_garden:</code></th>\n<th>🏫 <code>:school:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🏢 <code>:office:</code></td>\n<td>🏣 <code>:post_office:</code></td>\n<td>🏥 <code>:hospital:</code></td>\n</tr>\n<tr>\n<td>🏦 <code>:bank:</code></td>\n<td>🏪 <code>:convenience_store:</code></td>\n<td>🏨 <code>:hotel:</code></td>\n</tr>\n<tr>\n<td>💒 <code>:wedding:</code></td>\n<td>⛪ <code>:church:</code></td>\n<td>🌇 <code>:city_sunrise:</code></td>\n</tr>\n<tr>\n<td>🏯 <code>:japanese_castle:</code></td>\n<td>🏰 <code>:european_castle:</code></td>\n<td>⛺ <code>:tent:</code></td>\n</tr>\n<tr>\n<td>🏭 <code>:factory:</code></td>\n<td>🗼 <code>:tokyo_tower:</code></td>\n<td>🗻 <code>:mount_fuji:</code></td>\n</tr>\n<tr>\n<td>🌄 <code>:sunrise_over_mountains:</code></td>\n<td>🌅 <code>:sunrise:</code></td>\n<td>🌈 <code>:rainbow:</code></td>\n</tr>\n<tr>\n<td>🎡 <code>:ferris_wheel:</code></td>\n<td>⛲ <code>:fountain:</code></td>\n<td>🎢 <code>:roller_coaster:</code></td>\n</tr>\n<tr>\n<td>🚢 <code>:ship:</code></td>\n<td>🚤 <code>:speedboat:</code></td>\n<td>⛵ <code>:sailboat:</code></td>\n</tr>\n<tr>\n<td>🚀 <code>:rocket:</code></td>\n<td>✈️ <code>:airplane:</code></td>\n<td>🚁 <code>:helicopter:</code></td>\n</tr>\n<tr>\n<td>🚂 <code>:train:</code></td>\n<td>🚊 <code>:tram:</code></td>\n<td>🚲 <code>:bike:</code></td>\n</tr>\n<tr>\n<td>🚗 <code>:car:</code></td>\n<td>🚕 <code>:taxi:</code></td>\n<td>🚌 <code>:bus:</code></td>\n</tr>\n<tr>\n<td>🚓 <code>:police_car:</code></td>\n<td>🚑 <code>:ambulance:</code></td>\n<td>🚚 <code>:truck:</code></td>\n</tr>\n<tr>\n<td>🚦 <code>:traffic_light:</code></td>\n<td>⚠️ <code>:warning:</code></td>\n<td>🚧 <code>:construction:</code></td>\n</tr>\n<tr>\n<td>🏧 <code>:atm:</code></td>\n<td>🎫 <code>:ticket:</code></td>\n<td>♨️ <code>:hotsprings:</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>number</code>&amp;&amp; <code>directions</code>:</p>\n<table>\n<thead>\n<tr>\n<th>1️⃣ <code>:one:</code></th>\n<th>2️⃣ <code>:two:</code></th>\n<th>3️⃣ <code>:three:</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4️⃣ <code>:four:</code></td>\n<td>5️⃣ <code>:five:</code></td>\n<td>6️⃣ <code>:six:</code></td>\n</tr>\n<tr>\n<td>7️⃣ <code>:seven:</code></td>\n<td>8️⃣ <code>:eight:</code></td>\n<td>9️⃣ <code>:nine:</code></td>\n</tr>\n<tr>\n<td>🔟 <code>:keycap_ten:</code></td>\n<td>0️⃣ <code>:zero:</code></td>\n<td>#️⃣ <code>:hash:</code></td>\n</tr>\n<tr>\n<td>◀️ <code>:arrow_backward:</code></td>\n<td>⬇️ <code>:arrow_down:</code></td>\n<td>▶️ <code>:arrow_forward:</code></td>\n</tr>\n<tr>\n<td>⬅️ <code>:arrow_left:</code></td>\n<td>➡️ <code>:arrow_right:</code></td>\n<td>⬆️ <code>:arrow_up:</code></td>\n</tr>\n<tr>\n<td>🔄 <code>:arrows_counterclockwise:</code></td>\n<td>ℹ️ <code>:information_source:</code></td>\n<td>🆗 <code>:ok:</code></td>\n</tr>\n<tr>\n<td>🆕 <code>:new:</code></td>\n<td>🆙 <code>:up:</code></td>\n<td>🆒 <code>:cool:</code></td>\n</tr>\n<tr>\n<td>🚻 <code>:restroom:</code></td>\n<td>🚹 <code>:mens:</code></td>\n<td>🚺 <code>:womens:</code></td>\n</tr>\n<tr>\n<td>♿ <code>:wheelchair:</code></td>\n<td>🚇 <code>:metro:</code></td>\n<td>🚫 <code>:no_entry_sign:</code></td>\n</tr>\n<tr>\n<td>⛔ <code>:no_entry:</code></td>\n<td>♻️ <code>:recycle:</code></td>\n<td>🕐 <code>:clock1:</code></td>\n</tr>\n<tr>\n<td>❌ <code>:x:</code></td>\n<td>❗ <code>:exclamation:</code></td>\n<td>⭕ <code>:o:</code></td>\n</tr>\n<tr>\n<td>➕ <code>:plus:</code></td>\n<td>➖ <code>:minus:</code></td>\n<td>✔️ <code>:check_mark:</code></td>\n</tr>\n<tr>\n<td>🔘 <code>:radio_button:</code></td>\n<td>🔗 <code>:link:</code></td>\n<td>✅ <code>:white_check_mark:</code></td>\n</tr>\n<tr>\n<td>⚫ <code>:black_circle:</code></td>\n<td>⚪ <code>:white_circle:</code></td>\n<td>🔴 <code>:red_circle:</code></td>\n</tr>\n<tr>\n<td>🔵 <code>:blue_circle:</code></td>\n<td>©️ <code>:copyright:</code></td>\n<td>®️ <code>:registered:</code></td>\n</tr>\n<tr>\n<td>™️ <code>:tm:</code></td>\n<td>🔶 <code>:orange_diamond:</code></td>\n<td>🔷 <code>:blue_diamond:</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-提示\">5.提示</h4>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">&#123;%note 参数%&#125; 文字内容 &#123;%endnote%&#125;<br></code></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>default</code></td>\n<td>默认样式（灰色）</td>\n</tr>\n<tr>\n<td><code>primary</code></td>\n<td>主要样式（蓝色）</td>\n</tr>\n<tr>\n<td><code>info</code></td>\n<td>信息提示（浅蓝色）</td>\n</tr>\n<tr>\n<td><code>success</code></td>\n<td>成功提示（绿色）</td>\n</tr>\n<tr>\n<td><code>warning</code></td>\n<td>警告提示（黄色）</td>\n</tr>\n<tr>\n<td><code>danger</code></td>\n<td>危险/错误（红色）</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>default</code></li>\n</ul>\n<div class=\"note note-info\">\n            <p>默认！</p>\n          </div>\n<ul>\n<li><code>primary</code></li>\n</ul>\n<div class=\"note note-primary\">\n            <p>主要！</p>\n          </div>\n<ul>\n<li><code>info</code></li>\n</ul>\n<div class=\"note note-info\">\n            <p>提示！</p>\n          </div>\n<ul>\n<li><code>success</code></li>\n</ul>\n<div class=\"note note-success\">\n            <p>成功！</p>\n          </div>\n<ul>\n<li><code>warning</code></li>\n</ul>\n<div class=\"note note-warning\">\n            <p>警告！</p>\n          </div>\n<ul>\n<li><code>danger</code></li>\n</ul>\n<div class=\"note note-danger\">\n            <p>危险！</p>\n          </div>\n<p>恭喜！ 看到这里你已经掌握了 Markdown 的核心语法和进阶技巧！</p>\n<p>✨ 小建议：</p>\n<p>精致排版 + 优质内容 = 王炸组合 💥 清晰的结构和美观的格式会让你的博客更专业、更吸睛！</p>\n<p>立刻动手写一篇吧！ 从今天开始，用 Markdown 打造你的技术分享博客，下一个顶尖技术博主就是你！ 🚀</p>\n<p>参考文献：<br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142665344\">Markdown 语法详解大全(超级版)（一）——标题、字体文本式样、颜色、列表、版块区块、缩进、列表项</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142711165\">Markdown 语法详解大全(超级版)（二）——图片、表格、段落、转义字符、内嵌、注释、缩进、公式</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/142719257\">Markdown 语法详解大全(超级版)（三）——甘特图语法详解</a><br>\n<a href=\"https://blog.csdn.net/weixin_69553582/article/details/140277283\">Markdown 语法详解大全(超级版)（四）——Markdown 使用 Emoji 表情 （附：表情符号简码列表）</a></p>\n"},{"title":"Offload Your Hexo Images","date":"2025-08-21T08:59:18.000Z","index_img":"https://github.com/Richard110206/Blog-image/blob/main/cover/ImageHosting.png?raw=true","category_bar":true,"description":"Using GitHub in conjunction with PicGo to establish an image hosting service.","_content":"\n{%note info%}之前刚开始进行`Hexo`博客撰写，图片都保存在本地`Hexo`源文件目录（`source/images/`）文件夹，随着图片增多，管理起来压力增大，于是产生了使用图床，引入外链进行图片存储的想法！{%endnote%}\n\n## `Pros and Cons`\n{%note info%}\n- **提升部署速度**：当你执行 `hexo g -d `部署时，`Hexo` 需要将你博客的所有源文件，包括文章、主题、以及几十上百张图片，全部处理并拷贝到`public`文件夹，然后再将这个巨大的文件夹推送到`GitHub`，这个过程会非常缓慢。\n- **跨设备写作与协作更方便**：本地存储时，如果你想在另一台电脑上写文章，必须把整个包含所有图片的庞大仓库克隆下来。而使用图床，你只需要克隆**轻量级的博客源码仓库**。文章里的图片都是绝对路径（`URL`），在任何设备上打开都能正常显示。\n- **版本控制体验极佳**：使用图床后，你的博客源码仓库非常干净，`Git` 可以高效地管理文本差异。图片仓库独立出去，两者互不干扰，管理起来清晰明了。\n{%endnote%}\n\n&emsp;&emsp;正因为有以上优势，因而我强烈建议将图片放在图床中进行存储，常见的的**图床服务**有[阿里云OSS](https://oss.console.aliyun.com)、[腾讯云 COS](https://console.cloud.tencent.com/cos5)、[七牛云](https://portal.qiniu.com/kodo)、[SM.MS](https://sm.ms/)、[Github](https://github.com/)等。\n&emsp;&emsp;考虑到前几者涉及到注册、实名认证、存储收费等问题，再加上认为`Github`大概率不会倒闭，图片存储较为稳定，且已有账号注册等原因，最终选择使用[PicGo插件](https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here)和`Github`实现**图床**功能！\n\n{%note info%}\n- 更简单的图床功能网站：[IMG.TG](https://img.tg/richard_11_02_06)（但是感觉像`start up company`界面有点简陋，担心有**存储不稳定**的问题）（后来发现有国内百度云 CDN 节点加速，口碑还不错，那大抵是我手拙无福消受了:cry:）\n\n- 不想折腾的可以看看这篇骚操作:grinning:：[图片外链方法大全： 免费的图床！ 告别新浪图床 和 CDN](https://blog.csdn.net/hotdog233/article/details/119380498?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E7%89%87%E7%9B%B4%E9%93%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119380498.142^v102^pc_search_result_base2&spm=1018.2226.3001.4187)\n{%endnote%}\n\n\n下面分别介绍 `PicGo` **图形化桌面版**（适合新手，操作直观）和 `PicGo-Core` **命令行版**（适合终端用户，轻量化）的完整配置流程，实现`GitHub`图床功能。\n### 一、准备工作\n以 `GitHub` 图床 为例，配置步骤如下：\n1. 创建 `GitHub` 仓库\n2. 新建一个公开仓库（如 `blog-images`），用于存储图片\n3. 记住仓库路径：用户名/仓库名（如 `username/blog-images`）\n4. 生成 `GitHub` 访问令牌\n- 打开 `GitHub` → 点击头像 → `Settings` → `Developer settings` → `Personal access tokens` → `Generate new token`\n- **勾选 `repo` 权限**（**必须**），生成后复制令牌（仅显示一次，需在记事本中保存）\n选择并安装**图床插件**\n根据需求安装对应图床的插件，以常用的`GitHub`图床 为例：\n```bash\npicgo install github-plus  # GitHub 增强插件，支持自定义路径等\n```\n其他常用插件：\n- 阿里云 OSS：`picgo install aliyun-oss`\n- 腾讯云 COS：`picgo install tencent-cos`\n- 七牛云：`picgo install qiniu`\n\n### 二、配置图床参数\n安装 `Node.js`（命令行版必装，图形化版可选）\n下载地址：[Node.js 官网](https://nodejs.org/zh-cn)（推荐 LTS 版本）。\n验证安装：终端输入 `node -v` 和 `npm -v`，能显示版本号即成功。\n\n### 三、`PicGo` 图形化桌面版配置（新手推荐）\n图形化界面**操作直观**，无需记忆命令，适合首次配置图床的用户。\n\n1. 安装`PicGo`桌面版\n下载地址：[PicGo GitHub Releases](https://github.com/Molunerfinn/PicGo/releases)。\n选择对应系统版本（`Windows` 选 `exe`，`Mac` 选 `dmg`），安装后打开。\n2. 配置 GitHub 图床参数\n左侧菜单栏点击 「`图床设置`」 → 选择 「`GitHub图床`」）。\n依次填写参数：\n- `repo`：用户名/仓库名（如 `username/blog-images`）\n- `branch`：分支名（默认 `main`）\n- `token`：刚才生成的 `GitHub` 令牌\n- `path`：图片在`github`的存储路径（可选，如 `images/2024/`）\n- `customUrl`：自定义 CDN 域名（可选，如 `https://cdn.jsdelivr.net/gh/用户名/仓库名`）\n填写完成后，点击 「`设为默认图床`」，配置生效。\n3. 验证配置（上传测试）\n点击 `PicGo` 主界面的 「`上传区`」，**直接拖入本地图片**，或**粘贴剪贴板截图**（如微信截图后直接粘贴或电脑快捷键截图）。上传成功后，进入`Github`，进入图片右键`复制图片链接`即可！\n### 三、`PicGo-Core` 命令行版配置（终端用户推荐）\n**轻量化**、**无界面**，适合习惯用终端操作的用户，**可集成到脚本或编辑器**中。\n1. 安装 `PicGo-Core`\n打开终端（`Windows` 用 `CMD/PowerShell`，`Mac/Linux` 用 `Terminal`），执行以下命令全局安装：\n```bash\nnpm install picgo -g\n```\n- 验证安装：输入 `picgo -v`，显示版本号即成功。\n\n2. 安装 `GitHub` 图床插件\n```bash\npicgo install github-plus\n```\n其他常用图床插件（按需安装）：\n- 阿里云 OSS：`picgo install aliyun-oss`\n- 腾讯云 COS：`picgo install tencent-cos`\n- 七牛云：`picgo install qiniu`\n\n3. 配置 `GitHub` 图床参数\n```bash\npicgo set uploader\n```\n依次**填写参数**（参考前面图形化版的参数说明）\n\n4. 配置完成后，设置 `github-plus` 为默认上传器：\n```bash\npicgo use uploader  # 再次选择 github-plus 并回车\n```\n\n5. 验证配置（上传测试）\n```bash\n# 替换为你图片的本地路径\n# Windows 示例\npicgo upload C:\\Users\\Legion\\Pictures\\test.jpg\n# Mac/Linux 示例\npicgo upload ~/Desktop/test.jpg\n```\n{%note info%}\n- 成功：终端会输出图片直链，复制链接到浏览器可打开图片。\n- 失败：检查 `token`、`repo`权限是否开通、图片存储路径是否正确，或网络是否通畅。\n{%endnote%}\n\n### 四、与 `Hexo` 集成\n在 `Hexo`文章中直接使用上传后的图片链接，例如：\n```markdown\n![示例图片](Github直链地址)\n```\n\n### 链接在csdn无法显示问题\n&emsp;&emsp;当我们在`github`配置好图床服务后，想要在`CSDN`进行引用 ，会发现编辑时显示正常，但是发布后会显示图片转存失败，如下图所示。这是因为`CSDN` 为了防止其他网站直接引用（消耗 CSDN 的服务器流量和带宽）本站的图片资源，会设置**防盗链功能**。\n![编辑器中显示正常](https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/editor.png?raw=true)\n\n![发布后显示转存失败](https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/imagefail.png?raw=true)\n\n&emsp;&emsp;当在外站中插入一个来自 `github.com` 的图片链接时，用户的浏览器会向 `GitHub` 的服务器请求这张图片。`GitHub` 服务器在响应时，可能会检查请求的来源（`Referer`）。如果来源是 `csdn.net`，而 `GitHub` 并未将 `CSDN` 加入白名单，`GitHub` 可能会**拒绝这个请求或返回一个错误**（如 `403 Forbidden`）。反过来，如果 `CSDN` 检测到图片不是来自自己的服务器，也可能会拦截显示。\n\n&emsp;&emsp;在 `CSDN` 博客编辑器中，点击图片上传按钮。选择图片进行上传。`CSDN` 会**自动将图片上传到自己的图床**，并生成一个新的、稳定的 `CSDN` **内部链接**，这时候就可以正常引用图片了！\n\n封面来源：[Imagen AI](https://x.com/Imagen_Network/status/1957955746492215713/photo/1)\n\n\n","source":"_posts/Tutorial/Offload-Your-Hexo-Images.md","raw":"---\ntitle: Offload Your Hexo Images\ndate: 2025-08-21 16:59:18\ntags: [tutorial, hexo,image hosting]\nindex_img:  https://github.com/Richard110206/Blog-image/blob/main/cover/ImageHosting.png?raw=true\ncategory: Tutorial\ncategory_bar: true\ndescription: Using GitHub in conjunction with PicGo to establish an image hosting service.\n---\n\n{%note info%}之前刚开始进行`Hexo`博客撰写，图片都保存在本地`Hexo`源文件目录（`source/images/`）文件夹，随着图片增多，管理起来压力增大，于是产生了使用图床，引入外链进行图片存储的想法！{%endnote%}\n\n## `Pros and Cons`\n{%note info%}\n- **提升部署速度**：当你执行 `hexo g -d `部署时，`Hexo` 需要将你博客的所有源文件，包括文章、主题、以及几十上百张图片，全部处理并拷贝到`public`文件夹，然后再将这个巨大的文件夹推送到`GitHub`，这个过程会非常缓慢。\n- **跨设备写作与协作更方便**：本地存储时，如果你想在另一台电脑上写文章，必须把整个包含所有图片的庞大仓库克隆下来。而使用图床，你只需要克隆**轻量级的博客源码仓库**。文章里的图片都是绝对路径（`URL`），在任何设备上打开都能正常显示。\n- **版本控制体验极佳**：使用图床后，你的博客源码仓库非常干净，`Git` 可以高效地管理文本差异。图片仓库独立出去，两者互不干扰，管理起来清晰明了。\n{%endnote%}\n\n&emsp;&emsp;正因为有以上优势，因而我强烈建议将图片放在图床中进行存储，常见的的**图床服务**有[阿里云OSS](https://oss.console.aliyun.com)、[腾讯云 COS](https://console.cloud.tencent.com/cos5)、[七牛云](https://portal.qiniu.com/kodo)、[SM.MS](https://sm.ms/)、[Github](https://github.com/)等。\n&emsp;&emsp;考虑到前几者涉及到注册、实名认证、存储收费等问题，再加上认为`Github`大概率不会倒闭，图片存储较为稳定，且已有账号注册等原因，最终选择使用[PicGo插件](https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here)和`Github`实现**图床**功能！\n\n{%note info%}\n- 更简单的图床功能网站：[IMG.TG](https://img.tg/richard_11_02_06)（但是感觉像`start up company`界面有点简陋，担心有**存储不稳定**的问题）（后来发现有国内百度云 CDN 节点加速，口碑还不错，那大抵是我手拙无福消受了:cry:）\n\n- 不想折腾的可以看看这篇骚操作:grinning:：[图片外链方法大全： 免费的图床！ 告别新浪图床 和 CDN](https://blog.csdn.net/hotdog233/article/details/119380498?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E7%89%87%E7%9B%B4%E9%93%BE&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119380498.142^v102^pc_search_result_base2&spm=1018.2226.3001.4187)\n{%endnote%}\n\n\n下面分别介绍 `PicGo` **图形化桌面版**（适合新手，操作直观）和 `PicGo-Core` **命令行版**（适合终端用户，轻量化）的完整配置流程，实现`GitHub`图床功能。\n### 一、准备工作\n以 `GitHub` 图床 为例，配置步骤如下：\n1. 创建 `GitHub` 仓库\n2. 新建一个公开仓库（如 `blog-images`），用于存储图片\n3. 记住仓库路径：用户名/仓库名（如 `username/blog-images`）\n4. 生成 `GitHub` 访问令牌\n- 打开 `GitHub` → 点击头像 → `Settings` → `Developer settings` → `Personal access tokens` → `Generate new token`\n- **勾选 `repo` 权限**（**必须**），生成后复制令牌（仅显示一次，需在记事本中保存）\n选择并安装**图床插件**\n根据需求安装对应图床的插件，以常用的`GitHub`图床 为例：\n```bash\npicgo install github-plus  # GitHub 增强插件，支持自定义路径等\n```\n其他常用插件：\n- 阿里云 OSS：`picgo install aliyun-oss`\n- 腾讯云 COS：`picgo install tencent-cos`\n- 七牛云：`picgo install qiniu`\n\n### 二、配置图床参数\n安装 `Node.js`（命令行版必装，图形化版可选）\n下载地址：[Node.js 官网](https://nodejs.org/zh-cn)（推荐 LTS 版本）。\n验证安装：终端输入 `node -v` 和 `npm -v`，能显示版本号即成功。\n\n### 三、`PicGo` 图形化桌面版配置（新手推荐）\n图形化界面**操作直观**，无需记忆命令，适合首次配置图床的用户。\n\n1. 安装`PicGo`桌面版\n下载地址：[PicGo GitHub Releases](https://github.com/Molunerfinn/PicGo/releases)。\n选择对应系统版本（`Windows` 选 `exe`，`Mac` 选 `dmg`），安装后打开。\n2. 配置 GitHub 图床参数\n左侧菜单栏点击 「`图床设置`」 → 选择 「`GitHub图床`」）。\n依次填写参数：\n- `repo`：用户名/仓库名（如 `username/blog-images`）\n- `branch`：分支名（默认 `main`）\n- `token`：刚才生成的 `GitHub` 令牌\n- `path`：图片在`github`的存储路径（可选，如 `images/2024/`）\n- `customUrl`：自定义 CDN 域名（可选，如 `https://cdn.jsdelivr.net/gh/用户名/仓库名`）\n填写完成后，点击 「`设为默认图床`」，配置生效。\n3. 验证配置（上传测试）\n点击 `PicGo` 主界面的 「`上传区`」，**直接拖入本地图片**，或**粘贴剪贴板截图**（如微信截图后直接粘贴或电脑快捷键截图）。上传成功后，进入`Github`，进入图片右键`复制图片链接`即可！\n### 三、`PicGo-Core` 命令行版配置（终端用户推荐）\n**轻量化**、**无界面**，适合习惯用终端操作的用户，**可集成到脚本或编辑器**中。\n1. 安装 `PicGo-Core`\n打开终端（`Windows` 用 `CMD/PowerShell`，`Mac/Linux` 用 `Terminal`），执行以下命令全局安装：\n```bash\nnpm install picgo -g\n```\n- 验证安装：输入 `picgo -v`，显示版本号即成功。\n\n2. 安装 `GitHub` 图床插件\n```bash\npicgo install github-plus\n```\n其他常用图床插件（按需安装）：\n- 阿里云 OSS：`picgo install aliyun-oss`\n- 腾讯云 COS：`picgo install tencent-cos`\n- 七牛云：`picgo install qiniu`\n\n3. 配置 `GitHub` 图床参数\n```bash\npicgo set uploader\n```\n依次**填写参数**（参考前面图形化版的参数说明）\n\n4. 配置完成后，设置 `github-plus` 为默认上传器：\n```bash\npicgo use uploader  # 再次选择 github-plus 并回车\n```\n\n5. 验证配置（上传测试）\n```bash\n# 替换为你图片的本地路径\n# Windows 示例\npicgo upload C:\\Users\\Legion\\Pictures\\test.jpg\n# Mac/Linux 示例\npicgo upload ~/Desktop/test.jpg\n```\n{%note info%}\n- 成功：终端会输出图片直链，复制链接到浏览器可打开图片。\n- 失败：检查 `token`、`repo`权限是否开通、图片存储路径是否正确，或网络是否通畅。\n{%endnote%}\n\n### 四、与 `Hexo` 集成\n在 `Hexo`文章中直接使用上传后的图片链接，例如：\n```markdown\n![示例图片](Github直链地址)\n```\n\n### 链接在csdn无法显示问题\n&emsp;&emsp;当我们在`github`配置好图床服务后，想要在`CSDN`进行引用 ，会发现编辑时显示正常，但是发布后会显示图片转存失败，如下图所示。这是因为`CSDN` 为了防止其他网站直接引用（消耗 CSDN 的服务器流量和带宽）本站的图片资源，会设置**防盗链功能**。\n![编辑器中显示正常](https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/editor.png?raw=true)\n\n![发布后显示转存失败](https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/imagefail.png?raw=true)\n\n&emsp;&emsp;当在外站中插入一个来自 `github.com` 的图片链接时，用户的浏览器会向 `GitHub` 的服务器请求这张图片。`GitHub` 服务器在响应时，可能会检查请求的来源（`Referer`）。如果来源是 `csdn.net`，而 `GitHub` 并未将 `CSDN` 加入白名单，`GitHub` 可能会**拒绝这个请求或返回一个错误**（如 `403 Forbidden`）。反过来，如果 `CSDN` 检测到图片不是来自自己的服务器，也可能会拦截显示。\n\n&emsp;&emsp;在 `CSDN` 博客编辑器中，点击图片上传按钮。选择图片进行上传。`CSDN` 会**自动将图片上传到自己的图床**，并生成一个新的、稳定的 `CSDN` **内部链接**，这时候就可以正常引用图片了！\n\n封面来源：[Imagen AI](https://x.com/Imagen_Network/status/1957955746492215713/photo/1)\n\n\n","slug":"Tutorial/Offload-Your-Hexo-Images","published":1,"updated":"2025-09-03T03:11:13.781Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hcv002u40w36at25gax","content":"<div class=\"note note-info\">\n            <p>之前刚开始进行<code>Hexo</code>博客撰写，图片都保存在本地<code>Hexo</code>源文件目录（<code>source/images/</code>）文件夹，随着图片增多，管理起来压力增大，于是产生了使用图床，引入外链进行图片存储的想法！</p>\n          </div>\n<h2 id=\"Pros-and-Cons\"><code>Pros and Cons</code></h2>\n<div class=\"note note-info\">\n            <ul><li><strong>提升部署速度</strong>：当你执行 <code>hexo g -d </code>部署时，<code>Hexo</code> 需要将你博客的所有源文件，包括文章、主题、以及几十上百张图片，全部处理并拷贝到<code>public</code>文件夹，然后再将这个巨大的文件夹推送到<code>GitHub</code>，这个过程会非常缓慢。</li><li><strong>跨设备写作与协作更方便</strong>：本地存储时，如果你想在另一台电脑上写文章，必须把整个包含所有图片的庞大仓库克隆下来。而使用图床，你只需要克隆<strong>轻量级的博客源码仓库</strong>。文章里的图片都是绝对路径（<code>URL</code>），在任何设备上打开都能正常显示。</li><li><strong>版本控制体验极佳</strong>：使用图床后，你的博客源码仓库非常干净，<code>Git</code> 可以高效地管理文本差异。图片仓库独立出去，两者互不干扰，管理起来清晰明了。</li></ul>\n          </div>\n<p>  正因为有以上优势，因而我强烈建议将图片放在图床中进行存储，常见的的<strong>图床服务</strong>有<a href=\"https://oss.console.aliyun.com\">阿里云OSS</a>、<a href=\"https://console.cloud.tencent.com/cos5\">腾讯云 COS</a>、<a href=\"https://portal.qiniu.com/kodo\">七牛云</a>、<a href=\"https://sm.ms/\">SM.MS</a>、<a href=\"https://github.com/\">Github</a>等。<br>\n  考虑到前几者涉及到注册、实名认证、存储收费等问题，再加上认为<code>Github</code>大概率不会倒闭，图片存储较为稳定，且已有账号注册等原因，最终选择使用<a href=\"https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\">PicGo插件</a>和<code>Github</code>实现<strong>图床</strong>功能！</p>\n<div class=\"note note-info\">\n            <ul><li><p>更简单的图床功能网站：<a href=\"https://img.tg/richard_11_02_06\">IMG.TG</a>（但是感觉像<code>start up company</code>界面有点简陋，担心有<strong>存储不稳定</strong>的问题）（后来发现有国内百度云 CDN 节点加速，口碑还不错，那大抵是我手拙无福消受了😢）</p></li><li><p>不想折腾的可以看看这篇骚操作😀：<a href=\"https://blog.csdn.net/hotdog233/article/details/119380498?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E7%89%87%E7%9B%B4%E9%93%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119380498.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">图片外链方法大全： 免费的图床！ 告别新浪图床 和 CDN</a></p></li></ul>\n          </div>\n<p>下面分别介绍 <code>PicGo</code> <strong>图形化桌面版</strong>（适合新手，操作直观）和 <code>PicGo-Core</code> <strong>命令行版</strong>（适合终端用户，轻量化）的完整配置流程，实现<code>GitHub</code>图床功能。</p>\n<h3 id=\"一、准备工作\">一、准备工作</h3>\n<p>以 <code>GitHub</code> 图床 为例，配置步骤如下：</p>\n<ol>\n<li>创建 <code>GitHub</code> 仓库</li>\n<li>新建一个公开仓库（如 <code>blog-images</code>），用于存储图片</li>\n<li>记住仓库路径：用户名/仓库名（如 <code>username/blog-images</code>）</li>\n<li>生成 <code>GitHub</code> 访问令牌</li>\n</ol>\n<ul>\n<li>打开 <code>GitHub</code> → 点击头像 → <code>Settings</code> → <code>Developer settings</code> → <code>Personal access tokens</code> → <code>Generate new token</code></li>\n<li><strong>勾选 <code>repo</code> 权限</strong>（<strong>必须</strong>），生成后复制令牌（仅显示一次，需在记事本中保存）<br>\n选择并安装<strong>图床插件</strong><br>\n根据需求安装对应图床的插件，以常用的<code>GitHub</code>图床 为例：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo install github-plus  <span class=\"hljs-comment\"># GitHub 增强插件，支持自定义路径等</span><br></code></pre></td></tr></tbody></table></figure>\n<p>其他常用插件：</p>\n<ul>\n<li>阿里云 OSS：<code>picgo install aliyun-oss</code></li>\n<li>腾讯云 COS：<code>picgo install tencent-cos</code></li>\n<li>七牛云：<code>picgo install qiniu</code></li>\n</ul>\n<h3 id=\"二、配置图床参数\">二、配置图床参数</h3>\n<p>安装 <code>Node.js</code>（命令行版必装，图形化版可选）<br>\n下载地址：<a href=\"https://nodejs.org/zh-cn\">Node.js 官网</a>（推荐 LTS 版本）。<br>\n验证安装：终端输入 <code>node -v</code> 和 <code>npm -v</code>，能显示版本号即成功。</p>\n<h3 id=\"三、PicGo-图形化桌面版配置（新手推荐）\">三、<code>PicGo</code> 图形化桌面版配置（新手推荐）</h3>\n<p>图形化界面<strong>操作直观</strong>，无需记忆命令，适合首次配置图床的用户。</p>\n<ol>\n<li>安装<code>PicGo</code>桌面版<br>\n下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">PicGo GitHub Releases</a>。<br>\n选择对应系统版本（<code>Windows</code> 选 <code>exe</code>，<code>Mac</code> 选 <code>dmg</code>），安装后打开。</li>\n<li>配置 GitHub 图床参数<br>\n左侧菜单栏点击 「<code>图床设置</code>」 → 选择 「<code>GitHub图床</code>」）。<br>\n依次填写参数：</li>\n</ol>\n<ul>\n<li><code>repo</code>：用户名/仓库名（如 <code>username/blog-images</code>）</li>\n<li><code>branch</code>：分支名（默认 <code>main</code>）</li>\n<li><code>token</code>：刚才生成的 <code>GitHub</code> 令牌</li>\n<li><code>path</code>：图片在<code>github</code>的存储路径（可选，如 <code>images/2024/</code>）</li>\n<li><code>customUrl</code>：自定义 CDN 域名（可选，如 <code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>）<br>\n填写完成后，点击 「<code>设为默认图床</code>」，配置生效。</li>\n</ul>\n<ol start=\"3\">\n<li>验证配置（上传测试）<br>\n点击 <code>PicGo</code> 主界面的 「<code>上传区</code>」，<strong>直接拖入本地图片</strong>，或<strong>粘贴剪贴板截图</strong>（如微信截图后直接粘贴或电脑快捷键截图）。上传成功后，进入<code>Github</code>，进入图片右键<code>复制图片链接</code>即可！</li>\n</ol>\n<h3 id=\"三、PicGo-Core-命令行版配置（终端用户推荐）\">三、<code>PicGo-Core</code> 命令行版配置（终端用户推荐）</h3>\n<p><strong>轻量化</strong>、<strong>无界面</strong>，适合习惯用终端操作的用户，<strong>可集成到脚本或编辑器</strong>中。</p>\n<ol>\n<li>安装 <code>PicGo-Core</code><br>\n打开终端（<code>Windows</code> 用 <code>CMD/PowerShell</code>，<code>Mac/Linux</code> 用 <code>Terminal</code>），执行以下命令全局安装：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install picgo -g<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>验证安装：输入 <code>picgo -v</code>，显示版本号即成功。</li>\n</ul>\n<ol start=\"2\">\n<li>安装 <code>GitHub</code> 图床插件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo install github-plus<br></code></pre></td></tr></tbody></table></figure>\n<p>其他常用图床插件（按需安装）：</p>\n<ul>\n<li>阿里云 OSS：<code>picgo install aliyun-oss</code></li>\n<li>腾讯云 COS：<code>picgo install tencent-cos</code></li>\n<li>七牛云：<code>picgo install qiniu</code></li>\n</ul>\n<ol start=\"3\">\n<li>配置 <code>GitHub</code> 图床参数</li>\n</ol>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo <span class=\"hljs-built_in\">set</span> uploader<br></code></pre></td></tr></tbody></table></figure>\n<p>依次<strong>填写参数</strong>（参考前面图形化版的参数说明）</p>\n<ol start=\"4\">\n<li>配置完成后，设置 <code>github-plus</code> 为默认上传器：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo use uploader  <span class=\"hljs-comment\"># 再次选择 github-plus 并回车</span><br></code></pre></td></tr></tbody></table></figure>\n<ol start=\"5\">\n<li>验证配置（上传测试）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 替换为你图片的本地路径</span><br><span class=\"hljs-comment\"># Windows 示例</span><br>picgo upload C:\\Users\\Legion\\Pictures\\test.jpg<br><span class=\"hljs-comment\"># Mac/Linux 示例</span><br>picgo upload ~/Desktop/test.jpg<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-info\">\n            <ul><li>成功：终端会输出图片直链，复制链接到浏览器可打开图片。</li><li>失败：检查 <code>token</code>、<code>repo</code>权限是否开通、图片存储路径是否正确，或网络是否通畅。</li></ul>\n          </div>\n<h3 id=\"四、与-Hexo-集成\">四、与 <code>Hexo</code> 集成</h3>\n<p>在 <code>Hexo</code>文章中直接使用上传后的图片链接，例如：</p>\n<figure class=\"highlight markdown\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">![<span class=\"hljs-string\">示例图片</span>](<span class=\"hljs-link\">Github直链地址</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"链接在csdn无法显示问题\">链接在csdn无法显示问题</h3>\n<p>  当我们在<code>github</code>配置好图床服务后，想要在<code>CSDN</code>进行引用 ，会发现编辑时显示正常，但是发布后会显示图片转存失败，如下图所示。这是因为<code>CSDN</code> 为了防止其他网站直接引用（消耗 CSDN 的服务器流量和带宽）本站的图片资源，会设置<strong>防盗链功能</strong>。<br>\n<img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/editor.png?raw=true\" alt=\"编辑器中显示正常\"></p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/imagefail.png?raw=true\" alt=\"发布后显示转存失败\"></p>\n<p>  当在外站中插入一个来自 <code>github.com</code> 的图片链接时，用户的浏览器会向 <code>GitHub</code> 的服务器请求这张图片。<code>GitHub</code> 服务器在响应时，可能会检查请求的来源（<code>Referer</code>）。如果来源是 <code>csdn.net</code>，而 <code>GitHub</code> 并未将 <code>CSDN</code> 加入白名单，<code>GitHub</code> 可能会<strong>拒绝这个请求或返回一个错误</strong>（如 <code>403 Forbidden</code>）。反过来，如果 <code>CSDN</code> 检测到图片不是来自自己的服务器，也可能会拦截显示。</p>\n<p>  在 <code>CSDN</code> 博客编辑器中，点击图片上传按钮。选择图片进行上传。<code>CSDN</code> 会<strong>自动将图片上传到自己的图床</strong>，并生成一个新的、稳定的 <code>CSDN</code> <strong>内部链接</strong>，这时候就可以正常引用图片了！</p>\n<p>封面来源：<a href=\"https://x.com/Imagen_Network/status/1957955746492215713/photo/1\">Imagen AI</a></p>\n","excerpt":"","more":"<div class=\"note note-info\">\n            <p>之前刚开始进行<code>Hexo</code>博客撰写，图片都保存在本地<code>Hexo</code>源文件目录（<code>source/images/</code>）文件夹，随着图片增多，管理起来压力增大，于是产生了使用图床，引入外链进行图片存储的想法！</p>\n          </div>\n<h2 id=\"Pros-and-Cons\"><code>Pros and Cons</code></h2>\n<div class=\"note note-info\">\n            <ul><li><strong>提升部署速度</strong>：当你执行 <code>hexo g -d </code>部署时，<code>Hexo</code> 需要将你博客的所有源文件，包括文章、主题、以及几十上百张图片，全部处理并拷贝到<code>public</code>文件夹，然后再将这个巨大的文件夹推送到<code>GitHub</code>，这个过程会非常缓慢。</li><li><strong>跨设备写作与协作更方便</strong>：本地存储时，如果你想在另一台电脑上写文章，必须把整个包含所有图片的庞大仓库克隆下来。而使用图床，你只需要克隆<strong>轻量级的博客源码仓库</strong>。文章里的图片都是绝对路径（<code>URL</code>），在任何设备上打开都能正常显示。</li><li><strong>版本控制体验极佳</strong>：使用图床后，你的博客源码仓库非常干净，<code>Git</code> 可以高效地管理文本差异。图片仓库独立出去，两者互不干扰，管理起来清晰明了。</li></ul>\n          </div>\n<p>  正因为有以上优势，因而我强烈建议将图片放在图床中进行存储，常见的的<strong>图床服务</strong>有<a href=\"https://oss.console.aliyun.com\">阿里云OSS</a>、<a href=\"https://console.cloud.tencent.com/cos5\">腾讯云 COS</a>、<a href=\"https://portal.qiniu.com/kodo\">七牛云</a>、<a href=\"https://sm.ms/\">SM.MS</a>、<a href=\"https://github.com/\">Github</a>等。<br>\n  考虑到前几者涉及到注册、实名认证、存储收费等问题，再加上认为<code>Github</code>大概率不会倒闭，图片存储较为稳定，且已有账号注册等原因，最终选择使用<a href=\"https://picgo.github.io/PicGo-Doc/zh/guide/#picgo-is-here\">PicGo插件</a>和<code>Github</code>实现<strong>图床</strong>功能！</p>\n<div class=\"note note-info\">\n            <ul><li><p>更简单的图床功能网站：<a href=\"https://img.tg/richard_11_02_06\">IMG.TG</a>（但是感觉像<code>start up company</code>界面有点简陋，担心有<strong>存储不稳定</strong>的问题）（后来发现有国内百度云 CDN 节点加速，口碑还不错，那大抵是我手拙无福消受了😢）</p></li><li><p>不想折腾的可以看看这篇骚操作😀：<a href=\"https://blog.csdn.net/hotdog233/article/details/119380498?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%9B%BE%E7%89%87%E7%9B%B4%E9%93%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-119380498.142%5Ev102%5Epc_search_result_base2&amp;spm=1018.2226.3001.4187\">图片外链方法大全： 免费的图床！ 告别新浪图床 和 CDN</a></p></li></ul>\n          </div>\n<p>下面分别介绍 <code>PicGo</code> <strong>图形化桌面版</strong>（适合新手，操作直观）和 <code>PicGo-Core</code> <strong>命令行版</strong>（适合终端用户，轻量化）的完整配置流程，实现<code>GitHub</code>图床功能。</p>\n<h3 id=\"一、准备工作\">一、准备工作</h3>\n<p>以 <code>GitHub</code> 图床 为例，配置步骤如下：</p>\n<ol>\n<li>创建 <code>GitHub</code> 仓库</li>\n<li>新建一个公开仓库（如 <code>blog-images</code>），用于存储图片</li>\n<li>记住仓库路径：用户名/仓库名（如 <code>username/blog-images</code>）</li>\n<li>生成 <code>GitHub</code> 访问令牌</li>\n</ol>\n<ul>\n<li>打开 <code>GitHub</code> → 点击头像 → <code>Settings</code> → <code>Developer settings</code> → <code>Personal access tokens</code> → <code>Generate new token</code></li>\n<li><strong>勾选 <code>repo</code> 权限</strong>（<strong>必须</strong>），生成后复制令牌（仅显示一次，需在记事本中保存）<br>\n选择并安装<strong>图床插件</strong><br>\n根据需求安装对应图床的插件，以常用的<code>GitHub</code>图床 为例：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo install github-plus  <span class=\"hljs-comment\"># GitHub 增强插件，支持自定义路径等</span><br></code></pre></td></tr></table></figure>\n<p>其他常用插件：</p>\n<ul>\n<li>阿里云 OSS：<code>picgo install aliyun-oss</code></li>\n<li>腾讯云 COS：<code>picgo install tencent-cos</code></li>\n<li>七牛云：<code>picgo install qiniu</code></li>\n</ul>\n<h3 id=\"二、配置图床参数\">二、配置图床参数</h3>\n<p>安装 <code>Node.js</code>（命令行版必装，图形化版可选）<br>\n下载地址：<a href=\"https://nodejs.org/zh-cn\">Node.js 官网</a>（推荐 LTS 版本）。<br>\n验证安装：终端输入 <code>node -v</code> 和 <code>npm -v</code>，能显示版本号即成功。</p>\n<h3 id=\"三、PicGo-图形化桌面版配置（新手推荐）\">三、<code>PicGo</code> 图形化桌面版配置（新手推荐）</h3>\n<p>图形化界面<strong>操作直观</strong>，无需记忆命令，适合首次配置图床的用户。</p>\n<ol>\n<li>安装<code>PicGo</code>桌面版<br>\n下载地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">PicGo GitHub Releases</a>。<br>\n选择对应系统版本（<code>Windows</code> 选 <code>exe</code>，<code>Mac</code> 选 <code>dmg</code>），安装后打开。</li>\n<li>配置 GitHub 图床参数<br>\n左侧菜单栏点击 「<code>图床设置</code>」 → 选择 「<code>GitHub图床</code>」）。<br>\n依次填写参数：</li>\n</ol>\n<ul>\n<li><code>repo</code>：用户名/仓库名（如 <code>username/blog-images</code>）</li>\n<li><code>branch</code>：分支名（默认 <code>main</code>）</li>\n<li><code>token</code>：刚才生成的 <code>GitHub</code> 令牌</li>\n<li><code>path</code>：图片在<code>github</code>的存储路径（可选，如 <code>images/2024/</code>）</li>\n<li><code>customUrl</code>：自定义 CDN 域名（可选，如 <code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>）<br>\n填写完成后，点击 「<code>设为默认图床</code>」，配置生效。</li>\n</ul>\n<ol start=\"3\">\n<li>验证配置（上传测试）<br>\n点击 <code>PicGo</code> 主界面的 「<code>上传区</code>」，<strong>直接拖入本地图片</strong>，或<strong>粘贴剪贴板截图</strong>（如微信截图后直接粘贴或电脑快捷键截图）。上传成功后，进入<code>Github</code>，进入图片右键<code>复制图片链接</code>即可！</li>\n</ol>\n<h3 id=\"三、PicGo-Core-命令行版配置（终端用户推荐）\">三、<code>PicGo-Core</code> 命令行版配置（终端用户推荐）</h3>\n<p><strong>轻量化</strong>、<strong>无界面</strong>，适合习惯用终端操作的用户，<strong>可集成到脚本或编辑器</strong>中。</p>\n<ol>\n<li>安装 <code>PicGo-Core</code><br>\n打开终端（<code>Windows</code> 用 <code>CMD/PowerShell</code>，<code>Mac/Linux</code> 用 <code>Terminal</code>），执行以下命令全局安装：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">npm install picgo -g<br></code></pre></td></tr></table></figure>\n<ul>\n<li>验证安装：输入 <code>picgo -v</code>，显示版本号即成功。</li>\n</ul>\n<ol start=\"2\">\n<li>安装 <code>GitHub</code> 图床插件</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo install github-plus<br></code></pre></td></tr></table></figure>\n<p>其他常用图床插件（按需安装）：</p>\n<ul>\n<li>阿里云 OSS：<code>picgo install aliyun-oss</code></li>\n<li>腾讯云 COS：<code>picgo install tencent-cos</code></li>\n<li>七牛云：<code>picgo install qiniu</code></li>\n</ul>\n<ol start=\"3\">\n<li>配置 <code>GitHub</code> 图床参数</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo <span class=\"hljs-built_in\">set</span> uploader<br></code></pre></td></tr></table></figure>\n<p>依次<strong>填写参数</strong>（参考前面图形化版的参数说明）</p>\n<ol start=\"4\">\n<li>配置完成后，设置 <code>github-plus</code> 为默认上传器：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">picgo use uploader  <span class=\"hljs-comment\"># 再次选择 github-plus 并回车</span><br></code></pre></td></tr></table></figure>\n<ol start=\"5\">\n<li>验证配置（上传测试）</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 替换为你图片的本地路径</span><br><span class=\"hljs-comment\"># Windows 示例</span><br>picgo upload C:\\Users\\Legion\\Pictures\\test.jpg<br><span class=\"hljs-comment\"># Mac/Linux 示例</span><br>picgo upload ~/Desktop/test.jpg<br></code></pre></td></tr></table></figure>\n<div class=\"note note-info\">\n            <ul><li>成功：终端会输出图片直链，复制链接到浏览器可打开图片。</li><li>失败：检查 <code>token</code>、<code>repo</code>权限是否开通、图片存储路径是否正确，或网络是否通畅。</li></ul>\n          </div>\n<h3 id=\"四、与-Hexo-集成\">四、与 <code>Hexo</code> 集成</h3>\n<p>在 <code>Hexo</code>文章中直接使用上传后的图片链接，例如：</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs markdown\">![<span class=\"hljs-string\">示例图片</span>](<span class=\"hljs-link\">Github直链地址</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"链接在csdn无法显示问题\">链接在csdn无法显示问题</h3>\n<p>  当我们在<code>github</code>配置好图床服务后，想要在<code>CSDN</code>进行引用 ，会发现编辑时显示正常，但是发布后会显示图片转存失败，如下图所示。这是因为<code>CSDN</code> 为了防止其他网站直接引用（消耗 CSDN 的服务器流量和带宽）本站的图片资源，会设置<strong>防盗链功能</strong>。<br>\n<img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/editor.png?raw=true\" alt=\"编辑器中显示正常\"></p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Tutorial/ImageHosting/imagefail.png?raw=true\" alt=\"发布后显示转存失败\"></p>\n<p>  当在外站中插入一个来自 <code>github.com</code> 的图片链接时，用户的浏览器会向 <code>GitHub</code> 的服务器请求这张图片。<code>GitHub</code> 服务器在响应时，可能会检查请求的来源（<code>Referer</code>）。如果来源是 <code>csdn.net</code>，而 <code>GitHub</code> 并未将 <code>CSDN</code> 加入白名单，<code>GitHub</code> 可能会<strong>拒绝这个请求或返回一个错误</strong>（如 <code>403 Forbidden</code>）。反过来，如果 <code>CSDN</code> 检测到图片不是来自自己的服务器，也可能会拦截显示。</p>\n<p>  在 <code>CSDN</code> 博客编辑器中，点击图片上传按钮。选择图片进行上传。<code>CSDN</code> 会<strong>自动将图片上传到自己的图床</strong>，并生成一个新的、稳定的 <code>CSDN</code> <strong>内部链接</strong>，这时候就可以正常引用图片了！</p>\n<p>封面来源：<a href=\"https://x.com/Imagen_Network/status/1957955746492215713/photo/1\">Imagen AI</a></p>\n"},{"title":"Powerful Editor:Vim","date":"2025-07-28T08:33:00.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Powerful Editor Vim.jpg","category_bar":true,"description":"A brief tutorial of Editor Vim,including the Unique Philosophy and Basic Commands!","_content":"\n\n\n{% note primary %}\"Writing English words and writing code are very different activities. When programming, you spend more time switching files, reading, navigating, and editing code compared to writing a long stream.\"—— < The Missing Semester of Your CS Education >{%endnote%}\n\n\n`Vim` 是一个**模态编辑器**（modal editor），它的设计哲学是：编辑操作应当通过**键盘组合**完成，而非依赖鼠标或菜单。\n\n{% note primary %}\"Vim avoids the use of the mouse, because it’s too slow; Vim even avoids using the arrow keys because it requires too much movement.\"—— < The Missing Semester of Your CS Education >{%endnote%}\n\n`Vim`认为使用鼠标浪费时间，会降低效率，因为手从鼠标移动到键盘需要一定时间，对程序员来说反复来回的切换是很`annoying`的。因此，所有的`vim`功能都可以通过键盘操作，或许一开始你并不习惯，但等你使用久了，便能发现它得到程序员青睐的原因！:blush:\n\n课程相关视频与讲义：[Editors (Vim)](https://missing.csail.mit.edu/2020/editors/)\n## 核心特性\n \n   - `普通模式`：用于导航和操作文本（默认模式）\n   - `插入模式`：像常规编辑器一样输入文本（按 `i` 进入）\n   - `可视模式`：选择文本块（按 `v` 进入）\n   - `命令行模式`：执行保存/退出等命令（按 `:` 进入）\n## 基础操作\n使用 `Vim` 时会经常使用`<ESC>`键，而它不在主键盘区，显然不那么方便，于是很多程序员考虑将 `Caps Lock` 重新映射到 `Escape`或使用简单的键序列创建替代映射！\n### 模式切换\n| 操作 | 功能 |\n|------|------|\n| `vim` | 进入vim编辑器 |\n| `vim 文件名` | 打开特定文件（不存在时会新建） |\n| `i`(`insert`) | 进入插入模式 |\n| `Esc` | 返回普通模式 |\n| `:` | 进入命令行模式 |\n\n### 光标移动\n| 操作 | 功能 |\n|------|------|\n| `h` `j` `k` `l` | 左/下/上/右移动 |\n| `0` | 移动到行首 |\n| `$` | 移动到行尾 |\n| `^` | 移动到行首非空字符 |\n| `G` | 移动到文件底部 |\n| `gg` | 移动到文件顶部 |\n| `H` | 移动到窗口顶部 |\n| `L` | 移动到窗口底部 |\n| `Ctrl+u` | 上翻半页 |\n| `Ctrl+d` | 下翻半页 |\n| `Ctrl+b` | 上翻整页 | \n| `Ctrl+f` | 下翻整页 | \n\n\n## 编辑功能\n### 文本操作\n| 操作 | 功能 |\n|------|------|\n| `o` | 下方新建行并插入 |\n| `O` | 上方新建行并插入 |\n| `u` | 撤销 |\n| `Ctrl+r` | 重做 |\n| `x` | 删除字符 |\n| `dw` | 删除单词 |\n| `dd` | 删除整行 |\n| `cc` | 删除并进入插入模式 |\n### 复制粘贴\n| 操作 | 功能 |\n|------|------|\n| `y` (`yank`)| 复制 |\n| `yy` | 复制当前行 |\n| `yw` | 复制单词 |\n| `p`(`paste`) | 粘贴 |\n### 可视化模式\n| 操作 | 功能 | 说明 |\n|------|------|------|\n| `v` | 字符可视化 | 按字符选择 |\n| `V` | 行可视化 | 按行选择 |\n| `Ctrl+v` | 块可视化 | 矩形选择 |\n\n## 高级功能\n\n### 搜索与替换\n| 操作 | 功能 |\n|------|------|\n| `f+字符` | 向前查找字符 |\n| `F+字符` | 向后查找字符 |\n| `~` | 大小写转换 |\n\n### 批量操作\n`数字+指令`可以进行批量化操作\n```bash\n 4j #向下移动4行 \n 3ee #选择3个单词 \n 7dw #删除7个单词\n```\n\n## 文件操作\n\n### 保存与退出\n| 操作 | 功能 |\n|------|------|\n| `:w`(`write`) | 保存文件 |\n| `:q`(`quit`) | 退出 |\n| `:qa`(`all`) | 退出所有窗口 |\n| `:wq` | 保存并退出 |\n\n### 实战演示\n学习了上面那么多的指令不妨自己创建一个`python`文件，结合之前学习的`shell`命令，在实践中感受`Vim`的魅力吧！:smile:\n```python\nimport sys #导入sys来接受shell中的参数\n\ndef fizz_buzz(limit):\n    for i in range(1, limit + 1):\n        if i % 3 != 0 and i % 5 != 0:\n            print(i)\n        elif i % 3 == 0 and i % 5 != 0:\n            print('fizz')\n        elif i % 5 == 0 and i % 3 != 0:\n            print('buzz')\n        else:\n            print('fizzbuzz')\n\ndef main():\n    fizz_buzz(int(sys.argv[1]))\n\nif __name__=='__main__':\n    main()\n   ```\n   ```bash\n   $ python3 fizzbuzz.py 30\n1\n2\nfizz\n4\nbuzz\nfizz\n7\n8\nfizz\nbuzz\n11\nfizz\n13\n14\nfizzbuzz\n16\n17\nfizz\n19\nbuzz\nfizz\n22\n23\nfizz\nbuzz\n26\nfizz\n28\n29\nfizzbuzz\n```\n","source":"_posts/Tutorial/Powerful-Editor-Vim.md","raw":"---\ntitle: Powerful Editor:Vim\ndate: 2025-07-28 16:33:00\ntags: [vim]\nindex_img:  https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Powerful Editor Vim.jpg\ncategory: Tutorial\ncategory_bar: true\ndescription: A brief tutorial of Editor Vim,including the Unique Philosophy and Basic Commands!\n---\n\n\n\n{% note primary %}\"Writing English words and writing code are very different activities. When programming, you spend more time switching files, reading, navigating, and editing code compared to writing a long stream.\"—— < The Missing Semester of Your CS Education >{%endnote%}\n\n\n`Vim` 是一个**模态编辑器**（modal editor），它的设计哲学是：编辑操作应当通过**键盘组合**完成，而非依赖鼠标或菜单。\n\n{% note primary %}\"Vim avoids the use of the mouse, because it’s too slow; Vim even avoids using the arrow keys because it requires too much movement.\"—— < The Missing Semester of Your CS Education >{%endnote%}\n\n`Vim`认为使用鼠标浪费时间，会降低效率，因为手从鼠标移动到键盘需要一定时间，对程序员来说反复来回的切换是很`annoying`的。因此，所有的`vim`功能都可以通过键盘操作，或许一开始你并不习惯，但等你使用久了，便能发现它得到程序员青睐的原因！:blush:\n\n课程相关视频与讲义：[Editors (Vim)](https://missing.csail.mit.edu/2020/editors/)\n## 核心特性\n \n   - `普通模式`：用于导航和操作文本（默认模式）\n   - `插入模式`：像常规编辑器一样输入文本（按 `i` 进入）\n   - `可视模式`：选择文本块（按 `v` 进入）\n   - `命令行模式`：执行保存/退出等命令（按 `:` 进入）\n## 基础操作\n使用 `Vim` 时会经常使用`<ESC>`键，而它不在主键盘区，显然不那么方便，于是很多程序员考虑将 `Caps Lock` 重新映射到 `Escape`或使用简单的键序列创建替代映射！\n### 模式切换\n| 操作 | 功能 |\n|------|------|\n| `vim` | 进入vim编辑器 |\n| `vim 文件名` | 打开特定文件（不存在时会新建） |\n| `i`(`insert`) | 进入插入模式 |\n| `Esc` | 返回普通模式 |\n| `:` | 进入命令行模式 |\n\n### 光标移动\n| 操作 | 功能 |\n|------|------|\n| `h` `j` `k` `l` | 左/下/上/右移动 |\n| `0` | 移动到行首 |\n| `$` | 移动到行尾 |\n| `^` | 移动到行首非空字符 |\n| `G` | 移动到文件底部 |\n| `gg` | 移动到文件顶部 |\n| `H` | 移动到窗口顶部 |\n| `L` | 移动到窗口底部 |\n| `Ctrl+u` | 上翻半页 |\n| `Ctrl+d` | 下翻半页 |\n| `Ctrl+b` | 上翻整页 | \n| `Ctrl+f` | 下翻整页 | \n\n\n## 编辑功能\n### 文本操作\n| 操作 | 功能 |\n|------|------|\n| `o` | 下方新建行并插入 |\n| `O` | 上方新建行并插入 |\n| `u` | 撤销 |\n| `Ctrl+r` | 重做 |\n| `x` | 删除字符 |\n| `dw` | 删除单词 |\n| `dd` | 删除整行 |\n| `cc` | 删除并进入插入模式 |\n### 复制粘贴\n| 操作 | 功能 |\n|------|------|\n| `y` (`yank`)| 复制 |\n| `yy` | 复制当前行 |\n| `yw` | 复制单词 |\n| `p`(`paste`) | 粘贴 |\n### 可视化模式\n| 操作 | 功能 | 说明 |\n|------|------|------|\n| `v` | 字符可视化 | 按字符选择 |\n| `V` | 行可视化 | 按行选择 |\n| `Ctrl+v` | 块可视化 | 矩形选择 |\n\n## 高级功能\n\n### 搜索与替换\n| 操作 | 功能 |\n|------|------|\n| `f+字符` | 向前查找字符 |\n| `F+字符` | 向后查找字符 |\n| `~` | 大小写转换 |\n\n### 批量操作\n`数字+指令`可以进行批量化操作\n```bash\n 4j #向下移动4行 \n 3ee #选择3个单词 \n 7dw #删除7个单词\n```\n\n## 文件操作\n\n### 保存与退出\n| 操作 | 功能 |\n|------|------|\n| `:w`(`write`) | 保存文件 |\n| `:q`(`quit`) | 退出 |\n| `:qa`(`all`) | 退出所有窗口 |\n| `:wq` | 保存并退出 |\n\n### 实战演示\n学习了上面那么多的指令不妨自己创建一个`python`文件，结合之前学习的`shell`命令，在实践中感受`Vim`的魅力吧！:smile:\n```python\nimport sys #导入sys来接受shell中的参数\n\ndef fizz_buzz(limit):\n    for i in range(1, limit + 1):\n        if i % 3 != 0 and i % 5 != 0:\n            print(i)\n        elif i % 3 == 0 and i % 5 != 0:\n            print('fizz')\n        elif i % 5 == 0 and i % 3 != 0:\n            print('buzz')\n        else:\n            print('fizzbuzz')\n\ndef main():\n    fizz_buzz(int(sys.argv[1]))\n\nif __name__=='__main__':\n    main()\n   ```\n   ```bash\n   $ python3 fizzbuzz.py 30\n1\n2\nfizz\n4\nbuzz\nfizz\n7\n8\nfizz\nbuzz\n11\nfizz\n13\n14\nfizzbuzz\n16\n17\nfizz\n19\nbuzz\nfizz\n22\n23\nfizz\nbuzz\n26\nfizz\n28\n29\nfizzbuzz\n```\n","slug":"Tutorial/Powerful-Editor-Vim","published":1,"updated":"2025-08-21T09:45:48.651Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hd2005x40w30prwgg4y","content":"<div class=\"note note-primary\">\n            <p>“Writing English words and writing code are very different activities. When programming, you spend more time switching files, reading, navigating, and editing code compared to writing a long stream.”—— &lt; The Missing Semester of Your CS Education &gt;</p>\n          </div>\n<p><code>Vim</code> 是一个<strong>模态编辑器</strong>（modal editor），它的设计哲学是：编辑操作应当通过<strong>键盘组合</strong>完成，而非依赖鼠标或菜单。</p>\n<div class=\"note note-primary\">\n            <p>“Vim avoids the use of the mouse, because it’s too slow; Vim even avoids using the arrow keys because it requires too much movement.”—— &lt; The Missing Semester of Your CS Education &gt;</p>\n          </div>\n<p><code>Vim</code>认为使用鼠标浪费时间，会降低效率，因为手从鼠标移动到键盘需要一定时间，对程序员来说反复来回的切换是很<code>annoying</code>的。因此，所有的<code>vim</code>功能都可以通过键盘操作，或许一开始你并不习惯，但等你使用久了，便能发现它得到程序员青睐的原因！😊</p>\n<p>课程相关视频与讲义：<a href=\"https://missing.csail.mit.edu/2020/editors/\">Editors (Vim)</a></p>\n<h2 id=\"核心特性\">核心特性</h2>\n<ul>\n<li><code>普通模式</code>：用于导航和操作文本（默认模式）</li>\n<li><code>插入模式</code>：像常规编辑器一样输入文本（按 <code>i</code> 进入）</li>\n<li><code>可视模式</code>：选择文本块（按 <code>v</code> 进入）</li>\n<li><code>命令行模式</code>：执行保存/退出等命令（按 <code>:</code> 进入）</li>\n</ul>\n<h2 id=\"基础操作\">基础操作</h2>\n<p>使用 <code>Vim</code> 时会经常使用<code>&lt;ESC&gt;</code>键，而它不在主键盘区，显然不那么方便，于是很多程序员考虑将 <code>Caps Lock</code> 重新映射到 <code>Escape</code>或使用简单的键序列创建替代映射！</p>\n<h3 id=\"模式切换\">模式切换</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>vim</code></td>\n<td>进入vim编辑器</td>\n</tr>\n<tr>\n<td><code>vim 文件名</code></td>\n<td>打开特定文件（不存在时会新建）</td>\n</tr>\n<tr>\n<td><code>i</code>(<code>insert</code>)</td>\n<td>进入插入模式</td>\n</tr>\n<tr>\n<td><code>Esc</code></td>\n<td>返回普通模式</td>\n</tr>\n<tr>\n<td><code>:</code></td>\n<td>进入命令行模式</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"光标移动\">光标移动</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>h</code> <code>j</code> <code>k</code> <code>l</code></td>\n<td>左/下/上/右移动</td>\n</tr>\n<tr>\n<td><code>0</code></td>\n<td>移动到行首</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>移动到行尾</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>移动到行首非空字符</td>\n</tr>\n<tr>\n<td><code>G</code></td>\n<td>移动到文件底部</td>\n</tr>\n<tr>\n<td><code>gg</code></td>\n<td>移动到文件顶部</td>\n</tr>\n<tr>\n<td><code>H</code></td>\n<td>移动到窗口顶部</td>\n</tr>\n<tr>\n<td><code>L</code></td>\n<td>移动到窗口底部</td>\n</tr>\n<tr>\n<td><code>Ctrl+u</code></td>\n<td>上翻半页</td>\n</tr>\n<tr>\n<td><code>Ctrl+d</code></td>\n<td>下翻半页</td>\n</tr>\n<tr>\n<td><code>Ctrl+b</code></td>\n<td>上翻整页</td>\n</tr>\n<tr>\n<td><code>Ctrl+f</code></td>\n<td>下翻整页</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编辑功能\">编辑功能</h2>\n<h3 id=\"文本操作\">文本操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>o</code></td>\n<td>下方新建行并插入</td>\n</tr>\n<tr>\n<td><code>O</code></td>\n<td>上方新建行并插入</td>\n</tr>\n<tr>\n<td><code>u</code></td>\n<td>撤销</td>\n</tr>\n<tr>\n<td><code>Ctrl+r</code></td>\n<td>重做</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>删除字符</td>\n</tr>\n<tr>\n<td><code>dw</code></td>\n<td>删除单词</td>\n</tr>\n<tr>\n<td><code>dd</code></td>\n<td>删除整行</td>\n</tr>\n<tr>\n<td><code>cc</code></td>\n<td>删除并进入插入模式</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复制粘贴\">复制粘贴</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>y</code> (<code>yank</code>)</td>\n<td>复制</td>\n</tr>\n<tr>\n<td><code>yy</code></td>\n<td>复制当前行</td>\n</tr>\n<tr>\n<td><code>yw</code></td>\n<td>复制单词</td>\n</tr>\n<tr>\n<td><code>p</code>(<code>paste</code>)</td>\n<td>粘贴</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"可视化模式\">可视化模式</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>v</code></td>\n<td>字符可视化</td>\n<td>按字符选择</td>\n</tr>\n<tr>\n<td><code>V</code></td>\n<td>行可视化</td>\n<td>按行选择</td>\n</tr>\n<tr>\n<td><code>Ctrl+v</code></td>\n<td>块可视化</td>\n<td>矩形选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"高级功能\">高级功能</h2>\n<h3 id=\"搜索与替换\">搜索与替换</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>f+字符</code></td>\n<td>向前查找字符</td>\n</tr>\n<tr>\n<td><code>F+字符</code></td>\n<td>向后查找字符</td>\n</tr>\n<tr>\n<td><code>~</code></td>\n<td>大小写转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量操作\">批量操作</h3>\n<p><code>数字+指令</code>可以进行批量化操作</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">4j <span class=\"hljs-comment\">#向下移动4行 </span><br>3ee <span class=\"hljs-comment\">#选择3个单词 </span><br>7dw <span class=\"hljs-comment\">#删除7个单词</span><br></code></pre></td></tr></tbody></table></figure>\n<h2 id=\"文件操作\">文件操作</h2>\n<h3 id=\"保存与退出\">保存与退出</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>:w</code>(<code>write</code>)</td>\n<td>保存文件</td>\n</tr>\n<tr>\n<td><code>:q</code>(<code>quit</code>)</td>\n<td>退出</td>\n</tr>\n<tr>\n<td><code>:qa</code>(<code>all</code>)</td>\n<td>退出所有窗口</td>\n</tr>\n<tr>\n<td><code>:wq</code></td>\n<td>保存并退出</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实战演示\">实战演示</h3>\n<p>学习了上面那么多的指令不妨自己创建一个<code>python</code>文件，结合之前学习的<code>shell</code>命令，在实践中感受<code>Vim</code>的魅力吧！😄</p>\n<figure class=\"highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> sys <span class=\"hljs-comment\">#导入sys来接受shell中的参数</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fizz_buzz</span>(<span class=\"hljs-params\">limit</span>):<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, limit + <span class=\"hljs-number\">1</span>):<br>        <span class=\"hljs-keyword\">if</span> i % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(i)<br>        <span class=\"hljs-keyword\">elif</span> i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'fizz'</span>)<br>        <span class=\"hljs-keyword\">elif</span> i % <span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'buzz'</span>)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">'fizzbuzz'</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    fizz_buzz(<span class=\"hljs-built_in\">int</span>(sys.argv[<span class=\"hljs-number\">1</span>]))<br><br><span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">'__main__'</span>:<br>    main()<br></code></pre></td></tr></tbody></table></figure>\n   <figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">   $ python3 fizzbuzz.py 30<br>1<br>2<br>fizz<br>4<br>buzz<br>fizz<br>7<br>8<br>fizz<br>buzz<br>11<br>fizz<br>13<br>14<br>fizzbuzz<br>16<br>17<br>fizz<br>19<br>buzz<br>fizz<br>22<br>23<br>fizz<br>buzz<br>26<br>fizz<br>28<br>29<br>fizzbuzz<br></code></pre></td></tr></tbody></table></figure>\n","excerpt":"","more":"<div class=\"note note-primary\">\n            <p>“Writing English words and writing code are very different activities. When programming, you spend more time switching files, reading, navigating, and editing code compared to writing a long stream.”—— &lt; The Missing Semester of Your CS Education &gt;</p>\n          </div>\n<p><code>Vim</code> 是一个<strong>模态编辑器</strong>（modal editor），它的设计哲学是：编辑操作应当通过<strong>键盘组合</strong>完成，而非依赖鼠标或菜单。</p>\n<div class=\"note note-primary\">\n            <p>“Vim avoids the use of the mouse, because it’s too slow; Vim even avoids using the arrow keys because it requires too much movement.”—— &lt; The Missing Semester of Your CS Education &gt;</p>\n          </div>\n<p><code>Vim</code>认为使用鼠标浪费时间，会降低效率，因为手从鼠标移动到键盘需要一定时间，对程序员来说反复来回的切换是很<code>annoying</code>的。因此，所有的<code>vim</code>功能都可以通过键盘操作，或许一开始你并不习惯，但等你使用久了，便能发现它得到程序员青睐的原因！😊</p>\n<p>课程相关视频与讲义：<a href=\"https://missing.csail.mit.edu/2020/editors/\">Editors (Vim)</a></p>\n<h2 id=\"核心特性\">核心特性</h2>\n<ul>\n<li><code>普通模式</code>：用于导航和操作文本（默认模式）</li>\n<li><code>插入模式</code>：像常规编辑器一样输入文本（按 <code>i</code> 进入）</li>\n<li><code>可视模式</code>：选择文本块（按 <code>v</code> 进入）</li>\n<li><code>命令行模式</code>：执行保存/退出等命令（按 <code>:</code> 进入）</li>\n</ul>\n<h2 id=\"基础操作\">基础操作</h2>\n<p>使用 <code>Vim</code> 时会经常使用<code>&lt;ESC&gt;</code>键，而它不在主键盘区，显然不那么方便，于是很多程序员考虑将 <code>Caps Lock</code> 重新映射到 <code>Escape</code>或使用简单的键序列创建替代映射！</p>\n<h3 id=\"模式切换\">模式切换</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>vim</code></td>\n<td>进入vim编辑器</td>\n</tr>\n<tr>\n<td><code>vim 文件名</code></td>\n<td>打开特定文件（不存在时会新建）</td>\n</tr>\n<tr>\n<td><code>i</code>(<code>insert</code>)</td>\n<td>进入插入模式</td>\n</tr>\n<tr>\n<td><code>Esc</code></td>\n<td>返回普通模式</td>\n</tr>\n<tr>\n<td><code>:</code></td>\n<td>进入命令行模式</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"光标移动\">光标移动</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>h</code> <code>j</code> <code>k</code> <code>l</code></td>\n<td>左/下/上/右移动</td>\n</tr>\n<tr>\n<td><code>0</code></td>\n<td>移动到行首</td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>移动到行尾</td>\n</tr>\n<tr>\n<td><code>^</code></td>\n<td>移动到行首非空字符</td>\n</tr>\n<tr>\n<td><code>G</code></td>\n<td>移动到文件底部</td>\n</tr>\n<tr>\n<td><code>gg</code></td>\n<td>移动到文件顶部</td>\n</tr>\n<tr>\n<td><code>H</code></td>\n<td>移动到窗口顶部</td>\n</tr>\n<tr>\n<td><code>L</code></td>\n<td>移动到窗口底部</td>\n</tr>\n<tr>\n<td><code>Ctrl+u</code></td>\n<td>上翻半页</td>\n</tr>\n<tr>\n<td><code>Ctrl+d</code></td>\n<td>下翻半页</td>\n</tr>\n<tr>\n<td><code>Ctrl+b</code></td>\n<td>上翻整页</td>\n</tr>\n<tr>\n<td><code>Ctrl+f</code></td>\n<td>下翻整页</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"编辑功能\">编辑功能</h2>\n<h3 id=\"文本操作\">文本操作</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>o</code></td>\n<td>下方新建行并插入</td>\n</tr>\n<tr>\n<td><code>O</code></td>\n<td>上方新建行并插入</td>\n</tr>\n<tr>\n<td><code>u</code></td>\n<td>撤销</td>\n</tr>\n<tr>\n<td><code>Ctrl+r</code></td>\n<td>重做</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>删除字符</td>\n</tr>\n<tr>\n<td><code>dw</code></td>\n<td>删除单词</td>\n</tr>\n<tr>\n<td><code>dd</code></td>\n<td>删除整行</td>\n</tr>\n<tr>\n<td><code>cc</code></td>\n<td>删除并进入插入模式</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复制粘贴\">复制粘贴</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>y</code> (<code>yank</code>)</td>\n<td>复制</td>\n</tr>\n<tr>\n<td><code>yy</code></td>\n<td>复制当前行</td>\n</tr>\n<tr>\n<td><code>yw</code></td>\n<td>复制单词</td>\n</tr>\n<tr>\n<td><code>p</code>(<code>paste</code>)</td>\n<td>粘贴</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"可视化模式\">可视化模式</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>v</code></td>\n<td>字符可视化</td>\n<td>按字符选择</td>\n</tr>\n<tr>\n<td><code>V</code></td>\n<td>行可视化</td>\n<td>按行选择</td>\n</tr>\n<tr>\n<td><code>Ctrl+v</code></td>\n<td>块可视化</td>\n<td>矩形选择</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"高级功能\">高级功能</h2>\n<h3 id=\"搜索与替换\">搜索与替换</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>f+字符</code></td>\n<td>向前查找字符</td>\n</tr>\n<tr>\n<td><code>F+字符</code></td>\n<td>向后查找字符</td>\n</tr>\n<tr>\n<td><code>~</code></td>\n<td>大小写转换</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量操作\">批量操作</h3>\n<p><code>数字+指令</code>可以进行批量化操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">4j <span class=\"hljs-comment\">#向下移动4行 </span><br>3ee <span class=\"hljs-comment\">#选择3个单词 </span><br>7dw <span class=\"hljs-comment\">#删除7个单词</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"文件操作\">文件操作</h2>\n<h3 id=\"保存与退出\">保存与退出</h3>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>:w</code>(<code>write</code>)</td>\n<td>保存文件</td>\n</tr>\n<tr>\n<td><code>:q</code>(<code>quit</code>)</td>\n<td>退出</td>\n</tr>\n<tr>\n<td><code>:qa</code>(<code>all</code>)</td>\n<td>退出所有窗口</td>\n</tr>\n<tr>\n<td><code>:wq</code></td>\n<td>保存并退出</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"实战演示\">实战演示</h3>\n<p>学习了上面那么多的指令不妨自己创建一个<code>python</code>文件，结合之前学习的<code>shell</code>命令，在实践中感受<code>Vim</code>的魅力吧！😄</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> sys <span class=\"hljs-comment\">#导入sys来接受shell中的参数</span><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fizz_buzz</span>(<span class=\"hljs-params\">limit</span>):<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, limit + <span class=\"hljs-number\">1</span>):<br>        <span class=\"hljs-keyword\">if</span> i % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(i)<br>        <span class=\"hljs-keyword\">elif</span> i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">5</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;fizz&#x27;</span>)<br>        <span class=\"hljs-keyword\">elif</span> i % <span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">and</span> i % <span class=\"hljs-number\">3</span> != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;buzz&#x27;</span>)<br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;fizzbuzz&#x27;</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    fizz_buzz(<span class=\"hljs-built_in\">int</span>(sys.argv[<span class=\"hljs-number\">1</span>]))<br><br><span class=\"hljs-keyword\">if</span> __name__==<span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure>\n   <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">   $ python3 fizzbuzz.py 30<br>1<br>2<br>fizz<br>4<br>buzz<br>fizz<br>7<br>8<br>fizz<br>buzz<br>11<br>fizz<br>13<br>14<br>fizzbuzz<br>16<br>17<br>fizz<br>19<br>buzz<br>fizz<br>22<br>23<br>fizz<br>buzz<br>26<br>fizz<br>28<br>29<br>fizzbuzz<br></code></pre></td></tr></table></figure>\n"},{"title":"Shell Magic","date":"2025-07-27T14:34:30.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Shell%20Magic%20Notes%20from%20The%20Missing%20Semeste.jpeg","category_bar":true,"description":"This document summarizes my key takeaways from the Shell module of MIT’s The Missing Semester course, focusing on:Interaction and Automation Power!","_content":"\n\n{%note default%}对计算机的学生而言，许多开发工具是未来老师或企业默认你已经“精通”的，然而未经学校系统培训的我们或许会对此感到迷茫，正如 MIT 课程 **[The Missing Semester of Your CS Education](https://missing.csail.mit.edu/)** 所强调的： **“掌握基础工具是程序员的核心竞争力”**。这个课程会帮助你入门、了解一些计算机常用的开发工具，也算是程序员的自我修养吧！**Let's Go！**:smile:{%endnote%}\n\n相关课程在b站也有双语翻译（大部分应该都能听懂，就是有个好像是西班牙的老师带点口音听起来有点不适应:cry:）[[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell](https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.1387.favlist.content.click&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n\n***\n\n&emsp;&emsp;不论是在电影里还是在我们初识计算机的过程中，都会看到一个黑乎乎的窗口，只要输入几行代码就可以完成酷炫的操作，但是你或许对这有一点疑惑，这到底是`terminal`、`bash`、`zsh`还是`powershell`，他们到底是如何区分的呢？\n\n1.`Terminal`：用户终端，用来启动`shell`，这也可以说算是一个“工具”，活跃在为用户服务的**前端**\n2.`Shell`：是一个**命令行解释器**，负责接收用户输入的命令并将其**解释**为计算机可以执行的操作，与`Terminal`相比，是活跃于用户服务**后端的程序**，以下都是`Shell`在不同操作系统中的实现：\n- `Bash`：是一种**常用的Shell**，在`Linux`和`macOS`中默认安装。\n- `Zsh`：是一种**功能强大的Shell**，在`macOS`中默认安装，也可以在`Linux`中安装。\n- `PowerShell`：是一种**Windows**系统下的**命令行工具**，用于**管理Windows系统**和**执行PowerShell脚本**。\n\n## Shell\n&emsp;&emsp;当熟悉的**可视化界面**无法实现你想要的功能时，`Shell`将成为你与计算机交互的强大工具。相比**图形界面有限的按钮和滑块**，命令行提供了更灵活、更强大的控制方式，允许你通过**文本命令和脚本实现自动化操作**。本文基于`VMware`虚拟机中的`Ubuntu 22.04`发行版演示基础`Shell`操作：\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ date\nSat Jul 26 03:27:54 PM CST 2025\n```\n第一行通常是用户名、机器名称和当前所在路径\n{%note danger%}\n- `Windows`中路径通常使用**反斜杠**`\\`分隔，每个驱动器都有一个单独的路径结构。\n- `Linux` / `macOS` 中这些路径使用**正斜杠**`/`分隔，他们挂载在同一个命名空间下。\n{%endnote%}\n\n开头的斜杠表示从文件系统的顶部开始。\n{%note warning%}\n- 相对路径：相对于当前位置的路径\n- 绝对路径：完整路径，从顶部开始\n{%endnote%}\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello World\"\nHello World\n```\n`echo`可以将后面的参数**打印**在屏幕上\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ which echo\n/usr/bin/echo\n```\n`which`可以用于**寻找后面参数文件的绝对位置**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ pwd\n/home/richard\n```\n`pwd`（`Print Working Directory`）**打印当前所在路径**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cd /home\nrichard@richard-VMware-Virtual-Platform:/home$ \n```\n`cd`（`Change Directory`）表示更改当前目录\n\n这是更方便**切换目录**的方式：\n{%note warning%}\n- `.`表示**当前**目录\n- `..`表示**父**目录\n{%endnote%}\n\n**注意**：使用相对路径能提高命令在不同电脑上的**兼容性**！\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:/$ ls\nbin                home               mnt   sbin.usr-is-merged  usr\nbin.usr-is-merged  lib                opt   snap                var\nboot               lib64              proc  srv\ncdrom              lib.usr-is-merged  root  swap.img\ndev                lost+found         run   sys\netc                media              sbin  tmp\n```\n`ls`会列出当前目录中的文件，这能够快速浏览文件\n```bash\nrichard@richard-VMware-Virtual-Platform:/home$ cd ~\nrichard@richard-VMware-Virtual-Platform:~$\n```\n{%note warning%}\n- `cd ~`能够快速**回到用户主目录**\n- `cd -`切换到**上一个工作目录**\n{%endnote%}\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n```\n`--help`参数显示**命令帮助信息**\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls -l\ntotal 40\ndrwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Desktop\ndrwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Documents\n\nlrwxrwxrwx   1 root root          7 Apr 22  2024 bin -> usr/bin\ndrwxr-xr-x   2 root root       4096 Feb 26  2024 bin.usr-is-merged\n# 仅列举部分进行展示说明\n```\n**文件类型**（第`1`个字符）\n\n| 字符 | 类型       | 说明                  | 示例                  |\n|------|------------|-----------------------|-----------------------|\n| `d`  | 目录       | 文件夹                | `drwxr-xr-x` |\n| `-`  | 普通文件   | 文本/二进制文件       | `-rw-r--r--` |\n| `l`  | 符号链接   | 软链接文件            | `lrwxrwxrwx` |\n| `c`  | 字符设备   | 终端等串行设备        | `crw--w----` |\n| `b`  | 块设备     | 磁盘等存储设备        | `brw-rw----` |\n| `s`  | 套接字     | 进程通信文件          | `srwxrwxrwx` |\n| `p`  | 管道       | `FIFO` 管道文件         | `prw-------`|\n\n用户权限分为 **3组**（每组`3`字符），分别对应：\n\n| 组别       | 示例          | \n|------------|---------------|\n| 所有者权限 | `rwx`         | \n| 所属组权限 | `r-x`         | \n| 其他用户   | `r-x`         | \n\n权限字符**含义**：\n\n 字符 | 权限 | 对文件的影响             | 对目录的影响              |\n|------|------|--------------------------|---------------------------|\n| `r`  | 读   | 查看文件内容             | 列出目录内容（`ls`）      |\n| `w`  | 写   | 修改/删除文件            | 创建/删除目录内文件       |\n| `x`  | 执行 | 运行程序/脚本            | 进入目录（`cd`）          |\n| `-`  | 无   | 无权限                   | 无权限                    |\n\n{%note danger%}\n:warning:**注意**：\n1. 即使文件本身有 `w` 权限，如果所在目录没有` w`，你只能**清空或删除文件内容**，却仍然**无法删除或重命名**它\n2. 如果我想要访问一个目录，**必须拥有其所有父目录的权限**：`/usr/bin/echo`我必须拥有`/usr` `/bin`目录的权限，否则我将不被允许访问该文件，因为我将无法进入其中的目录\n{%endnote%}\n\n`mv`能将文件**修改位置并重命名**\n`cp`复制文件 需要两个参数 一个要**复制的文件路径** **一个目标文件路径**\n`rm`用于**删除文件**\n`rmdir`能**删除一个目录** 但它只能删除**空目录** 防止不小心删除一大堆文件\n`mkdir`**创建目录**\n```bash\nmkdir My Photos\n```\n`mkdir`创建目录\n```bash\nmkdir \"My Photos\"\n```\n这里如果不加上上引号则会创建\"My\"和\"Photos\"两个目录，因为`Bash`（或其他 `Shell`）会**将空格视为命令参数的分隔符**，相当于**命令收到了两个独立的参数**，因此它会创建两个独立的目录！\n\n{%note info%}\n或者使用**反斜杠**来转义空格，反斜杠会告诉 Shell：下一个字符是普通字符，不要把它当做特殊符号处理！\n```bash\nmkdir My\\ Photos\n```\n{%endnote%}\n\n`man+指令` 查找手册\n\n`ctrl`+`l`清空窗口\n\n### 输入流和输出流\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo hello > hello.txt\n```\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls > hello.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello.txt\nDesktop\nDocuments\nDownloads\nfizzbuzz.py\nhello2.txt\nhello.txt\nMusic\nPictures\nPublic\nsnap\nTemplates\nVideos\nweb\n```\n这样就可以将输出到屏幕的信息**存储**起来！\n{%note warning%}\n- `>`覆盖输出到文件\n- `<`从文件读取输入\n{%endnote%}\n***\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat hello.txt\nhello\n```\n通过`cat`指令输出文件内容\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat <hello.txt>hello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello2.txt\nhello\n```\n`<`将`hello.txt`作为输入内容并通过`>`将`cat`打印的任何内容输出到`hello2.txt`文件中\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat <hello.txt>>hello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello2.txt\nhello\nhello\n```\n`>>`表示追加而不是覆盖(`append instead of overwrite`)\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls -l|tail -n1\ndrwxrwxr-x 3 richard richard 4096 Mar  9 12:26 web\n```\n管道运算符`|`作用是将**左侧命令的输出**作为**右侧命令的输入**：可以连接多个命令形成**处理流水线**\n\n`tail`将输出最后一行的内容\n\n***\n\n### 用户权限管理\n`root`相当于`Windows`的管理员权限，是一位**超级用户**，可以做任何想做的事情，但是倘若一直使用`root`用户操作计算机，如果运行了错误的程序，那会彻底毁坏你的电脑！\n```bash\nrichard@richard-VMware-Virtual-Platform:/sys/class/backlight$ sudo su\n[sudo] password for richard: \nroot@richard-VMware-Virtual-Platform:/sys/class/backlight# \n```\n通过`sudo su`来进入`root`身份，同时提示符由`$`变为`#`\n\n***\n\n```bash\nroot@richard-VMware-Virtual-Platform:/sys/class/backlight# exit\nexit\nrichard@richard-VMware-Virtual-Platform:/sys/class/backlight$\n```\n`exit`来退出用户权限\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ xdg-open hello.txt\n```\n这样就可以直接在`terminal`打开文件！\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ foo=bar\nrichard@richard-VMware-Virtual-Platform:~$ echo $foo\nbar\n```\n在`shell`中，`$`符号是一个特殊字符，主要用于变量展开。当你在变量名前面加上$时，`shell`会将其替换为该变量的值！\n\n- ` foo` 会被`Shell`视为普通字符串\n- `$foo` 告诉`Shell`这是一个需要展开的变量\n\n\n ***\n\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello\"\nHello\nrichard@richard-VMware-Virtual-Platform:~$ foo=World\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello foo\"\nHello foo\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello $foo\"\nHello World\n```\n在`shell`中我们一定要非常注意**空格**`space`的使用，它是用作不同参数间的分隔符，倘若多打一个可能就会出现报错！\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ false\nrichard@richard-VMware-Virtual-Platform:~$ echo $?\n1\nrichard@richard-VMware-Virtual-Platform:~$ true\nrichard@richard-VMware-Virtual-Platform:~$ echo $?\n0\n```\n`$? `是一个特殊变量，存储上一个命令的退出状态码\n{%note warning%}\n- `false` 是一个 Shell 内置命令，返回非零退出状态（失败）设置退出状态码为 1（表示失败）\n- `true` 也是一个 Shell 内置命令，返回零退出状态（成功）退出状态码被设为 0（表示成功）\n{%endnote%}\n\n&emsp;&emsp;这里看上去有点反常理，我们学的其他编程语言中`0`是`false`，非零是`true`，为什么这里反过来了？\n&emsp;&emsp;当我们想到`c`、`c++`中`main`**函数结束的返回值**或许就不奇怪了！`main() `函数默认返回`0` 表示成功，非零表示错误（如 `return 1`;）。\n\n再考虑到程序运行只有两种可能：\n1. 完全成功（**唯一状态 0**）\n2. 失败（可能有多种原因，**用不同非零值区分**）：\n\n{%note warning%}\n- 0 = 没有错误（成功）\n- 1 = 通用错误\n- 2 = 参数错误\n- 3 = 文件不存在\n{%endnote%}\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ false || echo \"Oops fail\"\nOops fail\nrichard@richard-VMware-Virtual-Platform:~$ true || echo \"Will be not be printed\"\nrichard@richard-VMware-Virtual-Platform:~$\n```\n`shell`中`||`同样遵循**短路原则**，`&&`同理！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"We are now at $(pwd)\"\nWe are now at /home/richard\n```\n`shell`中使用`$(command)`进行**命令替换**\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls\nDesktop    Downloads   hello.txt  Pictures  snap       Videos\nDocuments  hello2.txt  Music      Public    Templates  web\nrichard@richard-VMware-Virtual-Platform:~$ ls *.txt\nhello2.txt  hello.txt\n```\n`*`是一个**通配符**（`globbing`）：表示**匹配任意数量的任意字符**（**包括零个字符**）。`Shell`会在执行`ls` 前先展开 `*.txt`，将其替换为所有匹配的文件名，相当于寻找所有后缀为`.txt`的文件！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls hello?.txt\nhello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ ls hello*.txt\nhello2.txt  hello.txt\n```\n这里可以看到`?`也是**通配符**，表示匹配任意一个字符（区别是必须存在，**不能匹配空字符**）\n```bash\n#!/usr/bin/env python3 #自动查找python3\n```\n通过`Shell`调用`Python`脚本可以充分发挥两者的优势：`Shell`的**流程控制能力**结合`Python`的**丰富库函数**，但我们要在路径中找到并配置好`python`解释器。\n```bash\nimport sys\n```\n由于`shell`默认不会执行`python`指令，我们需要添加库函数，来让`python`接受`shell`传递的参数\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ history\n```\n我们可以使用:arrow_up:来一个个**浏览历史记录命令**，我们也可以使用`history`直接打印所有历史命令！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ history | grep git\n```\n我们通过`history +N | grep +指令`来查找所有与指令字符串相匹配的`N`条历史记录命令！\n\n```bash\ntree\n```\n能列出**目录结构性**的位置！\n\n***\n\n`wc`（word count）是一个用于**统计文本文件中单词、行、字符等**的**命令行工具**。\n```bash\nwc [选项参数]... [文件]...\n```\n可选参数：\n- `c` 或 `--bytes`: 显示**字节数**\n- `m`或 `--chars`: 显示**字符数** 对于多字节字符（如中文），这与 -c 不同\n- `w` 或 `--words`: 显示**单词数**（以空格、制表符、换行符分隔的字符串）\n- `l` 或 `--lines`: 显示**行数**\n- **不指定**任何选项: 默认会**同时显示行数、单词数、字节数，以及文件名**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ wc hello.txt\n 13  13 109 hello.txt\n```\n```\nrichard@richard-VMware-Virtual-Platform:~$ wc --word hello.txt\n13 hello.txt\n```\n### 关机与重启\n\n1.`shutdown`\n- `-r` 或 `--reboot`: 重新启动系统\n- `-h` 或 `--halt`: 关闭系统\n- `-c` 或 `--cancel`: 取消之前的计划关机或重启\n- `-t` 或 `--time <时间>`: 指定关机或重启的时间（格式：`HH:MM`）\n- `-k` 或 `--kill`: 不关机，只发送`SIGTERM`信号给所有进程\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ shutdown -r\nReboot scheduled for Tue 2025-09-02 12:05:06 CST, use 'shutdown -c' to cancel.\n```\n2.`reboot`\n- `-f` 或 `--force`: 强制重启，不发送`SIGTERM`信号\n- `-n` 或 `--no-fsync`: 不执行`fsync`系统调用，加快重启速度\n- `-w` 或 `--wait`: 等待所有进程结束后再重启\n- `-i` 或 `--init`: 关机之前，关闭所有网络接口\n3. `init`\n4. `poweroff`","source":"_posts/Tutorial/Shell-Magic.md","raw":"---\ntitle: Shell Magic\ndate: 2025-07-27 22:34:30\ntags: [shell]\nindex_img:  https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Shell%20Magic%20Notes%20from%20The%20Missing%20Semeste.jpeg\ncategory: Tutorial\ncategory_bar: true\ndescription: This document summarizes my key takeaways from the Shell module of MIT’s The Missing Semester course, focusing on:Interaction and Automation Power!\n---\n\n\n{%note default%}对计算机的学生而言，许多开发工具是未来老师或企业默认你已经“精通”的，然而未经学校系统培训的我们或许会对此感到迷茫，正如 MIT 课程 **[The Missing Semester of Your CS Education](https://missing.csail.mit.edu/)** 所强调的： **“掌握基础工具是程序员的核心竞争力”**。这个课程会帮助你入门、了解一些计算机常用的开发工具，也算是程序员的自我修养吧！**Let's Go！**:smile:{%endnote%}\n\n相关课程在b站也有双语翻译（大部分应该都能听懂，就是有个好像是西班牙的老师带点口音听起来有点不适应:cry:）[[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell](https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.1387.favlist.content.click&vd_source=54c2981c1a7a8e0433b7d23096150b7a)\n\n***\n\n&emsp;&emsp;不论是在电影里还是在我们初识计算机的过程中，都会看到一个黑乎乎的窗口，只要输入几行代码就可以完成酷炫的操作，但是你或许对这有一点疑惑，这到底是`terminal`、`bash`、`zsh`还是`powershell`，他们到底是如何区分的呢？\n\n1.`Terminal`：用户终端，用来启动`shell`，这也可以说算是一个“工具”，活跃在为用户服务的**前端**\n2.`Shell`：是一个**命令行解释器**，负责接收用户输入的命令并将其**解释**为计算机可以执行的操作，与`Terminal`相比，是活跃于用户服务**后端的程序**，以下都是`Shell`在不同操作系统中的实现：\n- `Bash`：是一种**常用的Shell**，在`Linux`和`macOS`中默认安装。\n- `Zsh`：是一种**功能强大的Shell**，在`macOS`中默认安装，也可以在`Linux`中安装。\n- `PowerShell`：是一种**Windows**系统下的**命令行工具**，用于**管理Windows系统**和**执行PowerShell脚本**。\n\n## Shell\n&emsp;&emsp;当熟悉的**可视化界面**无法实现你想要的功能时，`Shell`将成为你与计算机交互的强大工具。相比**图形界面有限的按钮和滑块**，命令行提供了更灵活、更强大的控制方式，允许你通过**文本命令和脚本实现自动化操作**。本文基于`VMware`虚拟机中的`Ubuntu 22.04`发行版演示基础`Shell`操作：\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ date\nSat Jul 26 03:27:54 PM CST 2025\n```\n第一行通常是用户名、机器名称和当前所在路径\n{%note danger%}\n- `Windows`中路径通常使用**反斜杠**`\\`分隔，每个驱动器都有一个单独的路径结构。\n- `Linux` / `macOS` 中这些路径使用**正斜杠**`/`分隔，他们挂载在同一个命名空间下。\n{%endnote%}\n\n开头的斜杠表示从文件系统的顶部开始。\n{%note warning%}\n- 相对路径：相对于当前位置的路径\n- 绝对路径：完整路径，从顶部开始\n{%endnote%}\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello World\"\nHello World\n```\n`echo`可以将后面的参数**打印**在屏幕上\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ which echo\n/usr/bin/echo\n```\n`which`可以用于**寻找后面参数文件的绝对位置**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ pwd\n/home/richard\n```\n`pwd`（`Print Working Directory`）**打印当前所在路径**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cd /home\nrichard@richard-VMware-Virtual-Platform:/home$ \n```\n`cd`（`Change Directory`）表示更改当前目录\n\n这是更方便**切换目录**的方式：\n{%note warning%}\n- `.`表示**当前**目录\n- `..`表示**父**目录\n{%endnote%}\n\n**注意**：使用相对路径能提高命令在不同电脑上的**兼容性**！\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:/$ ls\nbin                home               mnt   sbin.usr-is-merged  usr\nbin.usr-is-merged  lib                opt   snap                var\nboot               lib64              proc  srv\ncdrom              lib.usr-is-merged  root  swap.img\ndev                lost+found         run   sys\netc                media              sbin  tmp\n```\n`ls`会列出当前目录中的文件，这能够快速浏览文件\n```bash\nrichard@richard-VMware-Virtual-Platform:/home$ cd ~\nrichard@richard-VMware-Virtual-Platform:~$\n```\n{%note warning%}\n- `cd ~`能够快速**回到用户主目录**\n- `cd -`切换到**上一个工作目录**\n{%endnote%}\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls --help\nUsage: ls [OPTION]... [FILE]...\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n```\n`--help`参数显示**命令帮助信息**\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls -l\ntotal 40\ndrwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Desktop\ndrwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Documents\n\nlrwxrwxrwx   1 root root          7 Apr 22  2024 bin -> usr/bin\ndrwxr-xr-x   2 root root       4096 Feb 26  2024 bin.usr-is-merged\n# 仅列举部分进行展示说明\n```\n**文件类型**（第`1`个字符）\n\n| 字符 | 类型       | 说明                  | 示例                  |\n|------|------------|-----------------------|-----------------------|\n| `d`  | 目录       | 文件夹                | `drwxr-xr-x` |\n| `-`  | 普通文件   | 文本/二进制文件       | `-rw-r--r--` |\n| `l`  | 符号链接   | 软链接文件            | `lrwxrwxrwx` |\n| `c`  | 字符设备   | 终端等串行设备        | `crw--w----` |\n| `b`  | 块设备     | 磁盘等存储设备        | `brw-rw----` |\n| `s`  | 套接字     | 进程通信文件          | `srwxrwxrwx` |\n| `p`  | 管道       | `FIFO` 管道文件         | `prw-------`|\n\n用户权限分为 **3组**（每组`3`字符），分别对应：\n\n| 组别       | 示例          | \n|------------|---------------|\n| 所有者权限 | `rwx`         | \n| 所属组权限 | `r-x`         | \n| 其他用户   | `r-x`         | \n\n权限字符**含义**：\n\n 字符 | 权限 | 对文件的影响             | 对目录的影响              |\n|------|------|--------------------------|---------------------------|\n| `r`  | 读   | 查看文件内容             | 列出目录内容（`ls`）      |\n| `w`  | 写   | 修改/删除文件            | 创建/删除目录内文件       |\n| `x`  | 执行 | 运行程序/脚本            | 进入目录（`cd`）          |\n| `-`  | 无   | 无权限                   | 无权限                    |\n\n{%note danger%}\n:warning:**注意**：\n1. 即使文件本身有 `w` 权限，如果所在目录没有` w`，你只能**清空或删除文件内容**，却仍然**无法删除或重命名**它\n2. 如果我想要访问一个目录，**必须拥有其所有父目录的权限**：`/usr/bin/echo`我必须拥有`/usr` `/bin`目录的权限，否则我将不被允许访问该文件，因为我将无法进入其中的目录\n{%endnote%}\n\n`mv`能将文件**修改位置并重命名**\n`cp`复制文件 需要两个参数 一个要**复制的文件路径** **一个目标文件路径**\n`rm`用于**删除文件**\n`rmdir`能**删除一个目录** 但它只能删除**空目录** 防止不小心删除一大堆文件\n`mkdir`**创建目录**\n```bash\nmkdir My Photos\n```\n`mkdir`创建目录\n```bash\nmkdir \"My Photos\"\n```\n这里如果不加上上引号则会创建\"My\"和\"Photos\"两个目录，因为`Bash`（或其他 `Shell`）会**将空格视为命令参数的分隔符**，相当于**命令收到了两个独立的参数**，因此它会创建两个独立的目录！\n\n{%note info%}\n或者使用**反斜杠**来转义空格，反斜杠会告诉 Shell：下一个字符是普通字符，不要把它当做特殊符号处理！\n```bash\nmkdir My\\ Photos\n```\n{%endnote%}\n\n`man+指令` 查找手册\n\n`ctrl`+`l`清空窗口\n\n### 输入流和输出流\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo hello > hello.txt\n```\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls > hello.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello.txt\nDesktop\nDocuments\nDownloads\nfizzbuzz.py\nhello2.txt\nhello.txt\nMusic\nPictures\nPublic\nsnap\nTemplates\nVideos\nweb\n```\n这样就可以将输出到屏幕的信息**存储**起来！\n{%note warning%}\n- `>`覆盖输出到文件\n- `<`从文件读取输入\n{%endnote%}\n***\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat hello.txt\nhello\n```\n通过`cat`指令输出文件内容\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat <hello.txt>hello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello2.txt\nhello\n```\n`<`将`hello.txt`作为输入内容并通过`>`将`cat`打印的任何内容输出到`hello2.txt`文件中\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ cat <hello.txt>>hello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ cat hello2.txt\nhello\nhello\n```\n`>>`表示追加而不是覆盖(`append instead of overwrite`)\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls -l|tail -n1\ndrwxrwxr-x 3 richard richard 4096 Mar  9 12:26 web\n```\n管道运算符`|`作用是将**左侧命令的输出**作为**右侧命令的输入**：可以连接多个命令形成**处理流水线**\n\n`tail`将输出最后一行的内容\n\n***\n\n### 用户权限管理\n`root`相当于`Windows`的管理员权限，是一位**超级用户**，可以做任何想做的事情，但是倘若一直使用`root`用户操作计算机，如果运行了错误的程序，那会彻底毁坏你的电脑！\n```bash\nrichard@richard-VMware-Virtual-Platform:/sys/class/backlight$ sudo su\n[sudo] password for richard: \nroot@richard-VMware-Virtual-Platform:/sys/class/backlight# \n```\n通过`sudo su`来进入`root`身份，同时提示符由`$`变为`#`\n\n***\n\n```bash\nroot@richard-VMware-Virtual-Platform:/sys/class/backlight# exit\nexit\nrichard@richard-VMware-Virtual-Platform:/sys/class/backlight$\n```\n`exit`来退出用户权限\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ xdg-open hello.txt\n```\n这样就可以直接在`terminal`打开文件！\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ foo=bar\nrichard@richard-VMware-Virtual-Platform:~$ echo $foo\nbar\n```\n在`shell`中，`$`符号是一个特殊字符，主要用于变量展开。当你在变量名前面加上$时，`shell`会将其替换为该变量的值！\n\n- ` foo` 会被`Shell`视为普通字符串\n- `$foo` 告诉`Shell`这是一个需要展开的变量\n\n\n ***\n\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello\"\nHello\nrichard@richard-VMware-Virtual-Platform:~$ foo=World\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello foo\"\nHello foo\nrichard@richard-VMware-Virtual-Platform:~$ echo \"Hello $foo\"\nHello World\n```\n在`shell`中我们一定要非常注意**空格**`space`的使用，它是用作不同参数间的分隔符，倘若多打一个可能就会出现报错！\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ false\nrichard@richard-VMware-Virtual-Platform:~$ echo $?\n1\nrichard@richard-VMware-Virtual-Platform:~$ true\nrichard@richard-VMware-Virtual-Platform:~$ echo $?\n0\n```\n`$? `是一个特殊变量，存储上一个命令的退出状态码\n{%note warning%}\n- `false` 是一个 Shell 内置命令，返回非零退出状态（失败）设置退出状态码为 1（表示失败）\n- `true` 也是一个 Shell 内置命令，返回零退出状态（成功）退出状态码被设为 0（表示成功）\n{%endnote%}\n\n&emsp;&emsp;这里看上去有点反常理，我们学的其他编程语言中`0`是`false`，非零是`true`，为什么这里反过来了？\n&emsp;&emsp;当我们想到`c`、`c++`中`main`**函数结束的返回值**或许就不奇怪了！`main() `函数默认返回`0` 表示成功，非零表示错误（如 `return 1`;）。\n\n再考虑到程序运行只有两种可能：\n1. 完全成功（**唯一状态 0**）\n2. 失败（可能有多种原因，**用不同非零值区分**）：\n\n{%note warning%}\n- 0 = 没有错误（成功）\n- 1 = 通用错误\n- 2 = 参数错误\n- 3 = 文件不存在\n{%endnote%}\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ false || echo \"Oops fail\"\nOops fail\nrichard@richard-VMware-Virtual-Platform:~$ true || echo \"Will be not be printed\"\nrichard@richard-VMware-Virtual-Platform:~$\n```\n`shell`中`||`同样遵循**短路原则**，`&&`同理！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ echo \"We are now at $(pwd)\"\nWe are now at /home/richard\n```\n`shell`中使用`$(command)`进行**命令替换**\n\n***\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls\nDesktop    Downloads   hello.txt  Pictures  snap       Videos\nDocuments  hello2.txt  Music      Public    Templates  web\nrichard@richard-VMware-Virtual-Platform:~$ ls *.txt\nhello2.txt  hello.txt\n```\n`*`是一个**通配符**（`globbing`）：表示**匹配任意数量的任意字符**（**包括零个字符**）。`Shell`会在执行`ls` 前先展开 `*.txt`，将其替换为所有匹配的文件名，相当于寻找所有后缀为`.txt`的文件！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ ls hello?.txt\nhello2.txt\nrichard@richard-VMware-Virtual-Platform:~$ ls hello*.txt\nhello2.txt  hello.txt\n```\n这里可以看到`?`也是**通配符**，表示匹配任意一个字符（区别是必须存在，**不能匹配空字符**）\n```bash\n#!/usr/bin/env python3 #自动查找python3\n```\n通过`Shell`调用`Python`脚本可以充分发挥两者的优势：`Shell`的**流程控制能力**结合`Python`的**丰富库函数**，但我们要在路径中找到并配置好`python`解释器。\n```bash\nimport sys\n```\n由于`shell`默认不会执行`python`指令，我们需要添加库函数，来让`python`接受`shell`传递的参数\n\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ history\n```\n我们可以使用:arrow_up:来一个个**浏览历史记录命令**，我们也可以使用`history`直接打印所有历史命令！\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ history | grep git\n```\n我们通过`history +N | grep +指令`来查找所有与指令字符串相匹配的`N`条历史记录命令！\n\n```bash\ntree\n```\n能列出**目录结构性**的位置！\n\n***\n\n`wc`（word count）是一个用于**统计文本文件中单词、行、字符等**的**命令行工具**。\n```bash\nwc [选项参数]... [文件]...\n```\n可选参数：\n- `c` 或 `--bytes`: 显示**字节数**\n- `m`或 `--chars`: 显示**字符数** 对于多字节字符（如中文），这与 -c 不同\n- `w` 或 `--words`: 显示**单词数**（以空格、制表符、换行符分隔的字符串）\n- `l` 或 `--lines`: 显示**行数**\n- **不指定**任何选项: 默认会**同时显示行数、单词数、字节数，以及文件名**\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ wc hello.txt\n 13  13 109 hello.txt\n```\n```\nrichard@richard-VMware-Virtual-Platform:~$ wc --word hello.txt\n13 hello.txt\n```\n### 关机与重启\n\n1.`shutdown`\n- `-r` 或 `--reboot`: 重新启动系统\n- `-h` 或 `--halt`: 关闭系统\n- `-c` 或 `--cancel`: 取消之前的计划关机或重启\n- `-t` 或 `--time <时间>`: 指定关机或重启的时间（格式：`HH:MM`）\n- `-k` 或 `--kill`: 不关机，只发送`SIGTERM`信号给所有进程\n```bash\nrichard@richard-VMware-Virtual-Platform:~$ shutdown -r\nReboot scheduled for Tue 2025-09-02 12:05:06 CST, use 'shutdown -c' to cancel.\n```\n2.`reboot`\n- `-f` 或 `--force`: 强制重启，不发送`SIGTERM`信号\n- `-n` 或 `--no-fsync`: 不执行`fsync`系统调用，加快重启速度\n- `-w` 或 `--wait`: 等待所有进程结束后再重启\n- `-i` 或 `--init`: 关机之前，关闭所有网络接口\n3. `init`\n4. `poweroff`","slug":"Tutorial/Shell-Magic","published":1,"updated":"2025-09-02T04:07:50.712Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hd3005y40w3e2bncuv0","content":"<div class=\"note note-info\">\n            <p>对计算机的学生而言，许多开发工具是未来老师或企业默认你已经“精通”的，然而未经学校系统培训的我们或许会对此感到迷茫，正如 MIT 课程 <strong><a href=\"https://missing.csail.mit.edu/\">The Missing Semester of Your CS Education</a></strong> 所强调的： <strong>“掌握基础工具是程序员的核心竞争力”</strong>。这个课程会帮助你入门、了解一些计算机常用的开发工具，也算是程序员的自我修养吧！<strong>Let’s Go！</strong>😄</p>\n          </div>\n<p>相关课程在b站也有双语翻译（大部分应该都能听懂，就是有个好像是西班牙的老师带点口音听起来有点不适应😢）<a href=\"https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a></p>\n<hr>\n<p>  不论是在电影里还是在我们初识计算机的过程中，都会看到一个黑乎乎的窗口，只要输入几行代码就可以完成酷炫的操作，但是你或许对这有一点疑惑，这到底是<code>terminal</code>、<code>bash</code>、<code>zsh</code>还是<code>powershell</code>，他们到底是如何区分的呢？</p>\n<p>1.<code>Terminal</code>：用户终端，用来启动<code>shell</code>，这也可以说算是一个“工具”，活跃在为用户服务的<strong>前端</strong><br>\n2.<code>Shell</code>：是一个<strong>命令行解释器</strong>，负责接收用户输入的命令并将其<strong>解释</strong>为计算机可以执行的操作，与<code>Terminal</code>相比，是活跃于用户服务<strong>后端的程序</strong>，以下都是<code>Shell</code>在不同操作系统中的实现：</p>\n<ul>\n<li><code>Bash</code>：是一种<strong>常用的Shell</strong>，在<code>Linux</code>和<code>macOS</code>中默认安装。</li>\n<li><code>Zsh</code>：是一种<strong>功能强大的Shell</strong>，在<code>macOS</code>中默认安装，也可以在<code>Linux</code>中安装。</li>\n<li><code>PowerShell</code>：是一种<strong>Windows</strong>系统下的<strong>命令行工具</strong>，用于<strong>管理Windows系统</strong>和<strong>执行PowerShell脚本</strong>。</li>\n</ul>\n<h2 id=\"Shell\">Shell</h2>\n<p>  当熟悉的<strong>可视化界面</strong>无法实现你想要的功能时，<code>Shell</code>将成为你与计算机交互的强大工具。相比<strong>图形界面有限的按钮和滑块</strong>，命令行提供了更灵活、更强大的控制方式，允许你通过<strong>文本命令和脚本实现自动化操作</strong>。本文基于<code>VMware</code>虚拟机中的<code>Ubuntu 22.04</code>发行版演示基础<code>Shell</code>操作：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">date</span><br>Sat Jul 26 03:27:54 PM CST 2025<br></code></pre></td></tr></tbody></table></figure>\n<p>第一行通常是用户名、机器名称和当前所在路径</p>\n<div class=\"note note-danger\">\n            <ul><li><code>Windows</code>中路径通常使用<strong>反斜杠</strong><code>\\</code>分隔，每个驱动器都有一个单独的路径结构。</li><li><code>Linux</code> / <code>macOS</code> 中这些路径使用<strong>正斜杠</strong><code>/</code>分隔，他们挂载在同一个命名空间下。</li></ul>\n          </div>\n<p>开头的斜杠表示从文件系统的顶部开始。</p>\n<div class=\"note note-warning\">\n            <ul><li>相对路径：相对于当前位置的路径</li><li>绝对路径：完整路径，从顶部开始</li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello World\"</span><br>Hello World<br></code></pre></td></tr></tbody></table></figure>\n<p><code>echo</code>可以将后面的参数<strong>打印</strong>在屏幕上</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">which</span> <span class=\"hljs-built_in\">echo</span><br>/usr/bin/echo<br></code></pre></td></tr></tbody></table></figure>\n<p><code>which</code>可以用于<strong>寻找后面参数文件的绝对位置</strong></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">pwd</span><br>/home/richard<br></code></pre></td></tr></tbody></table></figure>\n<p><code>pwd</code>（<code>Print Working Directory</code>）<strong>打印当前所在路径</strong></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cd</span> /home<br>richard@richard-VMware-Virtual-Platform:/home$ <br></code></pre></td></tr></tbody></table></figure>\n<p><code>cd</code>（<code>Change Directory</code>）表示更改当前目录</p>\n<p>这是更方便<strong>切换目录</strong>的方式：</p>\n<div class=\"note note-warning\">\n            <ul><li><code>.</code>表示<strong>当前</strong>目录</li><li><code>..</code>表示<strong>父</strong>目录</li></ul>\n          </div>\n<p><strong>注意</strong>：使用相对路径能提高命令在不同电脑上的<strong>兼容性</strong>！</p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/$ <span class=\"hljs-built_in\">ls</span><br>bin                home               mnt   sbin.usr-is-merged  usr<br>bin.usr-is-merged  lib                opt   snap                var<br>boot               lib64              proc  srv<br>cdrom              lib.usr-is-merged  root  swap.img<br>dev                lost+found         run   sys<br>etc                media              sbin  tmp<br></code></pre></td></tr></tbody></table></figure>\n<p><code>ls</code>会列出当前目录中的文件，这能够快速浏览文件</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/home$ <span class=\"hljs-built_in\">cd</span> ~<br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-warning\">\n            <ul><li><code>cd ~</code>能够快速<strong>回到用户主目录</strong></li><li><code>cd -</code>切换到<strong>上一个工作目录</strong></li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> --<span class=\"hljs-built_in\">help</span><br>Usage: <span class=\"hljs-built_in\">ls</span> [OPTION]... [FILE]...<br>List information about the FILEs (the current directory by default).<br>Sort entries alphabetically <span class=\"hljs-keyword\">if</span> none of -cftuvSUX nor --<span class=\"hljs-built_in\">sort</span> is specified.<br></code></pre></td></tr></tbody></table></figure>\n<p><code>--help</code>参数显示<strong>命令帮助信息</strong></p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> -l<br>total 40<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Desktop<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Documents<br><br>lrwxrwxrwx   1 root root          7 Apr 22  2024 bin -&gt; usr/bin<br>drwxr-xr-x   2 root root       4096 Feb 26  2024 bin.usr-is-merged<br><span class=\"hljs-comment\"># 仅列举部分进行展示说明</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>文件类型</strong>（第<code>1</code>个字符）</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>类型</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>d</code></td>\n<td>目录</td>\n<td>文件夹</td>\n<td><code>drwxr-xr-x</code></td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>普通文件</td>\n<td>文本/二进制文件</td>\n<td><code>-rw-r--r--</code></td>\n</tr>\n<tr>\n<td><code>l</code></td>\n<td>符号链接</td>\n<td>软链接文件</td>\n<td><code>lrwxrwxrwx</code></td>\n</tr>\n<tr>\n<td><code>c</code></td>\n<td>字符设备</td>\n<td>终端等串行设备</td>\n<td><code>crw--w----</code></td>\n</tr>\n<tr>\n<td><code>b</code></td>\n<td>块设备</td>\n<td>磁盘等存储设备</td>\n<td><code>brw-rw----</code></td>\n</tr>\n<tr>\n<td><code>s</code></td>\n<td>套接字</td>\n<td>进程通信文件</td>\n<td><code>srwxrwxrwx</code></td>\n</tr>\n<tr>\n<td><code>p</code></td>\n<td>管道</td>\n<td><code>FIFO</code> 管道文件</td>\n<td><code>prw-------</code></td>\n</tr>\n</tbody>\n</table>\n<p>用户权限分为 <strong>3组</strong>（每组<code>3</code>字符），分别对应：</p>\n<table>\n<thead>\n<tr>\n<th>组别</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>所有者权限</td>\n<td><code>rwx</code></td>\n</tr>\n<tr>\n<td>所属组权限</td>\n<td><code>r-x</code></td>\n</tr>\n<tr>\n<td>其他用户</td>\n<td><code>r-x</code></td>\n</tr>\n</tbody>\n</table>\n<p>权限字符<strong>含义</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>权限</th>\n<th>对文件的影响</th>\n<th>对目录的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>r</code></td>\n<td>读</td>\n<td>查看文件内容</td>\n<td>列出目录内容（<code>ls</code>）</td>\n</tr>\n<tr>\n<td><code>w</code></td>\n<td>写</td>\n<td>修改/删除文件</td>\n<td>创建/删除目录内文件</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>执行</td>\n<td>运行程序/脚本</td>\n<td>进入目录（<code>cd</code>）</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>无</td>\n<td>无权限</td>\n<td>无权限</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-danger\">\n            <p>⚠️<strong>注意</strong>：</p><ol><li>即使文件本身有 <code>w</code> 权限，如果所在目录没有<code> w</code>，你只能<strong>清空或删除文件内容</strong>，却仍然<strong>无法删除或重命名</strong>它</li><li>如果我想要访问一个目录，<strong>必须拥有其所有父目录的权限</strong>：<code>/usr/bin/echo</code>我必须拥有<code>/usr</code> <code>/bin</code>目录的权限，否则我将不被允许访问该文件，因为我将无法进入其中的目录</li></ol>\n          </div>\n<p><code>mv</code>能将文件<strong>修改位置并重命名</strong><br>\n<code>cp</code>复制文件 需要两个参数 一个要<strong>复制的文件路径</strong> <strong>一个目标文件路径</strong><br>\n<code>rm</code>用于<strong>删除文件</strong><br>\n<code>rmdir</code>能<strong>删除一个目录</strong> 但它只能删除<strong>空目录</strong> 防止不小心删除一大堆文件<br>\n<code>mkdir</code><strong>创建目录</strong></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> My Photos<br></code></pre></td></tr></tbody></table></figure>\n<p><code>mkdir</code>创建目录</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> <span class=\"hljs-string\">\"My Photos\"</span><br></code></pre></td></tr></tbody></table></figure>\n<p>这里如果不加上上引号则会创建\"My\"和\"Photos\"两个目录，因为<code>Bash</code>（或其他 <code>Shell</code>）会<strong>将空格视为命令参数的分隔符</strong>，相当于<strong>命令收到了两个独立的参数</strong>，因此它会创建两个独立的目录！</p>\n<div class=\"note note-info\">\n            <p>或者使用<strong>反斜杠</strong>来转义空格，反斜杠会告诉 Shell：下一个字符是普通字符，不要把它当做特殊符号处理！</p><figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> My\\ Photos<br></code></pre></td></tr></tbody></table></figure>\n          </div>\n<p><code>man+指令</code> 查找手册</p>\n<p><code>ctrl</code>+<code>l</code>清空窗口</p>\n<h3 id=\"输入流和输出流\">输入流和输出流</h3>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> hello &gt; hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> &gt; hello.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello.txt<br>Desktop<br>Documents<br>Downloads<br>fizzbuzz.py<br>hello2.txt<br>hello.txt<br>Music<br>Pictures<br>Public<br>snap<br>Templates<br>Videos<br>web<br></code></pre></td></tr></tbody></table></figure>\n<p>这样就可以将输出到屏幕的信息<strong>存储</strong>起来！</p>\n<div class=\"note note-warning\">\n            <ul><li><code>&gt;</code>覆盖输出到文件</li><li><code>&lt;</code>从文件读取输入</li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello.txt<br>hello<br></code></pre></td></tr></tbody></table></figure>\n<p>通过<code>cat</code>指令输出文件内容</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> &lt;hello.txt&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello2.txt<br>hello<br></code></pre></td></tr></tbody></table></figure>\n<p><code>&lt;</code>将<code>hello.txt</code>作为输入内容并通过<code>&gt;</code>将<code>cat</code>打印的任何内容输出到<code>hello2.txt</code>文件中</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> &lt;hello.txt&gt;&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello2.txt<br>hello<br>hello<br></code></pre></td></tr></tbody></table></figure>\n<p><code>&gt;&gt;</code>表示追加而不是覆盖(<code>append instead of overwrite</code>)</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> -l|<span class=\"hljs-built_in\">tail</span> -n1<br>drwxrwxr-x 3 richard richard 4096 Mar  9 12:26 web<br></code></pre></td></tr></tbody></table></figure>\n<p>管道运算符<code>|</code>作用是将<strong>左侧命令的输出</strong>作为<strong>右侧命令的输入</strong>：可以连接多个命令形成<strong>处理流水线</strong></p>\n<p><code>tail</code>将输出最后一行的内容</p>\n<hr>\n<h3 id=\"用户权限管理\">用户权限管理</h3>\n<p><code>root</code>相当于<code>Windows</code>的管理员权限，是一位<strong>超级用户</strong>，可以做任何想做的事情，但是倘若一直使用<code>root</code>用户操作计算机，如果运行了错误的程序，那会彻底毁坏你的电脑！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/sys/class/backlight$ <span class=\"hljs-built_in\">sudo</span> su<br>[<span class=\"hljs-built_in\">sudo</span>] password <span class=\"hljs-keyword\">for</span> richard: <br>root@richard-VMware-Virtual-Platform:/sys/class/backlight# <br></code></pre></td></tr></tbody></table></figure>\n<p>通过<code>sudo su</code>来进入<code>root</code>身份，同时提示符由<code>$</code>变为<code>#</code></p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">root@richard-VMware-Virtual-Platform:/sys/class/backlight# <span class=\"hljs-built_in\">exit</span><br><span class=\"hljs-built_in\">exit</span><br>richard@richard-VMware-Virtual-Platform:/sys/class/backlight$<br></code></pre></td></tr></tbody></table></figure>\n<p><code>exit</code>来退出用户权限</p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ xdg-open hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<p>这样就可以直接在<code>terminal</code>打开文件！</p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ foo=bar<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$foo</span><br>bar<br></code></pre></td></tr></tbody></table></figure>\n<p>在<code>shell</code>中，<code>$</code>符号是一个特殊字符，主要用于变量展开。当你在变量名前面加上$时，<code>shell</code>会将其替换为该变量的值！</p>\n<ul>\n<li><code> foo</code> 会被<code>Shell</code>视为普通字符串</li>\n<li><code>$foo</code> 告诉<code>Shell</code>这是一个需要展开的变量</li>\n</ul>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello\"</span><br>Hello<br>richard@richard-VMware-Virtual-Platform:~$ foo=World<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello foo\"</span><br>Hello foo<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello <span class=\"hljs-variable\">$foo</span>\"</span><br>Hello World<br></code></pre></td></tr></tbody></table></figure>\n<p>在<code>shell</code>中我们一定要非常注意<strong>空格</strong><code>space</code>的使用，它是用作不同参数间的分隔符，倘若多打一个可能就会出现报错！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">false</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> $?<br>1<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">true</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> $?<br>0<br></code></pre></td></tr></tbody></table></figure>\n<p><code>$? </code>是一个特殊变量，存储上一个命令的退出状态码</p>\n<div class=\"note note-warning\">\n            <ul><li><code>false</code> 是一个 Shell 内置命令，返回非零退出状态（失败）设置退出状态码为 1（表示失败）</li><li><code>true</code> 也是一个 Shell 内置命令，返回零退出状态（成功）退出状态码被设为 0（表示成功）</li></ul>\n          </div>\n<p>  这里看上去有点反常理，我们学的其他编程语言中<code>0</code>是<code>false</code>，非零是<code>true</code>，为什么这里反过来了？<br>\n  当我们想到<code>c</code>、<code>c++</code>中<code>main</code><strong>函数结束的返回值</strong>或许就不奇怪了！<code>main() </code>函数默认返回<code>0</code> 表示成功，非零表示错误（如 <code>return 1</code>;）。</p>\n<p>再考虑到程序运行只有两种可能：</p>\n<ol>\n<li>完全成功（<strong>唯一状态 0</strong>）</li>\n<li>失败（可能有多种原因，<strong>用不同非零值区分</strong>）：</li>\n</ol>\n<div class=\"note note-warning\">\n            <ul><li>0 = 没有错误（成功）</li><li>1 = 通用错误</li><li>2 = 参数错误</li><li>3 = 文件不存在</li></ul>\n          </div>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">false</span> || <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Oops fail\"</span><br>Oops fail<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">true</span> || <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Will be not be printed\"</span><br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></tbody></table></figure>\n<p><code>shell</code>中<code>||</code>同样遵循<strong>短路原则</strong>，<code>&amp;&amp;</code>同理！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"We are now at <span class=\"hljs-subst\">$(pwd)</span>\"</span><br>We are now at /home/richard<br></code></pre></td></tr></tbody></table></figure>\n<p><code>shell</code>中使用<code>$(command)</code>进行<strong>命令替换</strong></p>\n<hr>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span><br>Desktop    Downloads   hello.txt  Pictures  snap       Videos<br>Documents  hello2.txt  Music      Public    Templates  web<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> *.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<p><code>*</code>是一个<strong>通配符</strong>（<code>globbing</code>）：表示<strong>匹配任意数量的任意字符</strong>（<strong>包括零个字符</strong>）。<code>Shell</code>会在执行<code>ls</code> 前先展开 <code>*.txt</code>，将其替换为所有匹配的文件名，相当于寻找所有后缀为<code>.txt</code>的文件！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> hello?.txt<br>hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> hello*.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<p>这里可以看到<code>?</code>也是<strong>通配符</strong>，表示匹配任意一个字符（区别是必须存在，<strong>不能匹配空字符</strong>）</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/usr/bin/env python3 #自动查找python3</span><br></code></pre></td></tr></tbody></table></figure>\n<p>通过<code>Shell</code>调用<code>Python</code>脚本可以充分发挥两者的优势：<code>Shell</code>的<strong>流程控制能力</strong>结合<code>Python</code>的<strong>丰富库函数</strong>，但我们要在路径中找到并配置好<code>python</code>解释器。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">import sys<br></code></pre></td></tr></tbody></table></figure>\n<p>由于<code>shell</code>默认不会执行<code>python</code>指令，我们需要添加库函数，来让<code>python</code>接受<code>shell</code>传递的参数</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">history</span><br></code></pre></td></tr></tbody></table></figure>\n<p>我们可以使用⬆️来一个个<strong>浏览历史记录命令</strong>，我们也可以使用<code>history</code>直接打印所有历史命令！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">history</span> | grep git<br></code></pre></td></tr></tbody></table></figure>\n<p>我们通过<code>history +N | grep +指令</code>来查找所有与指令字符串相匹配的<code>N</code>条历史记录命令！</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tree<br></code></pre></td></tr></tbody></table></figure>\n<p>能列出<strong>目录结构性</strong>的位置！</p>\n<hr>\n<p><code>wc</code>（word count）是一个用于<strong>统计文本文件中单词、行、字符等</strong>的<strong>命令行工具</strong>。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">wc</span> [选项参数]... [文件]...<br></code></pre></td></tr></tbody></table></figure>\n<p>可选参数：</p>\n<ul>\n<li><code>c</code> 或 <code>--bytes</code>: 显示<strong>字节数</strong></li>\n<li><code>m</code>或 <code>--chars</code>: 显示<strong>字符数</strong> 对于多字节字符（如中文），这与 -c 不同</li>\n<li><code>w</code> 或 <code>--words</code>: 显示<strong>单词数</strong>（以空格、制表符、换行符分隔的字符串）</li>\n<li><code>l</code> 或 <code>--lines</code>: 显示<strong>行数</strong></li>\n<li><strong>不指定</strong>任何选项: 默认会<strong>同时显示行数、单词数、字节数，以及文件名</strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">wc</span> hello.txt<br> 13  13 109 hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<figure class=\"highlight ruby\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">richard<span class=\"hljs-variable\">@richard</span>-<span class=\"hljs-title class_\">VMware</span>-<span class=\"hljs-title class_\">Virtual</span>-<span class=\"hljs-title class_\">Platform</span><span class=\"hljs-symbol\">:~</span><span class=\"hljs-variable\">$ </span>wc --word hello.txt<br><span class=\"hljs-number\">13</span> hello.txt<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"关机与重启\">关机与重启</h3>\n<p>1.<code>shutdown</code></p>\n<ul>\n<li><code>-r</code> 或 <code>--reboot</code>: 重新启动系统</li>\n<li><code>-h</code> 或 <code>--halt</code>: 关闭系统</li>\n<li><code>-c</code> 或 <code>--cancel</code>: 取消之前的计划关机或重启</li>\n<li><code>-t</code> 或 <code>--time &lt;时间&gt;</code>: 指定关机或重启的时间（格式：<code>HH:MM</code>）</li>\n<li><code>-k</code> 或 <code>--kill</code>: 不关机，只发送<code>SIGTERM</code>信号给所有进程</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ shutdown -r<br>Reboot scheduled <span class=\"hljs-keyword\">for</span> Tue 2025-09-02 12:05:06 CST, use <span class=\"hljs-string\">'shutdown -c'</span> to cancel.<br></code></pre></td></tr></tbody></table></figure>\n<p>2.<code>reboot</code></p>\n<ul>\n<li><code>-f</code> 或 <code>--force</code>: 强制重启，不发送<code>SIGTERM</code>信号</li>\n<li><code>-n</code> 或 <code>--no-fsync</code>: 不执行<code>fsync</code>系统调用，加快重启速度</li>\n<li><code>-w</code> 或 <code>--wait</code>: 等待所有进程结束后再重启</li>\n<li><code>-i</code> 或 <code>--init</code>: 关机之前，关闭所有网络接口</li>\n</ul>\n<ol start=\"3\">\n<li><code>init</code></li>\n<li><code>poweroff</code></li>\n</ol>\n","excerpt":"","more":"<div class=\"note note-info\">\n            <p>对计算机的学生而言，许多开发工具是未来老师或企业默认你已经“精通”的，然而未经学校系统培训的我们或许会对此感到迷茫，正如 MIT 课程 <strong><a href=\"https://missing.csail.mit.edu/\">The Missing Semester of Your CS Education</a></strong> 所强调的： <strong>“掌握基础工具是程序员的核心竞争力”</strong>。这个课程会帮助你入门、了解一些计算机常用的开发工具，也算是程序员的自我修养吧！<strong>Let’s Go！</strong>😄</p>\n          </div>\n<p>相关课程在b站也有双语翻译（大部分应该都能听懂，就是有个好像是西班牙的老师带点口音听起来有点不适应😢）<a href=\"https://www.bilibili.com/video/BV1uc411N7eK/?spm_id_from=333.1387.favlist.content.click&amp;vd_source=54c2981c1a7a8e0433b7d23096150b7a\">[自制双语字幕] 计算机教育缺失的一课(2020) - 第1讲 - 课程概览与 shell</a></p>\n<hr>\n<p>  不论是在电影里还是在我们初识计算机的过程中，都会看到一个黑乎乎的窗口，只要输入几行代码就可以完成酷炫的操作，但是你或许对这有一点疑惑，这到底是<code>terminal</code>、<code>bash</code>、<code>zsh</code>还是<code>powershell</code>，他们到底是如何区分的呢？</p>\n<p>1.<code>Terminal</code>：用户终端，用来启动<code>shell</code>，这也可以说算是一个“工具”，活跃在为用户服务的<strong>前端</strong><br>\n2.<code>Shell</code>：是一个<strong>命令行解释器</strong>，负责接收用户输入的命令并将其<strong>解释</strong>为计算机可以执行的操作，与<code>Terminal</code>相比，是活跃于用户服务<strong>后端的程序</strong>，以下都是<code>Shell</code>在不同操作系统中的实现：</p>\n<ul>\n<li><code>Bash</code>：是一种<strong>常用的Shell</strong>，在<code>Linux</code>和<code>macOS</code>中默认安装。</li>\n<li><code>Zsh</code>：是一种<strong>功能强大的Shell</strong>，在<code>macOS</code>中默认安装，也可以在<code>Linux</code>中安装。</li>\n<li><code>PowerShell</code>：是一种<strong>Windows</strong>系统下的<strong>命令行工具</strong>，用于<strong>管理Windows系统</strong>和<strong>执行PowerShell脚本</strong>。</li>\n</ul>\n<h2 id=\"Shell\">Shell</h2>\n<p>  当熟悉的<strong>可视化界面</strong>无法实现你想要的功能时，<code>Shell</code>将成为你与计算机交互的强大工具。相比<strong>图形界面有限的按钮和滑块</strong>，命令行提供了更灵活、更强大的控制方式，允许你通过<strong>文本命令和脚本实现自动化操作</strong>。本文基于<code>VMware</code>虚拟机中的<code>Ubuntu 22.04</code>发行版演示基础<code>Shell</code>操作：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">date</span><br>Sat Jul 26 03:27:54 PM CST 2025<br></code></pre></td></tr></table></figure>\n<p>第一行通常是用户名、机器名称和当前所在路径</p>\n<div class=\"note note-danger\">\n            <ul><li><code>Windows</code>中路径通常使用<strong>反斜杠</strong><code>\\</code>分隔，每个驱动器都有一个单独的路径结构。</li><li><code>Linux</code> / <code>macOS</code> 中这些路径使用<strong>正斜杠</strong><code>/</code>分隔，他们挂载在同一个命名空间下。</li></ul>\n          </div>\n<p>开头的斜杠表示从文件系统的顶部开始。</p>\n<div class=\"note note-warning\">\n            <ul><li>相对路径：相对于当前位置的路径</li><li>绝对路径：完整路径，从顶部开始</li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Hello World&quot;</span><br>Hello World<br></code></pre></td></tr></table></figure>\n<p><code>echo</code>可以将后面的参数<strong>打印</strong>在屏幕上</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">which</span> <span class=\"hljs-built_in\">echo</span><br>/usr/bin/echo<br></code></pre></td></tr></table></figure>\n<p><code>which</code>可以用于<strong>寻找后面参数文件的绝对位置</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">pwd</span><br>/home/richard<br></code></pre></td></tr></table></figure>\n<p><code>pwd</code>（<code>Print Working Directory</code>）<strong>打印当前所在路径</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cd</span> /home<br>richard@richard-VMware-Virtual-Platform:/home$ <br></code></pre></td></tr></table></figure>\n<p><code>cd</code>（<code>Change Directory</code>）表示更改当前目录</p>\n<p>这是更方便<strong>切换目录</strong>的方式：</p>\n<div class=\"note note-warning\">\n            <ul><li><code>.</code>表示<strong>当前</strong>目录</li><li><code>..</code>表示<strong>父</strong>目录</li></ul>\n          </div>\n<p><strong>注意</strong>：使用相对路径能提高命令在不同电脑上的<strong>兼容性</strong>！</p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/$ <span class=\"hljs-built_in\">ls</span><br>bin                home               mnt   sbin.usr-is-merged  usr<br>bin.usr-is-merged  lib                opt   snap                var<br>boot               lib64              proc  srv<br>cdrom              lib.usr-is-merged  root  swap.img<br>dev                lost+found         run   sys<br>etc                media              sbin  tmp<br></code></pre></td></tr></table></figure>\n<p><code>ls</code>会列出当前目录中的文件，这能够快速浏览文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/home$ <span class=\"hljs-built_in\">cd</span> ~<br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></table></figure>\n<div class=\"note note-warning\">\n            <ul><li><code>cd ~</code>能够快速<strong>回到用户主目录</strong></li><li><code>cd -</code>切换到<strong>上一个工作目录</strong></li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> --<span class=\"hljs-built_in\">help</span><br>Usage: <span class=\"hljs-built_in\">ls</span> [OPTION]... [FILE]...<br>List information about the FILEs (the current directory by default).<br>Sort entries alphabetically <span class=\"hljs-keyword\">if</span> none of -cftuvSUX nor --<span class=\"hljs-built_in\">sort</span> is specified.<br></code></pre></td></tr></table></figure>\n<p><code>--help</code>参数显示<strong>命令帮助信息</strong></p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> -l<br>total 40<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Desktop<br>drwxr-xr-x 2 richard richard 4096 Mar  9 10:21 Documents<br><br>lrwxrwxrwx   1 root root          7 Apr 22  2024 bin -&gt; usr/bin<br>drwxr-xr-x   2 root root       4096 Feb 26  2024 bin.usr-is-merged<br><span class=\"hljs-comment\"># 仅列举部分进行展示说明</span><br></code></pre></td></tr></table></figure>\n<p><strong>文件类型</strong>（第<code>1</code>个字符）</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>类型</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>d</code></td>\n<td>目录</td>\n<td>文件夹</td>\n<td><code>drwxr-xr-x</code></td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>普通文件</td>\n<td>文本/二进制文件</td>\n<td><code>-rw-r--r--</code></td>\n</tr>\n<tr>\n<td><code>l</code></td>\n<td>符号链接</td>\n<td>软链接文件</td>\n<td><code>lrwxrwxrwx</code></td>\n</tr>\n<tr>\n<td><code>c</code></td>\n<td>字符设备</td>\n<td>终端等串行设备</td>\n<td><code>crw--w----</code></td>\n</tr>\n<tr>\n<td><code>b</code></td>\n<td>块设备</td>\n<td>磁盘等存储设备</td>\n<td><code>brw-rw----</code></td>\n</tr>\n<tr>\n<td><code>s</code></td>\n<td>套接字</td>\n<td>进程通信文件</td>\n<td><code>srwxrwxrwx</code></td>\n</tr>\n<tr>\n<td><code>p</code></td>\n<td>管道</td>\n<td><code>FIFO</code> 管道文件</td>\n<td><code>prw-------</code></td>\n</tr>\n</tbody>\n</table>\n<p>用户权限分为 <strong>3组</strong>（每组<code>3</code>字符），分别对应：</p>\n<table>\n<thead>\n<tr>\n<th>组别</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>所有者权限</td>\n<td><code>rwx</code></td>\n</tr>\n<tr>\n<td>所属组权限</td>\n<td><code>r-x</code></td>\n</tr>\n<tr>\n<td>其他用户</td>\n<td><code>r-x</code></td>\n</tr>\n</tbody>\n</table>\n<p>权限字符<strong>含义</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>权限</th>\n<th>对文件的影响</th>\n<th>对目录的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>r</code></td>\n<td>读</td>\n<td>查看文件内容</td>\n<td>列出目录内容（<code>ls</code>）</td>\n</tr>\n<tr>\n<td><code>w</code></td>\n<td>写</td>\n<td>修改/删除文件</td>\n<td>创建/删除目录内文件</td>\n</tr>\n<tr>\n<td><code>x</code></td>\n<td>执行</td>\n<td>运行程序/脚本</td>\n<td>进入目录（<code>cd</code>）</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>无</td>\n<td>无权限</td>\n<td>无权限</td>\n</tr>\n</tbody>\n</table>\n<div class=\"note note-danger\">\n            <p>⚠️<strong>注意</strong>：</p><ol><li>即使文件本身有 <code>w</code> 权限，如果所在目录没有<code> w</code>，你只能<strong>清空或删除文件内容</strong>，却仍然<strong>无法删除或重命名</strong>它</li><li>如果我想要访问一个目录，<strong>必须拥有其所有父目录的权限</strong>：<code>/usr/bin/echo</code>我必须拥有<code>/usr</code> <code>/bin</code>目录的权限，否则我将不被允许访问该文件，因为我将无法进入其中的目录</li></ol>\n          </div>\n<p><code>mv</code>能将文件<strong>修改位置并重命名</strong><br>\n<code>cp</code>复制文件 需要两个参数 一个要<strong>复制的文件路径</strong> <strong>一个目标文件路径</strong><br>\n<code>rm</code>用于<strong>删除文件</strong><br>\n<code>rmdir</code>能<strong>删除一个目录</strong> 但它只能删除<strong>空目录</strong> 防止不小心删除一大堆文件<br>\n<code>mkdir</code><strong>创建目录</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> My Photos<br></code></pre></td></tr></table></figure>\n<p><code>mkdir</code>创建目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> <span class=\"hljs-string\">&quot;My Photos&quot;</span><br></code></pre></td></tr></table></figure>\n<p>这里如果不加上上引号则会创建&quot;My&quot;和&quot;Photos&quot;两个目录，因为<code>Bash</code>（或其他 <code>Shell</code>）会<strong>将空格视为命令参数的分隔符</strong>，相当于<strong>命令收到了两个独立的参数</strong>，因此它会创建两个独立的目录！</p>\n<div class=\"note note-info\">\n            <p>或者使用<strong>反斜杠</strong>来转义空格，反斜杠会告诉 Shell：下一个字符是普通字符，不要把它当做特殊符号处理！</p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkdir</span> My\\ Photos<br></code></pre></td></tr></table></figure>\n          </div>\n<p><code>man+指令</code> 查找手册</p>\n<p><code>ctrl</code>+<code>l</code>清空窗口</p>\n<h3 id=\"输入流和输出流\">输入流和输出流</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> hello &gt; hello.txt<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> &gt; hello.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello.txt<br>Desktop<br>Documents<br>Downloads<br>fizzbuzz.py<br>hello2.txt<br>hello.txt<br>Music<br>Pictures<br>Public<br>snap<br>Templates<br>Videos<br>web<br></code></pre></td></tr></table></figure>\n<p>这样就可以将输出到屏幕的信息<strong>存储</strong>起来！</p>\n<div class=\"note note-warning\">\n            <ul><li><code>&gt;</code>覆盖输出到文件</li><li><code>&lt;</code>从文件读取输入</li></ul>\n          </div>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello.txt<br>hello<br></code></pre></td></tr></table></figure>\n<p>通过<code>cat</code>指令输出文件内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> &lt;hello.txt&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello2.txt<br>hello<br></code></pre></td></tr></table></figure>\n<p><code>&lt;</code>将<code>hello.txt</code>作为输入内容并通过<code>&gt;</code>将<code>cat</code>打印的任何内容输出到<code>hello2.txt</code>文件中</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> &lt;hello.txt&gt;&gt;hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">cat</span> hello2.txt<br>hello<br>hello<br></code></pre></td></tr></table></figure>\n<p><code>&gt;&gt;</code>表示追加而不是覆盖(<code>append instead of overwrite</code>)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> -l|<span class=\"hljs-built_in\">tail</span> -n1<br>drwxrwxr-x 3 richard richard 4096 Mar  9 12:26 web<br></code></pre></td></tr></table></figure>\n<p>管道运算符<code>|</code>作用是将<strong>左侧命令的输出</strong>作为<strong>右侧命令的输入</strong>：可以连接多个命令形成<strong>处理流水线</strong></p>\n<p><code>tail</code>将输出最后一行的内容</p>\n<hr>\n<h3 id=\"用户权限管理\">用户权限管理</h3>\n<p><code>root</code>相当于<code>Windows</code>的管理员权限，是一位<strong>超级用户</strong>，可以做任何想做的事情，但是倘若一直使用<code>root</code>用户操作计算机，如果运行了错误的程序，那会彻底毁坏你的电脑！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:/sys/class/backlight$ <span class=\"hljs-built_in\">sudo</span> su<br>[<span class=\"hljs-built_in\">sudo</span>] password <span class=\"hljs-keyword\">for</span> richard: <br>root@richard-VMware-Virtual-Platform:/sys/class/backlight# <br></code></pre></td></tr></table></figure>\n<p>通过<code>sudo su</code>来进入<code>root</code>身份，同时提示符由<code>$</code>变为<code>#</code></p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">root@richard-VMware-Virtual-Platform:/sys/class/backlight# <span class=\"hljs-built_in\">exit</span><br><span class=\"hljs-built_in\">exit</span><br>richard@richard-VMware-Virtual-Platform:/sys/class/backlight$<br></code></pre></td></tr></table></figure>\n<p><code>exit</code>来退出用户权限</p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ xdg-open hello.txt<br></code></pre></td></tr></table></figure>\n<p>这样就可以直接在<code>terminal</code>打开文件！</p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ foo=bar<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$foo</span><br>bar<br></code></pre></td></tr></table></figure>\n<p>在<code>shell</code>中，<code>$</code>符号是一个特殊字符，主要用于变量展开。当你在变量名前面加上$时，<code>shell</code>会将其替换为该变量的值！</p>\n<ul>\n<li><code> foo</code> 会被<code>Shell</code>视为普通字符串</li>\n<li><code>$foo</code> 告诉<code>Shell</code>这是一个需要展开的变量</li>\n</ul>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Hello&quot;</span><br>Hello<br>richard@richard-VMware-Virtual-Platform:~$ foo=World<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Hello foo&quot;</span><br>Hello foo<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Hello <span class=\"hljs-variable\">$foo</span>&quot;</span><br>Hello World<br></code></pre></td></tr></table></figure>\n<p>在<code>shell</code>中我们一定要非常注意<strong>空格</strong><code>space</code>的使用，它是用作不同参数间的分隔符，倘若多打一个可能就会出现报错！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">false</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> $?<br>1<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">true</span><br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> $?<br>0<br></code></pre></td></tr></table></figure>\n<p><code>$? </code>是一个特殊变量，存储上一个命令的退出状态码</p>\n<div class=\"note note-warning\">\n            <ul><li><code>false</code> 是一个 Shell 内置命令，返回非零退出状态（失败）设置退出状态码为 1（表示失败）</li><li><code>true</code> 也是一个 Shell 内置命令，返回零退出状态（成功）退出状态码被设为 0（表示成功）</li></ul>\n          </div>\n<p>  这里看上去有点反常理，我们学的其他编程语言中<code>0</code>是<code>false</code>，非零是<code>true</code>，为什么这里反过来了？<br>\n  当我们想到<code>c</code>、<code>c++</code>中<code>main</code><strong>函数结束的返回值</strong>或许就不奇怪了！<code>main() </code>函数默认返回<code>0</code> 表示成功，非零表示错误（如 <code>return 1</code>;）。</p>\n<p>再考虑到程序运行只有两种可能：</p>\n<ol>\n<li>完全成功（<strong>唯一状态 0</strong>）</li>\n<li>失败（可能有多种原因，<strong>用不同非零值区分</strong>）：</li>\n</ol>\n<div class=\"note note-warning\">\n            <ul><li>0 = 没有错误（成功）</li><li>1 = 通用错误</li><li>2 = 参数错误</li><li>3 = 文件不存在</li></ul>\n          </div>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">false</span> || <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Oops fail&quot;</span><br>Oops fail<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-literal\">true</span> || <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Will be not be printed&quot;</span><br>richard@richard-VMware-Virtual-Platform:~$<br></code></pre></td></tr></table></figure>\n<p><code>shell</code>中<code>||</code>同样遵循<strong>短路原则</strong>，<code>&amp;&amp;</code>同理！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;We are now at <span class=\"hljs-subst\">$(pwd)</span>&quot;</span><br>We are now at /home/richard<br></code></pre></td></tr></table></figure>\n<p><code>shell</code>中使用<code>$(command)</code>进行<strong>命令替换</strong></p>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span><br>Desktop    Downloads   hello.txt  Pictures  snap       Videos<br>Documents  hello2.txt  Music      Public    Templates  web<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> *.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></table></figure>\n<p><code>*</code>是一个<strong>通配符</strong>（<code>globbing</code>）：表示<strong>匹配任意数量的任意字符</strong>（<strong>包括零个字符</strong>）。<code>Shell</code>会在执行<code>ls</code> 前先展开 <code>*.txt</code>，将其替换为所有匹配的文件名，相当于寻找所有后缀为<code>.txt</code>的文件！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> hello?.txt<br>hello2.txt<br>richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">ls</span> hello*.txt<br>hello2.txt  hello.txt<br></code></pre></td></tr></table></figure>\n<p>这里可以看到<code>?</code>也是<strong>通配符</strong>，表示匹配任意一个字符（区别是必须存在，<strong>不能匹配空字符</strong>）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-meta\">#!/usr/bin/env python3 #自动查找python3</span><br></code></pre></td></tr></table></figure>\n<p>通过<code>Shell</code>调用<code>Python</code>脚本可以充分发挥两者的优势：<code>Shell</code>的<strong>流程控制能力</strong>结合<code>Python</code>的<strong>丰富库函数</strong>，但我们要在路径中找到并配置好<code>python</code>解释器。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">import sys<br></code></pre></td></tr></table></figure>\n<p>由于<code>shell</code>默认不会执行<code>python</code>指令，我们需要添加库函数，来让<code>python</code>接受<code>shell</code>传递的参数</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">history</span><br></code></pre></td></tr></table></figure>\n<p>我们可以使用⬆️来一个个<strong>浏览历史记录命令</strong>，我们也可以使用<code>history</code>直接打印所有历史命令！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">history</span> | grep git<br></code></pre></td></tr></table></figure>\n<p>我们通过<code>history +N | grep +指令</code>来查找所有与指令字符串相匹配的<code>N</code>条历史记录命令！</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">tree<br></code></pre></td></tr></table></figure>\n<p>能列出<strong>目录结构性</strong>的位置！</p>\n<hr>\n<p><code>wc</code>（word count）是一个用于<strong>统计文本文件中单词、行、字符等</strong>的<strong>命令行工具</strong>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">wc</span> [选项参数]... [文件]...<br></code></pre></td></tr></table></figure>\n<p>可选参数：</p>\n<ul>\n<li><code>c</code> 或 <code>--bytes</code>: 显示<strong>字节数</strong></li>\n<li><code>m</code>或 <code>--chars</code>: 显示<strong>字符数</strong> 对于多字节字符（如中文），这与 -c 不同</li>\n<li><code>w</code> 或 <code>--words</code>: 显示<strong>单词数</strong>（以空格、制表符、换行符分隔的字符串）</li>\n<li><code>l</code> 或 <code>--lines</code>: 显示<strong>行数</strong></li>\n<li><strong>不指定</strong>任何选项: 默认会<strong>同时显示行数、单词数、字节数，以及文件名</strong></li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ <span class=\"hljs-built_in\">wc</span> hello.txt<br> 13  13 109 hello.txt<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">richard<span class=\"hljs-variable\">@richard</span>-<span class=\"hljs-title class_\">VMware</span>-<span class=\"hljs-title class_\">Virtual</span>-<span class=\"hljs-title class_\">Platform</span><span class=\"hljs-symbol\">:~</span><span class=\"hljs-variable\">$ </span>wc --word hello.txt<br><span class=\"hljs-number\">13</span> hello.txt<br></code></pre></td></tr></table></figure>\n<h3 id=\"关机与重启\">关机与重启</h3>\n<p>1.<code>shutdown</code></p>\n<ul>\n<li><code>-r</code> 或 <code>--reboot</code>: 重新启动系统</li>\n<li><code>-h</code> 或 <code>--halt</code>: 关闭系统</li>\n<li><code>-c</code> 或 <code>--cancel</code>: 取消之前的计划关机或重启</li>\n<li><code>-t</code> 或 <code>--time &lt;时间&gt;</code>: 指定关机或重启的时间（格式：<code>HH:MM</code>）</li>\n<li><code>-k</code> 或 <code>--kill</code>: 不关机，只发送<code>SIGTERM</code>信号给所有进程</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@richard-VMware-Virtual-Platform:~$ shutdown -r<br>Reboot scheduled <span class=\"hljs-keyword\">for</span> Tue 2025-09-02 12:05:06 CST, use <span class=\"hljs-string\">&#x27;shutdown -c&#x27;</span> to cancel.<br></code></pre></td></tr></table></figure>\n<p>2.<code>reboot</code></p>\n<ul>\n<li><code>-f</code> 或 <code>--force</code>: 强制重启，不发送<code>SIGTERM</code>信号</li>\n<li><code>-n</code> 或 <code>--no-fsync</code>: 不执行<code>fsync</code>系统调用，加快重启速度</li>\n<li><code>-w</code> 或 <code>--wait</code>: 等待所有进程结束后再重启</li>\n<li><code>-i</code> 或 <code>--init</code>: 关机之前，关闭所有网络接口</li>\n</ul>\n<ol start=\"3\">\n<li><code>init</code></li>\n<li><code>poweroff</code></li>\n</ol>\n"},{"title":"Simple Git Project Management Guide","date":"2025-07-13T03:16:13.000Z","index_img":"https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Simple-Git-Project-Management-Guide.png","category_bar":true,"description":"A simple guide to manage your Git project.","_content":"\n\n\n`Git` 是一个**分布式**版本控制系统(`Vision Control Systems`)，它允许多个人在同一项目上工作。通过` Git`，我们可以记录项目的每一次更改，并且可以将代码推送到 `GitHub`，方便以后查看和分享（多人的协作开发）。以下是`Git`进行代码版本管理的基本操作：\n\n## 基本操作\n### 1、在本地初始化git仓库\n打开命令行工具（`Windows` 用户可以使用 `PowerShell`，`Mac` 和 `Linux` 用户可以使用终端`terminal`），确保你进入了项目文件夹（命令：`cd path`），然后输入以下命令来初始化 `Git` 仓库：\n```bash\ngit init\n```\n\n **解释：**`git init`会在当前文件夹中创建一个新的**Git仓库**（`.git`目录），这个目录里存储着管理当前目录内容所需要的仓库数据。现在，你的项目文件夹已经开始被 Git 追踪，之后的每一次文件修改都可以通过 Git 来记录。\n \n - 使用`git status`命令可以查看当前**仓库的状态**，包括哪些文件被修改了，哪些文件被添加到暂存区了，哪些文件还没有被跟踪等。\n\n```bash\n$ git status\n# on branch master\n#\n# Initial commit\n#\nnothing to commit (creat/copy files and use \"git add\" to track)\n```\n\n### 2、添加文件到暂存区\n暂存区是一个**准备提交的区域**，只有在将文件添加到暂存区后，才能将它们提交到本地仓库中。\n```bash\ngit add\n```\n\n**解释**:`git add.`会将当前文件夹下的所有文件添加到暂存区。这意味着 Git 现在知道这些文件已经被修改，并准备将它们保存到版本历史中。\n\n### 3、提交文件到本地仓库\n暂存区中的文件提交到本地仓库。输入以下命令：\n```bash\ngit commit -m \"feat: \"\n```\n**解释：**`git commit -m` 命令用于提交更改到本地仓库，并且 `-m` 参数后面跟着的是你为此次提交**添加的描述信息**，也就是提交信息（`commit message`）。提交信息是对此次提交所做更改的简短描述，它帮助团队成员或其他查看项目历史的人理解每次提交的目的或内容。\n\n- `git log`可以查看以往仓库中**提交的日志**，包括什么人在什么时候进行了提交或合并，以及操作前后有什么差别。\n\n```bash\nrichard@RicharddeMacBook-Air leetcode % git log\ncommit 03748e1b5410364249cb10d78ae72f443682dc24 (HEAD -> main)\nAuthor: Richard110206 <lqx3222482537@qq.com>\nDate:   Sun Aug 17 23:28:22 2025 +0800\n\n    First Commit\n```\n\n- `git diff`可以查看**当前工作目录和暂存区之间的差异**。“+”表示添加的行，\"-\"表示删除的行，\"~\"表示修改的行。\n\n这些是特定的标签或标识符来说明提交的类型：\n - ```feat```: 表示**新功能的增加**（`feature`）\n - ```fix```: 表示**修复了一个`bug`**\n - ```docs```: 表示**文档更新**\n - ```refactor```: 表示**代码重构**（既不是修复bug也不是添加新功能）\n - ```style```: **改进代码格式但不影响逻辑**\n - ```test```: **添加或修正测试用例**\n\n### 4. 创建远程仓库\n前往 `GitHub`，创建一个**新的远程仓库**，并命名，注意：不要勾选“初始化仓库”，因为我们已经在本地初始化了仓库。\n\n### 5. 关联本地仓库\n在命令行中，输入以下命令来将本地仓库和 GitHub 的远程仓库**关联**起来：\n- 若是通过`SSH`方式连接远程仓库：\n```bash\n$ git remote add origin git@github.com:用户名/仓库名.git\n```\n- 若是通过`HTTPS`方式连接远程仓库：\n```bash\ngit remote set-url origin https://令牌@github.com/用户名/远程仓库名`\n```\n\n### 6、推送代码到 GitHub\n最后一步，我们将本地仓库中的更改**推送**到 `GitHub` 上的远程仓库：\n```bash\ngit push -u origin main\n```\n**解释：**`git push` 命令会将本地仓库中的代码上传到 `GitHub` 的远程仓库。`-u` 参数会将本地的 `main` 分支与远程仓库的 `main` 分支关联起来，确保以后每次推送都不需要重复指定分支。\n\n## 从远程仓库获取\n`git clone`可以**获取远程仓库的代码到本地**\n- 若是通过`SSH`方式连接远程仓库：\n```bash\ngit clone git@github.com:用户名/仓库名.git\n```\n- 若是通过`HTTPS`方式连接远程仓库：\n```bash\ngit clone https://github.com/用户名/仓库名.git\n```\n当前本地仓库的`main`分支和`Github`仓库的`main`分支在内容上是完全相同的。\n\n`git pull`可以从远程仓库分支**获取最新的代码到本地**，这样只要在本地进行提交再`push`给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，而如果两个人同时修改了同意部分的源代码，`push`时就很容易**发生冲突**，因此建议**更频繁的进行**`push`和`pull`操作！\n\n|操作|`git clone`|`git pull`|\n|----|----|----|\n|**用途**|首次下载远程仓库到本地|更新本地已有代码|\n|**执行前提**|本地没有仓库时使用|\t必须在已有`Git`仓库的目录内执行|\n|**操作内容**|下载完整仓库、自动创建远程跟踪分支|获取远程最新变更`git fetch`<br> 自动合并到当前分支`git merge`|\n\n![关键操作图解](https://xflops.sjtu.edu.cn/hpc-start-guide/primer/attachments/20241106195404.png)\n\n***\n\n### 快照\n`VCS` 通过一系列快照跟踪文件夹及其内容的更改，其中每个快照都封装了顶级目录中文件/文件夹的完整状态，其还维护元数据，例如每个快照的创建者、与每个快照相关的消息等等。\n\n`Git` 将某个顶级目录中文件和文件夹集合的历史记录建模为一系列快照。文件/文件夹的树模型：\n```bash\n<root> (tree)\n|\n+- foo (tree)\n|  |\n|  + bar.txt (blob, contents = \"hello world\")\n|\n+- baz.txt (blob, contents = \"git is wonderful\")\n```\n### 关联快照\n{% note warning %}不知你是否有过疑惑。如果我和我的伙伴并行共同完成一个项目的两个特性应该如何处理？是将他的那部分完成后让我在复制到我的版本上吗？显然那样做太过麻烦！{%endnote%}\n\n在`Git`中，历史记录是快照的**有向无环图** (`DAG`)。这意味着`Git `中的每个快照都指向一组“父级”，即它之前的快照。它是一组父级，而不是单个父级（线性历史记录中的情况），因为快照可能源自多个父级，例如，由于合并（合并）两个并行的开发分支。`Git` 将这些快照称为“提交”。可视化提交历史记录可能如下所示：\n```bash\no <-- o <-- o <-- o\n            ^\n             \\\n              --- o <-- o\n ```\n` o`s代表单个提交（快照），理解为提交的文件（夹）\n ```bash\n o <-- o <-- o <-- o <---- o\n            ^            /\n             \\          v\n              --- o <-- o\n  ```\n这里意味着并行开发项目的两个功能，并进行合并，创建了一个包含两个功能的快照，`Git`会自行合并处理两个快照，若出现冲突无法解决时，则需要人工进行调整！\n***\n### 分支\n- `git branch`可以将分支名列表显示，同时可以确认当前所在的分支\n```bash\n$ git branch\n* main\n```\n分支`main`左上角带有星号`*`表示这是我们当前所在的分支，也就是说我们正在`main`分支下进行开发，同时没有其他分支名，表示本地仓库只存在main一个分支。（以往`Git`默认分支是`master`，但现在改为了`main`）\n\n- `git checkout -b`创建并切换到新的分支\n\n```bash\n$ git checkout -b feature-A\n```\n可以创建并切换到新的分支`feature-A`\n\n```bash\n$ git branch feature-A\n$ git checkout feature-A\n```\n实际上，连续执行以上两条命令也能收到相同的的效果。\n\n```bash\n$ git branch\n* feature-A\n  main\n```\n这时再来查看我们的分支，就会发现我们正处在`feature-A`分支下，但我们在正常开发、执行`git add`命令并进行`commit`时，代码就会提交至`feature-A`分支，我们称为“**培育分支**”，这样我们就能在不相互影响的情况下同时进行多个功能的开发！\n\n- `git merge`可以**将分支合并**，如上文`feature-A`是典型的**特性分支**，能集中实现单一特性，且除此之外不进行任何作业，在日常开发中往往会创建数个特性分支，同时在保留一个可以随时发布软件的稳定分支。通常使用`main`作为**主干分支**（也就是特性分支的原点和合并的终点）。\n首先切换到`main`分支：\n```bash\n$ git checkout main\n```\n然后合并分支，为了在历史记录中明确记录下本次分支合并，我们需要创建合并并提交。\n```bash\n$ git merge --no-ff feature-A\n```\n\n- `git log --graph`**以图表形式查看分支合并历史**\n- \n***\n\n### 回溯历史版本\n当我们在开发时遇到：\n- 尝试新功能但效果不好，想回到之前状态\n- 发布后发现有严重问题难以修复，需要回滚到上一个版本\n- 找回被删除的文件或代码\n- 合并分支时冲突出错\n\n这时我们就可以考虑**回溯版本**！\n\n先获取想要**回滚到的那个版本的 commit hash**：\n```bash\ngit log --oneline\n```\n`--oneline`参数可以将提交历史以简洁的一行进行显示，便于查找哈希值\n\n\n```bash\nLegion@LAPTOP-THUPDMQ0 MINGW64 /e/Hexo-backup (main)\n$ git log --oneline\n5a9dcd9 (HEAD -> main, origin/main) test\n53397ae feat\n54d31f5 feat\n808d171 feat\n79e81c0 feat\ne485ebb feat\n8836ac9 修改文件名\n400f3e4 增加life-musings内容\n08de0b5 添加.gitignore忽略DS_Store文件\n13f5287 Initial commit of hexo source files\n```\n\n\n`git reset`**回溯历史版本**，我们只要**提供目标时间点的哈希值**，就可以完全恢复至当时该时间点的状态。\n\n```bash\ngit reset --hard <hash>\n```\n回溯完，强制**推送至远程仓库**：\n```bash\ngit push -f origin main\n```\n  \n{% note warning %}如果我上线测试时突然发现了一个`bug`，而我不知道他是他是何时产生的应该怎么办呢？{%endnote%}\n\n`Git`也会提供相应的二分历史记录查找！\n\n## 总结\n至此，你学会了如何通过 `Git` 管理项目的版本历史，最终将项目代码推送到 `GitHub`。整个过程包括了从初始化仓库、添加文件、提交文件到推送到远程仓库的完整步骤。通过这些操作，你便已经具备了基本的版本控制能力。\n\n封面来源：[Git Explained in 100 Seconds](https://www.youtube.com/watch?v=hwP7WQkmECE)\n\n","source":"_posts/Tutorial/Simple-Git-Project-Management-Guide.md","raw":"---\ntitle: Simple Git Project Management Guide\ndate: 2025-07-13 11:16:13\ntags: [Git]\nindex_img: https://raw.githubusercontent.com/Richard110206/blog-image/main/cover/Simple-Git-Project-Management-Guide.png\ncategory: Tutorial\ncategory_bar: true\ndescription: A simple guide to manage your Git project.\n---\n\n\n\n`Git` 是一个**分布式**版本控制系统(`Vision Control Systems`)，它允许多个人在同一项目上工作。通过` Git`，我们可以记录项目的每一次更改，并且可以将代码推送到 `GitHub`，方便以后查看和分享（多人的协作开发）。以下是`Git`进行代码版本管理的基本操作：\n\n## 基本操作\n### 1、在本地初始化git仓库\n打开命令行工具（`Windows` 用户可以使用 `PowerShell`，`Mac` 和 `Linux` 用户可以使用终端`terminal`），确保你进入了项目文件夹（命令：`cd path`），然后输入以下命令来初始化 `Git` 仓库：\n```bash\ngit init\n```\n\n **解释：**`git init`会在当前文件夹中创建一个新的**Git仓库**（`.git`目录），这个目录里存储着管理当前目录内容所需要的仓库数据。现在，你的项目文件夹已经开始被 Git 追踪，之后的每一次文件修改都可以通过 Git 来记录。\n \n - 使用`git status`命令可以查看当前**仓库的状态**，包括哪些文件被修改了，哪些文件被添加到暂存区了，哪些文件还没有被跟踪等。\n\n```bash\n$ git status\n# on branch master\n#\n# Initial commit\n#\nnothing to commit (creat/copy files and use \"git add\" to track)\n```\n\n### 2、添加文件到暂存区\n暂存区是一个**准备提交的区域**，只有在将文件添加到暂存区后，才能将它们提交到本地仓库中。\n```bash\ngit add\n```\n\n**解释**:`git add.`会将当前文件夹下的所有文件添加到暂存区。这意味着 Git 现在知道这些文件已经被修改，并准备将它们保存到版本历史中。\n\n### 3、提交文件到本地仓库\n暂存区中的文件提交到本地仓库。输入以下命令：\n```bash\ngit commit -m \"feat: \"\n```\n**解释：**`git commit -m` 命令用于提交更改到本地仓库，并且 `-m` 参数后面跟着的是你为此次提交**添加的描述信息**，也就是提交信息（`commit message`）。提交信息是对此次提交所做更改的简短描述，它帮助团队成员或其他查看项目历史的人理解每次提交的目的或内容。\n\n- `git log`可以查看以往仓库中**提交的日志**，包括什么人在什么时候进行了提交或合并，以及操作前后有什么差别。\n\n```bash\nrichard@RicharddeMacBook-Air leetcode % git log\ncommit 03748e1b5410364249cb10d78ae72f443682dc24 (HEAD -> main)\nAuthor: Richard110206 <lqx3222482537@qq.com>\nDate:   Sun Aug 17 23:28:22 2025 +0800\n\n    First Commit\n```\n\n- `git diff`可以查看**当前工作目录和暂存区之间的差异**。“+”表示添加的行，\"-\"表示删除的行，\"~\"表示修改的行。\n\n这些是特定的标签或标识符来说明提交的类型：\n - ```feat```: 表示**新功能的增加**（`feature`）\n - ```fix```: 表示**修复了一个`bug`**\n - ```docs```: 表示**文档更新**\n - ```refactor```: 表示**代码重构**（既不是修复bug也不是添加新功能）\n - ```style```: **改进代码格式但不影响逻辑**\n - ```test```: **添加或修正测试用例**\n\n### 4. 创建远程仓库\n前往 `GitHub`，创建一个**新的远程仓库**，并命名，注意：不要勾选“初始化仓库”，因为我们已经在本地初始化了仓库。\n\n### 5. 关联本地仓库\n在命令行中，输入以下命令来将本地仓库和 GitHub 的远程仓库**关联**起来：\n- 若是通过`SSH`方式连接远程仓库：\n```bash\n$ git remote add origin git@github.com:用户名/仓库名.git\n```\n- 若是通过`HTTPS`方式连接远程仓库：\n```bash\ngit remote set-url origin https://令牌@github.com/用户名/远程仓库名`\n```\n\n### 6、推送代码到 GitHub\n最后一步，我们将本地仓库中的更改**推送**到 `GitHub` 上的远程仓库：\n```bash\ngit push -u origin main\n```\n**解释：**`git push` 命令会将本地仓库中的代码上传到 `GitHub` 的远程仓库。`-u` 参数会将本地的 `main` 分支与远程仓库的 `main` 分支关联起来，确保以后每次推送都不需要重复指定分支。\n\n## 从远程仓库获取\n`git clone`可以**获取远程仓库的代码到本地**\n- 若是通过`SSH`方式连接远程仓库：\n```bash\ngit clone git@github.com:用户名/仓库名.git\n```\n- 若是通过`HTTPS`方式连接远程仓库：\n```bash\ngit clone https://github.com/用户名/仓库名.git\n```\n当前本地仓库的`main`分支和`Github`仓库的`main`分支在内容上是完全相同的。\n\n`git pull`可以从远程仓库分支**获取最新的代码到本地**，这样只要在本地进行提交再`push`给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，而如果两个人同时修改了同意部分的源代码，`push`时就很容易**发生冲突**，因此建议**更频繁的进行**`push`和`pull`操作！\n\n|操作|`git clone`|`git pull`|\n|----|----|----|\n|**用途**|首次下载远程仓库到本地|更新本地已有代码|\n|**执行前提**|本地没有仓库时使用|\t必须在已有`Git`仓库的目录内执行|\n|**操作内容**|下载完整仓库、自动创建远程跟踪分支|获取远程最新变更`git fetch`<br> 自动合并到当前分支`git merge`|\n\n![关键操作图解](https://xflops.sjtu.edu.cn/hpc-start-guide/primer/attachments/20241106195404.png)\n\n***\n\n### 快照\n`VCS` 通过一系列快照跟踪文件夹及其内容的更改，其中每个快照都封装了顶级目录中文件/文件夹的完整状态，其还维护元数据，例如每个快照的创建者、与每个快照相关的消息等等。\n\n`Git` 将某个顶级目录中文件和文件夹集合的历史记录建模为一系列快照。文件/文件夹的树模型：\n```bash\n<root> (tree)\n|\n+- foo (tree)\n|  |\n|  + bar.txt (blob, contents = \"hello world\")\n|\n+- baz.txt (blob, contents = \"git is wonderful\")\n```\n### 关联快照\n{% note warning %}不知你是否有过疑惑。如果我和我的伙伴并行共同完成一个项目的两个特性应该如何处理？是将他的那部分完成后让我在复制到我的版本上吗？显然那样做太过麻烦！{%endnote%}\n\n在`Git`中，历史记录是快照的**有向无环图** (`DAG`)。这意味着`Git `中的每个快照都指向一组“父级”，即它之前的快照。它是一组父级，而不是单个父级（线性历史记录中的情况），因为快照可能源自多个父级，例如，由于合并（合并）两个并行的开发分支。`Git` 将这些快照称为“提交”。可视化提交历史记录可能如下所示：\n```bash\no <-- o <-- o <-- o\n            ^\n             \\\n              --- o <-- o\n ```\n` o`s代表单个提交（快照），理解为提交的文件（夹）\n ```bash\n o <-- o <-- o <-- o <---- o\n            ^            /\n             \\          v\n              --- o <-- o\n  ```\n这里意味着并行开发项目的两个功能，并进行合并，创建了一个包含两个功能的快照，`Git`会自行合并处理两个快照，若出现冲突无法解决时，则需要人工进行调整！\n***\n### 分支\n- `git branch`可以将分支名列表显示，同时可以确认当前所在的分支\n```bash\n$ git branch\n* main\n```\n分支`main`左上角带有星号`*`表示这是我们当前所在的分支，也就是说我们正在`main`分支下进行开发，同时没有其他分支名，表示本地仓库只存在main一个分支。（以往`Git`默认分支是`master`，但现在改为了`main`）\n\n- `git checkout -b`创建并切换到新的分支\n\n```bash\n$ git checkout -b feature-A\n```\n可以创建并切换到新的分支`feature-A`\n\n```bash\n$ git branch feature-A\n$ git checkout feature-A\n```\n实际上，连续执行以上两条命令也能收到相同的的效果。\n\n```bash\n$ git branch\n* feature-A\n  main\n```\n这时再来查看我们的分支，就会发现我们正处在`feature-A`分支下，但我们在正常开发、执行`git add`命令并进行`commit`时，代码就会提交至`feature-A`分支，我们称为“**培育分支**”，这样我们就能在不相互影响的情况下同时进行多个功能的开发！\n\n- `git merge`可以**将分支合并**，如上文`feature-A`是典型的**特性分支**，能集中实现单一特性，且除此之外不进行任何作业，在日常开发中往往会创建数个特性分支，同时在保留一个可以随时发布软件的稳定分支。通常使用`main`作为**主干分支**（也就是特性分支的原点和合并的终点）。\n首先切换到`main`分支：\n```bash\n$ git checkout main\n```\n然后合并分支，为了在历史记录中明确记录下本次分支合并，我们需要创建合并并提交。\n```bash\n$ git merge --no-ff feature-A\n```\n\n- `git log --graph`**以图表形式查看分支合并历史**\n- \n***\n\n### 回溯历史版本\n当我们在开发时遇到：\n- 尝试新功能但效果不好，想回到之前状态\n- 发布后发现有严重问题难以修复，需要回滚到上一个版本\n- 找回被删除的文件或代码\n- 合并分支时冲突出错\n\n这时我们就可以考虑**回溯版本**！\n\n先获取想要**回滚到的那个版本的 commit hash**：\n```bash\ngit log --oneline\n```\n`--oneline`参数可以将提交历史以简洁的一行进行显示，便于查找哈希值\n\n\n```bash\nLegion@LAPTOP-THUPDMQ0 MINGW64 /e/Hexo-backup (main)\n$ git log --oneline\n5a9dcd9 (HEAD -> main, origin/main) test\n53397ae feat\n54d31f5 feat\n808d171 feat\n79e81c0 feat\ne485ebb feat\n8836ac9 修改文件名\n400f3e4 增加life-musings内容\n08de0b5 添加.gitignore忽略DS_Store文件\n13f5287 Initial commit of hexo source files\n```\n\n\n`git reset`**回溯历史版本**，我们只要**提供目标时间点的哈希值**，就可以完全恢复至当时该时间点的状态。\n\n```bash\ngit reset --hard <hash>\n```\n回溯完，强制**推送至远程仓库**：\n```bash\ngit push -f origin main\n```\n  \n{% note warning %}如果我上线测试时突然发现了一个`bug`，而我不知道他是他是何时产生的应该怎么办呢？{%endnote%}\n\n`Git`也会提供相应的二分历史记录查找！\n\n## 总结\n至此，你学会了如何通过 `Git` 管理项目的版本历史，最终将项目代码推送到 `GitHub`。整个过程包括了从初始化仓库、添加文件、提交文件到推送到远程仓库的完整步骤。通过这些操作，你便已经具备了基本的版本控制能力。\n\n封面来源：[Git Explained in 100 Seconds](https://www.youtube.com/watch?v=hwP7WQkmECE)\n\n","slug":"Tutorial/Simple-Git-Project-Management-Guide","published":1,"updated":"2025-09-12T07:50:16.196Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hd3006040w3fcnl4k1n","content":"<p><code>Git</code> 是一个<strong>分布式</strong>版本控制系统(<code>Vision Control Systems</code>)，它允许多个人在同一项目上工作。通过<code> Git</code>，我们可以记录项目的每一次更改，并且可以将代码推送到 <code>GitHub</code>，方便以后查看和分享（多人的协作开发）。以下是<code>Git</code>进行代码版本管理的基本操作：</p>\n<h2 id=\"基本操作\">基本操作</h2>\n<h3 id=\"1、在本地初始化git仓库\">1、在本地初始化git仓库</h3>\n<p>打开命令行工具（<code>Windows</code> 用户可以使用 <code>PowerShell</code>，<code>Mac</code> 和 <code>Linux</code> 用户可以使用终端<code>terminal</code>），确保你进入了项目文件夹（命令：<code>cd path</code>），然后输入以下命令来初始化 <code>Git</code> 仓库：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git init<br></code></pre></td></tr></tbody></table></figure>\n<p><strong>解释：</strong><code>git init</code>会在当前文件夹中创建一个新的<strong>Git仓库</strong>（<code>.git</code>目录），这个目录里存储着管理当前目录内容所需要的仓库数据。现在，你的项目文件夹已经开始被 Git 追踪，之后的每一次文件修改都可以通过 Git 来记录。</p>\n<ul>\n<li>使用<code>git status</code>命令可以查看当前<strong>仓库的状态</strong>，包括哪些文件被修改了，哪些文件被添加到暂存区了，哪些文件还没有被跟踪等。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git status<br><span class=\"hljs-comment\"># on branch master</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Initial commit</span><br><span class=\"hljs-comment\">#</span><br>nothing to commit (creat/copy files and use <span class=\"hljs-string\">\"git add\"</span> to track)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"2、添加文件到暂存区\">2、添加文件到暂存区</h3>\n<p>暂存区是一个<strong>准备提交的区域</strong>，只有在将文件添加到暂存区后，才能将它们提交到本地仓库中。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add<br></code></pre></td></tr></tbody></table></figure>\n<p><strong>解释</strong>:<code>git add.</code>会将当前文件夹下的所有文件添加到暂存区。这意味着 Git 现在知道这些文件已经被修改，并准备将它们保存到版本历史中。</p>\n<h3 id=\"3、提交文件到本地仓库\">3、提交文件到本地仓库</h3>\n<p>暂存区中的文件提交到本地仓库。输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">\"feat: \"</span><br></code></pre></td></tr></tbody></table></figure>\n<p><strong>解释：</strong><code>git commit -m</code> 命令用于提交更改到本地仓库，并且 <code>-m</code> 参数后面跟着的是你为此次提交<strong>添加的描述信息</strong>，也就是提交信息（<code>commit message</code>）。提交信息是对此次提交所做更改的简短描述，它帮助团队成员或其他查看项目历史的人理解每次提交的目的或内容。</p>\n<ul>\n<li><code>git log</code>可以查看以往仓库中<strong>提交的日志</strong>，包括什么人在什么时候进行了提交或合并，以及操作前后有什么差别。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@RicharddeMacBook-Air leetcode % git <span class=\"hljs-built_in\">log</span><br>commit 03748e1b5410364249cb10d78ae72f443682dc24 (HEAD -&gt; main)<br>Author: Richard110206 &lt;lqx3222482537@qq.com&gt;<br>Date:   Sun Aug 17 23:28:22 2025 +0800<br><br>    First Commit<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>git diff</code>可以查看<strong>当前工作目录和暂存区之间的差异</strong>。“+”表示添加的行，\"-“表示删除的行，”~\"表示修改的行。</li>\n</ul>\n<p>这些是特定的标签或标识符来说明提交的类型：</p>\n<ul>\n<li><code>feat</code>: 表示<strong>新功能的增加</strong>（<code>feature</code>）</li>\n<li><code>fix</code>: 表示<strong>修复了一个<code>bug</code></strong></li>\n<li><code>docs</code>: 表示<strong>文档更新</strong></li>\n<li><code>refactor</code>: 表示<strong>代码重构</strong>（既不是修复bug也不是添加新功能）</li>\n<li><code>style</code>: <strong>改进代码格式但不影响逻辑</strong></li>\n<li><code>test</code>: <strong>添加或修正测试用例</strong></li>\n</ul>\n<h3 id=\"4-创建远程仓库\">4. 创建远程仓库</h3>\n<p>前往 <code>GitHub</code>，创建一个<strong>新的远程仓库</strong>，并命名，注意：不要勾选“初始化仓库”，因为我们已经在本地初始化了仓库。</p>\n<h3 id=\"5-关联本地仓库\">5. 关联本地仓库</h3>\n<p>在命令行中，输入以下命令来将本地仓库和 GitHub 的远程仓库<strong>关联</strong>起来：</p>\n<ul>\n<li>若是通过<code>SSH</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git remote add origin git@github.com:用户名/仓库名.git<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>若是通过<code>HTTPS</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git remote set-url origin https://令牌@github.com/用户名/远程仓库名`<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"6、推送代码到-GitHub\">6、推送代码到 GitHub</h3>\n<p>最后一步，我们将本地仓库中的更改<strong>推送</strong>到 <code>GitHub</code> 上的远程仓库：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push -u origin main<br></code></pre></td></tr></tbody></table></figure>\n<p><strong>解释：</strong><code>git push</code> 命令会将本地仓库中的代码上传到 <code>GitHub</code> 的远程仓库。<code>-u</code> 参数会将本地的 <code>main</code> 分支与远程仓库的 <code>main</code> 分支关联起来，确保以后每次推送都不需要重复指定分支。</p>\n<h2 id=\"从远程仓库获取\">从远程仓库获取</h2>\n<p><code>git clone</code>可以<strong>获取远程仓库的代码到本地</strong></p>\n<ul>\n<li>若是通过<code>SSH</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:用户名/仓库名.git<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li>若是通过<code>HTTPS</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/用户名/仓库名.git<br></code></pre></td></tr></tbody></table></figure>\n<p>当前本地仓库的<code>main</code>分支和<code>Github</code>仓库的<code>main</code>分支在内容上是完全相同的。</p>\n<p><code>git pull</code>可以从远程仓库分支<strong>获取最新的代码到本地</strong>，这样只要在本地进行提交再<code>push</code>给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，而如果两个人同时修改了同意部分的源代码，<code>push</code>时就很容易<strong>发生冲突</strong>，因此建议<strong>更频繁的进行</strong><code>push</code>和<code>pull</code>操作！</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><code>git clone</code></th>\n<th><code>git pull</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>首次下载远程仓库到本地</td>\n<td>更新本地已有代码</td>\n</tr>\n<tr>\n<td><strong>执行前提</strong></td>\n<td>本地没有仓库时使用</td>\n<td>必须在已有<code>Git</code>仓库的目录内执行</td>\n</tr>\n<tr>\n<td><strong>操作内容</strong></td>\n<td>下载完整仓库、自动创建远程跟踪分支</td>\n<td>获取远程最新变更<code>git fetch</code><br> 自动合并到当前分支<code>git merge</code></td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://xflops.sjtu.edu.cn/hpc-start-guide/primer/attachments/20241106195404.png\" alt=\"关键操作图解\"></p>\n<hr>\n<h3 id=\"快照\">快照</h3>\n<p><code>VCS</code> 通过一系列快照跟踪文件夹及其内容的更改，其中每个快照都封装了顶级目录中文件/文件夹的完整状态，其还维护元数据，例如每个快照的创建者、与每个快照相关的消息等等。</p>\n<p><code>Git</code> 将某个顶级目录中文件和文件夹集合的历史记录建模为一系列快照。文件/文件夹的树模型：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;root&gt; (tree)<br>|<br>+- foo (tree)<br>|  |<br>|  + bar.txt (blob, contents = <span class=\"hljs-string\">\"hello world\"</span>)<br>|<br>+- baz.txt (blob, contents = <span class=\"hljs-string\">\"git is wonderful\"</span>)<br></code></pre></td></tr></tbody></table></figure>\n<h3 id=\"关联快照\">关联快照</h3>\n<div class=\"note note-warning\">\n            <p>不知你是否有过疑惑。如果我和我的伙伴并行共同完成一个项目的两个特性应该如何处理？是将他的那部分完成后让我在复制到我的版本上吗？显然那样做太过麻烦！</p>\n          </div>\n<p>在<code>Git</code>中，历史记录是快照的<strong>有向无环图</strong> (<code>DAG</code>)。这意味着<code>Git </code>中的每个快照都指向一组“父级”，即它之前的快照。它是一组父级，而不是单个父级（线性历史记录中的情况），因为快照可能源自多个父级，例如，由于合并（合并）两个并行的开发分支。<code>Git</code> 将这些快照称为“提交”。可视化提交历史记录可能如下所示：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">o &lt;-- o &lt;-- o &lt;-- o<br>            ^<br>             \\<br>              --- o &lt;-- o<br></code></pre></td></tr></tbody></table></figure>\n<p><code> o</code>s代表单个提交（快照），理解为提交的文件（夹）</p>\n <figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o<br>           ^            /<br>            \\          v<br>             --- o &lt;-- o<br></code></pre></td></tr></tbody></table></figure>\n<p>这里意味着并行开发项目的两个功能，并进行合并，创建了一个包含两个功能的快照，<code>Git</code>会自行合并处理两个快照，若出现冲突无法解决时，则需要人工进行调整！</p>\n<hr>\n<h3 id=\"分支\">分支</h3>\n<ul>\n<li><code>git branch</code>可以将分支名列表显示，同时可以确认当前所在的分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch<br>* main<br></code></pre></td></tr></tbody></table></figure>\n<p>分支<code>main</code>左上角带有星号<code>*</code>表示这是我们当前所在的分支，也就是说我们正在<code>main</code>分支下进行开发，同时没有其他分支名，表示本地仓库只存在main一个分支。（以往<code>Git</code>默认分支是<code>master</code>，但现在改为了<code>main</code>）</p>\n<ul>\n<li><code>git checkout -b</code>创建并切换到新的分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git checkout -b feature-A<br></code></pre></td></tr></tbody></table></figure>\n<p>可以创建并切换到新的分支<code>feature-A</code></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch feature-A<br>$ git checkout feature-A<br></code></pre></td></tr></tbody></table></figure>\n<p>实际上，连续执行以上两条命令也能收到相同的的效果。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch<br>* feature-A<br>  main<br></code></pre></td></tr></tbody></table></figure>\n<p>这时再来查看我们的分支，就会发现我们正处在<code>feature-A</code>分支下，但我们在正常开发、执行<code>git add</code>命令并进行<code>commit</code>时，代码就会提交至<code>feature-A</code>分支，我们称为“<strong>培育分支</strong>”，这样我们就能在不相互影响的情况下同时进行多个功能的开发！</p>\n<ul>\n<li><code>git merge</code>可以<strong>将分支合并</strong>，如上文<code>feature-A</code>是典型的<strong>特性分支</strong>，能集中实现单一特性，且除此之外不进行任何作业，在日常开发中往往会创建数个特性分支，同时在保留一个可以随时发布软件的稳定分支。通常使用<code>main</code>作为<strong>主干分支</strong>（也就是特性分支的原点和合并的终点）。<br>\n首先切换到<code>main</code>分支：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git checkout main<br></code></pre></td></tr></tbody></table></figure>\n<p>然后合并分支，为了在历史记录中明确记录下本次分支合并，我们需要创建合并并提交。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git merge --no-ff feature-A<br></code></pre></td></tr></tbody></table></figure>\n<ul>\n<li><code>git log --graph</code><strong>以图表形式查看分支合并历史</strong></li>\n<li></li>\n</ul>\n<hr>\n<h3 id=\"回溯历史版本\">回溯历史版本</h3>\n<p>当我们在开发时遇到：</p>\n<ul>\n<li>尝试新功能但效果不好，想回到之前状态</li>\n<li>发布后发现有严重问题难以修复，需要回滚到上一个版本</li>\n<li>找回被删除的文件或代码</li>\n<li>合并分支时冲突出错</li>\n</ul>\n<p>这时我们就可以考虑<strong>回溯版本</strong>！</p>\n<p>先获取想要<strong>回滚到的那个版本的 commit hash</strong>：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --oneline<br></code></pre></td></tr></tbody></table></figure>\n<p><code>--oneline</code>参数可以将提交历史以简洁的一行进行显示，便于查找哈希值</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Legion@LAPTOP-THUPDMQ0 MINGW64 /e/Hexo-backup (main)<br>$ git <span class=\"hljs-built_in\">log</span> --oneline<br>5a9dcd9 (HEAD -&gt; main, origin/main) <span class=\"hljs-built_in\">test</span><br>53397ae feat<br>54d31f5 feat<br>808d171 feat<br>79e81c0 feat<br>e485ebb feat<br>8836ac9 修改文件名<br>400f3e4 增加life-musings内容<br>08de0b5 添加.gitignore忽略DS_Store文件<br>13f5287 Initial commit of hexo <span class=\"hljs-built_in\">source</span> files<br></code></pre></td></tr></tbody></table></figure>\n<p><code>git reset</code><strong>回溯历史版本</strong>，我们只要<strong>提供目标时间点的哈希值</strong>，就可以完全恢复至当时该时间点的状态。</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard &lt;<span class=\"hljs-built_in\">hash</span>&gt;<br></code></pre></td></tr></tbody></table></figure>\n<p>回溯完，强制<strong>推送至远程仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push -f origin main<br></code></pre></td></tr></tbody></table></figure>\n<div class=\"note note-warning\">\n            <p>如果我上线测试时突然发现了一个<code>bug</code>，而我不知道他是他是何时产生的应该怎么办呢？</p>\n          </div>\n<p><code>Git</code>也会提供相应的二分历史记录查找！</p>\n<h2 id=\"总结\">总结</h2>\n<p>至此，你学会了如何通过 <code>Git</code> 管理项目的版本历史，最终将项目代码推送到 <code>GitHub</code>。整个过程包括了从初始化仓库、添加文件、提交文件到推送到远程仓库的完整步骤。通过这些操作，你便已经具备了基本的版本控制能力。</p>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=hwP7WQkmECE\">Git Explained in 100 Seconds</a></p>\n","excerpt":"","more":"<p><code>Git</code> 是一个<strong>分布式</strong>版本控制系统(<code>Vision Control Systems</code>)，它允许多个人在同一项目上工作。通过<code> Git</code>，我们可以记录项目的每一次更改，并且可以将代码推送到 <code>GitHub</code>，方便以后查看和分享（多人的协作开发）。以下是<code>Git</code>进行代码版本管理的基本操作：</p>\n<h2 id=\"基本操作\">基本操作</h2>\n<h3 id=\"1、在本地初始化git仓库\">1、在本地初始化git仓库</h3>\n<p>打开命令行工具（<code>Windows</code> 用户可以使用 <code>PowerShell</code>，<code>Mac</code> 和 <code>Linux</code> 用户可以使用终端<code>terminal</code>），确保你进入了项目文件夹（命令：<code>cd path</code>），然后输入以下命令来初始化 <code>Git</code> 仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git init<br></code></pre></td></tr></table></figure>\n<p><strong>解释：</strong><code>git init</code>会在当前文件夹中创建一个新的<strong>Git仓库</strong>（<code>.git</code>目录），这个目录里存储着管理当前目录内容所需要的仓库数据。现在，你的项目文件夹已经开始被 Git 追踪，之后的每一次文件修改都可以通过 Git 来记录。</p>\n<ul>\n<li>使用<code>git status</code>命令可以查看当前<strong>仓库的状态</strong>，包括哪些文件被修改了，哪些文件被添加到暂存区了，哪些文件还没有被跟踪等。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git status<br><span class=\"hljs-comment\"># on branch master</span><br><span class=\"hljs-comment\">#</span><br><span class=\"hljs-comment\"># Initial commit</span><br><span class=\"hljs-comment\">#</span><br>nothing to commit (creat/copy files and use <span class=\"hljs-string\">&quot;git add&quot;</span> to track)<br></code></pre></td></tr></table></figure>\n<h3 id=\"2、添加文件到暂存区\">2、添加文件到暂存区</h3>\n<p>暂存区是一个<strong>准备提交的区域</strong>，只有在将文件添加到暂存区后，才能将它们提交到本地仓库中。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git add<br></code></pre></td></tr></table></figure>\n<p><strong>解释</strong>:<code>git add.</code>会将当前文件夹下的所有文件添加到暂存区。这意味着 Git 现在知道这些文件已经被修改，并准备将它们保存到版本历史中。</p>\n<h3 id=\"3、提交文件到本地仓库\">3、提交文件到本地仓库</h3>\n<p>暂存区中的文件提交到本地仓库。输入以下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git commit -m <span class=\"hljs-string\">&quot;feat: &quot;</span><br></code></pre></td></tr></table></figure>\n<p><strong>解释：</strong><code>git commit -m</code> 命令用于提交更改到本地仓库，并且 <code>-m</code> 参数后面跟着的是你为此次提交<strong>添加的描述信息</strong>，也就是提交信息（<code>commit message</code>）。提交信息是对此次提交所做更改的简短描述，它帮助团队成员或其他查看项目历史的人理解每次提交的目的或内容。</p>\n<ul>\n<li><code>git log</code>可以查看以往仓库中<strong>提交的日志</strong>，包括什么人在什么时候进行了提交或合并，以及操作前后有什么差别。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">richard@RicharddeMacBook-Air leetcode % git <span class=\"hljs-built_in\">log</span><br>commit 03748e1b5410364249cb10d78ae72f443682dc24 (HEAD -&gt; main)<br>Author: Richard110206 &lt;lqx3222482537@qq.com&gt;<br>Date:   Sun Aug 17 23:28:22 2025 +0800<br><br>    First Commit<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>git diff</code>可以查看<strong>当前工作目录和暂存区之间的差异</strong>。“+”表示添加的行，&quot;-“表示删除的行，”~&quot;表示修改的行。</li>\n</ul>\n<p>这些是特定的标签或标识符来说明提交的类型：</p>\n<ul>\n<li><code>feat</code>: 表示<strong>新功能的增加</strong>（<code>feature</code>）</li>\n<li><code>fix</code>: 表示<strong>修复了一个<code>bug</code></strong></li>\n<li><code>docs</code>: 表示<strong>文档更新</strong></li>\n<li><code>refactor</code>: 表示<strong>代码重构</strong>（既不是修复bug也不是添加新功能）</li>\n<li><code>style</code>: <strong>改进代码格式但不影响逻辑</strong></li>\n<li><code>test</code>: <strong>添加或修正测试用例</strong></li>\n</ul>\n<h3 id=\"4-创建远程仓库\">4. 创建远程仓库</h3>\n<p>前往 <code>GitHub</code>，创建一个<strong>新的远程仓库</strong>，并命名，注意：不要勾选“初始化仓库”，因为我们已经在本地初始化了仓库。</p>\n<h3 id=\"5-关联本地仓库\">5. 关联本地仓库</h3>\n<p>在命令行中，输入以下命令来将本地仓库和 GitHub 的远程仓库<strong>关联</strong>起来：</p>\n<ul>\n<li>若是通过<code>SSH</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git remote add origin git@github.com:用户名/仓库名.git<br></code></pre></td></tr></table></figure>\n<ul>\n<li>若是通过<code>HTTPS</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git remote set-url origin https://令牌@github.com/用户名/远程仓库名`<br></code></pre></td></tr></table></figure>\n<h3 id=\"6、推送代码到-GitHub\">6、推送代码到 GitHub</h3>\n<p>最后一步，我们将本地仓库中的更改<strong>推送</strong>到 <code>GitHub</code> 上的远程仓库：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push -u origin main<br></code></pre></td></tr></table></figure>\n<p><strong>解释：</strong><code>git push</code> 命令会将本地仓库中的代码上传到 <code>GitHub</code> 的远程仓库。<code>-u</code> 参数会将本地的 <code>main</code> 分支与远程仓库的 <code>main</code> 分支关联起来，确保以后每次推送都不需要重复指定分支。</p>\n<h2 id=\"从远程仓库获取\">从远程仓库获取</h2>\n<p><code>git clone</code>可以<strong>获取远程仓库的代码到本地</strong></p>\n<ul>\n<li>若是通过<code>SSH</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> git@github.com:用户名/仓库名.git<br></code></pre></td></tr></table></figure>\n<ul>\n<li>若是通过<code>HTTPS</code>方式连接远程仓库：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/用户名/仓库名.git<br></code></pre></td></tr></table></figure>\n<p>当前本地仓库的<code>main</code>分支和<code>Github</code>仓库的<code>main</code>分支在内容上是完全相同的。</p>\n<p><code>git pull</code>可以从远程仓库分支<strong>获取最新的代码到本地</strong>，这样只要在本地进行提交再<code>push</code>给远程仓库，就可以与其他开发者同时在同一个分支中进行作业，而如果两个人同时修改了同意部分的源代码，<code>push</code>时就很容易<strong>发生冲突</strong>，因此建议<strong>更频繁的进行</strong><code>push</code>和<code>pull</code>操作！</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th><code>git clone</code></th>\n<th><code>git pull</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>用途</strong></td>\n<td>首次下载远程仓库到本地</td>\n<td>更新本地已有代码</td>\n</tr>\n<tr>\n<td><strong>执行前提</strong></td>\n<td>本地没有仓库时使用</td>\n<td>必须在已有<code>Git</code>仓库的目录内执行</td>\n</tr>\n<tr>\n<td><strong>操作内容</strong></td>\n<td>下载完整仓库、自动创建远程跟踪分支</td>\n<td>获取远程最新变更<code>git fetch</code><br> 自动合并到当前分支<code>git merge</code></td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://xflops.sjtu.edu.cn/hpc-start-guide/primer/attachments/20241106195404.png\" alt=\"关键操作图解\"></p>\n<hr>\n<h3 id=\"快照\">快照</h3>\n<p><code>VCS</code> 通过一系列快照跟踪文件夹及其内容的更改，其中每个快照都封装了顶级目录中文件/文件夹的完整状态，其还维护元数据，例如每个快照的创建者、与每个快照相关的消息等等。</p>\n<p><code>Git</code> 将某个顶级目录中文件和文件夹集合的历史记录建模为一系列快照。文件/文件夹的树模型：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;root&gt; (tree)<br>|<br>+- foo (tree)<br>|  |<br>|  + bar.txt (blob, contents = <span class=\"hljs-string\">&quot;hello world&quot;</span>)<br>|<br>+- baz.txt (blob, contents = <span class=\"hljs-string\">&quot;git is wonderful&quot;</span>)<br></code></pre></td></tr></table></figure>\n<h3 id=\"关联快照\">关联快照</h3>\n<div class=\"note note-warning\">\n            <p>不知你是否有过疑惑。如果我和我的伙伴并行共同完成一个项目的两个特性应该如何处理？是将他的那部分完成后让我在复制到我的版本上吗？显然那样做太过麻烦！</p>\n          </div>\n<p>在<code>Git</code>中，历史记录是快照的<strong>有向无环图</strong> (<code>DAG</code>)。这意味着<code>Git </code>中的每个快照都指向一组“父级”，即它之前的快照。它是一组父级，而不是单个父级（线性历史记录中的情况），因为快照可能源自多个父级，例如，由于合并（合并）两个并行的开发分支。<code>Git</code> 将这些快照称为“提交”。可视化提交历史记录可能如下所示：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">o &lt;-- o &lt;-- o &lt;-- o<br>            ^<br>             \\<br>              --- o &lt;-- o<br></code></pre></td></tr></table></figure>\n<p><code> o</code>s代表单个提交（快照），理解为提交的文件（夹）</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">o &lt;-- o &lt;-- o &lt;-- o &lt;---- o<br>           ^            /<br>            \\          v<br>             --- o &lt;-- o<br></code></pre></td></tr></table></figure>\n<p>这里意味着并行开发项目的两个功能，并进行合并，创建了一个包含两个功能的快照，<code>Git</code>会自行合并处理两个快照，若出现冲突无法解决时，则需要人工进行调整！</p>\n<hr>\n<h3 id=\"分支\">分支</h3>\n<ul>\n<li><code>git branch</code>可以将分支名列表显示，同时可以确认当前所在的分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch<br>* main<br></code></pre></td></tr></table></figure>\n<p>分支<code>main</code>左上角带有星号<code>*</code>表示这是我们当前所在的分支，也就是说我们正在<code>main</code>分支下进行开发，同时没有其他分支名，表示本地仓库只存在main一个分支。（以往<code>Git</code>默认分支是<code>master</code>，但现在改为了<code>main</code>）</p>\n<ul>\n<li><code>git checkout -b</code>创建并切换到新的分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git checkout -b feature-A<br></code></pre></td></tr></table></figure>\n<p>可以创建并切换到新的分支<code>feature-A</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch feature-A<br>$ git checkout feature-A<br></code></pre></td></tr></table></figure>\n<p>实际上，连续执行以上两条命令也能收到相同的的效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git branch<br>* feature-A<br>  main<br></code></pre></td></tr></table></figure>\n<p>这时再来查看我们的分支，就会发现我们正处在<code>feature-A</code>分支下，但我们在正常开发、执行<code>git add</code>命令并进行<code>commit</code>时，代码就会提交至<code>feature-A</code>分支，我们称为“<strong>培育分支</strong>”，这样我们就能在不相互影响的情况下同时进行多个功能的开发！</p>\n<ul>\n<li><code>git merge</code>可以<strong>将分支合并</strong>，如上文<code>feature-A</code>是典型的<strong>特性分支</strong>，能集中实现单一特性，且除此之外不进行任何作业，在日常开发中往往会创建数个特性分支，同时在保留一个可以随时发布软件的稳定分支。通常使用<code>main</code>作为<strong>主干分支</strong>（也就是特性分支的原点和合并的终点）。<br>\n首先切换到<code>main</code>分支：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git checkout main<br></code></pre></td></tr></table></figure>\n<p>然后合并分支，为了在历史记录中明确记录下本次分支合并，我们需要创建合并并提交。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ git merge --no-ff feature-A<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>git log --graph</code><strong>以图表形式查看分支合并历史</strong></li>\n<li></li>\n</ul>\n<hr>\n<h3 id=\"回溯历史版本\">回溯历史版本</h3>\n<p>当我们在开发时遇到：</p>\n<ul>\n<li>尝试新功能但效果不好，想回到之前状态</li>\n<li>发布后发现有严重问题难以修复，需要回滚到上一个版本</li>\n<li>找回被删除的文件或代码</li>\n<li>合并分支时冲突出错</li>\n</ul>\n<p>这时我们就可以考虑<strong>回溯版本</strong>！</p>\n<p>先获取想要<strong>回滚到的那个版本的 commit hash</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --oneline<br></code></pre></td></tr></table></figure>\n<p><code>--oneline</code>参数可以将提交历史以简洁的一行进行显示，便于查找哈希值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">Legion@LAPTOP-THUPDMQ0 MINGW64 /e/Hexo-backup (main)<br>$ git <span class=\"hljs-built_in\">log</span> --oneline<br>5a9dcd9 (HEAD -&gt; main, origin/main) <span class=\"hljs-built_in\">test</span><br>53397ae feat<br>54d31f5 feat<br>808d171 feat<br>79e81c0 feat<br>e485ebb feat<br>8836ac9 修改文件名<br>400f3e4 增加life-musings内容<br>08de0b5 添加.gitignore忽略DS_Store文件<br>13f5287 Initial commit of hexo <span class=\"hljs-built_in\">source</span> files<br></code></pre></td></tr></table></figure>\n<p><code>git reset</code><strong>回溯历史版本</strong>，我们只要<strong>提供目标时间点的哈希值</strong>，就可以完全恢复至当时该时间点的状态。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git reset --hard &lt;<span class=\"hljs-built_in\">hash</span>&gt;<br></code></pre></td></tr></table></figure>\n<p>回溯完，强制<strong>推送至远程仓库</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git push -f origin main<br></code></pre></td></tr></table></figure>\n<div class=\"note note-warning\">\n            <p>如果我上线测试时突然发现了一个<code>bug</code>，而我不知道他是他是何时产生的应该怎么办呢？</p>\n          </div>\n<p><code>Git</code>也会提供相应的二分历史记录查找！</p>\n<h2 id=\"总结\">总结</h2>\n<p>至此，你学会了如何通过 <code>Git</code> 管理项目的版本历史，最终将项目代码推送到 <code>GitHub</code>。整个过程包括了从初始化仓库、添加文件、提交文件到推送到远程仓库的完整步骤。通过这些操作，你便已经具备了基本的版本控制能力。</p>\n<p>封面来源：<a href=\"https://www.youtube.com/watch?v=hwP7WQkmECE\">Git Explained in 100 Seconds</a></p>\n"},{"title":"Huashu Cup Conclusion","date":"2025-08-22T15:27:22.000Z","category_bar":true,"archive":true,"description":"The blog is to profoundly analyze the reasons for our failure in the Huashu Cup, according to the assessment provided by the organizers.","_content":"\n\n&emsp;&emsp;在“华数杯”数学建模竞赛中，我们的队伍仅仅获得“**优秀奖**”，草草收场，于我，上次的一等奖让我有些心高气傲，很多**细节方面**没有关注到位，间接导致了失败，现根据官方提供的评价进行**自我剖析**，为即将到来的国赛摩拳擦掌！\n\n![华数杯官方评语](https://github.com/Richard110206/Blog-image/blob/main/article/Huashu-Cup-Conclusion/assessment.jpg?raw=true)\n\n\n比赛论文如下：\n\n<iframe \n  src=\"https://cdn.jsdelivr.net/gh/Richard110206/Blog-image@main/article/Huashu-Cup-Conclusion/CCM2501873.pdf\"\n  width=\"100%\" \n  height=\"800px\">\n</iframe>\n\n:warning::warning::warning:\n{%note danger}\n- 摘要是论文的门面，需要将使用的**关键数学模型**（依据的外部资料标准）、**求解步骤**进行呈现，最后还要“结果显示”，将**重点求解结果进行描述**！\n- 一个模型求解完成后，不能仅仅呈现图表作为结尾，要**用语言文字对图表求解结果进行分析**！\n- 绘制图表的格式要更加多样，注意**颜色的搭配**，字体**字号**的呈现！\n{%endnote%}","source":"_posts/Mathematical Modeling Tutorial/Huashu Cup Conclusion.md","raw":"---\ntitle: Huashu Cup Conclusion\ndate: 2025-08-22 23:27:22\ntags: [review]\ncategory: Mathematical Modeling Tutorial\ncategory_bar: true\narchive: true\ndescription: The blog is to profoundly analyze the reasons for our failure in the Huashu Cup, according to the assessment provided by the organizers.\n---\n\n\n&emsp;&emsp;在“华数杯”数学建模竞赛中，我们的队伍仅仅获得“**优秀奖**”，草草收场，于我，上次的一等奖让我有些心高气傲，很多**细节方面**没有关注到位，间接导致了失败，现根据官方提供的评价进行**自我剖析**，为即将到来的国赛摩拳擦掌！\n\n![华数杯官方评语](https://github.com/Richard110206/Blog-image/blob/main/article/Huashu-Cup-Conclusion/assessment.jpg?raw=true)\n\n\n比赛论文如下：\n\n<iframe \n  src=\"https://cdn.jsdelivr.net/gh/Richard110206/Blog-image@main/article/Huashu-Cup-Conclusion/CCM2501873.pdf\"\n  width=\"100%\" \n  height=\"800px\">\n</iframe>\n\n:warning::warning::warning:\n{%note danger}\n- 摘要是论文的门面，需要将使用的**关键数学模型**（依据的外部资料标准）、**求解步骤**进行呈现，最后还要“结果显示”，将**重点求解结果进行描述**！\n- 一个模型求解完成后，不能仅仅呈现图表作为结尾，要**用语言文字对图表求解结果进行分析**！\n- 绘制图表的格式要更加多样，注意**颜色的搭配**，字体**字号**的呈现！\n{%endnote%}","slug":"Mathematical Modeling Tutorial/Huashu Cup Conclusion","published":1,"updated":"2025-08-22T17:07:06.118Z","comments":1,"layout":"post","photos":[],"_id":"cmfj66hd3006140w39k6me3iq","content":"<p>  在“华数杯”数学建模竞赛中，我们的队伍仅仅获得“<strong>优秀奖</strong>”，草草收场，于我，上次的一等奖让我有些心高气傲，很多<strong>细节方面</strong>没有关注到位，间接导致了失败，现根据官方提供的评价进行<strong>自我剖析</strong>，为即将到来的国赛摩拳擦掌！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Huashu-Cup-Conclusion/assessment.jpg?raw=true\" alt=\"华数杯官方评语\"></p>\n<p>比赛论文如下：</p>\n<iframe src=\"https://cdn.jsdelivr.net/gh/Richard110206/Blog-image@main/article/Huashu-Cup-Conclusion/CCM2501873.pdf\" width=\"100%\" height=\"800px\">\n</iframe>\n<p>⚠️⚠️⚠️</p>\n","excerpt":"","more":"<p>  在“华数杯”数学建模竞赛中，我们的队伍仅仅获得“<strong>优秀奖</strong>”，草草收场，于我，上次的一等奖让我有些心高气傲，很多<strong>细节方面</strong>没有关注到位，间接导致了失败，现根据官方提供的评价进行<strong>自我剖析</strong>，为即将到来的国赛摩拳擦掌！</p>\n<p><img src=\"https://github.com/Richard110206/Blog-image/blob/main/article/Huashu-Cup-Conclusion/assessment.jpg?raw=true\" alt=\"华数杯官方评语\"></p>\n<p>比赛论文如下：</p>\n<iframe \n  src=\"https://cdn.jsdelivr.net/gh/Richard110206/Blog-image@main/article/Huashu-Cup-Conclusion/CCM2501873.pdf\"\n  width=\"100%\" \n  height=\"800px\">\n</iframe>\n<p>⚠️⚠️⚠️</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmfj66hcf000140w366ip256j","category_id":"cmfj66hch000440w37mukaqfq","_id":"cmfj66hck000d40w318qi05w1"},{"post_id":"cmfj66hci000640w3cqyo2zay","category_id":"cmfj66hch000440w37mukaqfq","_id":"cmfj66hcn000p40w3742hbf45"},{"post_id":"cmfj66hcj000740w37wgp1345","category_id":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hco000v40w32gw7hgyf"},{"post_id":"cmfj66hcj000840w34dzjdw10","category_id":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hco001040w31jfy9k40"},{"post_id":"cmfj66hck000b40w3dmgp8mdt","category_id":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hcp001740w3houz3c8y"},{"post_id":"cmfj66hck000b40w3dmgp8mdt","category_id":"cmfj66hco000u40w33w26e5yd","_id":"cmfj66hcp001a40w38kntgmvo"},{"post_id":"cmfj66hch000340w36nhhg0aa","category_id":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hcp001d40w3as224kdq"},{"post_id":"cmfj66hch000340w36nhhg0aa","category_id":"cmfj66hco000u40w33w26e5yd","_id":"cmfj66hcq001g40w3gpln008i"},{"post_id":"cmfj66hck000c40w39sd9142c","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcq001k40w381isgp4t"},{"post_id":"cmfj66hcl000g40w350yn5l5w","category_id":"cmfj66hcj000940w36ddsafbj","_id":"cmfj66hcr001p40w35ook9erm"},{"post_id":"cmfj66hcl000g40w350yn5l5w","category_id":"cmfj66hco000u40w33w26e5yd","_id":"cmfj66hcr001s40w36znwf837"},{"post_id":"cmfj66hcm000i40w3caj101or","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcs001x40w3bnuz2lh4"},{"post_id":"cmfj66hcm000m40w31qo4e6gs","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hct002340w3cedu5ny6"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hct002a40w30pbf516o"},{"post_id":"cmfj66hcn000r40w3de4cbrmb","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcu002g40w3ghs3cn0v"},{"post_id":"cmfj66hcn000t40w3gvscgf9j","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcv002m40w32jrz5mi0"},{"post_id":"cmfj66hco000x40w39fp82cne","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcv002s40w31v9ydwaf"},{"post_id":"cmfj66hco000z40w37fuvcrw7","category_id":"cmfj66hcu002l40w382s00hpy","_id":"cmfj66hcw002z40w38kli2n0w"},{"post_id":"cmfj66hco001240w38x9w28aq","category_id":"cmfj66hcp001640w3bi7j6y6r","_id":"cmfj66hcw003440w3fjduhs58"},{"post_id":"cmfj66hcp001440w3950k4nbk","category_id":"cmfj66hcu002l40w382s00hpy","_id":"cmfj66hcw003640w3brredrpw"},{"post_id":"cmfj66hcp001840w39foy141v","category_id":"cmfj66hcw003340w3g3959swh","_id":"cmfj66hcw003940w31ia4eeqr"},{"post_id":"cmfj66hcq001f40w32rd58gyq","category_id":"cmfj66hcw003740w3hhl82hh7","_id":"cmfj66hcw003e40w34eq19njv"},{"post_id":"cmfj66hcq001i40w39xuc5csn","category_id":"cmfj66hcw003a40w3el9s48xg","_id":"cmfj66hcw003i40w33neo3whb"},{"post_id":"cmfj66hct002540w3d6yk0h6f","category_id":"cmfj66hcw003g40w3gamxdekm","_id":"cmfj66hcx003m40w369mzcfb8"},{"post_id":"cmfj66hct002740w3448wesxq","category_id":"cmfj66hcw003g40w3gamxdekm","_id":"cmfj66hcx003q40w3e2v0b91l"},{"post_id":"cmfj66hcu002j40w37mg722nr","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hcx003v40w38rfq5i72"},{"post_id":"cmfj66hcv002o40w3bdd0bzd2","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hcy003y40w3f28t22wd"},{"post_id":"cmfj66hcv002q40w33m2g0cke","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hcy004040w3465d1692"},{"post_id":"cmfj66hcv002u40w36at25gax","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hcy004140w35tm85vcj"},{"post_id":"cmfj66hd2005x40w30prwgg4y","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hd4006240w36eqcaqjg"},{"post_id":"cmfj66hd3005y40w3e2bncuv0","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hd4006340w31bi3ccg0"},{"post_id":"cmfj66hd3006040w3fcnl4k1n","category_id":"cmfj66hcx003l40w3614lag19","_id":"cmfj66hd4006740w33svpdbmc"},{"post_id":"cmfj66hd3006140w39k6me3iq","category_id":"cmfj66hd4006540w32w62ggna","_id":"cmfj66hd4006b40w31l5o4ebz"}],"PostTag":[{"post_id":"cmfj66hcf000140w366ip256j","tag_id":"cmfj66hci000540w34qrz0i8a","_id":"cmfj66hcm000h40w3acxnawra"},{"post_id":"cmfj66hcf000140w366ip256j","tag_id":"cmfj66hck000a40w36vhzcff5","_id":"cmfj66hcm000j40w38h5cejrc"},{"post_id":"cmfj66hch000340w36nhhg0aa","tag_id":"cmfj66hcl000f40w3b6x3h9yv","_id":"cmfj66hcn000s40w389zm54gs"},{"post_id":"cmfj66hch000340w36nhhg0aa","tag_id":"cmfj66hcm000l40w3d2qkhrev","_id":"cmfj66hco000w40w3eh3lfg7m"},{"post_id":"cmfj66hci000640w3cqyo2zay","tag_id":"cmfj66hcn000q40w3cc6e7e51","_id":"cmfj66hcp001540w3h9yid760"},{"post_id":"cmfj66hci000640w3cqyo2zay","tag_id":"cmfj66hco000y40w365eo43ga","_id":"cmfj66hcp001940w3blcp55pj"},{"post_id":"cmfj66hcj000740w37wgp1345","tag_id":"cmfj66hco001340w30at5henu","_id":"cmfj66hcr001q40w374fbcc3i"},{"post_id":"cmfj66hcj000740w37wgp1345","tag_id":"cmfj66hcp001b40w3axrzadwm","_id":"cmfj66hcr001t40w37cg94kwv"},{"post_id":"cmfj66hcj000740w37wgp1345","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcs001y40w369jq7w0f"},{"post_id":"cmfj66hcj000840w34dzjdw10","tag_id":"cmfj66hco001340w30at5henu","_id":"cmfj66hct002440w3818i6ykc"},{"post_id":"cmfj66hcj000840w34dzjdw10","tag_id":"cmfj66hcp001b40w3axrzadwm","_id":"cmfj66hct002640w33zchbonv"},{"post_id":"cmfj66hcs002040w3cjos6kbx","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hct002b40w30exdegva"},{"post_id":"cmfj66hct002d40w39hf00ckc","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcu002i40w3hyth0qsr"},{"post_id":"cmfj66hck000b40w3dmgp8mdt","tag_id":"cmfj66hco001340w30at5henu","_id":"cmfj66hcv002n40w3bwlx76yf"},{"post_id":"cmfj66hck000b40w3dmgp8mdt","tag_id":"cmfj66hcm000l40w3d2qkhrev","_id":"cmfj66hcv002p40w3gyg15w1f"},{"post_id":"cmfj66hck000b40w3dmgp8mdt","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcv002t40w3ef0gbpcc"},{"post_id":"cmfj66hck000c40w39sd9142c","tag_id":"cmfj66hcu002k40w3a85k8n2w","_id":"cmfj66hcv002w40w30mte3mv3"},{"post_id":"cmfj66hcl000g40w350yn5l5w","tag_id":"cmfj66hcl000f40w3b6x3h9yv","_id":"cmfj66hcw003040w3f43pcxhz"},{"post_id":"cmfj66hcl000g40w350yn5l5w","tag_id":"cmfj66hcm000l40w3d2qkhrev","_id":"cmfj66hcw003140w3d9mqh0us"},{"post_id":"cmfj66hcm000i40w3caj101or","tag_id":"cmfj66hcw002x40w3855cats7","_id":"cmfj66hcw003b40w387x7gwmh"},{"post_id":"cmfj66hcm000i40w3caj101or","tag_id":"cmfj66hcw003240w31x4efzcy","_id":"cmfj66hcw003c40w32pjm63bl"},{"post_id":"cmfj66hcm000i40w3caj101or","tag_id":"cmfj66hco000y40w365eo43ga","_id":"cmfj66hcw003f40w3bvxce0zq"},{"post_id":"cmfj66hcm000m40w31qo4e6gs","tag_id":"cmfj66hcw003840w3gka6ev3e","_id":"cmfj66hcx003n40w3bxva9vvg"},{"post_id":"cmfj66hcm000m40w31qo4e6gs","tag_id":"cmfj66hcw003240w31x4efzcy","_id":"cmfj66hcx003o40w3862d5eio"},{"post_id":"cmfj66hcm000m40w31qo4e6gs","tag_id":"cmfj66hcw003h40w35p02fny2","_id":"cmfj66hcx003r40w3fzq27551"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","tag_id":"cmfj66hcw003240w31x4efzcy","_id":"cmfj66hcy004340w31ocy4od5"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","tag_id":"cmfj66hcx003p40w3d1sadqzc","_id":"cmfj66hcy004440w34ol21u5p"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","tag_id":"cmfj66hcx003t40w3dp7t0sf9","_id":"cmfj66hcy004640w33gatabr4"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","tag_id":"cmfj66hcy003w40w34n6w8o6k","_id":"cmfj66hcy004740w3cqe73yaa"},{"post_id":"cmfj66hcn000n40w3gcf86mg2","tag_id":"cmfj66hcy003z40w3c1hf13wz","_id":"cmfj66hcy004940w3dhkx1d62"},{"post_id":"cmfj66hcn000r40w3de4cbrmb","tag_id":"cmfj66hcy004240w38c7rdfvg","_id":"cmfj66hcy004a40w36ytnaw9s"},{"post_id":"cmfj66hcn000r40w3de4cbrmb","tag_id":"cmfj66hcy004540w32zszgy51","_id":"cmfj66hcy004c40w3co90bn71"},{"post_id":"cmfj66hcn000t40w3gvscgf9j","tag_id":"cmfj66hco000y40w365eo43ga","_id":"cmfj66hcy004d40w3gz9l4e20"},{"post_id":"cmfj66hco000x40w39fp82cne","tag_id":"cmfj66hcy004b40w31l4k1o72","_id":"cmfj66hcy004g40w3c5exgh00"},{"post_id":"cmfj66hco000x40w39fp82cne","tag_id":"cmfj66hcn000q40w3cc6e7e51","_id":"cmfj66hcy004h40w35m4d3pbx"},{"post_id":"cmfj66hco000x40w39fp82cne","tag_id":"cmfj66hcx003t40w3dp7t0sf9","_id":"cmfj66hcy004j40w3bxuae2m3"},{"post_id":"cmfj66hco000z40w37fuvcrw7","tag_id":"cmfj66hcy004f40w315kphbd2","_id":"cmfj66hcy004k40w34y3z5608"},{"post_id":"cmfj66hco001240w38x9w28aq","tag_id":"cmfj66hcy004240w38c7rdfvg","_id":"cmfj66hcz004p40w3bmjf2yyt"},{"post_id":"cmfj66hco001240w38x9w28aq","tag_id":"cmfj66hcw002x40w3855cats7","_id":"cmfj66hcz004q40w30xe5fo6k"},{"post_id":"cmfj66hco001240w38x9w28aq","tag_id":"cmfj66hcx003t40w3dp7t0sf9","_id":"cmfj66hcz004s40w33gt7gkkv"},{"post_id":"cmfj66hco001240w38x9w28aq","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcz004t40w35o7j6g1c"},{"post_id":"cmfj66hcp001440w3950k4nbk","tag_id":"cmfj66hcz004o40w33lqhaezh","_id":"cmfj66hcz004v40w39g17g6a4"},{"post_id":"cmfj66hcp001840w39foy141v","tag_id":"cmfj66hcz004r40w3fp7n8zl6","_id":"cmfj66hcz004w40w3ay75f03f"},{"post_id":"cmfj66hcq001f40w32rd58gyq","tag_id":"cmfj66hcz004u40w37mx29tah","_id":"cmfj66hcz004z40w3cbh2f9v4"},{"post_id":"cmfj66hcq001f40w32rd58gyq","tag_id":"cmfj66hcz004x40w3drmmcrze","_id":"cmfj66hcz005040w3fp5oedzc"},{"post_id":"cmfj66hcq001i40w39xuc5csn","tag_id":"cmfj66hcz004y40w38xtvcvxw","_id":"cmfj66hcz005240w3h9x34ov1"},{"post_id":"cmfj66hcs001u40w33jbr6zsz","tag_id":"cmfj66hcz005140w32ml7fxuf","_id":"cmfj66hcz005440w30xbtdhx7"},{"post_id":"cmfj66hct002540w3d6yk0h6f","tag_id":"cmfj66hcz005340w3gfjvhswo","_id":"cmfj66hcz005640w36vjm3abq"},{"post_id":"cmfj66hct002540w3d6yk0h6f","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcz005740w3a1r60ps4"},{"post_id":"cmfj66hct002740w3448wesxq","tag_id":"cmfj66hcz005340w3gfjvhswo","_id":"cmfj66hcz005940w394ageorc"},{"post_id":"cmfj66hct002740w3448wesxq","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hcz005a40w33nz6d9hn"},{"post_id":"cmfj66hct002c40w306u44mq4","tag_id":"cmfj66hcz005840w3bhayafuu","_id":"cmfj66hd0005e40w3fszxgda6"},{"post_id":"cmfj66hct002c40w306u44mq4","tag_id":"cmfj66hcz005b40w39gtbamfc","_id":"cmfj66hd0005f40w3592yhuke"},{"post_id":"cmfj66hct002c40w306u44mq4","tag_id":"cmfj66hcz005c40w3cmx67fas","_id":"cmfj66hd0005h40w332mnfhvi"},{"post_id":"cmfj66hcu002j40w37mg722nr","tag_id":"cmfj66hd0005d40w3a4h455un","_id":"cmfj66hd0005i40w36v6u13ye"},{"post_id":"cmfj66hcu002j40w37mg722nr","tag_id":"cmfj66hcq001h40w3chmgb89d","_id":"cmfj66hd0005k40w35b8c33k8"},{"post_id":"cmfj66hcv002o40w3bdd0bzd2","tag_id":"cmfj66hd0005g40w30bek1e6a","_id":"cmfj66hd0005m40w33c0z826y"},{"post_id":"cmfj66hcv002o40w3bdd0bzd2","tag_id":"cmfj66hd0005j40w3fpzf1x0b","_id":"cmfj66hd0005n40w32ffwhqa5"},{"post_id":"cmfj66hcv002q40w33m2g0cke","tag_id":"cmfj66hd0005l40w3howb1zhb","_id":"cmfj66hd0005q40w332exagl2"},{"post_id":"cmfj66hcv002q40w33m2g0cke","tag_id":"cmfj66hd0005o40w3h4kufprl","_id":"cmfj66hd0005r40w3ffd8ejtw"},{"post_id":"cmfj66hcv002u40w36at25gax","tag_id":"cmfj66hd0005p40w37ggp15mv","_id":"cmfj66hd0005u40w3g57p4d3q"},{"post_id":"cmfj66hcv002u40w36at25gax","tag_id":"cmfj66hd0005s40w3eetz0qj5","_id":"cmfj66hd0005v40w3c5zm1huy"},{"post_id":"cmfj66hcv002u40w36at25gax","tag_id":"cmfj66hd0005t40w3bz33dy18","_id":"cmfj66hd0005w40w3h5fu9snv"},{"post_id":"cmfj66hd2005x40w30prwgg4y","tag_id":"cmfj66hd3005z40w307ovau3x","_id":"cmfj66hd4006640w30vx0auns"},{"post_id":"cmfj66hd3005y40w3e2bncuv0","tag_id":"cmfj66hd4006440w3ed8rhn79","_id":"cmfj66hd4006940w36uvu37fc"},{"post_id":"cmfj66hd3006040w3fcnl4k1n","tag_id":"cmfj66hd4006840w3dgg2b5ke","_id":"cmfj66hd4006c40w36yppcj1a"},{"post_id":"cmfj66hd3006140w39k6me3iq","tag_id":"cmfj66hd4006a40w3fjhr91ti","_id":"cmfj66hd4006d40w3clhrbpqu"}],"Tag":[{"name":"Algorithm","_id":"cmfj66hci000540w34qrz0i8a"},{"name":"Double Pointer","_id":"cmfj66hck000a40w36vhzcff5"},{"name":"C++","_id":"cmfj66hcl000f40w3b6x3h9yv"},{"name":"OOP","_id":"cmfj66hcm000l40w3d2qkhrev"},{"name":"sort","_id":"cmfj66hcn000q40w3cc6e7e51"},{"name":"algorithm","_id":"cmfj66hco000y40w365eo43ga"},{"name":"CPP","_id":"cmfj66hco001340w30at5henu"},{"name":"syntax","_id":"cmfj66hcp001b40w3axrzadwm"},{"name":"updating","_id":"cmfj66hcq001h40w3chmgb89d"},{"name":"Linear List，stack","_id":"cmfj66hcu002k40w3a85k8n2w"},{"name":"stack","_id":"cmfj66hcw002x40w3855cats7"},{"name":"binary tree","_id":"cmfj66hcw003240w31x4efzcy"},{"name":"DFS","_id":"cmfj66hcw003840w3gka6ev3e"},{"name":"search，graph，sort","_id":"cmfj66hcw003h40w35p02fny2"},{"name":"huffman tree","_id":"cmfj66hcx003p40w3d1sadqzc"},{"name":"queue","_id":"cmfj66hcx003t40w3dp7t0sf9"},{"name":"Dijkstra","_id":"cmfj66hcy003w40w34n6w8o6k"},{"name":"Kruskal","_id":"cmfj66hcy003z40w3c1hf13wz"},{"name":"datastructure","_id":"cmfj66hcy004240w38c7rdfvg"},{"name":"linkedlist","_id":"cmfj66hcy004540w32zszgy51"},{"name":"hashtable","_id":"cmfj66hcy004b40w31l4k1o72"},{"name":"CSS","_id":"cmfj66hcy004f40w315kphbd2"},{"name":"html","_id":"cmfj66hcz004o40w33lqhaezh"},{"name":"JavaScript","_id":"cmfj66hcz004r40w3fp7n8zl6"},{"name":"Python","_id":"cmfj66hcz004u40w37mx29tah"},{"name":"function","_id":"cmfj66hcz004x40w3drmmcrze"},{"name":"College Physics","_id":"cmfj66hcz004y40w38xtvcvxw"},{"name":"Motivation","_id":"cmfj66hcz005140w32ml7fxuf"},{"name":"Leetcode","_id":"cmfj66hcz005340w3gfjvhswo"},{"name":"opencv","_id":"cmfj66hcz005840w3bhayafuu"},{"name":"yolov5","_id":"cmfj66hcz005b40w39gtbamfc"},{"name":"object detection","_id":"cmfj66hcz005c40w3cmx67fas"},{"name":"Github","_id":"cmfj66hd0005d40w3a4h455un"},{"name":"Hexo","_id":"cmfj66hd0005g40w30bek1e6a"},{"name":"Blogging","_id":"cmfj66hd0005j40w3fpzf1x0b"},{"name":"markdown","_id":"cmfj66hd0005l40w3howb1zhb"},{"name":"blogger","_id":"cmfj66hd0005o40w3h4kufprl"},{"name":"tutorial","_id":"cmfj66hd0005p40w37ggp15mv"},{"name":"hexo","_id":"cmfj66hd0005s40w3eetz0qj5"},{"name":"image hosting","_id":"cmfj66hd0005t40w3bz33dy18"},{"name":"vim","_id":"cmfj66hd3005z40w307ovau3x"},{"name":"shell","_id":"cmfj66hd4006440w3ed8rhn79"},{"name":"Git","_id":"cmfj66hd4006840w3dgg2b5ke"},{"name":"review","_id":"cmfj66hd4006a40w3fjhr91ti"}]}}